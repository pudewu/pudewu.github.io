

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="pudewu的技术分享">
  <meta name="author" content="pudewu">
  <meta name="keywords" content="">
  <meta name="description" content="一、前言Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。  Java 相比 C&#x2F;C++ 最显著的特点便是引入了自动垃圾回收 ，它解决了 C&#x2F;C++ 最令人头疼的内存管理问题，让程序员专注于程序本身，不用关心内存回收这些恼人的问题，这也是 Java 能大行其道的重要原因之一，GC 真正让程序员的生产力得到了释放，但是程序员很难感知到">
<meta property="og:type" content="article">
<meta property="og:title" content="垃圾回收机制">
<meta property="og:url" content="https://pudewu.github.io/2022/08/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="远方">
<meta property="og:description" content="一、前言Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。  Java 相比 C&#x2F;C++ 最显著的特点便是引入了自动垃圾回收 ，它解决了 C&#x2F;C++ 最令人头疼的内存管理问题，让程序员专注于程序本身，不用关心内存回收这些恼人的问题，这也是 Java 能大行其道的重要原因之一，GC 真正让程序员的生产力得到了释放，但是程序员很难感知到">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pudewu.github.io/img/work/1658756652612.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/1658757344719.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/1658757378988.gif">
<meta property="og:image" content="https://pudewu.github.io/img/work/1658757632055.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/1658760144545.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/1658762575693.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/1659205995494.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/1659206212030.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220804085924076.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220804094135547.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220804094326874.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220804094529179.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220804094647126.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/00831rSTly1gdc2z7ahusg30hr09l0v2.gif">
<meta property="og:image" content="https://pudewu.github.io/img/work/00831rSTly1gdc2zeh8bvg30hq09h76r.gif">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220804140548771.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/00831rSTly1gdc2zt5evgg30hs0axgnj.gif">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220804142225085.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/1659876973241.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/1659878842481.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/1659881403383.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220811110843131.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220811170339191.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220811172700022.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220812095626191.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220812095757822.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220812100445225.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220812100652059.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220812100943247.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220812104304863.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220812110614495.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220812112204614.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220816092121840.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220816092534056.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220816093144227.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220816093348733.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220816093559373.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220816094117348.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220816094337340.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220816094534610.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220816094703782.png">
<meta property="og:image" content="https://pudewu.github.io/img/work/image-20220816095034233.png">
<meta property="article:published_time" content="2022-08-18T03:49:25.000Z">
<meta property="article:modified_time" content="2022-08-29T02:43:51.206Z">
<meta property="article:author" content="pudewu">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://pudewu.github.io/img/work/1658756652612.png">
  
  <title>垃圾回收机制 - 远方</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"pudewu.github.io","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"BhicXbKDdNvP9NPx7rovXEdy-gzGzoHsz","app_key":"XqW1MD1MQUgHsxH0BNgcfIfd","server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="远方" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>远方</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-user-fill"></i>
                个人
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/about/">
                    <i class="iconfont icon-user-fill"></i>
                    关于
                  </a>
                
              </div>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/article.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="垃圾回收机制">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-08-18 11:49" pubdate>
        2022年8月18日 中午
      </time>
    </span>
  
</div>

<div class="mt-1">
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      56 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">垃圾回收机制</h1>
            
            <div class="markdown-body">
              <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。 </p>
<p>Java 相比 C/C++ 最显著的特点便是引入了自动垃圾回收 ，它解决了 C/C++ 最令人头疼的内存管理问题，让程序员专注于程序本身，不用关心内存回收这些恼人的问题，这也是 Java 能大行其道的重要原因之一，GC 真正让程序员的生产力得到了释放，但是程序员很难感知到它的存在。 </p>
<p>深入了解 GC 是成为一名优秀 Java 程序员的必修课！ </p>
<p><strong>回顾下 JVM 内存区域</strong></p>
<p><img src="/img/work/1658756652612.png" srcset="/img/loading.gif" lazyload> </p>
<h2 id="二、如何识别垃圾"><a href="#二、如何识别垃圾" class="headerlink" title="二、如何识别垃圾"></a>二、如何识别垃圾</h2><p>我们都知道 GC 主要发生在堆，那么 GC 该怎么判断堆中的对象实例或数据是不是垃圾呢，或者说判断某些数据是否是垃圾的方法有哪些。 </p>
<h3 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="2.1 引用计数法"></a>2.1 引用计数法</h3><p>最容易想到的一种方式是引用计数法，啥叫引用计数法，简单地说，就是对象被引用一次，在它的对象头上加一次引用次数，如果没有被引用（引用次数为 0），则此对象可回收 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String ref = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Java&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>以上代码 ref1 引用了右侧定义的对象，所以引用次数是 1 </p>
<p><img src="/img/work/1658757344719.png" srcset="/img/loading.gif" lazyload></p>
<p>如果在上述代码后面添加一个 ref = null，则由于对象没被引用，引用次数置为 0，由于不被任何变量引用，此时即被回收，动图如下 </p>
<p><img src="/img/work/1658757378988.gif" srcset="/img/loading.gif" lazyload></p>
<p>看起来用引用计数确实没啥问题了，不过它无法解决一个主要的问题：<strong>循环引用</strong>！啥叫循环引用 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestRC</span> </span>&#123;<br><br>    TestRC instance;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestRC</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// 第一步</span><br>      A a = <span class="hljs-keyword">new</span> TestRC(<span class="hljs-string">&quot;a&quot;</span>);<br>      B b = <span class="hljs-keyword">new</span> TestRC(<span class="hljs-string">&quot;b&quot;</span>);<br><br>      <span class="hljs-comment">// 第二步</span><br>      a.instance = b;<br>      b.instance = a;<br><br>      <span class="hljs-comment">// 第三步</span><br>      a = <span class="hljs-keyword">null</span>;<br>      b = <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>按步骤一步步画图 </p>
<p><img src="/img/work/1658757632055.png" srcset="/img/loading.gif" lazyload></p>
<p>到了第三步，虽然 a，b 都被置为 null 了，但是由于之前它们指向的对象互相指向了对方（引用计数都为 1），所以无法回收，也正是由于无法解决循环引用的问题，所以主流的 Java 虚拟机都没有选用引用计数法来管理内存。 </p>
<h4 id="2-1-1-优点"><a href="#2-1-1-优点" class="headerlink" title="2.1.1 优点:"></a>2.1.1 优点:</h4><p>引用计数法可以在对象不活跃时（引用计数为0）立刻回收其内存。因此可以保证堆上时时刻刻都没有垃圾对象的存在（先不考虑循环引用导致无法回收的情况）。 </p>
<p>引用计数法的最大暂停时间短。由于没有了独立的GC过程，而且不需要遍历整个堆来标记和清除对象，取而代之的是在对象引用计数为0时立即回收对象，这相当于将GC过程“分摊”到了每个对象上，不会有最大暂停时间特别长的情况发生。 </p>
<h4 id="2-1-2-缺点"><a href="#2-1-2-缺点" class="headerlink" title="2.1.2 缺点:"></a><strong>2.1.2 缺点:</strong></h4><p>引用计数法也有一些问题，引用计数的增减开销在一些情况下会比较大，比如一些根引用的指针更新非常频繁，此时这种开销是不能忽视的。另外对象引用计数器本身是需要空间的，而计数器要占用多少位也是一个问题，理论上系统内存可寻址的范围越大，对象计数器占用的空间就要越大，这样在一些小对象上就会出现计数器空间比对象本身的域还要大的情况，内存空间利用率就会降低。</p>
<p>还有一个问题是循环引用的问题，假设两个对象A和B，A引用B，B也引用A，除此之外它们都没有其他引用关系了，这个时候A和B就形成了循环引用，变成一个“孤岛”，且它们的引用计数都是1，按照引用计数法的要求，它们将无法被回收，造成内存泄漏。 </p>
<p><a target="_blank" rel="noopener" href="https://nullcc.github.io/2017/11/11/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%28GC%29%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%282%29%E2%80%94%E2%80%94GC%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95/">引用计算详情参考</a></p>
<h3 id="2-2-可达性算法"><a href="#2-2-可达性算法" class="headerlink" title="2.2 可达性算法"></a>2.2 可达性算法</h3><p>现代虚拟机基本都是采用这种算法来判断对象是否存活，可达性算法的原理是以一系列叫做 <strong>GC Root</strong> 的对象为起点出发，引出它们指向的下一个节点，再以下个节点为起点，引出此节点指向的下一个结点。。。（这样通过 GC Root 串成的一条线就叫引用链），直到所有的结点都遍历完毕，如果相关对象不在任意一个以 <strong>GC Root</strong> 为起点的引用链中，则这些对象会被判断为「垃圾」,会被GC回收。 </p>
<p><img src="/img/work/1658760144545.png" srcset="/img/loading.gif" lazyload></p>
<p>如图示，如果用可达性算法即可解决上述循环引用的问题，因为从<strong>GC Root</strong> 出发没有到达 a,b，所以 a，b 可回收 </p>
<blockquote>
<p> a, b 对象可回收，就一定会被回收吗? </p>
</blockquote>
<p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候他们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要两次标记过程： </p>
<ol>
<li>对象不可达（可回收），会进行第一次标记并进行一次筛选，筛选条件是此对象是否有必要执行 <code>finalize()</code> 方法</li>
<li>如果有必要执行 <code>finaize()</code> 方法，这个对象会被放在一个叫做 F-Queue 的队列中，稍后会由 JVM 自动建立的、低优先级的 Finalizer 线程去执行（触发，并不会等其运行结束），这时进行第二次标记，仍然不可达，则会被真的回收。</li>
</ol>
<p><strong>注意</strong>：任何一个对象的 <code>finalize()</code> 方法只会被系统自动调用一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收！这一点切记! </p>
<p>那么这些 <strong>GC Roots</strong> 到底是什么东西呢，哪些对象可以作为 GC Root 呢，有以下几类 </p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li>
<li>Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象</li>
<li>所有被同步锁（synchronized 关键字）持有的对象</li>
<li>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存</li>
</ul>
<h4 id="2-2-1-虚拟机栈中引用的对象"><a href="#2-2-1-虚拟机栈中引用的对象" class="headerlink" title="2.2.1 虚拟机栈中引用的对象"></a>2.2.1 虚拟机栈中引用的对象</h4><p>如下代码所示，a 是栈帧中的本地变量，当 a = null 时，由于此时 a 充当了 <strong>GC Root</strong> 的作用，a 与原来指向的实例 <strong>new Test()</strong> 断开了连接，所以对象会被回收。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Test a = <span class="hljs-keyword">new</span> Test();<br>    a = <span class="hljs-keyword">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-2-2-方法区中类静态属性引用的对象"><a href="#2-2-2-方法区中类静态属性引用的对象" class="headerlink" title="2.2.2 方法区中类静态属性引用的对象"></a>2.2.2 方法区中类静态属性引用的对象</h4><p>如下代码所示，当栈帧中的本地变量 a = null 时，由于a原来指向的对象与 GC Root (变量 a) 断开了连接，所以 a 原来指向的对象会被回收，而由于我们给s赋值了变量的引用，s在此时是类静态属性引用，充当了GC Root 的作用，它指向的对象依然存活! </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Test s;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	  Test a = <span class="hljs-keyword">new</span> Test();<br>	  a.s = <span class="hljs-keyword">new</span> Test();<br>	  a = <span class="hljs-keyword">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-2-3-方法区中常量引用的对象"><a href="#2-2-3-方法区中常量引用的对象" class="headerlink" title="2.2.3 方法区中常量引用的对象"></a>2.2.3 方法区中常量引用的对象</h4><p>如下代码所示，常量 s 指向的对象并不会因为 a 指向的对象被回收而回收 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Test s = <span class="hljs-keyword">new</span> Test();<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	   Test a = <span class="hljs-keyword">new</span> Test();<br>	   a = <span class="hljs-keyword">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-2-4-本地方法栈中-JNI-引用的对象"><a href="#2-2-4-本地方法栈中-JNI-引用的对象" class="headerlink" title="2.2.4 本地方法栈中 JNI 引用的对象"></a>2.2.4 本地方法栈中 JNI 引用的对象</h4><p>所谓本地方法就是一个 Java 调用非 Java 代码的接口，该方法并非 Java 实现的，可能由 C 或 Python等其他语言实现的， Java 通过 JNI 来调用本地方法， 而本地方法是以库文件的形式存放的（在 WINDOWS 平台上是 DLL 文件形式，在 UNIX 机器上是 SO 文件形式）。通过调用本地的库文件的内部方法，使 JAVA 可以实现和本地机器的紧密联系，调用系统级的各接口方法。 </p>
<p>当调用 Java 方法时，虚拟机会创建一个栈桢并压入 Java 栈，而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不会在 Java 栈祯中压入新的祯，虚拟机只是简单地动态连接并直接调用指定的本地方法。 </p>
<p><img src="/img/work/1658762575693.png" srcset="/img/loading.gif" lazyload> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">JNIEXPORT <span class="hljs-keyword">void</span> JNICALL <span class="hljs-title">Java_com_pecuyu_jnirefdemo_MainActivity_newStringNative</span><span class="hljs-params">(JNIEnv *env, jobject instance，jstring jmsg)</span> </span>&#123;<br><br>		<span class="hljs-comment">//...</span><br><br>   <span class="hljs-comment">// 缓存String的class</span><br><br>   jclass jc = (*env)-&gt;FindClass(env, STRING_PATH);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上代码所示，当 Java 调用以上本地方法时，jc 会被本地方法栈压入栈中， jc 就是我们说的本地方法栈中 JNI 的对象引用，因此只会在此本地方法执行完成后才会被释放。 </p>
<h4 id="2-2-5-JDK8-之前的方法区回收"><a href="#2-2-5-JDK8-之前的方法区回收" class="headerlink" title="2.2.5 JDK8 之前的方法区回收"></a>2.2.5 JDK8 之前的方法区回收</h4><p>永久代的垃圾收集主要回收两部分内容: <strong>废弃常量和无用的类</strong>  </p>
<p>废弃常量：与堆中对象回收类似，以常量池中字面量的回收为例，例如资格字符串“abc”已经进入常量池，但没有任何一个 String 对象引用常量池中的”abc”常量，也没有其他地方引用了这个字面量，如果发生内存回收，且有必要的话，这个常量就会被系统清理出常量池。 </p>
<p>无用类： </p>
<ul>
<li>该类所有的实例都已经被回收（堆中不存在该类的任何实例）</li>
<li>加载该类的 ClassLoader 已经被回收</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机<strong>可以</strong>对满足以上 3 个条件的无用类进行回收，并不是一定会被回收。是否对类回收，HotSpot 虚拟机提供了 <code>-Xnoclassgc</code> 参数进行控制 </p>
<h2 id="三、垃圾收集算法"><a href="#三、垃圾收集算法" class="headerlink" title="三、垃圾收集算法"></a>三、垃圾收集算法</h2><p>可以通过可达性算法来识别哪些数据是垃圾，那该怎么对这些垃圾进行回收呢。主要有以下几种方式 </p>
<ul>
<li>标记清除算法</li>
<li>复制算法</li>
<li>标记整理法</li>
<li>分代收集算法</li>
</ul>
<h3 id="3-1-标记清除算法"><a href="#3-1-标记清除算法" class="headerlink" title="3.1 标记清除算法"></a>3.1 标记清除算法</h3><p>步骤很简单，和名字一样，分为“标记”和“清除”两个阶段 </p>
<ol>
<li>先根据可达性算法<strong>标记</strong>出相应的可回收对象（图中黄色部分）</li>
</ol>
<p><img src="/img/work/1659205995494.png" srcset="/img/loading.gif" lazyload></p>
<ol start="2">
<li>对可回收的对象进行回收操作起来确实很简单，也不用做移动数据的操作，那有啥问题呢？仔细看上图，没错，内存碎片！假如我们想在上图中的堆中分配一块需要<strong>连续内存</strong>占用 4M 或 5M 的区域，显然是会失败，怎么解决呢，如果能把上面未使用的 2M， 2M，1M 内存能连起来就能连成一片可用空间为 5M 的区域即可，怎么做呢?</li>
</ol>
<h3 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h3><p>把堆等分成两块区域, A 和 B，区域 A 负责分配对象，区域 B 不分配，对区域 A 使用以上所说的标记法把存活的对象标记出来，然后把区域 A 中存活的对象都复制到区域 B（存活对象都依次<strong>紧邻排列</strong>）最后把 A 区对象全部清理掉释放出空间，这样就解决了内存碎片的问题了。 </p>
<p><img src="/img/work/1659206212030.png" srcset="/img/loading.gif" lazyload></p>
<p>不过复制算法的缺点很明显，比如给堆分配了 500M 内存，结果只有 250M 可用，空间平白无故减少了一半！这肯定是不能接受的！另外每次回收也要把存活对象移动到另一半，效率低下（我们可以想想删除数组元素再把非删除的元素往一端移，效率显然堪忧） </p>
<h3 id="3-3-标记整理法"><a href="#3-3-标记整理法" class="headerlink" title="3.3 标记整理法"></a>3.3 标记整理法</h3><p>前面两步和标记清除法一样，不同的是它在标记清除法的基础上添加了一个整理的过程 ，即将所有的存活对象都往一端移动，紧邻排列（如图示），再清理掉另一端的所有区域，这样的话就解决了内存碎片的问题。</p>
<p><img src="/img/work/image-20220804085924076.png" srcset="/img/loading.gif" lazyload></p>
<p>但是缺点也很明显：每进一次垃圾清除都要频繁地移动存活的对象，效率十分低下。</p>
<h3 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h3><p>分代收集算法整合了以上算法，综合了这些算法的优点，最大程度避免了它们的缺点，所以是现代虚拟机采用的首选算法，与其说它是算法，倒不是说它是一种策略，因为它是把上述几种算法整合在了一起，为啥需要分代收集呢，来看一下对象的分配有啥规律</p>
<p><img src="/img/work/image-20220804094135547.png" srcset="/img/loading.gif" lazyload></p>
<p><em>如图示：纵轴代表已分配的字节，而横轴代表程序运行时间</em></p>
<p>由图可知，大部分的对象都很短命，都在很短的时间内都被回收了（IBM 专业研究表明，一般来说，98% 的对象都是朝生夕死的，经过一次 Minor GC 后就会被回收），所以分代收集算法根据<strong>对象存活周期的不同</strong>将堆分成新生代和老生代（Java8 以前还有个永久代），默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1)，三者的比例为 <code>8: 1 : 1</code>，这样就可以根据新老生代的特点选择最合适的垃圾回收算法，我们把新生代发生的 GC 称为 Young GC（也叫 Minor GC），老年代发生的 GC 称为 Old GC。</p>
<p><img src="/img/work/image-20220804094326874.png" srcset="/img/loading.gif" lazyload></p>
<p><em>画外音：思考一下，新生代为啥要分这么多区？</em></p>
<p>那么分代垃圾收集是怎么工作的呢，我们一起来看看</p>
<h4 id="3-4-1-分代收集工作原理"><a href="#3-4-1-分代收集工作原理" class="headerlink" title="3.4.1 分代收集工作原理"></a>3.4.1 分代收集工作原理</h4><p><strong>1、对象在新生代的分配与回收</strong></p>
<p>由以上的分析可知，大部分对象在很短的时间内都会被回收，对象一般分配在 Eden 区</p>
<p><img src="/img/work/image-20220804094529179.png" srcset="/img/loading.gif" lazyload></p>
<p>当 Eden 区将满时，触发 Minor GC</p>
<p><img src="/img/work/image-20220804094647126.png" srcset="/img/loading.gif" lazyload></p>
<p>我们之前怎么说来着，大部分对象在短时间内都会被回收，所以经过 Minor GC 后只有少部分对象会存活，它们会被移到 S0 区（这就是为啥空间大小 <code>Eden: S0: S1 = 8:1:1</code>，Eden 区远大于 S0，S1 的原因，因为在 Eden 区触发的 Minor GC 把大部对象（接近98%）都回收了，只留下少量存活的对象，此时把它们移到 S0 或 S1 绰绰有余）同时对象年龄加一（对象的年龄即发生 Minor GC 的次数），最后把 Eden 区对象全部清理以释放出空间，如下</p>
<p><img src="/img/work/00831rSTly1gdc2z7ahusg30hr09l0v2.gif" srcset="/img/loading.gif" lazyload></p>
<p>当触发下一次 Minor GC 时，会把 Eden 区的存活对象和 S0（或S1） 中的存活对象（S0 或 S1 中的存活对象经过每次 Minor GC 都可能被回收）一起移到 S1（Eden 和 S0 的存活对象年龄+1）, 同时清空 Eden 和 S0 的空间。</p>
<p><img src="/img/work/00831rSTly1gdc2zeh8bvg30hq09h76r.gif" srcset="/img/loading.gif" lazyload></p>
<p>若再触发下一次 Minor GC，则重复上一步，只不过此时变成了从 Eden，S1 区将存活对象复制到 S0 区，每次垃圾回收，S0，S1 角色互换，都是从 Eden ，S0(或S1) 将存活对象移动到 S1(或S0)。也就是说在 Eden 区的垃圾回收我们采用的是<strong>复制算法</strong>，因为在 Eden 区分配的对象大部分在 Minor GC 后都消亡了，只剩下极少部分存活对象，S0，S1 区域也比较小，所以最大限度地降低了复制算法造成的对象频繁拷贝带来的开销。</p>
<blockquote>
<p>新生代采用的复制算法，其实是优化后的复制算法，即在复制算法的基础上，使用三个分区（Eden/S0/S1）进行处理</p>
</blockquote>
<p><img src="/img/work/image-20220804140548771.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>2、对象何时晋升老年代</strong></p>
<ul>
<li>当对象的年龄达到了我们设定的阈值，则会从S0（或S1）晋升到老年代</li>
</ul>
<p><img src="/img/work/00831rSTly1gdc2zt5evgg30hs0axgnj.gif" srcset="/img/loading.gif" lazyload></p>
<p>如图示：年龄阈值设置为 15（默认为15岁）， 当发生下一次 Minor GC 时，S0 中有个对象年龄达到 15，达到我们的设定阈值，晋升到老年代!</p>
<ul>
<li>大对象，当某个对象分配需要大量的连续内存时，此时对象的创建不会分配在 Eden 区，会直接分配在老年代，因为如果把大对象分配在 Eden 区，Minor GC 后再移动到 S0，S1 会有很大的开销（对象比较大，复制会比较慢，也占空间），也很快会占满 S0，S1 区，所以干脆就直接移到老年代。最典型的大对象就是那种很长的字符串以及数组</li>
<li>还有一种情况也会让对象晋升到老年代，即在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代。</li>
</ul>
<p><strong>3、空间分配担保</strong></p>
<p>在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么 Minor GC 可以确保是安全的，如果不大于，那么虚拟机会查看 <code>HandlePromotionFailure</code> 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行 Minor GC，否则可能进行一次 Full GC。</p>
<p><strong>4、Stop The World</strong></p>
<p>如果老年代满了，会触发 Full GC， Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW），造成挺大的性能开销。</p>
<p>什么是 STW ？所谓的 STW，即在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。</p>
<p><img src="/img/work/image-20220804142225085.png" srcset="/img/loading.gif" lazyload></p>
<p><em>画外音：为啥在垃圾收集期间其他工作线程会被挂起？想象一下，你一边在收垃圾，另外一群人一边丢垃圾，垃圾能收拾干净吗。</em></p>
<p>一般 Full GC 会导致工作线程停顿时间过长（因为Full GC 会清理<strong>整个堆</strong>中的不可用对象，一般要花较长的时间），如果在此 server 收到了很多请求，则会被拒绝服务！所以我们要尽量减少 Full GC（Minor GC 也会造成 STW，但只会触发轻微的 STW，因为 Eden 区的对象大部分都被回收了，只有极少数存活对象会通过复制算法转移到 S0 或 S1 区，所以相对还好）。</p>
<p>现在我们应该明白把新生代设置成 Eden， S0，S1区或者给对象设置年龄阈值或者默认把新生代与老年代的空间大小设置成 1:2 都是为了<strong>尽可能地避免对象过早地进入老年代，尽可能晚地触发 Full GC</strong>。想想新生代如果只设置 Eden 会发生什么，后果就是每经过一次 Minor GC，存活对象会过早地进入老年代，那么老年代很快就会装满，很快会触发 Full GC，而对象其实在经过两三次的 Minor GC 后大部分都会消亡，所以有了 S0，S1的缓冲，只有少数的对象会进入老年代，老年代大小也就不会这么快地增长，也就避免了过早地触发 Full GC。</p>
<p>由于 Full GC（或Minor GC） 会影响性能，所以我们要在一个合适的时间点发起 GC，这个时间点被称为 <strong>Safe Point（安全点）</strong>，这个时间点的选定既不能太少以让 GC 时间太长导致程序过长时间卡顿，也不能过于频繁以至于过分增大运行时的负荷。一般当线程在这个时间点上状态是可以确定的，如确定 GC Root 的信息等，可以使 JVM 开始安全地 GC。Safe Point 主要指的是以下特定位置： </p>
<ul>
<li>循环的末尾</li>
<li>方法返回前</li>
<li>调用方法的 call 之后</li>
<li>抛出异常的位置 另外需要注意的是由于新生代的特点（大部分对象经过 Minor GC后会消亡）， Minor GC 用的是复制算法，而在老生代由于对象比较多，占用的空间较大，使用复制算法会有较大开销（复制算法在对象存活率较高时要进行多次复制操作，同时浪费一半空间）所以根据老年代的特点，在老年代进行的 GC 一般采用的是标记整理法来进行回收。</li>
</ul>
<blockquote>
<p>《深入理解 Java 虚拟机》中有个注意事项，整理了下各种 GC，避免混乱 </p>
<ul>
<li>部分收集（Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集，其中又分为：<ul>
<li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</li>
<li>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有 CMS 收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。</li>
<li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有 G1 收集器会有这种行为。</li>
</ul>
</li>
<li>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。</li>
</ul>
</blockquote>
<p><strong>什么时候会触发 Full GC ?</strong> </p>
<ol>
<li><p><code>System.gc()</code> 方法的调用 </p>
<p>此方法的调用是建议 JVM 进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加Full GC 的频率，也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过通过 -XX:+ DisableExplicitGC 来禁止 RMI 调用 System.gc。 </p>
</li>
<li><p>老年代空间不足 </p>
<p>老年代空间只有在新生代对象转入及创建大对象、大数组时才会出现不足的现象，当执行 Full GC 后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space 为避免以上两种状况引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。 </p>
</li>
<li><p>老年代的内存使用率达到了一定阈值（可通过参数调整），直接触发 FGC</p>
</li>
<li><p>空间分配担保：在 YGC 之前，会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果小于，说明 YGC 是不安全的，则会查看参数 HandlePromotionFailure 是否被设置成了允许担保失败，如果不允许则直接触发 Full GC；如果允许，那么会进一步检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于也会触发 Full GC</p>
</li>
<li><p>Metaspace（元空间）在空间不足时会进行扩容，当扩容到了-XX:MetaspaceSize 参数的指定值时，也会触发FGC</p>
</li>
</ol>
<h2 id="四、垃圾收集器种类"><a href="#四、垃圾收集器种类" class="headerlink" title="四、垃圾收集器种类"></a>四、垃圾收集器种类</h2><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java 虚拟机规范并没有规定垃圾收集器应该如何实现，因此一般来说不同厂商，不同版本的虚拟机提供的垃圾收集器实现可能会有差别，一般会给出参数来让用户根据应用的特点来组合各个年代使用的收集器，主要有以下垃圾收集器 </p>
<p><img src="/img/work/1659876973241.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>在新生代工作的垃圾回收器：Serial、ParNew、ParallelScavenge</li>
<li>在老年代工作的垃圾回收器：CMS、Serial Old(MSC)、Parallel Old</li>
<li>同时在新老生代工作的垃圾回收器：G1</li>
</ul>
<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。  </p>
<p>注：G1 垃圾收集器既可以回收年轻代内存，也可以回收老年代内存。而其他垃圾收集器只能针对特定代的内存进行回收。 </p>
<h3 id="4-1-串行收集器"><a href="#4-1-串行收集器" class="headerlink" title="4.1. 串行收集器"></a>4.1. 串行收集器</h3><p>串行收集器（Serial）是最基本、发展历史最悠久的收集器。 </p>
<p>串行收集器是 <strong><code>client</code> 模式下的默认收集器配置</strong>。因为在客户端模式下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的年轻代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。 </p>
<p><strong>串行收集器采用单线程 stop-the-world 的方式进行收集</strong>。当内存不足时，串行 GC 设置停顿标识，待所有线程都进入安全点（Safepoint）时，应用线程暂停，串行 GC 开始工作，<strong>采用单线程方式回收空间并整理内存</strong>。 </p>
<p><img src="/img/work/1659878842481.png" srcset="/img/loading.gif" lazyload alt=" Serial / Serial Old 收集器运行示意图 "></p>
<p>单线程意味着复杂度更低、占用内存更少，垃圾回收效率高；但同时也意味着不能有效利用多核优势。事实上，串行收集器特别适合堆内存不高、单核甚至双核 CPU 的场合。 </p>
<h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a><strong>Serial 收集器</strong></h4><blockquote>
<p>开启选项：<code>-XX:+UseSerialGC</code></p>
<p>打开此开关后，使用 <strong>Serial</strong> + <strong>Serial Old</strong> 收集器组合来进行内存回收。</p>
</blockquote>
<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a><strong>Serial Old 收集器</strong></h4><p>Serial Old 是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途： </p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h3 id="4-2-并行收集器"><a href="#4-2-并行收集器" class="headerlink" title="4.2. 并行收集器"></a>4.2. 并行收集器</h3><blockquote>
<p> 开启选项：<code>-XX:+UseParallelGC</code> </p>
<p> 打开此开关后，使用 <strong>Parallel Scavenge</strong> + <strong>Serial Old</strong> 收集器组合来进行内存回收。 </p>
<p> 开启选项：<code>-XX:+UseParallelOldGC</code> </p>
<p> 打开此开关后，使用 <strong>Parallel Scavenge</strong> + <strong>Parallel Old</strong> 收集器组合来进行内存回收。 </p>
</blockquote>
<p>其他收集器都是以关注停顿时间为目标，而<strong>并行收集器是以关注吞吐量（Throughput）为目标的垃圾收集器</strong>。 </p>
<ul>
<li>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验；</li>
<li>而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)<br></code></pre></td></tr></table></figure>

<p><strong>并行收集器是 server 模式下的默认收集器。</strong> </p>
<p>并行收集器与串行收集器工作模式相似，都是 stop-the-world 方式，只是暂停时并行地进行垃圾收集。<strong>并行收集器年轻代采用复制算法，老年代采用标记-整理</strong>，在回收的同时还会对内存进行压缩。并行收集器适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延时的情况下，并行收集器将提供最佳的吞吐量。 </p>
<p><strong>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 收集器 + Parallel Old 收集器。</strong> </p>
<p><img src="/img/work/1659881403383.png" srcset="/img/loading.gif" lazyload alt=" Parallel / Parallel Old 收集器运行示意图 "></p>
<h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a><strong>Parallel Scavenge 收集器</strong></h4><p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是： </p>
<ul>
<li><code>-XX:MaxGCPauseMillis</code> - 控制最大垃圾收集停顿时间，收集器将尽可能保证内存回收时间不超过设定值。</li>
<li><code>-XX:GCTimeRatio</code> - 直接设置吞吐量大小的（值为大于 0 且小于 100 的整数）。</li>
</ul>
<p>缩短停顿时间是以牺牲吞吐量和年轻代空间来换取的：年轻代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
<p>Parallel Scavenge 收集器还提供了一个参数 <code>-XX:+UseAdaptiveSizePolicy</code>，这是一个开关参数，打开参数后，就不需要手工指定年轻代的大小（<code>-Xmn</code>）、Eden 和 Survivor 区的比例（<code>-XX:SurvivorRatio</code>）、晋升老年代对象年龄（<code>-XX:PretenureSizeThreshold</code>）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（GC Ergonomics）。</p>
<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p>Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，使用<strong>多线程和 “标记-整理” 算法</strong>。</p>
<h3 id="4-3-并发标记清除收集器"><a href="#4-3-并发标记清除收集器" class="headerlink" title="4.3 并发标记清除收集器"></a>4.3 并发标记清除收集器</h3><blockquote>
<p>开启选项：<code>-XX:+UseConcMarkSweepGC</code></p>
<p>打开此开关后，使用 <strong>CMS</strong> + <strong>ParNew</strong> + <strong>Serial Old</strong> 收集器组合来进行内存回收。</p>
</blockquote>
<p>并发标记清除收集器是以获取最短停顿时间为目标。</p>
<p>开启后，年轻代使用 ParNew 收集器；老年代使用 CMS 收集器，如果 CMS 产生的碎片过多，导致无法存放浮动垃圾，JVM 会出现 <code>Concurrent Mode Failure</code> ，此时使用 Serial Old 收集器来替代 CMS 收集器清理碎片。</p>
<h4 id="4-3-1-CMS-收集器"><a href="#4-3-1-CMS-收集器" class="headerlink" title="4.3.1 CMS 收集器"></a>4.3.1 CMS 收集器</h4><p><strong>CMS 收集器是一种以获取最短停顿时间为目标的收集器。</strong></p>
<p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p>
<p> <strong>CMS 回收机制</strong></p>
<p>CMS 收集器运行步骤如下：</p>
<ol>
<li><strong>初始标记</strong>：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li><strong>并发标记</strong>：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li><strong>重新标记</strong>：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li><strong>并发清除</strong>：回收在标记阶段被鉴定为不可达的对象。不需要停顿。</li>
</ol>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p><img src="/img/work/image-20220811110843131.png" srcset="/img/loading.gif" lazyload alt="CMS 收集器运行示意图"></p>
<h5 id="CMS-回收年轻代详细步骤"><a href="#CMS-回收年轻代详细步骤" class="headerlink" title="CMS 回收年轻代详细步骤"></a><strong>CMS 回收年轻代详细步骤</strong></h5><p><strong>（1）堆空间被分割为三块空间</strong></p>
<p><img src="/img/work/image-20220811170339191.png" srcset="/img/loading.gif" lazyload></p>
<p>年轻代分割成一个 Eden 区和两个 Survivor 区。年老代一个连续的空间。就地完成对象收集。除非有 FullGC 否则不会压缩。</p>
<p><strong>（2）CMS 年轻代垃圾收集如何工作</strong></p>
<p>年轻代被标为浅绿色，年老代被标记为蓝色。如果你的应用已经运行了一段时间，CMS 的堆看起来应该是这个样子。对象分散在年老代区域里。</p>
<p><img src="/img/work/image-20220811172700022.png" srcset="/img/loading.gif" lazyload></p>
<p>使用 CMS，年老代对象就地释放。它们不会被来回移动。这个空间不会被压缩除非发生 FullGC。</p>
<p><strong>（3）年轻代收集</strong></p>
<p>从 Eden 和 Survivor 区复制活跃对象到另一个 Survivor 区。所有达到他们的年龄阈值的对象会晋升到年老代。</p>
<p><img src="/img/work/image-20220812095626191.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>（4）年轻代回收之后</strong></p>
<p>一次年轻代垃圾收集之后，Eden 区和其中一个 Survivor 区被清空。</p>
<p><img src="/img/work/image-20220812095757822.png" srcset="/img/loading.gif" lazyload></p>
<p>最近晋升的对象以深蓝色显示在上图中，绿色的对象是年轻代幸免的还没有晋升到老年代对象。</p>
<h5 id="CMS-回收年老代详细步骤"><a href="#CMS-回收年老代详细步骤" class="headerlink" title="CMS 回收年老代详细步骤"></a>CMS 回收年老代详细步骤</h5><p><strong>（1）CMS 的年老代收集</strong></p>
<p>发生两次 stop the world 事件：初始标记和重新标记。当年老代达到特定的占用比例时，CMS 开始执行。</p>
<p><img src="/img/work/image-20220812100445225.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>初始标记是一个短暂暂停的、可达对象被标记的阶段。</li>
<li>并发标记寻找活跃对象在应用连续执行时。</li>
<li>最后，在重新标记阶段，寻找在之前并发标记阶段中丢失的对象。</li>
</ul>
<p><strong>（2）年老代收集-并发清除</strong></p>
<p>在之前阶段没有被标记的对象会被就地释放。不进行压缩操作。</p>
<p><img src="/img/work/image-20220812100652059.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>注意：</strong>未被标记的对象等于死亡对象</p>
<p><strong>（3）年老代收集-清除之后</strong></p>
<p>清除阶段之后，你可以看到大量内存被释放。你还可以注意到没有进行压缩操作。</p>
<p><img src="/img/work/image-20220812100943247.png" srcset="/img/loading.gif" lazyload></p>
<p>最后，CMS 收集器会再次进入重新设置阶段，等待下一次垃圾收集时机的到来。</p>
<h5 id="CMS-特点"><a href="#CMS-特点" class="headerlink" title="CMS 特点"></a>CMS 特点</h5><p>CMS 收集器具有以下缺点：</p>
<ul>
<li>CMS 收集器对 CPU 资源非常敏感 。原因也可以理解，比如本来我本来可以有 10 个用户线程处理请求，现在却要分出 3 个作为回收线程，吞吐量下降了30%，CMS 默认启动的回收线程数是 （CPU数量+3）/ 4，如果 CPU 数量只有一两个，那吞吐量就直接下降 50%，显然是不可接受的</li>
<li><strong>CMS 无法处理浮动垃圾</strong>（Floating Garbage），可能出现 「Concurrent Mode Failure」而导致另一次 Full GC 的产生，由于在并发清理阶段用户线程还在运行，所以清理的同时新的垃圾也在不断出现，这部分垃圾只能在下一次 GC 时再清理掉（即浮云垃圾），同时在垃圾收集阶段用户线程也要继续运行，就需要预留足够多的空间要确保用户线程正常执行，这就意味着 CMS 收集器不能像其他收集器一样等老年代满了再使用，JDK 1.5 默认当老年代使用了 68% 空间后就会被激活，当然这个比例可以通过 <code>-XX:CMSInitiatingOccupancyFraction</code> 来设置，但是如果设置的太高很容易导致在 CMS 运行期间预留的内存无法满足程序要求，会导致 <strong>Concurrent Mode Failure</strong> 失败，这时会启用 Serial Old 收集器来重新进行老年代的收集，而我们知道 Serial Old 收集器是单线程收集器，这样就会导致 STW 更长了。</li>
<li>CMS 采用的是标记清除法，上文我们已经提到这种方法<strong>会产生大量的内存碎片</strong>，这样会给大内存分配带来很大的麻烦，如果无法找到足够大的连续空间来分配对象，将会触发 Full GC，这会影响应用的性能。当然我们可以开启 <code>-XX:+UseCMSCompactAtFullCollection</code>（默认是开启的），用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理会导致 STW，停顿时间会变长，还可以用另一个参数 <code>-XX:CMSFullGCsBeforeCompation</code> 用来设置执行多少次不压缩的 Full GC 后跟着带来一次带压缩的。</li>
</ul>
<h4 id="4-3-2-ParNew-收集器"><a href="#4-3-2-ParNew-收集器" class="headerlink" title="4.3.2 ParNew 收集器"></a>4.3.2 ParNew 收集器</h4><blockquote>
<p>开启选项：<code>-XX:+UseParNewGC</code></p>
</blockquote>
<p>ParNew 收集器其实是 Serial 收集器的多线程版本。</p>
<p><img src="/img/work/image-20220812104304863.png" srcset="/img/loading.gif" lazyload alt="ParNew 收集器运行示意图"></p>
<p>是 Server 模式下的虚拟机首选年轻代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p>
<p>ParNew 收集器也是使用 <code>-XX:+UseConcMarkSweepGC</code> 后的默认年轻代收集器。</p>
<p>ParNew 收集器默认开启的线程数量与 CPU 数量相同，可以使用 -<code>XX:ParallelGCThreads</code> 参数来设置线程数。</p>
<h3 id="4-4-G1-收集器"><a href="#4-4-G1-收集器" class="headerlink" title="4.4. G1 收集器"></a>4.4. G1 收集器</h3><blockquote>
<p>开启选项：<code>-XX:+UseG1GC</code></p>
<p>Java8 默认使用 Parallel Scavenge + Parallel Old 组合，Java9 开始 G1 取代了它们。</p>
</blockquote>
<p>前面提到的垃圾收集器一般策略是关注吞吐量或停顿时间。而 <strong>G1 是一种兼顾吞吐量和停顿时间的 GC 收集器</strong>。G1 是 Oracle JDK9 以后的默认 GC 收集器。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</p>
<p>G1 最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至 CMS 的众多缺陷。</p>
<p>G1 收集器是面向服务端的垃圾收集器，被称为驾驭一切的垃圾回收器，主要有以下几个特点:</p>
<ul>
<li>像 CMS 收集器一样，能与应用程序线程并发执行。</li>
<li>整理空闲空间更快。</li>
<li>需要 GC 停顿时间更好预测。</li>
<li>不会像 CMS 那样牺牲大量的吞吐性能。</li>
<li>不需要更大的 Java Heap</li>
</ul>
<h4 id="4-4-1-分代和分区"><a href="#4-4-1-分代和分区" class="headerlink" title="4.4.1 分代和分区"></a>4.4.1 分代和分区</h4><p>旧的垃圾收集器一般采取分代收集，Java 堆被分为年轻代、老年代和永久代。收集的范围都是整个年轻代或者整个老年代。</p>
<p>G1 取消了永久代，并把年轻代和老年代划分成多个大小相等的独立区域（Region），年轻代和老年代不再物理隔离。G1 可以直接对年轻代和老年代一起回收。</p>
<p><img src="/img/work/image-20220812110614495.png" srcset="/img/loading.gif" lazyload></p>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<h4 id="4-4-2-G1-回收机制"><a href="#4-4-2-G1-回收机制" class="headerlink" title="4.4.2 G1 回收机制"></a>4.4.2 G1 回收机制</h4><p><img src="/img/work/image-20220812112204614.png" srcset="/img/loading.gif" lazyload alt="G1 收集器运行示意图"></p>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ol>
<li><strong>初始标记</strong></li>
<li><strong>并发标记</strong></li>
<li><strong>最终标记</strong> - 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li><strong>筛选回收</strong> - 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ol>
<p>G1具备如下特点：</p>
<ul>
<li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<h4 id="4-4-3-G1-回收年轻代详细步骤"><a href="#4-4-3-G1-回收年轻代详细步骤" class="headerlink" title="4.4.3 G1 回收年轻代详细步骤"></a>4.4.3 G1 回收年轻代详细步骤</h4><p><strong>（1）G1 初始堆空间</strong></p>
<p>堆空间是一个被分成许多固定大小区域的内存块。</p>
<p><img src="/img/work/image-20220816092121840.png" srcset="/img/loading.gif" lazyload></p>
<p>Java 虚拟机启动时选定区域大小。Java 虚拟机通常会指定 2000 个左右的大小相等、每个大小范围在 1 到 32M 的区域。</p>
<p><strong>（2）G1 堆空间分配</strong></p>
<p>实际上，这些区域被映射成 Eden、Survivor、年老代空间的逻辑表述形式。</p>
<p><img src="/img/work/image-20220816092534056.png" srcset="/img/loading.gif" lazyload></p>
<p>图片中的颜色表明了哪个区域被关联上什么角色。活跃对象从一个区域疏散（复制、移动）到另一个区域。区域被设计为并行的方式收集，可以暂停或者不暂停所有的其它用户线程。</p>
<p>明显的区域可以被分配成 Eden、Survivor、Old 区域。另外，有第四种类型的区域叫做*极大区域(Humongous regions)*。这些区域被设计成保持标准区域大小的 50%或者更大的对象。它们被保存在一个连续的区域集合里。最后，最后一个类型的区域就是堆空间里没有使用的区域。</p>
<p><strong>注意：</strong> 写作此文章时，收集极大对象时还没有被优化。因此，你应该避免创建这个大小的对象。</p>
<p><strong>（3）G1 的年轻代</strong></p>
<p>堆空间被分割成大约 2000 个区域。最小 1M，最大 32M，蓝色区域保持年老代对象，绿色区域保持年轻代对象。</p>
<p><img src="/img/work/image-20220816093144227.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>注意：</strong>区域没有必要像旧的收集器一样是保持连续的。</p>
<p><strong>（4）G1 的年轻代收集</strong></p>
<p>活跃对象会被疏散（复制、移动）到一个或多个 survivor 区域。如果达到晋升总阈值，对象会晋升到年老代区域。</p>
<p><img src="/img/work/image-20220816093348733.png" srcset="/img/loading.gif" lazyload></p>
<p>这是一个 stop the world 暂停。为下一次年轻代垃圾回收计算 Eden 和 Survivor 的大小。保留审计信息有助于计算大小。类似目标暂停时间的事情会被考虑在内。</p>
<p>这个方法使重调区域大小变得很容易，按需把它们调大或调小。</p>
<p><strong>（5）G1 年轻代回收的尾声</strong></p>
<p>活跃对象被疏散到 Survivor 或者年老代区域。</p>
<p><img src="/img/work/image-20220816093559373.png" srcset="/img/loading.gif" lazyload></p>
<p>最近晋升的对象显示为深蓝色。Survivor 区域显示为绿色。</p>
<p>关于 G1 的年轻代回收做以下总结：</p>
<ul>
<li>堆空间是一块单独的内存空间被分割成多个区域。</li>
<li>年轻代内存是由一组非连续的区域组成。这使得需要重调大小变得容易。</li>
<li>年轻代垃圾回收是 stop the world 事件，所有应用线程都会因此操作暂停。</li>
<li>年轻代垃圾收集使用多线程并行回收。</li>
<li>活跃对象被复制到新的 Survivor 区或者年老代区域。</li>
</ul>
<h4 id="4-4-4-G1-回收年老代详细步骤"><a href="#4-4-4-G1-回收年老代详细步骤" class="headerlink" title="4.4.4 G1 回收年老代详细步骤"></a>4.4.4 G1 回收年老代详细步骤</h4><p><strong>（1）初始标记阶段</strong></p>
<p>年轻代垃圾收集肩负着活跃对象初始标记的任务。在日志文件中被标为<em>GC pause (young)(inital-mark)</em></p>
<p><img src="/img/work/image-20220816094117348.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>（2）并发标记阶段</strong></p>
<p>如果发现空区域(“X”标示的)，在重新标记阶段它们会被马上清除掉。当然，决定活性的审计信息也在此时被计算。</p>
<p><img src="/img/work/image-20220816094337340.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>（3）重新标记阶段</strong></p>
<p>空的区域被清除和回收掉。所有区域的活性在此时计算。</p>
<p><img src="/img/work/image-20220816094534610.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>（4）复制/清理阶段</strong></p>
<p>G1 选择活性最低的区域，这些区域能够以最快的速度回收。然后这些区域会在年轻代垃圾回收过程中被回收。在日志中被指示为*[GC pause (mixed)]*。所以年轻代和年老代在同一时间被回收。</p>
<p><img src="/img/work/image-20220816094703782.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>（5）复制/清理阶段之后</strong></p>
<p>被选择的区域已经被回收和压缩到图中显示的深蓝色区和深绿色区中。</p>
<p><img src="/img/work/image-20220816095034233.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="4-5-总结"><a href="#4-5-总结" class="headerlink" title="4.5 总结"></a>4.5 总结</h3><table>
<thead>
<tr>
<th align="center">收集器</th>
<th align="center">串行/并行/并发</th>
<th align="center">年轻代/老年代</th>
<th align="center">收集算法</th>
<th align="center">目标</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Serial</strong></td>
<td align="center">串行</td>
<td align="center">年轻代</td>
<td align="center">复制</td>
<td align="center">响应速度优先</td>
<td align="center">单 CPU 环境下的 Client 模式</td>
</tr>
<tr>
<td align="center"><strong>Serial Old</strong></td>
<td align="center">串行</td>
<td align="center">老年代</td>
<td align="center">标记-整理</td>
<td align="center">响应速度优先</td>
<td align="center">单 CPU 环境下的 Client 模式、CMS 的后备预案</td>
</tr>
<tr>
<td align="center"><strong>ParNew</strong></td>
<td align="center">串行 + 并行</td>
<td align="center">年轻代</td>
<td align="center">复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">多 CPU 环境时在 Server 模式下与 CMS 配合</td>
</tr>
<tr>
<td align="center"><strong>Parallel Scavenge</strong></td>
<td align="center">串行 + 并行</td>
<td align="center">年轻代</td>
<td align="center">复制算法</td>
<td align="center">吞吐量优先</td>
<td align="center">在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td align="center"><strong>Parallel Old</strong></td>
<td align="center">串行 + 并行</td>
<td align="center">老年代</td>
<td align="center">标记-整理</td>
<td align="center">吞吐量优先</td>
<td align="center">在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td align="center"><strong>CMS</strong></td>
<td align="center">并行 + 并发</td>
<td align="center">老年代</td>
<td align="center">标记-清除</td>
<td align="center">响应速度优先</td>
<td align="center">集中在互联网站或 B/S 系统服务端上的 Java 应用</td>
</tr>
<tr>
<td align="center"><strong>G1</strong></td>
<td align="center">并行 + 并发</td>
<td align="center">年轻代 + 老年代</td>
<td align="center">标记-整理 + 复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">面向服务端应用，将来替换 CMS</td>
</tr>
</tbody></table>
<h2 id="五、GC-日志"><a href="#五、GC-日志" class="headerlink" title="五、GC 日志"></a>五、GC 日志</h2><p>接下来我们看看 GC 日志怎么看，日志可以有效地帮助我们定位问题，所以搞清楚 GC 日志的格式非常重要，来看下如下例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  VM Args:-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:+PrintGCTimeStamps  -XX:+UseSerialGC -                 *XX:SurvivorRatio=8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestGC</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;<br>        allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> * _1MB];<br>        allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> * _1MB];<br>        allocation3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> * _1MB];<br>        allocation4 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4</span> * _1MB];    <span class="hljs-comment">// 这里会出现一次 Minor GC</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行以上代码，会输出如下 GC 日志信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">10.080: 2[GC 3(Allocation Failure) 0.080: 4[DefNew: 56815K-&gt;280K(9216K),6 0.0043690 secs] 76815K-&gt;6424K(19456K), 80.0044111 secs]9 [Times: user=0.00 sys=0.01, real=0.01 secs]<br></code></pre></td></tr></table></figure>

<p>以上是发生 Minor GC 的 GC 是日志，如果发生 Full GC 呢，格式如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">10.088: 2[Full GC 3(Allocation Failure) 0.088: 4[Tenured: 50K-&gt;210K(10240K), 60.0009420 secs] 74603K-&gt;210K(19456K), [Metaspace: 2630K-&gt;2630K(1056768K)], 80.0009700 secs]9 [Times: user=0.01 sys=0.00, real=0.02 secs]<br></code></pre></td></tr></table></figure>

<p>两者格式其实差不多，一起来看看，主要以本例触发的 Minor GC 来讲解，以上日志中标的每一个数字与以下序号一一对应</p>
<ol>
<li>开头的 0.080，0.088 代表了 GC 发生的时间，这个数字的含义是从 Java 虚拟机启动以来经过的秒数</li>
<li><strong>[GC</strong> 或者 <strong>[Full GC</strong> 说明了这次垃圾收集的停顿类型，注意不是用来区分新生代 GC 还是老年化 GC 的，如果有 <strong>Full</strong>，说明这次 GC 是发生了<strong>Stop The World</strong> 的，如果是调用 System.gc() 所触发的收集，这里会显示 <strong>[Full GC（System）</strong></li>
<li>之后的 <strong>Allocation Failure</strong> 代表了触发 GC 的原因，在这个程序中我们设置了新生代的大小为 10M（-Xmn10M），Eden:S0:S1 = 8：1：1（-XX:SurvivorRatio=8），也就是说 Eden 区占了 8M, 当分配 allocation4 时，由于将要分配的总大小为 10M,超过了 Eden 区，所以此时会发生 GC</li>
<li>接下来的 <strong>[DefNew</strong>，**[Tenured<strong>，</strong>[Metaspace** 表示 GC 发生的区域，这里显示的区域名与使用的 GC 收集器是密切相关的，在此例中由于新生代我们使用了 Serial 收集器，此收集器新生代名为「Default New Generation」，所以显示的是 <strong>[DefNew</strong>，如果是 ParNew 收集器，新生代名称就会变为 <strong>[ParNew</strong>`，意为 「Parallel New Generation」,如果采用 「Parallel Scavenge」收集器，则配套的新生代名称为「PSYoungGen」,老年代与新生代一样，名称也是由收集器决定的</li>
<li>再往后 <strong>6815K-&gt;280K(9216K)</strong> 表示 「GC 前该内存区域已使用容量 -&gt; GC 后该内存区域已使用容量（该内存区域总容量）」</li>
<li>0.0043690 secs 表示该块内存区域 GC 所占用的时间，单位是秒</li>
<li>6815K-&gt;6424K(19456K) 表示「GC 前 Java 堆已使用容量 -&gt; GC 后 Java 堆已使用容量（java 堆总容量）」。</li>
<li><strong>0.0044111 secs</strong> 表示整个 GC 执行时间，注意和 6 中 <strong>0.0043690 secs</strong>的区别，后者专指<strong>相关区域</strong>所花的 GC 时间，而前者指的 GC 的整体堆内存变化所花时间（新生代与老生代的的内存整理），所以前者是肯定大于后者的！</li>
<li>最后一个 [Times: user=0.01 sys=0.00, real=0.02 secs] 这里的 user, sys 和 real 与Linux 的 time 命令所输出的时间一致，分别代表用户态消耗的 CPU 时间，内核态消耗的 CPU 时间，和操作从开始到结束所经过的墙钟时间，墙钟时间包括各种非运算的等待耗时，例如等待磁盘 I/O，等待线程阻塞，而 CPU 时间不包括这些耗时，但当系统有多 CPU 或者多核的话，多线程操作会叠加这些 CPU 时间，所以 user 或 sys 时间是可能超过 real 时间的。</li>
</ol>
<p>知道了 GC 日志怎么看，我们就可以根据 GC 日志有效定位问题了，如我们发现 Full GC 发生时间过长，则结合打印的 OOM 日志可能可以快速定位到问题</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本文简述了垃圾回收的原理与垃圾收集器的种类，相信大家对开头提的一些问题应该有了更深刻的认识，在生产环境中我们要根据<strong>不同的场景</strong>来选择垃圾收集器组合，如果是运行在桌面环境处于 Client 模式的，则用 Serial + Serial Old 收集器绰绰有余，如果需要响应时间快，用户体验好的，则用 ParNew + CMS 的搭配模式，即使是号称是「驾驭一切」的 G1，也需要根据吞吐量等要求适当调整相应的 JVM 参数，没有最牛的技术，只有最合适的使用场景，切记！</p>
<h2 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://javakeeper.starfish.ink/java/JVM/GC.html#%E4%BA%94%E3%80%81gc-%E6%97%A5%E5%BF%97">javakeeper《垃圾回收机制》</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://dunwu.github.io/javacore/jvm/jvm-gc.html#_4-2-full-gc">JAVACORE《JVM垃圾回收》</a></p>
</li>
<li><p>主要来源“码海”公号</p>
</li>
<li><p>《深入理解 Java 虚拟机》</p>
</li>
<li><p>堆外内存的回收机制分析 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/35cf0f348275">https://www.jianshu.com/p/35cf0f348275</a></p>
</li>
<li><p>java调用本地方法–jni简介 <a target="_blank" rel="noopener" href="https://blog.csdn.net/w1992wishes/article/details/80283403">https://blog.csdn.net/w1992wishes/article/details/80283403</a></p>
</li>
<li><p>咱们从头到尾说一次 Java 垃圾回收 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/pR7U1OTwsNSg5fRyWafucA">https://mp.weixin.qq.com/s/pR7U1OTwsNSg5fRyWafucA</a></p>
</li>
<li><p>Java Hotspot G1 GC的一些关键技术 <a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/09/23/g1.html">https://tech.meituan.com/2016/09/23/g1.html</a></p>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/categories/Java/JVM/">JVM</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/JVM/">JVM</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/08/25/MySQL%E8%BF%90%E7%BB%B4/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MySQL运维</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/28/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                        <span class="hidden-mobile">为什么要学习数据结构和算法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"BhicXbKDdNvP9NPx7rovXEdy-gzGzoHsz","appKey":"XqW1MD1MQUgHsxH0BNgcfIfd","path":"window.location.pathname","placeholder":"评论下吧","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
