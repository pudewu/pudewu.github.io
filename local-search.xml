<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaIO之NIO</title>
    <link href="/2022/01/23/JavaIO%E4%B9%8BNIO/"/>
    <url>/2022/01/23/JavaIO%E4%B9%8BNIO/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><h3 id="1-Java-NIO就基本介绍"><a href="#1-Java-NIO就基本介绍" class="headerlink" title="1 Java NIO就基本介绍"></a>1 Java NIO就基本介绍</h3><ol><li><p><code>Java NIO</code> 全称 <strong><code>Java non-blocking IO</code></strong> ，是指 <code>JDK</code> 提供的新 <code>API</code>。从 <code>JDK1.4</code> 开始，<code>Java</code> 提供了一系列改进的输入/输出的新特性，被统称为 <code>NIO</code>（即 <code>NewIO</code>），是同步非阻塞的。</p></li><li><p><code>NIO</code> 相关类都被放在 <strong><code>java.nio</code></strong> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写。【基本案例】</p></li><li><p><code>NIO</code> 有三大核心部分: <strong><code>Channel</code>（通道）、<code>Buffer</code>（缓冲区）、<code>Selector</code>（选择器）</strong> 。</p></li><li><p><code>NIO</code> 是<strong>面向缓冲区，或者面向块编程</strong>的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</p></li><li><p><code>Java NIO</code> 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。【后面有案例说明】</p></li><li><p>通俗理解：<code>NIO</code> 是可以做到用一个线程来处理多个操作的。假设有 <code>10000</code> 个请求过来,根据实际情况，可以分配 <code>50</code> 或者 <code>100</code> 个线程来处理。不像之前的阻塞 <code>IO</code> 那样，非得分配 <code>10000</code> 个。</p></li><li><p><code>HTTP 2.0</code> 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 <code>HTTP 1.1</code> 大了好几个数量级。</p></li></ol><p>案例说明 <code>NIO</code> 的 <code>Buffer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.nio;<br><br><span class="hljs-keyword">import</span> java.nio.IntBuffer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicBuffer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//举例说明 Buffer 的使用(简单说明)</span><br>        <span class="hljs-comment">//创建一个 Buffer，大小为 5，即可以存放 5 个 int</span><br>        IntBuffer intBuffer = IntBuffer.allocate(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">//向buffer存放数据</span><br>        <span class="hljs-comment">//intBuffer.put(10);</span><br>        <span class="hljs-comment">//intBuffer.put(11);</span><br>        <span class="hljs-comment">//intBuffer.put(12);</span><br>        <span class="hljs-comment">//intBuffer.put(13);</span><br>        <span class="hljs-comment">//intBuffer.put(14);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intBuffer.capacity(); i++) &#123;<br>            intBuffer.put(i * <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-comment">//如何从 buffer 读取数据</span><br>        <span class="hljs-comment">//将 buffer 转换，读写切换(!!!)</span><br>        intBuffer.flip();<br>        <span class="hljs-keyword">while</span> (intBuffer.hasRemaining()) &#123;<br>            System.out.println(intBuffer.get());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-NIO和BIO的比较"><a href="#2-NIO和BIO的比较" class="headerlink" title="2 NIO和BIO的比较"></a>2 NIO和BIO的比较</h3><ol><li><code>BIO</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据，块 <code>I/O</code> 的效率比流 <code>I/O</code> 高很多。</li><li><code>BIO</code> 是阻塞的，<code>NIO</code> 则是非阻塞的。</li><li><code>BIO</code> 基于字节流和字符流进行操作，而 <code>NIO</code> 基于 <code>Channel</code>（通道）和 <code>Buffer</code>（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<code>Selector</code>（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li></ol><h3 id="3-NIO三大核心原理示意图"><a href="#3-NIO三大核心原理示意图" class="headerlink" title="3 NIO三大核心原理示意图"></a>3 NIO三大核心原理示意图</h3><p>一张图描述 <code>NIO</code> 的 <code>Selector</code>、<code>Channel</code> 和 <code>Buffer</code> 的关系。</p><p><strong>3.1 Selector、Channel和Buffer关系图</strong></p><p>关系图的说明:</p><p><img src="/img/work/chapter03_01.png" alt="Selector、Channel和Buffer关系图"></p><ol><li>每个 <code>Channel</code> 都会对应一个 <code>Buffer</code>。</li><li><code>Selector</code> 对应一个线程，一个线程对应多个 <code>Channel</code>（连接）。</li><li>该图反应了有三个 <code>Channel</code> 注册到该 <code>Selector</code> 程序</li><li>程序切换到哪个 <code>Channel</code> 是由事件决定的，<code>Event</code> 就是一个重要的概念。</li><li><code>Selector</code> 会根据不同的事件，在各个通道上切换。</li><li><code>Buffer</code> 就是一个内存块，底层是有一个数组。</li><li>数据的读取写入是通过 <code>Buffer</code>，这个和 <code>BIO</code>，<code>BIO</code> 中要么是输入流，或者是输出流，不能双向，但是 <code>NIO</code> 的 <code>Buffer</code> 是可以读也可以写，需要 <code>flip</code> 方法切换， <code>Channel</code> 是双向的，可以返回底层操作系统的情况，比如 <code>Linux</code>，底层的操作系统通道就是双向的。</li></ol><h3 id="4-缓冲区-Buffer"><a href="#4-缓冲区-Buffer" class="headerlink" title="4 缓冲区(Buffer)"></a>4 缓冲区(Buffer)</h3><blockquote><p>缓冲区（<code>Buffer</code>）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个<strong>容器对象（含数组）</strong>，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<code>Channel</code> 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 <code>Buffer</code>，如图:【后面举例说明】</p></blockquote><p><img src="/img/work/chapter03_02.png"></p><h4 id="4-2-Buffer-类及其子类"><a href="#4-2-Buffer-类及其子类" class="headerlink" title="4.2 Buffer 类及其子类"></a>4.2 Buffer 类及其子类</h4><ol><li><p>在 <code>NIO</code> 中，<code>Buffer</code> 是一个顶层父类，它是一个抽象类，类的层级关系图：</p><p><img src="/img/work/chapter03_03.png" alt="img"></p></li><li><p><code>Buffer</code> 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息：</p></li></ol><p><img src="/img/work/chapter03_05.png"></p><ol start="3"><li><code>Buffer</code> 类相关方法一览</li></ol><p><img src="/img/work/chapter03_06.png"></p><h4 id="4-3-ByteBuffer"><a href="#4-3-ByteBuffer" class="headerlink" title="4.3 ByteBuffer"></a>4.3 ByteBuffer</h4><p>从前面可以看出对于 <code>Java</code> 中的基本数据类型（<code>boolean</code> 除外），都有一个 <code>Buffer</code> 类型与之相对应，最常用的自然是 <code>ByteBuffer</code> 类（二进制数据），该类的主要方法如下：</p><p><img src="/img/work/chapter03_07.png"></p><h3 id="5-通道（Channel）"><a href="#5-通道（Channel）" class="headerlink" title="5 通道（Channel）"></a>5 通道（Channel）</h3><h4 id="5-1-基本介绍"><a href="#5-1-基本介绍" class="headerlink" title="5.1 基本介绍"></a>5.1 基本介绍</h4><ol><li><code>NIO</code> 的通道类似于流，但有些区别如下：</li></ol><ul><li>通道可以同时进行读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲读数据，也可以写数据到缓冲:</li></ul><ol start="2"><li><code>BIO</code> 中的 <code>Stream</code> 是单向的，例如 <code>FileInputStream</code> 对象只能进行读取数据的操作，而 <code>NIO</code> 中的通道（<code>Channel</code>）是双向的，可以读操作，也可以写操作。</li><li><code>Channel</code> 在 <code>NIO</code> 中是一个接口 <code>public interface Channel extends Closeable&#123;&#125;</code></li><li>常用的 <code>Channel</code> 类有: <strong><code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code></strong> 。【<code>ServerSocketChannel</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code>】</li><li><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</li><li>图示</li></ol><p><img src="/img/work/chapter03_08.png"></p><h4 id="5-2-FileChannel"><a href="#5-2-FileChannel" class="headerlink" title="5.2 FileChannel"></a>5.2 FileChannel</h4><p><code>FileChannel</code> 主要用来对本地文件进行 <code>IO</code> 操作，常见的方法有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(ByteBuffer dst)</span><span class="hljs-comment">//从通道读取数据并放到缓冲区中</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">write</span><span class="hljs-params">(ByteBuffer src)</span> <span class="hljs-comment">//把缓冲区的数据写到通道中</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">transferFrom</span><span class="hljs-params">(ReadableByteChannel src, <span class="hljs-keyword">long</span> position, <span class="hljs-keyword">long</span> count)</span><span class="hljs-comment">//从目标通道中复制数据到当前通道</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">transferTo</span><span class="hljs-params">(<span class="hljs-keyword">long</span> position, <span class="hljs-keyword">long</span> count, WritableByteChannel target)</span><span class="hljs-comment">//把数据从当前通道复制给目标通道</span></span><br></code></pre></td></tr></table></figure><p><strong>实例1-本地文件写数据</strong></p><ol><li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 “hello,尚硅谷” 写入到 <code>file01.txt</code> 中</li><li>文件不存在就创建</li><li>代码演示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel01</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String str = <span class="hljs-string">&quot;hello,尚硅谷&quot;</span>;<br>        <span class="hljs-comment">//创建一个输出流 -》 channel</span><br>        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;/Users/pudewu/software07/Java/stud_code/java-basic/file01.txt&quot;</span>);<br><br>        <span class="hljs-comment">//通过 FileOutputStream获取对应的FileChannel</span><br>        <span class="hljs-comment">//这个 fileChannel 真实类型是FileChannelImpl</span><br>        FileChannel fileChannel = fileOutputStream.getChannel();<br><br>        <span class="hljs-comment">//创建一个缓冲区ByteBuffer</span><br>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>        <span class="hljs-comment">//将str放入byteBuffer</span><br>        byteBuffer.put(str.getBytes());<br><br>        <span class="hljs-comment">//对 byteBuffer进行flip</span><br>        byteBuffer.flip();<br><br>        <span class="hljs-comment">//将byteBuffer数据写入到 fileChannel</span><br>        fileChannel.write(byteBuffer);<br>        fileOutputStream.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实例2-本地文件读数据</strong></p><ol><li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 <code>file01.txt</code> 中的数据读入到程序，并显示在控制台屏幕</li><li>假定文件已经存在</li><li>代码演示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel02</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//创建文件的输入流</span><br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/Users/pudewu/software07/Java/stud_code/java-basic/file01.txt&quot;</span>);<br>        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(file);<br><br>        <span class="hljs-comment">//通过fileInputStream获取对应的FileChannel -&gt; 实际类型FileChannelImpl</span><br>        FileChannel fileChannel = fileInputStream.getChannel();<br><br>        <span class="hljs-comment">//创建缓冲区</span><br>        ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="hljs-keyword">int</span>) file.length());<br><br>        <span class="hljs-comment">//将通道的数据读入到Buffer</span><br>        fileChannel.read(byteBuffer);<br><br>        <span class="hljs-comment">//将 byteBuffer的字节数据转成String</span><br>        System.out.println(<span class="hljs-keyword">new</span> String(byteBuffer.array()));<br><br>        fileInputStream.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实例3-使用一个Buffer完成文件读取、写入</strong></p><ol><li>使用 <code>FileChannel</code>（通道）和方法 <code>read、write</code>，完成文件的拷贝</li><li>拷贝一个文本文件 <code>1.txt</code>，放在项目下即可</li><li>代码演示</li></ol><p><img src="/img/work/chapter03_09.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel03</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;file01.txt&quot;</span>);<br><br>        FileChannel fileChannel01 = fileInputStream.getChannel();<br><br>        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;file02.txt&quot;</span>);<br>        FileChannel fileChannel02 = fileOutputStream.getChannel();<br><br>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">512</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            byteBuffer.clear();<br><br>            <span class="hljs-keyword">int</span> read = fileChannel01.read(byteBuffer);<br>            System.out.println(<span class="hljs-string">&quot;read=&quot;</span> + read);<br>            <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//将buffer中的数据写入到 fileChannel02--file02.txt</span><br>            byteBuffer.flip();<br>            fileChannel02.write(byteBuffer);<br>        &#125;<br><br>        fileChannel01.close();<br>        fileChannel02.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实例4-拷贝文件transferFrom方法</strong></p><ol><li>实例要求：</li><li>使用 <code>FileChannel</code>（通道）和方法 <code>transferFrom</code>，完成文件的拷贝</li><li>拷贝一张图片</li><li>代码演示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel04</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        <span class="hljs-comment">//创建相关流</span><br>        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;wallhaven-lqkxmr.jpg&quot;</span>);<br>        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;fengjing.jpg&quot;</span>);<br>        <br>        <span class="hljs-comment">//获取各个流对应的FileChannel</span><br>        FileChannel sourceChannel = fileInputStream.getChannel();<br>        FileChannel targetChannel = fileOutputStream.getChannel();<br><br>        <span class="hljs-comment">//使用transferForm 完成拷贝</span><br>        targetChannel.transferFrom(sourceChannel,<span class="hljs-number">0</span>,sourceChannel.size());<br><br>        <span class="hljs-comment">//关闭相关通道和流</span><br>        sourceChannel.close();<br>        targetChannel.close();<br>        fileInputStream.close();<br>        fileOutputStream.close();<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-关于Buffer和Channel注意事项和细节"><a href="#5-3-关于Buffer和Channel注意事项和细节" class="headerlink" title="5.3 关于Buffer和Channel注意事项和细节"></a>5.3 关于Buffer和Channel注意事项和细节</h4><ol><li><code>ByteBuffer</code> 支持类型化的 <code>put</code> 和 <code>get</code>，<code>put</code> 放入的是什么数据类型，<code>get</code> 就应该使用相应的数据类型来取出，否则可能有 <code>BufferUnderflowException</code> 异常。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOByteBufferPutGet</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建一个Buffer</span><br>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">64</span>);<br><br>        <span class="hljs-comment">//类型化方式放入数据</span><br>        byteBuffer.putInt(<span class="hljs-number">100</span>);<br>        byteBuffer.putLong(<span class="hljs-number">9</span>);<br>        byteBuffer.putChar(<span class="hljs-string">&#x27;尚&#x27;</span>);<br>        byteBuffer.putShort((<span class="hljs-keyword">short</span>) <span class="hljs-number">4</span>);<br><br>        <span class="hljs-comment">//取出</span><br>        byteBuffer.flip();<br><br>        System.out.println();<br><br>        System.out.println(byteBuffer.getInt());<br>        System.out.println(byteBuffer.getLong());<br>        System.out.println(byteBuffer.getChar());<br>        System.out.println(byteBuffer.getShort());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>可以将一个普通 <code>Buffer</code> 转成只读 <code>Buffer</code>【举例说明】</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadOnlyBuffer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//创建一个buffer</span><br>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">64</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">64</span>; i++) &#123;<br>            buffer.put((<span class="hljs-keyword">byte</span>) i);<br>        &#125;<br><br>        <span class="hljs-comment">//读取</span><br>        buffer.flip();<br><br>        <span class="hljs-comment">//得到一个只读的buffer</span><br>        ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();<br>        System.out.println(readOnlyBuffer.getClass());<br><br>        <span class="hljs-keyword">while</span> (readOnlyBuffer.hasRemaining()) &#123;<br>            System.out.println(readOnlyBuffer.get());<br>        &#125;<br><br>        <span class="hljs-comment">//ReadOnlyBufferException</span><br>        readOnlyBuffer.put((<span class="hljs-keyword">byte</span>) <span class="hljs-number">100</span>); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><code>NIO</code> 还提供了 <code>MappedByteBuffer</code>，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由 <code>NIO</code> 来完成。</li></ol><p><strong>MappedByteBuffer 可让文件直接在内存（堆外内存）修改,操作系统不需要拷贝一次</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MappedByteBufferTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br><br>        RandomAccessFile randomAccessFile = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br><br>        <span class="hljs-comment">//获取对应的通道</span><br>        FileChannel fileChannel = randomAccessFile.getChannel();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数 1:FileChannel.MapMode.READ_WRITE 使用的读写模式</span><br><span class="hljs-comment">         * 参数 2：0：可以直接修改的起始位置</span><br><span class="hljs-comment">         * 参数 3:5: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存</span><br><span class="hljs-comment">         * 可以直接修改的范围就是 0-5</span><br><span class="hljs-comment">         * 实际类型 DirectByteBuffer</span><br><span class="hljs-comment">         */</span><br>        MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br><br>        mappedByteBuffer.put(<span class="hljs-number">0</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;H&#x27;</span>);<br>        mappedByteBuffer.put(<span class="hljs-number">3</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;9&#x27;</span>);<br>        <br>        <span class="hljs-comment">//IndexOutOfBoundsException</span><br>        mappedByteBuffer.put(<span class="hljs-number">5</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;Y&#x27;</span>);<br><br>        randomAccessFile.close();<br>        System.out.println(<span class="hljs-string">&quot;修改成功~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终成功文件为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">H9<br></code></pre></td></tr></table></figure><ol start="4"><li>前面我们讲的读写操作，都是通过一个 <code>Buffer</code> 完成的，<code>NIO</code> 还支持通过多个 <code>Buffer</code>（即 <code>Buffer</code>数组）完成读写操作，即 <code>Scattering</code> 和 <code>Gathering</code></li></ol><p><strong>Scattering：将数据写入到 buffer 时，可以采用 buffer 数组，依次写入 [分散]</strong> </p><p><strong>Gathering：从 buffer 读取数据时，可以采用 buffer 数组，依次读</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScatteringAndGatheringTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        <span class="hljs-comment">//使用 ServerSocketChannel 和 SocketChannel 网络</span><br>        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<br><br>        InetSocketAddress inetSocketAddress = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">7000</span>);<br><br>        <span class="hljs-comment">//绑定端口到 socket，并启动</span><br>        serverSocketChannel.socket().bind(inetSocketAddress);<br><br>        <span class="hljs-comment">//创建 buffer 数组</span><br>        ByteBuffer[] byteBuffers = <span class="hljs-keyword">new</span> ByteBuffer[<span class="hljs-number">2</span>];<br><br>        byteBuffers[<span class="hljs-number">0</span>] = ByteBuffer.allocate(<span class="hljs-number">5</span>);<br>        byteBuffers[<span class="hljs-number">1</span>] = ByteBuffer.allocate(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">//等客户端连接 (telnet)</span><br>        SocketChannel socketChannel = serverSocketChannel.accept();<br><br>        <span class="hljs-comment">//假定从客户端接收 8 个字节</span><br>        <span class="hljs-keyword">int</span> messageLength = <span class="hljs-number">8</span>;<br><br>        <span class="hljs-comment">//循环的读取</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">int</span> byteRead = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">while</span> (byteRead &lt; messageLength ) &#123;<br>                <span class="hljs-keyword">long</span> read = socketChannel.read(byteBuffers);<br><br>                byteRead += read;<br><br>                System.out.println(<span class="hljs-string">&quot;byteRead = &quot;</span> + byteRead);<br><br>                Arrays.asList(byteBuffers).stream().map(buffer -&gt; <span class="hljs-string">&quot;position = &quot;</span> + buffer.position() + <span class="hljs-string">&quot;, limit = &quot;</span> + buffer.limit()).forEach(System.out::println);<br><br><br>            &#125;<br><br>            <span class="hljs-comment">//将所有的 buffer 进行 flip</span><br>            Arrays.asList(byteBuffers).forEach(e -&gt; e.flip());<br><br><br><br>            <span class="hljs-comment">//将数据读出显示到客户端</span><br>            <span class="hljs-keyword">long</span> byteWrite = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">while</span> (byteWrite &lt; messageLength) &#123;<br>                <span class="hljs-keyword">long</span> l = socketChannel.write(byteBuffers);<br>                byteWrite += l;<br>            &#125;<br><br><br>            <span class="hljs-comment">//将所有buffer进行clear</span><br>            Arrays.asList(byteBuffers).forEach(e -&gt; e.clear());<br><br>            System.out.println(<span class="hljs-string">&quot;byteRead = &quot;</span> + byteRead + <span class="hljs-string">&quot;, byteWrite = &quot;</span> + byteWrite + <span class="hljs-string">&quot;, messagelength = &quot;</span> + messageLength);<br>        &#125;<br><br><br><br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-Selector-选择器"><a href="#6-Selector-选择器" class="headerlink" title="6 Selector(选择器)"></a>6 Selector(选择器)</h3><h4 id="6-4-基本介绍"><a href="#6-4-基本介绍" class="headerlink" title="6.4 基本介绍"></a>6.4 基本介绍</h4><ol><li><code>Java</code> 的 <code>NIO</code>，用非阻塞的 <code>IO</code> 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <code>Selector</code>（选择器）。</li><li><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。【示意图】</li><li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li><li>避免了多线程之间的上下文切换导致的开销。</li></ol><h4 id="6-2-Selector示意图和特点说明"><a href="#6-2-Selector示意图和特点说明" class="headerlink" title="6.2 Selector示意图和特点说明"></a>6.2 Selector示意图和特点说明</h4><p><img src="/img/work/chapter03_10.png" alt="img"></p><p>说明如下:</p><ol><li>Netty的IO线程NioEventLoop聚合了Selector(选择器，也叫多路复用器)，可以同时并发处理成百上千个客户端连接。</li><li>当线程从某个客户端<code>Socket</code>通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</li><li>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</li><li>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</li><li>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li></ol><h4 id="6-3-Selector类相关方法"><a href="#6-3-Selector类相关方法" class="headerlink" title="6.3 Selector类相关方法"></a>6.3 Selector类相关方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Selector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Closeable</span> </span>&#123;<br>  <br>  <span class="hljs-comment">//得到一个选择器对象</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Selector <span class="hljs-title">open</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">return</span> SelectorProvider.provider().openSelector();<br>    &#125;<br>  <br>  <span class="hljs-comment">//监控所有注册的通道，当其中有io操作可以进行时，将对应的SelectionKey加入到内部集合并返回，参数用来设置超时时间。</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span></span>;<br>  <br>  <br>  <span class="hljs-comment">//从内部集合中得到所有的SelectionKey</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Set&lt;SelectionKey&gt; <span class="hljs-title">selectedKeys</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-4-注意事项"><a href="#6-4-注意事项" class="headerlink" title="6.4 注意事项"></a>6.4 注意事项</h4><ol><li>NIO中的<code>ServerSocketChannel</code>功能类似<code>ServerSocket</code>、<code>SocketChannel</code>功能类似<code>Socket</code></li><li><code>Selector</code> 相关方法说明<ul><li><code>selector.select();</code> //阻塞</li><li><code>selector.select(1000);</code> //阻塞 1000 毫秒，在 1000 毫秒后返回</li><li><code>selector.wakeup();</code> //唤醒 selector</li><li><code>selector.selectNow();</code> //不阻塞，立马返还</li></ul></li></ol><h3 id="7-NIO-非阻塞网络编程原理分析图"><a href="#7-NIO-非阻塞网络编程原理分析图" class="headerlink" title="7 [NIO 非阻塞网络编程原理分析图"></a>7 [NIO 非阻塞网络编程原理分析图</h3><p><code>NIO</code> 非阻塞网络编程相关的（<code>Selector</code>、<code>SelectionKey</code>、<code>ServerScoketChannel</code> 和 <code>SocketChannel</code>）关系梳理图</p><p><img src="/img/work/chapter03_22.png"></p><p>对上图的说明：</p><ol><li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li><li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li><li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li><li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li><li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li><li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li><li>可以通过得到的 <code>channel</code>，完成业务处理。</li><li>代码撑腰。。。</li></ol><h3 id="8-SelectionKey"><a href="#8-SelectionKey" class="headerlink" title="8 SelectionKey"></a>8 SelectionKey</h3><ol><li> <code>SelectionKey</code>，表示 <code>Selector</code> 和网络通道的注册关系，共四种： </li></ol><ul><li><code>int OP_ACCEPT</code>: 有新的网络连接可以 <code>accept</code>，值为 <code>16</code> </li><li><code>int OP_CONNECT</code>：代表连接已经建立，值为 <code>8</code></li><li><code>int OP_READ</code>：代表读操作，值为 <code>1</code></li><li><code>int OP_WRITE</code>：代表写操作，值为 <code>4</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_READ = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_WRITE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_CONNECT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_ACCEPT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><ol start="2"><li><code>SelectionKey</code> 相关方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectionKey</span></span>&#123;<br>    <span class="hljs-comment">//得到与之关联的Selector对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Selector <span class="hljs-title">selector</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-comment">//得到与之关联的通道</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> SelectableChannel <span class="hljs-title">channel</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-comment">//得到与之关联的共享数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">attachment</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> attachment;<br>    &#125;<br>    <br>    <span class="hljs-comment">//设置或改变监听事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> SelectionKey <span class="hljs-title">interestOps</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ops)</span></span>;<br>    <br>    <span class="hljs-comment">// 是否可以accept</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAcceptable</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (readyOps() &amp; OP_ACCEPT) != <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//是否可以读</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isReadable</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (readyOps() &amp; OP_READ) != <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isWritable</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (readyOps() &amp; OP_WRITE) != <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-ServerSocketChannel"><a href="#9-ServerSocketChannel" class="headerlink" title="9 ServerSocketChannel"></a>9 ServerSocketChannel</h3><ol><li><code>ServerSocketChannel</code> 在服务器端监听新的客户端 <code>Socket</code> 连接</li><li>相关方法如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerSocketChannel</span>    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSelectableChannel</span>    <span class="hljs-keyword">implements</span> <span class="hljs-title">NetworkChannel</span></span>&#123;<br>    <br>    <span class="hljs-comment">//得到一个ServerSocketChannel通道</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ServerSocketChannel <span class="hljs-title">open</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function">    <span class="hljs-comment">//设置服务器端端口号    </span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ServerSocketChannel <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress local)</span>    </span><br><span class="hljs-function">    </span><br><span class="hljs-function">        </span><br><span class="hljs-function">    <span class="hljs-comment">//接受一个连接，返回代表这个连接的通道对象  </span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> SocketChannel <span class="hljs-title">accept</span><span class="hljs-params">()</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="10-SocketChannel"><a href="#10-SocketChannel" class="headerlink" title="10 SocketChannel"></a>10 SocketChannel</h3><ol><li><p><code>SocketChannel</code>，网络 <code>IO</code> 通道，具体负责进行读写操作。<code>NIO</code> 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</p></li><li><p>相关方法如下</p><p> <img src="/img/work/chapter03_14.png"> </p></li></ol><h3 id="11-NIO-网络编程应用实例-群聊系统"><a href="#11-NIO-网络编程应用实例-群聊系统" class="headerlink" title="11 NIO 网络编程应用实例 - 群聊系统"></a>11 NIO 网络编程应用实例 - 群聊系统</h3><p> 实例要求： </p><ol><li><p>编写一个 <code>NIO</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</p></li><li><p>实现多人群聊</p></li><li><p>服务器端：可以监测用户上线，离线，并实现消息转发功能</p></li><li><p>客户端：通过 <code>Channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</p></li><li><p>目的：进一步理解 <code>NIO</code> 非阻塞网络编程机制</p></li><li><p>示意图分析和代码</p></li></ol><p><img src="/img/work/chapter03_15.png"></p><p>server端代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatServer</span> </span>&#123;<br><br>    <span class="hljs-comment">//定义属性</span><br>    <span class="hljs-keyword">private</span> Selector selector;<br><br>    <span class="hljs-keyword">private</span> ServerSocketChannel listenChannel;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">6667</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatServer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-comment">//得到选择器</span><br>            selector = Selector.open();<br><br>            <span class="hljs-comment">//ServerSocketChannel</span><br>            listenChannel = ServerSocketChannel.open();<br><br>            <span class="hljs-comment">//绑定端口</span><br>            listenChannel.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(PORT));<br><br>            <span class="hljs-comment">//设置非阻塞模式</span><br>            listenChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br><br>            <span class="hljs-comment">//将该ListenChannel 注册到 selector</span><br>            listenChannel.register(selector, SelectionKey.OP_ACCEPT);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">int</span> count = selector.select();<br><br>                <span class="hljs-comment">//有事件处理</span><br>                <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">//遍历得到SelectionKey集合</span><br>                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();<br><br>                    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br><br>                        <span class="hljs-comment">//取出selectionKey</span><br>                        SelectionKey key = iterator.next();<br>                        <span class="hljs-comment">//监听到 accept</span><br>                        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                            SocketChannel sc = listenChannel.accept();<br>                            sc.configureBlocking(<span class="hljs-keyword">false</span>);<br><br>                            <span class="hljs-comment">//将该sc注册到selector</span><br>                            sc.register(selector,SelectionKey.OP_READ);<br><br>                            <span class="hljs-comment">//提示</span><br>                            System.out.println(sc.getRemoteAddress() + <span class="hljs-string">&quot;上线&quot;</span>);<br>                        &#125;<br><br>                        <span class="hljs-comment">// 通道发送read事件，即通道是刻度的状态</span><br>                        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                            <span class="hljs-comment">//处理读（专门写方法）</span><br>                            readData(key);<br>                        &#125;<br><br>                        <span class="hljs-comment">//当前的 key删除，防止重复处理</span><br>                        iterator.remove();<br><br>                    &#125;<br><br><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;等待。。。&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//发生异常处理</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readData</span><span class="hljs-params">(SelectionKey selectionKey)</span> </span>&#123;<br>        SocketChannel channel = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-comment">//得到channel</span><br>            channel = (SocketChannel) selectionKey.channel();<br><br>            <span class="hljs-comment">//创建buffer</span><br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>            <span class="hljs-keyword">int</span> read = channel.read(buffer);<br><br>            <span class="hljs-keyword">if</span> (read &gt; <span class="hljs-number">0</span> ) &#123;<br>                <span class="hljs-comment">//把缓存区的数据转成字符串</span><br>                String msg = <span class="hljs-keyword">new</span> String(buffer.array());<br>                <span class="hljs-comment">//输出该消息</span><br>                System.out.println(<span class="hljs-string">&quot;from客户端：&quot;</span> + msg);<br><br>                <span class="hljs-comment">//向其他的客户端转发消息(去掉自己)，专门写一个方法来处理</span><br>                sendInfoToOtherClients(msg,channel);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(channel.getRemoteAddress()+ <span class="hljs-string">&quot;离线了&quot;</span>);<br><br>                <span class="hljs-comment">//取消注册</span><br>                selectionKey.cancel();<br><br>                <span class="hljs-comment">//关闭通道</span><br>                channel.close();<br><br>            &#125; <span class="hljs-keyword">catch</span> (IOException e1) &#123;<br>                e1.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendInfoToOtherClients</span><span class="hljs-params">(String msg,SocketChannel self)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器转发消息。。。。&quot;</span>);<br>        <span class="hljs-comment">//遍历所有注册到selector上的SocketChannel，并排除self</span><br>        <span class="hljs-keyword">for</span> (SelectionKey key : selector.keys()) &#123;<br>            <span class="hljs-comment">//通过key取出对应的SocketChannel</span><br>            SelectableChannel targetChannel = key.channel();<br>            <span class="hljs-comment">//排除自己</span><br>            <span class="hljs-keyword">if</span> (targetChannel <span class="hljs-keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != self) &#123;<br>                <span class="hljs-comment">//转型</span><br>                SocketChannel socketChannel = (SocketChannel) targetChannel;<br><br>                <span class="hljs-comment">//将msg 存储到Buffer</span><br>                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());<br><br>                <span class="hljs-comment">//将buffer的数据写入通道</span><br>                socketChannel.write(buffer);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建服务器对象</span><br>        GroupChatServer groupChatServer = <span class="hljs-keyword">new</span> GroupChatServer();<br>        groupChatServer.listen();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatClient</span> </span>&#123;<br><br>    <span class="hljs-comment">//服务器ip</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String HOST = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><br>    <span class="hljs-comment">//服务器端口</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">6667</span>;<br><br>    <span class="hljs-keyword">private</span> Selector selector;<br><br>    <span class="hljs-keyword">private</span> SocketChannel socketChannel;<br><br>    <span class="hljs-keyword">private</span> String username;<br><br>    <span class="hljs-comment">//构造器，完成初始化工作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatClient</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        selector = Selector.open();<br><br>        <span class="hljs-comment">//连接服务器</span><br>        socketChannel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(HOST, PORT));<br><br>        <span class="hljs-comment">//设置非阻塞</span><br>        socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br><br>        <span class="hljs-comment">//将channel 注册到selector</span><br>        socketChannel.register(selector, SelectionKey.OP_READ);<br><br>        <span class="hljs-comment">//得到 username</span><br>        username = socketChannel.getLocalAddress().toString().substring(<span class="hljs-number">1</span>);<br><br>        System.out.println(username + <span class="hljs-string">&quot; is ok&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//向服务器发送消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendInfo</span><span class="hljs-params">(String info)</span> </span>&#123;<br>        info = username + <span class="hljs-string">&quot;说:&quot;</span> + info;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            socketChannel.write(ByteBuffer.wrap(info.getBytes()));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> readChannels = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            readChannels = selector.select();<br><br>            <span class="hljs-keyword">if</span> (readChannels &gt; <span class="hljs-number">0</span>) &#123;<br>                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();<br><br>                <span class="hljs-keyword">if</span> (iterator.hasNext()) &#123;<br>                    SelectionKey key = iterator.next();<br><br>                    <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                        SocketChannel sc = (SocketChannel) key.channel();<br>                        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>                        sc.read(buffer);<br><br>                        String msg = <span class="hljs-keyword">new</span> String(buffer.array());<br><br>                        System.out.println(msg);<br>                    &#125;<br>                &#125;<br>                iterator.remove();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//启动客户端</span><br>        GroupChatClient client = <span class="hljs-keyword">new</span> GroupChatClient();<br><br>        <span class="hljs-keyword">new</span> Thread() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                    client.readInfo();<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        sleep(<span class="hljs-number">3000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;.start();<br><br>        <span class="hljs-comment">//发送数据给服务端</span><br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br><br>        <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;<br>            String line = scanner.nextLine();<br>            client.sendInfo(line);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-NIO-与零拷贝"><a href="#12-NIO-与零拷贝" class="headerlink" title="12 NIO 与零拷贝"></a>12 NIO 与零拷贝</h3><h4 id="12-1-零拷贝基本介绍"><a href="#12-1-零拷贝基本介绍" class="headerlink" title="12.1 零拷贝基本介绍"></a>12.1 零拷贝基本介绍</h4><ol><li>零拷贝是网络编程的关键，很多性能优化都离不开。</li><li>在 <code>Java</code> 程序中，常用的零拷贝有 <code>mmap</code>（内存映射）和 <code>sendFile</code>。那么，他们在 <code>OS</code> 里，到底是怎么样的一个的设计？我们分析 <code>mmap</code> 和 <code>sendFile</code> 这两个零拷贝</li><li>另外我们看下 <code>NIO</code> 中如何使用零拷贝</li></ol><h4 id="12-2-传统IO数据的读写"><a href="#12-2-传统IO数据的读写" class="headerlink" title="12.2 传统IO数据的读写"></a>12.2 传统IO数据的读写</h4><p><code>Java</code> 传统 <code>IO</code> 和网络编程的一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(file, <span class="hljs-string">&quot;rw&quot;</span>);<br><br><span class="hljs-keyword">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>) file.length()];<br>raf.read(arr);<br><br>Socket socket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>).accept();<br>socket.getOutputStream().write(arr);<br></code></pre></td></tr></table></figure><h4 id="12-3-传统IO模型"><a href="#12-3-传统IO模型" class="headerlink" title="12.3 传统IO模型"></a>12.3 传统IO模型</h4><p><img src="/img/work/chapter03_17.png" alt="img"></p><p><strong>DMA</strong>：<code>direct memory access</code> 直接内存拷贝（不使用 <code>CPU</code>）</p><h4 id="12-4-mmap优化"><a href="#12-4-mmap优化" class="headerlink" title="12.4 mmap优化"></a>12.4 mmap优化</h4><ol><li><code>mmap</code> 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图</li><li><code>mmap</code> 示意图</li></ol><p><img src="/img/work/chapter03_18.png"></p><p>3.12.5 sendFile优化</p><ol><li><code>Linux2.1</code> 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 <code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换</li><li>示意图和小结</li></ol><p><img src="/img/work/chapter03_19.png"></p><ol start="3"><li><p>提示：零拷贝从操作系统角度，是没有 <code>cpu</code> 拷贝</p></li><li><p><code>Linux在2.4</code> 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socketbuffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图和小结：</p></li></ol><p><img src="/img/work/chapter03_20.png"></p><ol start="5"><li>这里其实有一次 <code>cpu</code> 拷贝 <code>kernel buffer</code> -&gt; <code>socket buffer</code> 但是，拷贝的信息很少，比如 <code>lenght</code>、<code>offset</code> 消耗低，可以忽略</li></ol><p>3.12.4 零拷贝的再次理解</p><ol><li>我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的（只有 <code>kernel buffer</code> 有一份数据）。</li><li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 <code>CPU</code> 缓存伪共享以及无 <code>CPU</code> 校验和计算。</li></ol><h4 id="12-5-mmap-和-sendFile-的区别"><a href="#12-5-mmap-和-sendFile-的区别" class="headerlink" title="12.5 mmap 和 sendFile 的区别"></a>12.5 mmap 和 sendFile 的区别</h4><ol><li><code>mmap</code> 适合小数据量读写，<code>sendFile</code> 适合大文件传输。</li><li><code>mmap</code> 需要 <code>4</code> 次上下文切换，<code>3</code> 次数据拷贝；<code>sendFile</code> 需要 <code>3</code> 次上下文切换，最少 <code>2</code> 次数据拷贝。</li><li><code>sendFile</code> 可以利用 <code>DMA</code> 方式，减少 <code>CPU</code> 拷贝，<code>mmap</code> 则不能（必须从内核拷贝到 <code>Socket</code>缓冲区）。</li></ol><h4 id="12-6-NIO零拷贝案例"><a href="#12-6-NIO零拷贝案例" class="headerlink" title="12.6 NIO零拷贝案例"></a>12.6 NIO零拷贝案例</h4><p>案例要求：</p><ol><li>使用传统的 <code>IO</code> 方法传递一个大文件</li><li>使用 <code>NIO</code> 零拷贝方式传递（<code>transferTo</code>）一个大文件</li><li>看看两种传递方式耗时时间分别是多少</li></ol><p>Server端:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewIOServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        InetSocketAddress inetSocketAddress = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8001</span>);<br>        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<br>        ServerSocket serverSocket = serverSocketChannel.socket();<br>        serverSocket.bind(inetSocketAddress);<br><br>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">4096</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            SocketChannel socketChannel = serverSocketChannel.accept();<br>            <span class="hljs-keyword">int</span> readCount = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (-<span class="hljs-number">1</span> != readCount) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    readCount = socketChannel.read(byteBuffer);<br>                &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//倒带 position = 0 mark 作废</span><br>                byteBuffer.rewind();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Client端:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewIOClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        SocketChannel socketChannel = SocketChannel.open();<br><br>        socketChannel.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">8001</span>));<br>        String filename = <span class="hljs-string">&quot;/Users/pudewu/Downloads/激活码包含专用激活 (3).zip&quot;</span>;<br><br>        <span class="hljs-comment">//得到一个文件Channel</span><br>        FileChannel fileChannel = <span class="hljs-keyword">new</span> FileInputStream(filename).getChannel();<br><br>        <span class="hljs-comment">//准备发送</span><br>        <span class="hljs-keyword">long</span> currentTimeMillis = System.currentTimeMillis();<br>        <span class="hljs-comment">//在 linux 下一个 transferTo 方法就可以完成传输</span><br>        <span class="hljs-comment">//在 windows 下一次调用 transferTo 只能发送 8m, 就需要分段传输文件,而且要主要</span><br>        <span class="hljs-comment">//传输时的位置=》课后思考...</span><br>        <span class="hljs-comment">//transferTo 底层使用到零拷贝</span><br>        <span class="hljs-keyword">long</span> transferCount = fileChannel.transferTo(<span class="hljs-number">0</span>, fileChannel.size(), socketChannel);<br>        System.out.println(<span class="hljs-string">&quot;发送的总的字节数 = &quot;</span> + transferCount + <span class="hljs-string">&quot; 耗时: &quot;</span> + (System.currentTimeMillis() - currentTimeMillis));<br><br>        <span class="hljs-comment">//关闭</span><br>        fileChannel.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="12-7-JavaAIO-基本介绍"><a href="#12-7-JavaAIO-基本介绍" class="headerlink" title="12.7 JavaAIO 基本介绍"></a>12.7 JavaAIO 基本介绍</h4><ol><li><code>JDK7</code> 引入了 <code>AsynchronousI/O</code>，即 <code>AIO</code>。在进行 <code>I/O</code> 编程中，常用到两种模式：<code>Reactor</code> 和 <code>Proactor</code>。<code>Java</code> 的 <code>NIO</code> 就是 <code>Reactor</code>，当有事件触发时，服务器端得到通知，进行相应的处理</li><li><code>AIO</code> 即 <code>NIO2.0</code>，叫做异步不阻塞的 <code>IO</code>。<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li><li>目前 <code>AIO</code> 还没有广泛应用，<code>Netty</code> 也是基于 <code>NIO</code>，而不是 <code>AIO</code>，因此我们就不详解 <code>AIO</code> 了，有兴趣的同学可以参考<a href="http://www.52im.net/thread-306-1-1.html">《Java新一代网络编程模型AIO原理及Linux系统AIO介绍》</a></li></ol><h4 id="12-8-BIO、NIO、AIO对比表"><a href="#12-8-BIO、NIO、AIO对比表" class="headerlink" title="12.8 BIO、NIO、AIO对比表"></a>12.8 BIO、NIO、AIO对比表</h4><table><thead><tr><th></th><th>BIO</th><th>NIO</th><th>AIO</th></tr></thead><tbody><tr><td>IO模型</td><td>同步阻塞</td><td>同步非阻塞（多路复用）</td><td>异步非阻塞</td></tr><tr><td>编程难度</td><td>简单</td><td>复杂</td><td>复杂</td></tr><tr><td>可靠性</td><td>差</td><td>好</td><td>好</td></tr><tr><td>吞吐量</td><td>低</td><td>高</td><td>高</td></tr></tbody></table><p><strong>举例说明</strong></p><ol><li>同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。</li><li>同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说下，先干其他事情，一会过来看是否轮到自己.</li><li>异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发</li></ol><h3 id="13-参考"><a href="#13-参考" class="headerlink" title="13 参考"></a>13 参考</h3><p><a href="https://dongzl.github.io/netty-handbook/#/_content/chapter03">Java NIO编程</a></p><p><a href="https://www.bilibili.com/video/av76227904/">尚硅谷Ntty视频教程</a></p><p><a href="https://ke.qq.com/course/463900">尚硅谷Netty视频教程</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaIO之BIO</title>
    <link href="/2022/01/23/JavaIO%E4%B9%8BBIO/"/>
    <url>/2022/01/23/JavaIO%E4%B9%8BBIO/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Java-BIO"><a href="#Java-BIO" class="headerlink" title="Java BIO"></a>Java BIO</h2><h3 id="1-IO模型"><a href="#1-IO模型" class="headerlink" title="1 IO模型"></a>1 IO模型</h3><h4 id="1-1-模型基本说明"><a href="#1-1-模型基本说明" class="headerlink" title="1.1 模型基本说明"></a>1.1 模型基本说明</h4><ol><li><code>I/O</code> 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。</li><li><code>Java</code> 共支持 <code>3</code> 种网络编程模型 <code>I/O</code> 模式：<code>BIO</code>、<code>NIO</code>、<code>AIO</code>。</li><li><code>Java BIO</code>：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。【简单示意图】</li></ol><p><img src="/img/work/chapter02_01.png"></p><ol start="4"><li><code>Java NIO</code>：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 <code>I/O</code> 请求就进行处理。【简单示意图】</li></ol><p><img src="/img/work/chapter02_02.png"></p><ol start="5"><li><code>Java AIO(NIO.2)</code>：异步非阻塞，<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</li></ol><h3 id="2-BIO、NIO、AIO-使用场景分析"><a href="#2-BIO、NIO、AIO-使用场景分析" class="headerlink" title="2 BIO、NIO、AIO 使用场景分析"></a>2 BIO、NIO、AIO 使用场景分析</h3><ol><li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，但程序简单易理解。</li><li><code>NIO</code> 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，<code>JDK1.4</code> 开始支持。</li><li><code>AIO</code> 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 <code>OS</code> 参与并发操作，编程比较复杂，<code>JDK7</code> 开始支持。</li></ol><h3 id="3-Java-BIO基本介绍"><a href="#3-Java-BIO基本介绍" class="headerlink" title="3 Java BIO基本介绍"></a>3 Java BIO基本介绍</h3><ol><li><code>Java BIO</code> 就是传统的 <code>Java I/O</code> 编程，其相关的类和接口在 <code>java.io</code>。</li><li><code>BIO(BlockingI/O)</code>：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）。【后有应用实例】</li><li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，程序简单易理解。</li></ol><h3 id="4-Java-BIO机制"><a href="#4-Java-BIO机制" class="headerlink" title="4 Java BIO机制"></a>4 Java BIO机制</h3><p><img src="/img/work/chapter02_03.png"></p><p>对 <code>BIO</code> 编程流程的梳理</p><ol><li>服务器端启动一个 <code>ServerSocket</code>。</li><li>客户端启动 <code>Socket</code> 对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯。</li><li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。</li><li>如果有响应，客户端线程会等待请求结束后，在继续执行。</li></ol><h3 id="5-Java-BIO应用实例"><a href="#5-Java-BIO应用实例" class="headerlink" title="5 Java BIO应用实例"></a>5 Java BIO应用实例</h3><p>实例说明：</p><ol><li><p>使用 <code>BIO</code> 模型编写一个服务器端，监听 <code>6666</code> 端口，当有客户端连接时，就启动一个线程与之通讯。</p></li><li><p>要求使用线程池机制改善，可以连接多个客户端。</p></li><li><p>服务器端可以接收客户端发送的数据（<code>telnet</code> 方式即可）。</p></li><li><p>代码演示：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.bio;<br><br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BIOServer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//线程池机制</span><br>        <span class="hljs-comment">//思路</span><br>        <span class="hljs-comment">//1. 创建一个线程池</span><br>        <span class="hljs-comment">//2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span><br>        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();<br>        <span class="hljs-comment">//创建ServerSocket</span><br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务器启动了&quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-comment">//监听，等待客户端连接</span><br>            System.out.println(<span class="hljs-string">&quot;等待连接....&quot;</span>);<br>            <span class="hljs-keyword">final</span> Socket socket = serverSocket.accept();<br>            System.out.println(<span class="hljs-string">&quot;连接到一个客户端&quot;</span>);<br>            <span class="hljs-comment">//就创建一个线程，与之通讯(单独写一个方法)</span><br>            newCachedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//我们重写</span><br>                    <span class="hljs-comment">//可以和客户端通讯</span><br>                    handler(socket);<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//编写一个handler方法，和客户端通讯</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(Socket socket)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-comment">//通过socket获取输入流</span><br>            InputStream inputStream = socket.getInputStream();<br>            <span class="hljs-comment">//循环的读取客户端发送的数据</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());<br>                System.out.println(<span class="hljs-string">&quot;read....&quot;</span>);<br>                <span class="hljs-keyword">int</span> read = inputStream.read(bytes);<br>                <span class="hljs-keyword">if</span> (read != -<span class="hljs-number">1</span>) &#123;<br>                    System.out.println(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, read));<span class="hljs-comment">//输出客户端发送的数据</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;关闭和client的连接&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                socket.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-Java-BIO问题分析"><a href="#6-Java-BIO问题分析" class="headerlink" title="6 Java BIO问题分析"></a>6 Java BIO问题分析</h3><ol><li>每个请求都需要创建独立的线程，与对应的客户端进行数据 <code>Read</code>，业务处理，数据 <code>Write</code>。</li><li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li><li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 <code>Read</code> 操作上，造成线程资源浪费。</li></ol><h3 id="7-参考"><a href="#7-参考" class="headerlink" title="7.参考"></a>7.参考</h3><p><a href="https://dongzl.github.io/netty-handbook/#/_content/chapter02">Java BIO编程</a></p><p><a href="https://www.bilibili.com/video/av76227904/">尚硅谷Ntty视频教程</a></p><p><a href="https://ke.qq.com/course/463900">尚硅谷Netty视频教程</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-IO模型</title>
    <link href="/2022/01/23/Java-IO%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/01/23/Java-IO%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-UNIX-I-O-模型"><a href="#1-UNIX-I-O-模型" class="headerlink" title="1 UNIX I/O 模型"></a>1 UNIX I/O 模型</h2><blockquote><p>UNIX 系统下的 I/O 模型有 5 种:</p></blockquote><ul><li><p>同步阻塞 I/O</p></li><li><p>同步非阻塞 I/O</p></li><li><p>I/O 多路复用</p></li><li><p>信号驱动 I/O</p></li><li><p>异步 I/O</p></li></ul><blockquote><p>如何去理解 UNIX I/O 模型，大致有以下两个维度：</p></blockquote><ul><li>区分同步或异步（synchronous/asynchronous）。简单来说，同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；而异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系。</li><li>区分阻塞与非阻塞（blocking/non-blocking）。在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。</li></ul><blockquote><p>不能一概而论认为同步或阻塞就是低效，具体还要看应用和系统特征。对于一个网络 I/O 通信过程，比如网络数据读取，会涉及两个对象，一个是调用这个 I/O 操作的用户线程，另外一个就是操作系统内核。一个进程的地址空间分为用户空间和内核空间，用户线程不能直接访问内核空间。</p></blockquote><p>当用户线程发起 I/O 操作后，网络数据读取操作会经历两个步骤：</p><ul><li><strong>用户线程等待内核将数据从网卡拷贝到内核空间。</strong></li><li><strong>内核将数据从内核空间拷贝到用户空间。</strong></li></ul><p>各种 I/O 模型的区别就是：它们实现这两个步骤的方式是不一样的。</p><h3 id="1-1-同步阻塞-I-O"><a href="#1-1-同步阻塞-I-O" class="headerlink" title="1.1 同步阻塞 I/O"></a>1.1 同步阻塞 I/O</h3><blockquote><p>用户线程发起 read 调用后就阻塞了，让出 CPU。内核等待网卡数据到来，把数据从网卡拷贝到内核空间，接着把数据拷贝到用户空间，再把用户线程叫醒。</p></blockquote><p><img src="/img/work/20201121163321.jpg"></p><h3 id="1-2-同步非阻塞-I-O"><a href="#1-2-同步非阻塞-I-O" class="headerlink" title="1.2 同步非阻塞 I/O"></a>1.2 同步非阻塞 I/O</h3><blockquote><p>用户线程不断的发起 read 调用，数据没到内核空间时，每次都返回失败，直到数据到了内核空间，这一次 read 调用后，在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的，等数据到了用户空间再把线程叫醒。</p></blockquote><p><img src="/img/work/20201121163344.jpg"></p><h3 id="1-3-I-O-多路复用"><a href="#1-3-I-O-多路复用" class="headerlink" title="1.3 I/O 多路复用"></a>1.3 I/O 多路复用</h3><blockquote><p>用户线程的读取操作分成两步了，线程先发起 select 调用，目的是问内核数据准备好了吗？等内核把数据准备好了，用户线程再发起 read 调用。在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的。那为什么叫 I/O 多路复用呢？因为一次 select 调用可以向内核查多个数据通道（Channel）的状态，所以叫多路复用。</p></blockquote><p><img src="/img/work/20201121163408.jpg"></p><h3 id="1-4-信号驱动-I-O"><a href="#1-4-信号驱动-I-O" class="headerlink" title="1.4 信号驱动 I/O"></a>1.4 信号驱动 I/O</h3><blockquote><p>首先开启 Socket 的信号驱动 I/O 功能，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函数处理数据。<strong>信号驱动式 I/O 模型的优点是我们在数据报到达期间进程不会被阻塞，我们只要等待信号处理函数的通知即可</strong></p></blockquote><h3 id="1-5-异步-I-O"><a href="#1-5-异步-I-O" class="headerlink" title="1.5 异步 I/O"></a>1.5 异步 I/O</h3><blockquote><p>用户线程发起 read 调用的同时注册一个回调函数，read 立即返回，等内核将数据准备好后，再调用指定的回调函数完成处理。在这个过程中，用户线程一直没有阻塞。</p></blockquote><p><img src="/img/work/20201121163428.jpg"></p><h2 id="2-参考"><a href="#2-参考" class="headerlink" title="2.参考"></a>2.参考</h2><p><a href="https://dunwu.github.io/javacore/io/java-io.html">JavaIO模型</a></p><p><a href="https://book.douban.com/subject/2130190/">《Java 编程思想（Thinking in java）》</a></p><p><a href="https://book.douban.com/subject/26880667/">《Java 核心技术 卷 I 基础知识》</a></p><p><a href="https://item.jd.com/12555860.html">《Java 从入门到精通》</a></p><p><a href="https://time.geekbang.org/column/intro/100006701">《Java 核心技术面试精讲》</a></p><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/BIO-NIO-AIO.md">BIO,NIO,AIO 总结</a></p><p><a href="https://time.geekbang.org/column/intro/100027701">深入拆解 Tomcat &amp; Jetty</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO模型,IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java容器之Queue</title>
    <link href="/2021/12/16/Java%E5%AE%B9%E5%99%A8%E4%B9%8BQueue/"/>
    <url>/2021/12/16/Java%E5%AE%B9%E5%99%A8%E4%B9%8BQueue/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-什么是Queue"><a href="#1-什么是Queue" class="headerlink" title="1.什么是Queue"></a>1.什么是Queue</h2><p><code>Queue</code>也就是队列，是一种基本的<code>线性数据结构</code>，与之类似的其他数据结构还有数组、链表、栈等。</p><p>Queue是一种遵循<strong>先进先出</strong>（<code>FIFO: First In, First Out</code>）原则的数据集合，数据在Queue中的流动是单向的，从队尾流向队首。</p><p>如下图所示，元素的插入发生在队尾，删除发生在队首；通常一个元素从队首中取出后，该元素从Queue中删除；非队首的元素，无法直接对其进行读取。</p><p><img src="/img/work/image-20211216094638623.png" alt="Queue队列"></p><p>在现实世界中队列非常常见，比如排队等待购票、上车的乘客，流水线上一个个等待处理的产品，都是一种队列模型；而且程序设计的世界中队列使用也非常广泛：比如多线程中等待处理的任务、排队等待获取某个锁的线程等。</p><h2 id="2-Java中的Queue接口"><a href="#2-Java中的Queue接口" class="headerlink" title="2. Java中的Queue接口"></a>2. Java中的Queue接口</h2><p><img src="/img/work/Queue-diagrams.png" alt="Queue类关系图"></p><h3 id="2-1-Queue接口定义"><a href="#2-1-Queue接口定义" class="headerlink" title="2.1 Queue接口定义"></a>2.1 Queue接口定义</h3><p>在Java中，队列是一种基本的集合类型，提供了队列接口<code>Queue</code>，定义在 其中<code>java.util</code>包中；其中<code>Queue</code>接口继承了基础集合接口<code>Collection</code>。</p><p>Queue接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">element</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Queue接口中，定义基本的元素插入和删除的方法，主要方法及其含义分别如下：</p><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>boolean add(E e)</code></td><td align="left">向队列中添加一个元素；如果有空间则添加成功返回true，否则则抛出<code>IllegalStateException</code>异常</td></tr><tr><td align="left"><code>boolean offer(E e)</code></td><td align="left">向队列中添加一个元素；如果有空间则添加成功返回true，否则返回false</td></tr><tr><td align="left"><code>E remove()</code></td><td align="left">从队列中删除一个元素；如果元素存在则返回队首元素，否则抛出<code>NoSuchElementException</code>异常</td></tr><tr><td align="left"><code>E poll();</code></td><td align="left">从队列中删除一个元素；如果元素存在则返回队首元素，否则返回null</td></tr><tr><td align="left"><code>E element()</code></td><td align="left">从队列获取一个元素，但是不删除；如果元素存在则返回队首元素，否则抛出<code>NoSuchElementException</code>异常</td></tr><tr><td align="left"><code>E peek()</code></td><td align="left">从队列获取一个元素，但是不删除；如果元素存在则返回队首元素，否则返回null</td></tr></tbody></table><h3 id="2-2-双端队列：Deque接口"><a href="#2-2-双端队列：Deque接口" class="headerlink" title="2.2 双端队列：Deque接口"></a>2.2 双端队列：Deque接口</h3><p>在上面的Queue接口定义中，实现了最基本的元素插入和删除方法，也就是从队尾进行元素插入，在队首进行元素删除；而Java还提供了另一个功能强大的<code>Deque接口</code>，实现了<strong>双端队列</strong>的功能。</p><p><strong>什么是双端队列？</strong></p><p>双端队列就是可以支持在队首或者队尾，都可以进行元素的插入和删除操作的队列，如下图所示。在双端队列中，分别使用<code>front</code>和<code>back</code>表示队列的首、尾两端，而在插入或删除元素时，可以通过指定在队列的哪一端进行操作。</p><p>比如：<code>push_front()</code>表示在队首进行元素的插入，<code>pop_back()</code>表示在队尾进行元素的删除。</p><p><img src="/img/work/image-20211216103519826.png"></p><p><strong>Deque接口的定义如下</strong>：</p><p><img src="/img/work/d3f650e5a9b846eab201c5aadcd703d2.png" alt="Deque类图"></p><p>可以看到，<code>Deque</code>接口继承了<code>Queue</code>接口，除了基本的<code>Queue</code>接口的方法外，<code>Deque</code>还提供了<strong>双端队列</strong>的操作方法，如代码所示，每个操作方法与<code>Queue</code>的操作方法类似，只是指定了在队首还是队尾进行元素操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">// 向队首添加一个元素；如果有空间则添加成功返回true，否则则抛出`IllegalStateException`异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span></span>;<br>    <span class="hljs-comment">// 向队尾添加一个元素；如果有空间则添加成功返回true，否则则抛出`IllegalStateException`异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-comment">// 向队首添加一个元素；如果有空间则添加成功返回true，否则返回false</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span></span>;<br>    <span class="hljs-comment">// 向队尾添加一个元素；如果有空间则添加成功返回true，否则返回false</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerLast</span><span class="hljs-params">(E e)</span></span>;<br>  <br>    <span class="hljs-comment">// 从队首删除一个元素；如果元素存在则返回队首元素，否则抛出`NoSuchElementException`异常</span><br>    <span class="hljs-function">E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 从队尾删除一个元素；如果元素存在则返回队尾元素，否则抛出`NoSuchElementException`异常</span><br>    <span class="hljs-function">E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 从队首删除一个元素；如果元素存在则返回队首元素，否则返回null</span><br>    <span class="hljs-function">E <span class="hljs-title">pollFirst</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 从队尾删除一个元素；如果元素存在则返回队首元素，否则返回null</span><br>    <span class="hljs-function">E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span></span>;<br>  <br>    <span class="hljs-comment">// 从队首获取一个元素，但是不删除；如果元素存在则返回队首元素，否则抛出`NoSuchElementException`异常</span><br>    <span class="hljs-function">E <span class="hljs-title">getFirst</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 从队尾获取一个元素，但是不删除；如果元素存在则返回队尾元素，否则抛出`NoSuchElementException`异常</span><br>    <span class="hljs-function">E <span class="hljs-title">getLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 从队首获取一个元素，但是不删除；如果元素存在则返回队首元素，否则返回null</span><br>    <span class="hljs-function">E <span class="hljs-title">peekFirst</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 从队尾获取一个元素，但是不删除；如果元素存在则返回队尾元素，否则返回null</span><br>    <span class="hljs-function">E <span class="hljs-title">peekLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 如果元素o存在，则从队列中删除第一次出现的该元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span></span>;<br>    <span class="hljs-comment">// 如果元素o存在，则从队列中删除最后一次出现的该元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeLastOccurrence</span><span class="hljs-params">(Object o)</span></span>;<br>    <span class="hljs-comment">// 其他方法省略....</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-实现类-LinkedList"><a href="#2-3-实现类-LinkedList" class="headerlink" title="2.3 实现类 LinkedList"></a>2.3 实现类 LinkedList</h3><p>在前面，我们了解了Java中定义的两个队列接口<code>Queue</code>和<code>Deque</code>，而两个接口的实现类是通过<code>LinkedList</code>来实现的。从类名定义上可以看出来，<code>LinkedList</code>其实是基于链表实现的List的一个数据集合，而且<code>LinkedList</code>还实现了<code>Queue</code>接口和<code>Deque</code>接口。我们可以直接使用<code>LinkedList</code>来实现队列的操作。下面是其定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializableb</span> </span>&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一个基于<code>LinkedList</code>实现的双端队列的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  Deque&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  <span class="hljs-comment">// 元素入队</span><br>  queue.offer(<span class="hljs-string">&quot;1&quot;</span>);<br>  queue.offer(<span class="hljs-string">&quot;2&quot;</span>);<br>  queue.offer(<span class="hljs-string">&quot;3&quot;</span>);<br>  queue.offerFirst(<span class="hljs-string">&quot;0&quot;</span>);  <span class="hljs-comment">// 队首添加元素0</span><br>  queue.offerLast(<span class="hljs-string">&quot;4&quot;</span>);   <span class="hljs-comment">// 队尾添加元素4</span><br><br>  System.out.println(queue);  <span class="hljs-comment">// 此时队列中的元素为：[0, 1, 2, 3, 4]</span><br><br>  <span class="hljs-comment">// 元素出队</span><br>  System.out.println(queue.poll());       <span class="hljs-comment">// 删除队首元素，打印值：0</span><br>  System.out.println(queue.pollFirst());  <span class="hljs-comment">// 删除队首元素，打印值：1</span><br>  System.out.println(queue.pollLast());   <span class="hljs-comment">// 删除队尾元素，打印值：4</span><br>&#125;<br></code></pre></td></tr></table></figure><p>OK，到这儿我们已经了解了队列接口的定义以及实现类LinkedList的定义以及使用方法，下面我们简单看下LinkedList底层是如何实现的队列功能。</p><h2 id="3-LinkedList如何实现队列功能"><a href="#3-LinkedList如何实现队列功能" class="headerlink" title="3. LinkedList如何实现队列功能"></a>3. LinkedList如何实现队列功能</h2><h3 id="3-1-链表的定义"><a href="#3-1-链表的定义" class="headerlink" title="3.1 链表的定义"></a>3.1 链表的定义</h3><p>上面我们了解到，<code>LinkedList</code>其实是基于链表实现的一个数据集合，并实现了队列的接口功能。我们再来看下<code>LinkedList</code>的定义和成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">// 元素数量</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 队首元素节点</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br>    <span class="hljs-comment">// 队尾元素节点</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在LinkedList中有两个成员变量<code>first</code>和<code>last</code>，类型为<code>Node&lt;E&gt;</code>，分别表示队列中队首和队尾的节点，其实也就是链表中的首尾节点。<code>Node&lt;E&gt;</code>是链表的一个节点，下面是其定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// 元素值</span><br>  E item;<br>  <span class="hljs-comment">// 后一个节点</span><br>  Node&lt;E&gt; next;<br>  <span class="hljs-comment">// 前一个节点</span><br>  Node&lt;E&gt; prev;<br><br>  Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>    <span class="hljs-keyword">this</span>.item = element;<br>    <span class="hljs-keyword">this</span>.next = next;<br>    <span class="hljs-keyword">this</span>.prev = prev;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>Node&lt;E&gt;</code>中，成员变量<code>item</code>用来存储具体的元素值，另外两个<code>Node&lt;E&gt;</code>类型的变量<code>next</code>和<code>prev</code>分别表示该节点的<strong>后一个节点</strong>和<strong>上一个节点</strong>。</p><p>到此，我们就可以知道，<code>LinkedList</code>其实是由一个<strong>双向链表</strong>构成，并通过<code>first</code>和<code>last</code>分别表示链表的首尾节点。然后我们可以画出下面这个链表的示意图。</p><p><img src="/img/work/image-20211216150618309.png" alt="双向链表"></p><h3 id="3-2-元素的插入"><a href="#3-2-元素的插入" class="headerlink" title="3.2 元素的插入"></a>3.2 元素的插入</h3><p>在前面的介绍中，我们知道，元素的插入可以使用<code>add</code>和<code>offer</code>两个方法，不同的是当队列容量不足时，<code>add</code>方法会抛除异常，而<code>offer</code>方法会返回false。但是<code>LinkedList</code>是基于双向链表实现，理论上该链表是无界的，只要程序内存允许，可以一直插入新的元素。</p><p>下面我们看下<code>offer</code>方法插入元素的实现逻辑，代码如下（已添加相关注释）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt; .....</span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 插入元素</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-comment">// 此处直接调用了add方法</span><br>    <span class="hljs-keyword">return</span> add(e);<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 插入元素</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-comment">// 调用linkLast方法</span><br>    linkLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在链表尾部，添加一个新元素，并作为新的last节点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-comment">// 当前last节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-comment">// 创建新节点，prev节点指向当前last节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(l, e, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// 新节点作为新的last节点</span><br>    last = newNode;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)<br>      <span class="hljs-comment">// 如果原last节点为null，表示该链表为空，则将节点同时作为first节点</span><br>      first = newNode;<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-comment">// 链表不为空，则将新节点，作为原last节点的next节点</span><br>      l.next = newNode;<br>    <span class="hljs-comment">// 元素数量+1</span><br>    size++;<br>    <span class="hljs-comment">// 集合修改次数+1</span><br>    modCount++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中可以很容易的看出，<code>offer</code>方法直接调用了<code>add</code>方法，<code>add</code>方法中调用了<code>linkLast</code>方法，并直接返回了true，表示该元素肯定可以插入成功。具体执行元素插入的逻辑在<code>linkLast</code>方法中完成，通过上面代码中的注释可以看出，<code>linkLast</code>方法主要功能是在链表尾端添加一个新节点，具体操作示意图如下：</p><p><img src="/img/work/583d7c2d5af44dec8a42e053e04e411d~tplv-k3u1fbpfcp-watermark.image.png" alt="链表的尾插入"></p><p><strong><code>offerFirst</code>和<code>offerLast</code>是如何实现的？</strong></p><p>当了解了<code>offer</code>方法后，我们再看下<code>offerFirst</code>和<code>offerLast</code>的实现。从下面代码中可以知道，<code>offerFirst</code>和<code>offerLast</code>方法分别调用了<code>addFirst</code>和<code>addLast</code>方法，然后在<code>addFirst</code>和<code>addLast</code>方法中，又分别调用了<code>linkFirst</code>和<code>linkLast</code>方法。</p><p><code>linkLast</code>方法上已经讲到，主要功能是在链表尾端添加一个新节点；而<code>linkFirst</code>方法，其主要功能是在链表首端添加一个新节点，具体逻辑与<code>linkLast</code>方法类似，本处不再赘述，可以参考下面代码中的注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt; .....</span>&#123;<br>  <span class="hljs-comment">// 队首插入元素</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    addFirst(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br>  <span class="hljs-comment">// 队尾插入元素</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    addLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br>  <span class="hljs-comment">// 队首插入元素</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    linkFirst(e);<br>  &#125;<br>  <span class="hljs-comment">// 队尾插入元素</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    linkLast(e);<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在链表头部，添加一个新元素，并作为新的first节点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">linkFirst</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-comment">// 当前first节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-comment">// 创建新节点，next节点指向当前first节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(<span class="hljs-keyword">null</span>, e, f);<br>    <span class="hljs-comment">// 新节点作为新的first节点</span><br>    first = newNode;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)<br>      <span class="hljs-comment">// 如果原first节点为null，表示该链表为空，则将节点同时作为last节点</span><br>      last = newNode;<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-comment">// 链表不为空，则将新节点，作为原first节点的prev节点</span><br>      f.prev = newNode;<br>    <span class="hljs-comment">// 元素数量+1</span><br>    size++;<br>    <span class="hljs-comment">// 集合修改次数+1</span><br>    modCount++;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在链表尾部，添加一个新元素，并作为新的last节点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-comment">// 本处省略，详见上一代码块</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此我们已经了解了元素是如何插入的，并且分别介绍了双端队列中在队首和队尾插入元素的实现逻辑，下面我们再简单看下元素是如何实现删除的。</p><h3 id="3-3-元素的删除"><a href="#3-3-元素的删除" class="headerlink" title="3.3 元素的删除"></a>3.3 元素的删除</h3><p>前面了解了元素的插入流程，我们再看删除流程就很清晰了，主要功能就是将队列头或者队尾的节点删除。删除节点的方法主要有<code>poll</code>和<code>pollFirst</code>和<code>pollLast</code>，以及<code>delete</code>、<code>deleteFirst</code>和<code>deleteLast</code>。这几个方法最终调用的都是两个链表的操作方法<code>unlinkFirst</code>和<code>unlinkLast</code>，表示删除链表头部和链表尾部的节点。</p><p>下面是<code>unlinkFirst</code>和<code>unlinkLast</code>方法的代码逻辑，此处不再赘述，可以直接看代码注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt; .....</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除链表头结点f，f不为空</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkFirst</span><span class="hljs-params">(Node&lt;E&gt; f)</span> </span>&#123;<br>        <span class="hljs-comment">// assert f == first &amp;&amp; f != null;</span><br>        <span class="hljs-comment">// 获取头结点的元素</span><br>        <span class="hljs-keyword">final</span> E element = f.item;<br>        <span class="hljs-comment">// 获取头结点的next结点</span><br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; next = f.next;<br>        f.item = <span class="hljs-keyword">null</span>;<br>        f.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>        <span class="hljs-comment">// 将next结点作为头结点</span><br>        first = next;<br>        <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-comment">// next结点为null，表示删除完成后链表为空，则last结点置为null</span><br>            last = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 删除完成后链表非空，则当前头结点的prev结点为null</span><br>            next.prev = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 元素数量-1</span><br>        size--;<br>        <span class="hljs-comment">// 集合修改次数-1</span><br>        modCount++;<br>        <span class="hljs-comment">// 返回删除结点的元素</span><br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除链表尾结点l，l不为空</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkLast</span><span class="hljs-params">(Node&lt;E&gt; l)</span> </span>&#123;<br>        <span class="hljs-comment">// assert l == last &amp;&amp; l != null;</span><br>        <span class="hljs-comment">// 获取尾结点的元素</span><br>        <span class="hljs-keyword">final</span> E element = l.item;<br>        <span class="hljs-comment">// 获取尾结点的prev结点</span><br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = l.prev;<br>        l.item = <span class="hljs-keyword">null</span>;<br>        l.prev = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>        <span class="hljs-comment">// 将prev结点作为尾结点</span><br>        last = prev;<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-comment">// prev结点为null，表示删除完成后链表为空，则first结点置为null</span><br>            first = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 删除完成后链表非空，则当前尾结点的next结点为null</span><br>            prev.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 元素数量-1</span><br>        size--;<br>        <span class="hljs-comment">// 集合修改次数-1</span><br>        modCount++;<br>        <span class="hljs-comment">// 返回删除结点的元素</span><br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文主要介绍了Java中Queue的基础用法以及相关底层原理，使用Queue我们可以实现一些任务排队处理的功能等。</p><p>但是在上面分析过程中，我们可以发现Java中Queue的实现其实是<strong>非线程安全</strong>的，如果在多线程环境下进行Queue的入队和出队操作，会产生不一致的情况。所以Java也提供了线程安全的队列类——阻塞队列<code>BlockingQueue</code>。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><p><a href="http://soiiy.com/Java/16298">深入理解Java系列 | Queue用法详解</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java-容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java容器之Set</title>
    <link href="/2021/12/15/Java%E5%AE%B9%E5%99%A8%E4%B9%8BSet/"/>
    <url>/2021/12/15/Java%E5%AE%B9%E5%99%A8%E4%B9%8BSet/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基于<code>jdk1.8</code>介绍<code>Set</code>接口下的常用实现类。</p><h2 id="1-java-集合框架"><a href="#1-java-集合框架" class="headerlink" title="1 java 集合框架"></a>1 java 集合框架</h2><p><img src="/img/work/image-20211122204933065.png" alt="集合关系图"></p><p>由类图我们可以看到，<code>set</code>接口继承自<code>Collection</code>接口且有四个实现类，分别为<code>AbstractSet</code>、<code>HashSet</code>、<code>LinkedHashSet</code>和<code>TreeSet</code>，其中<code>AbstractSet</code>为抽象类，继承自<code>AbstractCollection</code>，实现了最基本的<code>Collection</code>骨架。下面我们分别来看一下其余三个实现类的实现原理。</p><h2 id="2-HashSet"><a href="#2-HashSet" class="headerlink" title="2.HashSet"></a>2.HashSet</h2><p><img src="/img/work/image-20211215104248593.png" alt="HashSet类图"></p><p>对于<code>HashSet</code>而言，它是基于<code>HashMap</code>实现的，可以看作是对<code>HashMap</code>的封装，<code>HashSet</code>底层使用<code>HashMap</code>来保存所有元素，因此<code>HashSet</code>的实现比较简单，相关<code>HashSet</code>的操作，基本上都是直接调用底层<code>HashMap</code>的相关方法来完成.</p><h3 id="2-1-成员变量"><a href="#2-1-成员变量" class="headerlink" title="2.1 成员变量"></a>2.1 成员变量</h3><p>首先看一下两个成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<span class="hljs-comment">//存储元素的map</span><br><span class="hljs-comment">// Dummy value to associate with an Object in the backing Map</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object(); <span class="hljs-comment">//元素的默认vlaue</span><br></code></pre></td></tr></table></figure><p>通过这两个成员变量我们可以看到，在<code>HashSet</code>的内部维护着一个<code>HashMap</code>类型的变量<code>map</code>，这个<code>map</code>就是用来存储元素的容器。那我们知道，<code>HashMap</code>存储的是<code>key-value</code>形式的键值对，而<code>set</code>是一个单值对象，这要怎么存储呢？那就要看第二个成员变量<code>PRESENT</code>了，<code>PRESENT</code>是一个<code>Object</code>对象，这个对象就是充当键值对的值的，也就是说，我们只会把需要存储的元素当作<code>map</code>的<code>key</code>，而对应的<code>value</code>则默认为这个<code>Object</code>对象，这就是<code>HashSet</code>内部实现存储元素的数据结构。所以由<code>HashMap</code>的特性我们可以知道，<code>HashSet</code>存储的元素是无序的，元素是不可重复的并且可以为<code>null</code>，基于这个元素不允许重复的特性，<code>HashSet</code>经常被用来做元素的去重。</p><h3 id="2-2-构造方法"><a href="#2-2-构造方法" class="headerlink" title="2.2 构造方法"></a>2.2 构造方法</h3><p>下面我们看一下<code>HashSet</code>提供的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造一个使用HashMap的默认容量大小16和默认加载因子0.75初始化map的HashSet</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">()</span> </span>&#123;<br>     map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br> &#125;<br><br><br><span class="hljs-comment">//根据 Collection 接口构造一个HashSet</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>     map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="hljs-keyword">int</span>) (c.size()/<span class="hljs-number">.75f</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">16</span>));<br>     addAll(c);<br> &#125;<br><br> <span class="hljs-comment">//使用指定的初始容量大小和加载因子初始化map，构造一个HashSet</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>     map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);<br> &#125;<br><br><span class="hljs-comment">//使用指定的初始容量大小初始化map，构造一个HashSet</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>     map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(initialCapacity);<br> &#125;<br><br> <span class="hljs-comment">//构造一个LinkedHashMap，不对外公开 </span><br> HashSet(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor, <span class="hljs-keyword">boolean</span> dummy) &#123;<br>     map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);<br> &#125;<br></code></pre></td></tr></table></figure><p><code>HashSet</code>一共提供了5个构造方法，由构造方法也可以看到，底层是用了<code>HashMap</code>的数据结构实现，构造方法也跟<code>HashMap</code>比较类似，这里重点要说一下<code>HashSet(int initialCapacity, float loadFactor, boolean dummy)</code>这个构造方法，这个构造方法是不对外部公开的，其实放在这里实现是为了给<code>LinkedHashSet</code>使用，下文我们会讲到这一点。</p><h3 id="2-3-存取实现"><a href="#2-3-存取实现" class="headerlink" title="2.3 存取实现"></a>2.3 存取实现</h3><p>添加元素</p><p>由于底层使用了<code>HashMap</code>作存储结构，这里直接调用了<code>HashMap</code>的<code>put</code>方法插入元素，元素被作为<code>key</code>插入的<code>map</code>中，而<code>value</code>则是使用的默认值<code>Object</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;<span class="hljs-comment">//直接将元素作为map的key插入</span><br>&#125;<br></code></pre></td></tr></table></figure><p>遍历</p><p><code>HashSet</code>支持两种遍历方式，<code>Iterator</code>方式，<code>foreach</code>方式，不支持随机访问方式遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; set=<span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br> hashset.add(<span class="hljs-string">&quot;1&quot;</span>);<br> hashset.add(<span class="hljs-string">&quot;2&quot;</span>);<br><span class="hljs-comment">//Iterator遍历  </span><br><span class="hljs-keyword">for</span>(Iterator iterator = set.iterator();<br>      iterator.hasNext(); ) &#123; <br>   iterator.next();<br>&#125;<br><span class="hljs-comment">//foreach遍历</span><br> <span class="hljs-keyword">for</span> (String str:set)&#123;<br>    System.out.println(str);<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-特性总结"><a href="#2-4-特性总结" class="headerlink" title="2.4 特性总结"></a>2.4 特性总结</h3><p>1、由于底层基于<code>HashMap</code>实现，内部使用基于哈希表的数组+链表方式存储，所以不保证元素的存取顺序。<br>2、基于<code>key</code>的<code>hash</code>值存储，同样的对象<code>hash</code>值相同，所以元素不可重复，但是可以为<code>null</code>，可以快速查找是否包含某个元素。</p><h2 id="3-LinkedHashSet"><a href="#3-LinkedHashSet" class="headerlink" title="3.LinkedHashSet"></a>3.LinkedHashSet</h2><p><img src="/img/work/image-20211215111633626.png" alt="LinkedHashSet类关系图"></p><p>由类图我们可以看到，<code>LinkedHashSet</code>继承自<code>HashSet</code>，内部是基于<code>LinkedHashMap</code>来实现的。<code>LinkedHashSet</code>底层使用<code>LinkedHashMap</code>来保存所有元素，其所有的方法操作上又与<code>HashSet</code>相同，因此<code>LinkedHashSet</code> 的实现上非常简单，只提供了四个构造方法和一个<code>spliterator</code>方法，并通过传递一个标识参数，调用父类的构造方法，上文我们说到<code>HashSet</code>预留了一个不对外部公开的构造方法，就是用在这里。底层构造一个<code>LinkedHashMap来实现</code>，在相关操作上与父类<code>HashSet</code>的操作相同，直接调用父类<code>HashSet</code>的方法即可。</p><p><code>LinkedHashSet</code>源码，由于底层使用<code>LinkedHashMap</code>作为存储结构，继承了<code>HashSet</code>的各种方法,在此只做简单说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用指定的初始容量大小和加载因子初始化map，构造一个LinkedHashSet</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>     <span class="hljs-keyword">super</span>(initialCapacity, loadFactor, <span class="hljs-keyword">true</span>);<br> &#125;<br><span class="hljs-comment">//使用指定的初始容量大小初始化map，构造一个LinkedHashSet</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>     <span class="hljs-keyword">super</span>(initialCapacity, <span class="hljs-number">.75f</span>, <span class="hljs-keyword">true</span>);<br> &#125;<br> <span class="hljs-comment">// 构造一个使用HashMap的默认容量大小16和默认加载因子0.75初始化map的LinkedHashSet</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashSet</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">super</span>(<span class="hljs-number">16</span>, <span class="hljs-number">.75f</span>, <span class="hljs-keyword">true</span>);<br> &#125;<br>  <span class="hljs-comment">//根据 Collection 接口构造一个inkedHashSet</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashSet</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>     <span class="hljs-keyword">super</span>(Math.max(<span class="hljs-number">2</span>*c.size(), <span class="hljs-number">11</span>), <span class="hljs-number">.75f</span>, <span class="hljs-keyword">true</span>);<br>     addAll(c);<br> &#125;<br> <span class="hljs-comment">// 调用Spliterator接口中的spliterator()方法，将集合分割后遍历</span><br> <span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> Spliterator&lt;E&gt; <span class="hljs-title">spliterator</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> Spliterators.spliterator(<span class="hljs-keyword">this</span>, Spliterator.DISTINCT | Spliterator.ORDERED);<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="3-1-特性总结"><a href="#3-1-特性总结" class="headerlink" title="3.1 特性总结"></a>3.1 特性总结</h3><p>1、底层存储基于<code>LinkedHashMap</code>实现，内部使用双向链表存储元素，所以保证了元素的顺序性。<br>2、基于<code>key</code>的<code>hash</code>值存储，同样的对象<code>hash</code>值相同，所以元素不可重复，但是可以为<code>null</code>，可以快速查找是否包含某个元素。</p><h2 id="4-TreeSet"><a href="#4-TreeSet" class="headerlink" title="4.TreeSet"></a>4.TreeSet</h2><p><img src="/img/work/image-20211215115341761.png" alt="TreeSet类关系图"></p><p>还是先看类图，<code>TreeSet</code>继承自<code>AbstractSet</code>，实现了<code>NavigableSet</code>接口，<code>AbstractSet</code>为抽象类，继承自<code>AbstractCollection</code>，实现了最基本的<code>Collection</code>骨架。<code>TreeSet</code>是基于<code>TreeMap</code>实现的有序集合，<code>TreeSet</code>中含有一个<code>NavigableMap</code>类型的成员变量<code>m</code>，而<code>m</code>实际上是<code>TreeMap</code>的实例。我们知道<code>TreeMap</code>内部是用红黑树实现元素存储从而保证元素的顺序性的，那么同理<code>TreeSet</code>同样也是一个有序的集合。通过源码我们知道<code>TreeSet</code>继承自<code>AbstractSet</code>，实现<code>NavigableSet</code>、<code>Cloneable</code>、<code>Serializable</code>接口。其中<code>AbstractSet</code>提供 <code>Set</code> 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。<code>NavigableSet</code>是扩展的 <code>SortedSet</code>，具有了为给定搜索目标报告最接近匹配项的导航方法，这就意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。<code>Cloneable</code>支持克隆，<code>Serializable</code>支持序列化。</p><p>成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">//NavigableMap 对象</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> NavigableMap&lt;E,Object&gt; m;<br><span class="hljs-comment">//map的value值</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();<br></code></pre></td></tr></table></figure><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造由指定的可导航映射支持的集合。</span><br>TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;<br>    <span class="hljs-keyword">this</span>.m = m;<br>&#125;<br><span class="hljs-comment">//默认构造方法  根据其元素的自然顺序进行排序 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> TreeMap&lt;E,Object&gt;());<br>&#125;<br><span class="hljs-comment">//构造一个包含指定 collection 的TreeSet，它按照其元素的顺序进行排序</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; comparator)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> TreeMap&lt;&gt;(comparator));<br>&#125;<br><span class="hljs-comment">//构造一个指定Collection参数的TreeSet</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>();<br>    addAll(c);<br>&#125;<br><span class="hljs-comment">//构造一个指定SortedMap的TreeSet，根据SortedMap的比较器来来维持TreeSet的顺序</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">(SortedSet&lt;E&gt; s)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(s.comparator());<br>    addAll(s);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-特性总结"><a href="#4-1-特性总结" class="headerlink" title="4.1 特性总结"></a>4.1 特性总结</h3><p>1、底层存储基于<code>TreeMap</code>实现，内部使用红黑树结构表存储元素，所以保证了元素的顺序性。<br>2、元素不可为<code>null</code>。<br>2、遍历时不支持随机访问，只能通过迭代器和<code>for-each</code>遍进行遍历。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><p><a href="https://yanglukuan.github.io/2017/09/09/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BSet%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/">Java集合框架之Set接口详解</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java-容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java容器之Map</title>
    <link href="/2021/12/14/Java%E5%AE%B9%E5%99%A8%E4%B9%8BMap/"/>
    <url>/2021/12/14/Java%E5%AE%B9%E5%99%A8%E4%B9%8BMap/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Map集合概述"><a href="#1-Map集合概述" class="headerlink" title="1.Map集合概述"></a>1.Map集合概述</h2><h3 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h3><blockquote><p>如果程序中存储了几百万个学生，而且经常需要使用学号来搜索某个学生，那么这个需求有效的数据结构就是Map。Map是一种依照键（key）存储元素的容器，键（key）很像下标，在List中下标是整数。在Map中键（key）可以使任意类型的对象。Map中不能有重复的键（Key），每个键（key）都有一个对应的值（value）。一个键（key）和它对应的值构成map集合中的一个元素。Map中的元素是两个对象，一个对象作为键，一个对象作为值。键不可以重复，但是值可以重复。</p></blockquote><h3 id="1-2-Map架构"><a href="#1-2-Map架构" class="headerlink" title="1.2 Map架构"></a>1.2 Map架构</h3><p><img src="/img/work/image-20211129105948926.png" alt="map集合关系图"></p><p>Map 家族主要成员功能如下：</p><ul><li><p><code>Map</code> 是 Map 容器家族的祖先，Map 是一个用于保存键值对(key-value)的接口。<strong>Map 中不能包含重复的键；每个键最多只能映射到一个值。</strong></p></li><li><p><code>AbstractMap</code> 继承了 <code>Map</code> 的抽象类，它实现了 <code>Map</code> 中的核心 API。其它 <code>Map</code> 的实现类可以通过继承 <code>AbstractMap</code> 来减少重复编码。</p></li><li><p><code>SortedMap</code> 继承了 <code>Map</code> 的接口。<code>SortedMap</code> 中的内容是排序的键值对，排序的方法是通过实现比较器(<code>Comparator</code>)完成的。</p></li><li><p><code>NavigableMap</code> 继承了 <code>SortedMap</code> 的接口。相比于 <code>SortedMap</code>，<code>NavigableMap</code> 有一系列的“导航”方法；如”获取大于/等于某对象的键值对”、“获取小于/等于某对象的键值对”等等。</p></li><li><p><code>HashMap</code> 继承了 <code>AbstractMap</code>，但没实现 <code>NavigableMap</code> 接口。<code>HashMap</code> 的主要作用是储存无序的键值对，而 <code>Hash</code> 也体现了它的查找效率很高。<code>HashMap</code> 是使用最广泛的 <code>Map</code>。</p></li><li><p><code>Hashtable</code> 虽然没有继承 <code>AbstractMap</code>，但它继承了 <code>Dictionary</code>（<code>Dictionary</code> 也是键值对的接口），而且也实现 <code>Map</code> 接口。因此，<code>Hashtable</code> 的主要作用是储存无序的键值对。和 HashMap 相比，<code>Hashtable</code> 在它的主要方法中使用 <code>synchronized</code> 关键字修饰，来保证线程安全。但是，由于它的锁粒度太大，非常影响读写速度，所以，现代 Java 程序几乎不会使用 <code>Hashtable</code> ，如果需要保证线程安全，一般会用 <code>ConcurrentHashMap</code> 来替代。</p></li><li><p><code>TreeMap</code> 继承了 <code>AbstractMap</code>，且实现了 <code>NavigableMap</code> 接口。<code>TreeMap</code> 的主要作用是储存有序的键值对，排序依据根据元素类型的 <code>Comparator</code> 而定。</p></li><li><p><code>WeakHashMap</code> 继承了 <code>AbstractMap</code>。<code>WeakHashMap</code> 的键是<strong>弱引用</strong> （即 <code>WeakReference</code>），它的主要作用是当 GC 内存不足时，会自动将 <code>WeakHashMap</code> 中的 key 回收，这避免了 <code>WeakHashMap</code> 的内存空间无限膨胀。很明显，<code>WeakHashMap</code> 适用于作为缓存。</p></li><li><p><code>LinkedHashMap</code>继承了HashMap,HashMap是无序的，当我们希望有顺序地去存储key-value时，就需要使用LinkedHashMap了。</p></li></ul><h3 id="1-3-Map集合与Collection集合的区别"><a href="#1-3-Map集合与Collection集合的区别" class="headerlink" title="1.3 Map集合与Collection集合的区别"></a>1.3 Map集合与Collection集合的区别</h3><ul><li>collection中的集合，元素是孤立存在的(单身狗)，向集合中存储元素采用一个个元素的方式存储。</li><li>map中的集合，元素是成对存在的(情侣、夫妻)，每个元素由键(key)与值(value)两个部分组成，通过键可以找到其所对应的值。</li><li>collection中的集合成为单列集合，map中的集合称为双列集合。</li><li>Collection接口的底层是由哈希表或哈希表+链表实现的。</li><li>Map接口的底层是由哈希表和链接列表实现的。</li></ul><h3 id="1-4-Map集合特点"><a href="#1-4-Map集合特点" class="headerlink" title="1.4 Map集合特点"></a>1.4 Map集合特点</h3><ul><li><p>Map集合是一个双列集合，一个元素包含两个值（一个key，一个value）。</p></li><li><p>Map集合中的元素，key和value的数据类型可以相同，也可以不同。</p></li><li><p>Map集合中的元素，key是不允许重复的， value是可以重复的。</p></li><li><p>Map集合中的元素，key和 value是一一对应的。</p></li></ul><h3 id="1-4-Map-接口"><a href="#1-4-Map-接口" class="headerlink" title="1.4 Map 接口"></a>1.4 Map 接口</h3><p>Map 的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>Map 是一个用于保存键值对(key-value)的接口。<strong>Map 中不能包含重复的键；每个键最多只能映射到一个值。</strong></p><p>Map 接口提供三种 <code>Collection</code> 视图，允许以<strong>键集</strong>、<strong>值集</strong>或<strong>键-值映射关系集</strong>的形式访问数据。</p><p>Map 有些实现类，可以有序的保存元素，如 <code>TreeMap</code>；另一些实现类则不保证顺序，如 <code>HashMap</code> 类。</p><p>Map 的实现类应该提供 2 个“标准的”构造方法：</p><ul><li>void（无参数）构造方法，用于创建空 Map；</li><li>带有单个 Map 类型参数的构造方法，用于创建一个与其参数具有相同键-值映射关系的新 Map。</li></ul><p>实际上，后一个构造方法允许用户复制任意 Map，生成所需类的一个等价 Map。尽管无法强制执行此建议（因为接口不能包含构造方法），但是 JDK 中所有通用的 Map 实现都遵从它。</p><p><strong>Map.Entry 接口:</strong></p><p><code>Map.Entry</code> 一般用于通过迭代器（<code>Iterator</code>）访问问 <code>Map</code>。</p><p><code>Map.Entry</code> 是 Map 中内部的一个接口，<code>Map.Entry</code> 代表了 <strong>键值对</strong> 实体，Map 通过 <code>entrySet()</code> 获取 <code>Map.Entry</code> 集合，从而通过该集合实现对键值对的操作。</p><h3 id="1-5-Map接口常用的方法"><a href="#1-5-Map接口常用的方法" class="headerlink" title="1.5 Map接口常用的方法"></a>1.5 Map接口常用的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span></span><br><span class="hljs-function"><span class="hljs-comment">// 把指定的键与指定的值添加到Map集合中。</span></span><br><span class="hljs-function"> </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span></span><br><span class="hljs-function"><span class="hljs-comment">// 把指定的键所对应的键值对元素在Map集合中删除,返回被删除元素的值</span></span><br><span class="hljs-function"> </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span></span><br><span class="hljs-function"><span class="hljs-comment">// 根据指定的键,在Map集合中获取对应的值。</span></span><br><span class="hljs-function"> </span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(Object key)</span></span><br><span class="hljs-function"><span class="hljs-comment">// 判断集合中是否包含指定的键。</span></span><br><span class="hljs-function"> </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;K&gt; <span class="hljs-title">keySet</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">// 获取Map集合中所有的键,存储到Set集合中。</span></span><br><span class="hljs-function"> </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Map. Entry&lt;K,V&gt; <span class="hljs-title">entrySet</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">// 获取到Map集合中所有的键值对对象的集合(Set集合)。</span></span><br></code></pre></td></tr></table></figure><h2 id="2-HashMap"><a href="#2-HashMap" class="headerlink" title="2.HashMap"></a>2.HashMap</h2><blockquote><p> 底层是哈希表数据结构，线程是不同步的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法。 </p></blockquote><h3 id="2-1-HashMap要点"><a href="#2-1-HashMap要点" class="headerlink" title="2.1 HashMap要点"></a>2.1 HashMap要点</h3><p>从 <code>HashMap</code> 的命名，也可以看出：**<code>HashMap</code> 以散列方式存储键值对**。 </p><p><strong><code>HashMap</code> 允许使用空值和空键</strong>。（<code>HashMap</code> 类大致等同于 <code>Hashtable</code>，除了它是不同步的并且允许为空值。）这个类不保序；特别是，它的元素顺序可能会随着时间的推移变化。 </p><p><strong><code>HashMap</code> 有两个影响其性能的参数：初始容量和负载因子</strong>。 </p><ul><li>容量是哈希表中桶的数量，初始容量就是哈希表创建时的容量。</li><li>加载因子是散列表在其容量自动扩容之前被允许的最大饱和量。当哈希表中的 entry 数量超过负载因子和当前容量的乘积时，散列表就会被重新映射（即重建内部数据结构），一般散列表大约是存储桶数量的两倍。</li></ul><p>通常，默认加载因子（0.75）在时间和空间成本之间提供了良好的平衡。较高的值会减少空间开销，但会增加查找成本（反映在大部分 <code>HashMap</code> 类的操作中，包括 <code>get</code> 和 <code>put</code>）。在设置初始容量时，应考虑映射中的条目数量及其负载因子，以尽量减少重新运行操作的次数。如果初始容量大于最大入口数除以负载因子，则不会发生重新刷新操作。 </p><p>如果许多映射要存储在 <code>HashMap</code> 实例中，使用足够大的容量创建映射将允许映射存储的效率高于根据需要执行自动重新散列以增长表。请注意，使用多个具有相同 <code>hashCode()</code> 的密钥是降低任何散列表性能的一个可靠方法。为了改善影响，当键是 <code>Comparable</code> 时，该类可以使用键之间的比较顺序来帮助断开关系。 </p><p> <code>HashMap</code> 不是线程安全的。 </p><h3 id="2-2-HashMap-原理"><a href="#2-2-HashMap-原理" class="headerlink" title="2.2. HashMap 原理"></a>2.2. HashMap 原理</h3><p><strong>HashMap 数据结构</strong></p><p><code>HashMap</code> 的核心字段 </p><ul><li><code>table</code> - <code>HashMap</code> 使用一个 <code>Node[]</code> 类型的数组 <code>table</code> 来储存元素。</li><li><code>size</code> - 初始容量。 初始为 16，每次容量不够自动扩容</li><li><code>loadFactor</code> - 负载因子。自动扩容之前被允许的最大饱和量，默认 0.75。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">// 该表在初次使用时初始化，并根据需要调整大小。分配时，长度总是2的幂。</span><br>    <span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br>    <span class="hljs-comment">// 保存缓存的 entrySet()。请注意，AbstractMap 字段用于 keySet() 和 values()。</span><br>    <span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<br>    <span class="hljs-comment">// map 中的键值对数</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-comment">// 这个HashMap被结构修改的次数结构修改是那些改变HashMap中的映射数量或者修改其内部结构（例如，重新散列）的修改。</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;<br>    <span class="hljs-comment">// 下一个调整大小的值（容量*加载因子）。</span><br>    <span class="hljs-keyword">int</span> threshold;<br>    <span class="hljs-comment">// 散列表的加载因子</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>HashMap 构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 默认加载因子0.75</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span></span>; <span class="hljs-comment">// 默认加载因子0.75；以 initialCapacity 初始化容量</span><br><span class="hljs-comment">// 以 initialCapacity 初始化容量；以 loadFactor 初始化加载因子</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> <span class="hljs-comment">// 默认加载因子0.75</span></span><br></code></pre></td></tr></table></figure><p> <strong>put 方法的实现</strong></p><p> put 方法大致的思路为： </p><ul><li>对 key 的 <code>hashCode()</code> 做 hash 计算，然后根据 hash 值再计算 Node 的存储位置;</li><li>如果没有哈希碰撞，直接放到桶里；如果有哈希碰撞，以链表的形式存在桶后。</li><li>如果哈希碰撞导致链表过长(大于等于 <code>TREEIFY_THRESHOLD</code>，数值为 8)，就把链表转换成红黑树；</li><li>如果节点已经存在就替换旧值</li><li>桶数量超过容量*负载因子（即 load factor * current capacity），HashMap 调用 <code>resize</code> 自动扩容一倍</li></ul><p> 具体代码的实现如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>&#125;<br><br><span class="hljs-comment">// hashcode 无符号位移 16 位</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>    <span class="hljs-comment">// tab 为空则创建</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// 计算 index，并对 null 做处理</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 节点存在</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-comment">// 该链为树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 该链为链表</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 写入</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            V oldValue = e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么计算 hash 使用 hashcode 无符号位移 16 位? </p><p>假设要添加两个对象 a 和 b，如果数组长度是 16，这时对象 a 和 b 通过公式 (n - 1) &amp; hash 运算，也就是 (16-1)＆a.hashCode 和 (16-1)＆b.hashCode，15 的二进制为 0000000000000000000000000001111，假设对象 A 的 hashCode 为 1000010001110001000001111000000，对象 B 的 hashCode 为 0111011100111000101000010100000，你会发现上述与运算结果都是 0。这样的哈希结果就太让人失望了，很明显不是一个好的哈希算法。</p><p>但如果我们将 hashCode 值右移 16 位（h &gt;&gt;&gt; 16 代表无符号右移 16 位），也就是取 int 类型的一半，刚好可以将该二进制数对半切开，并且使用位异或运算（如果两个数对应的位置相反，则结果为 1，反之为 0），这样的话，就能避免上面的情况发生。这就是 hash() 方法的具体实现方式。<strong>简而言之，就是尽量打乱 hashCode 真正参与运算的低 16 位。</strong></p><p><strong>get 方法的实现</strong> </p><p> 在理解了 put 之后，get 就很简单了。大致思路如下： </p><ul><li>对 key 的 hashCode() 做 hash 计算，然后根据 hash 值再计算桶的 index</li><li>如果桶中的第一个节点命中，直接返回；</li><li> 如果有冲突，则通过 <code>key.equals(k)</code> 去查找对应的 entry </li><li>若为树，则在红黑树中通过 key.equals(k) 查找，O(logn)；</li><li>若为链表，则在链表中通过 key.equals(k) 查找，O(n)。</li></ul><p> 具体代码的实现如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-keyword">int</span> n; K k;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 直接命中</span><br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-comment">// 未命中</span><br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 在树中 get</span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <span class="hljs-comment">// 在链表中 get</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>hash 方法的实现:</strong></p><p> HashMap **计算桶下标（index）公式：<code>key.hashCode() ^ (h &gt;&gt;&gt; 16)</code>**。 </p><p> 下面针对这个公式来详细讲解。 </p><p> 在 <code>get</code> 和 <code>put</code> 的过程中，计算下标时，先对 <code>hashCode</code> 进行 <code>hash</code> 操作，然后再通过 <code>hash</code> 值进一步计算下标，如下图所示： </p><p><img src="/img/work/1638192040292.png"></p><p> 在对 <code>hashCode()</code> 计算 hash 时具体实现是这样的： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这个方法大概的作用就是：高 16bit 不变，低 16bit 和高 16bit 做了一个异或。 </p><p>在设计 hash 方法时，因为目前的 table 长度 n 为 2 的幂，而计算下标的时候，是这样实现的(使用 <code>&amp;</code> 位操作，而非 <code>%</code> 求余)： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(n - <span class="hljs-number">1</span>) &amp; hash<br></code></pre></td></tr></table></figure><p>设计者认为这方法很容易发生碰撞。为什么这么说呢？不妨思考一下，在 n - 1 为 15(0x1111) 时，其实散列真正生效的只是低 4bit 的有效位，当然容易碰撞了。 </p><p>因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高 16bit 和低 16bit 异或了一下。设计者还解释到因为现在大多数的 hashCode 的分布已经很不错了，就算是发生了碰撞也用 O(logn)的 tree 去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table 长度比较小时)，从而引起的碰撞。 </p><p>如果还是产生了频繁的碰撞，会发生什么问题呢？作者注释说，他们使用树来处理频繁的碰撞(we use trees to handle large sets of collisions in bins)，在 <a href="http://openjdk.java.net/jeps/180">JEP-180 (opens new window)</a>中，描述了这个问题： </p><blockquote><p> Improve the performance of java.util.HashMap under high hash-collision conditions by using balanced trees rather than linked lists to store map entries. Implement the same improvement in the LinkedHashMap class. </p></blockquote><p>之前已经提过，在获取 HashMap 的元素时，基本分两步： </p><ol><li>首先根据 hashCode()做 hash，然后确定 bucket 的 index；</li><li>如果 bucket 的节点的 key 不是我们需要的，则通过 keys.equals()在链中找。</li></ol><p>在 JDK8 之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行 get 时，两步的时间复杂度是 O(1)+O(n)。因此，当碰撞很厉害的时候 n 很大，O(n)的速度显然是影响速度的。 </p><p>因此在 JDK8 中，利用红黑树替换链表，这样复杂度就变成了 O(1)+O(logn)了，这样在 n 很大的时候，能够比较理想的解决这个问题，在 JDK8：HashMap 的性能提升一文中有性能测试的结果。 </p><p>如果对Hashcode计算还是不太清楚，建议参考下这位博主:</p><p><a href="https://blog.csdn.net/qq_33709582/article/details/113337405"><strong>真正搞懂hashCode和hash算法</strong></a></p><p> <strong>resize 的实现</strong></p><p>当 <code>put</code> 时，如果发现目前的 bucket 占用程度已经超过了 Load Factor 所希望的比例，那么就会发生 resize。在 resize 的过程，简单的说就是把 bucket 扩充为 2 倍，之后重新计算 index，把节点再放到新的 bucket 中。 </p><p>当超过限制的时候会 resize，然而又因为我们使用的是 2 次幂的扩展(指长度扩为原来 2 倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。 </p><p>怎么理解呢？例如我们从 16 扩展为 32 时，具体的变化如下所示： </p><p> <img src="/img/work/HashMap-resize-01.png"> </p><p>因此元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化： </p><p> <img src="/img/work/HashMap-resize-02.png"> </p><p>因此，我们在扩充 HashMap 的时候，不需要重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原索引+oldCap”。可以看看下图为 16 扩充为 32 的 resize 示意图： </p><p> <img src="/img/work/HashMap-resize-03.png"> </p><p>这个设计确实非常的巧妙，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 resize 的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-keyword">int</span> oldThr = threshold;<br>    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 没超过最大值，就扩充为原来的 2 倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br><br>    <span class="hljs-comment">// 计算新的 resize 上限</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?<br>                    (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 把每个 bucket 都移动到新的 buckets 中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// 原索引</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-comment">// 原索引+oldCap</span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">// 原索引放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                        loTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-comment">// 原索引+oldCap放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-LinkedHashMap-类"><a href="#3-LinkedHashMap-类" class="headerlink" title="3. LinkedHashMap 类"></a>3. LinkedHashMap 类</h2><p><img src="/img/work/1638877273531.png" alt="LinkedHashMap关系图"></p><h3 id="3-1-LinkedHashMap-要点"><a href="#3-1-LinkedHashMap-要点" class="headerlink" title="3.1. LinkedHashMap 要点"></a>3.1. LinkedHashMap 要点</h3><p><strong><code>LinkedHashMap</code> 通过维护一个保存所有条目（Entry）的双向链表，保证了元素迭代的顺序（即插入顺序）</strong>。 </p><table><thead><tr><th>关注点</th><th>结论</th></tr></thead><tbody><tr><td>是否允许键值对为 null</td><td>Key 和 Value 都允许 null</td></tr><tr><td>是否允许重复数据</td><td>Key 重复会覆盖、Value 允许重复</td></tr><tr><td>是否有序</td><td>按照元素插入顺序存储</td></tr><tr><td>是否线程安全</td><td>非线程安全</td></tr></tbody></table><h3 id="3-2-LinkedHashMap和HashMap区别"><a href="#3-2-LinkedHashMap和HashMap区别" class="headerlink" title="3.2 LinkedHashMap和HashMap区别"></a>3.2 LinkedHashMap和HashMap区别</h3><p> 从上面的类图中我们可以看到,<code>LinkedHashMap</code>直接继承自<code>HashMap</code>，所以<code>LinkedHashMap</code>拥有<code>HashMap</code>的大部分特性，最多只允许一个<code>key</code>为<code>null</code>，可以有多个<code>value</code>为<code>null</code>。一些主要的方法和属性也直接继承自<code>HashMap</code>，并对其中某些方法进行了重写。<code>LinkedHashMap</code>与<code>HashMap</code>最大的不同在于<code>LinkedHashMap</code>保持了元素的有序性，即遍历<code>LinkedHashMap</code>的时候，得到的元素的顺序与添加元素的顺序是相同的，可以按照插入序 <code>(insertion-order)</code>或访问序 <code>(access-order)</code>来对哈希表中的元素进行遍历。 </p><blockquote><p>所谓插入顺序，就是 <code>Entry</code>被添加到 <code>Map</code> 中的顺序，更新一个 <code>Key</code> 关联的 <code>Value</code> 并不会对插入顺序造成影响,而访问顺序则是对所有 <code>Entry</code> 按照最近访问<code>(least-recently)</code>到最远访问<code>(most-recently)</code>进行排序，读写都会影响到访问顺序，但是对迭代器 <code>(entrySet(), keySet(), values())</code> 的访问不会影响到访问顺序。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用<code>get</code>方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。 </p></blockquote><h3 id="3-3-顺序存取原理"><a href="#3-3-顺序存取原理" class="headerlink" title="3.3 顺序存取原理"></a>3.3 顺序存取原理</h3><p><code>LinkedHashMap</code>之所以能实现存取的顺序性，主要是他重新定义了 <code>Entry</code> ，这个新的 <code>Entry</code> 继承自<code>HashMap.Node</code>，并做了新的扩展，下面我们结合源码来分析一下。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>.<span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    Entry&lt;K,V&gt; before, after;<br>    Entry(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword">super</span>(hash, key, value, next);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-存取结构"><a href="#3-3-存取结构" class="headerlink" title="3.3 存取结构"></a>3.3 存取结构</h3><p>由上面的代码我们可以看出，这个自定义的 <code>Entry</code>比 <code>HashMap.Node</code>多了两个属性，<code>before</code>和<code>after</code>。正是使用这两个关键的属性，在<code>LinkedHashMap</code>内部实现了一个双向链表。数据结构的知识大家再回忆一下（想不起来的可以去面壁了），双向链表就是每个节点除了存储数据本身之外，还保存着两个指针，在<code>java</code>里面就是指向对象的引用，一个是前驱节点，也就是他的前一个节点的引用，一个是后继节点，也就是他的后一个节点的引用。这样，就可以实现存储一个有序节点的数据结构了。（这里说明下，在jdk1.7中，使用的结构为环形双向链表）另外，继承自<code>HashMap.Node</code>的<code>Entry</code>自身还保留着用于维持单链表的<code>next</code>属性，因此<code>LinkedHashMap</code>的<code>Entry</code>节点具有三个指针域，<code>next</code>指针维护<code>Hash</code>桶中冲突<code>key</code>的链表，<code>before</code>和<code>after</code>维护双向链表。结构如下图所示： </p><p> <img src="/img/work/LinkedHashMap.png" alt="LinkedHashMap存储结构"> </p><p>以上就是<code>LinkedHashMap</code>的数据结构，但是光有数据机构显然无法完成有序的存取，下面我们继续来看一下，<code>LinkedHashMap</code>的存取过程。 </p><h3 id="3-4-存取过程"><a href="#3-4-存取过程" class="headerlink" title="3.4 存取过程"></a>3.4 存取过程</h3><p>上面提到<code>LinkedHashMap</code>继承自<code>HashMap</code>，所以，<code>LinkedHashMap</code>的自身便拥有了<code>HashMap</code>全部的属性和方法。由代码我们也能看出，<code>LinkedHashMap</code>自身并没有实现<code>put</code>方法，而是直接使用其父类<code>HashMap</code>的<code>put</code>方法。不同的是，在创建<code>Entry</code>时，重写了父类的<code>newNode(int hash, K key, V value, Node e) &#123;&#125;</code>方法，并实现了父类预留的回调方法，通过重写父类的方法和回调方法，<code>LinkedHashMap</code>扩展了<code>HashMap</code>，使其拥有了保持存取顺序性的能力。从这点我们也可以看出，<code>java</code>的开发团队将这一功能实现的比较优雅，其中的思想值得我们在开发中借鉴和学习，这也是我们阅读<code>java</code>源码的意义所在。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建新的节点</span><br> <span class="hljs-function">Node&lt;K,V&gt; <span class="hljs-title">newNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;<br>     LinkedHashMap.Entry&lt;K,V&gt; p =<br>         <span class="hljs-keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);<br>     linkNodeLast(p);<br>     <span class="hljs-keyword">return</span> p;<br> &#125;<br> <span class="hljs-comment">// link at the end of list</span><br> <span class="hljs-comment">//将节点添加到双向链表尾部</span><br> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">linkNodeLast</span><span class="hljs-params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;<br>     LinkedHashMap.Entry&lt;K,V&gt; last = tail;<br>     tail = p;<br>     <span class="hljs-keyword">if</span> (last == <span class="hljs-keyword">null</span>)<br>         head = p;<br>     <span class="hljs-keyword">else</span> &#123;<br>         p.before = last;<br>         last.after = p;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p><code>LinkedHashMap</code>的<code>put</code>过程和<code>HashMap</code>大致相同，包括计算<code>hash</code>值、计算<code>table</code>数组索引、判断数组是否为空等步骤，不同的是创建节点的过程。从上面的代码中我们可以看出，重写的这个<code>newNode</code>方法代码比较简洁，首先实例化一个双链表结构的<code>Entry p</code>，这里会首先调用其父类 <code>HashMap.Node</code>的构造方法，维护着一个单链表的结构。实例化结束后，会调用一个<code>linkNodeLast</code>的私有方法，这个方法完成了将新的元素添加至双向链表的尾部的功能。我们知道，在<code>HashMap</code>中，如果单链表超过一定的长度，就会被转换为红黑树，那么在<code>LinkedHashMap</code>中也是同样的逻辑，于是就有了下面的代码。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建新的红黑树节点</span><br><span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">newTreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;<br>     TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">new</span> TreeNode&lt;K,V&gt;(hash, key, value, next);<br>     linkNodeLast(p);<br>     <span class="hljs-keyword">return</span> p;<br> &#125;<br> <span class="hljs-comment">//将链表节点转换为红黑树节点</span><br> <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">replacementTreeNode</span><span class="hljs-params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;<br>     LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;<br>     TreeNode&lt;K,V&gt; t = <span class="hljs-keyword">new</span> TreeNode&lt;K,V&gt;(q.hash, q.key, q.value, next);<br>     transferLinks(q, t);<span class="hljs-comment">//将双向链表中的TreeNode替换为新的普通节点</span><br>     <span class="hljs-keyword">return</span> t;<br> &#125;<br></code></pre></td></tr></table></figure><p>这两个也是被重写的方法，当存储结构为红黑树的时候，调用<code>newTreeNode</code>方法创建红黑树节点。当需要将链表转换为红黑树结构时，调用<code>replacementTreeNode</code>方法将双向链表中的<code>TreeNode</code>替换为新的链表节点。<br>由以上分析过程可以得出结论，在 <code>LinkedHashMap</code> 中，所有的 <code>Entry</code> 都被串联在一个双向链表中。每次在新建一个节点时都会将新建的节点链接到双向链表的末尾。这样从双向链表的尾部向头部遍历就可以保证插入顺序了，头部节点是最早添加的节点，而尾部节点则是最近添加的节点。上面我们还提到，<code>LinkedHashMap</code>可以实现插入的顺序和访问的顺序，那么访问的顺序是怎样实现的呢？下面我们来看一下。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>();<br>    accessOrder = <span class="hljs-keyword">false</span>;<br>    putMapEntries(m, <span class="hljs-keyword">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过观察<code>LinkedHashMap</code>的构造函数可以发现有这样一个字段，<code>accessOrder</code>，他的初始值为<code>false</code>。这个字段的意思是是否使用访问序,所以<code>LinkedHashMap</code>的默认顺序为插入顺序。上文我们提到了在<code>HashMap</code>类中预留了几个回调方法，这几个方法在<code>HashMap</code>中并没有实现，而在<code>LinkedHashMap</code>中这几个方法都有了具体的实现,这些方法就是为了实现访问序，下面我们结合代码来看一下。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//移除节点的回调方法</span><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeRemoval</span><span class="hljs-params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="hljs-comment">// unlink</span><br>     <span class="hljs-comment">//移除一个节点，双向链表中的连接关系需要调整</span><br>     LinkedHashMap.Entry&lt;K,V&gt; p =<br>         (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;<br>     p.before = p.after = <span class="hljs-keyword">null</span>;<br>     <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>)<br>         head = a;<br>     <span class="hljs-keyword">else</span><br>         b.after = a;<br>     <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span>)<br>         tail = b;<br>     <span class="hljs-keyword">else</span><br>         a.before = b;<br> &#125;<br><span class="hljs-comment">//插入节点的回调方法</span><br><span class="hljs-comment">//构造方法中调用 putMapEntries调用时  evict为false </span><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123; <span class="hljs-comment">// possibly remove eldest</span><br>     LinkedHashMap.Entry&lt;K,V&gt; first;<br>    <span class="hljs-comment">//first是头元素，也是最老的元素</span><br>    <span class="hljs-comment">//在插入序中，就是最先插入的元素</span><br>    <span class="hljs-comment">//在访问序中，就是最远被访问的元素</span><br>    <span class="hljs-comment">//这里removeEldestEntry(first)始终返回true，即不删除最老的元素</span><br>    <span class="hljs-comment">//如果是一个容量固定的cache，可调整removeEldestEntry(first)的实现</span><br>     <span class="hljs-keyword">if</span> (evict &amp;&amp; (first = head) != <span class="hljs-keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;<br>         K key = first.key;<br>         removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>     &#125;<br> &#125;<br> <span class="hljs-comment">//访问元素之后的回调方法</span><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="hljs-comment">// move node to last</span><br>     LinkedHashMap.Entry&lt;K,V&gt; last;<br>    <span class="hljs-comment">//如果是访问序，且当前节点并不是尾节点</span><br>    <span class="hljs-comment">//将该节点置为双向链表的尾部</span><br>     <span class="hljs-keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;<br>         LinkedHashMap.Entry&lt;K,V&gt; p =<br>             (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;<br>         p.after = <span class="hljs-keyword">null</span>;<br>         <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>)<br>             head = a;<br>         <span class="hljs-keyword">else</span><br>             b.after = a;<br>         <span class="hljs-keyword">if</span> (a != <span class="hljs-keyword">null</span>)<br>             a.before = b;<br>         <span class="hljs-keyword">else</span><br>             last = b;<br>         <span class="hljs-keyword">if</span> (last == <span class="hljs-keyword">null</span>)<br>             head = p;<br>         <span class="hljs-keyword">else</span> &#123;<br>             p.before = last;<br>             last.after = p;<br>         &#125;<br>         tail = p;<br>         ++modCount;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>在插入节点、删除节点和访问节点后会调用相应的回调函数。可以看到，在 <code>afterNodeAccess</code> 方法中，如果该<code>LinkedHashMap</code>是访问序，且当前访问的节点不是尾部节点，则该节点会被置为双链表的尾节点。即，在访问序下，最近访问的节点会是尾节点，头节点则是最远访问的节点。</p><h3 id="3-5-遍历"><a href="#3-5-遍历" class="headerlink" title="3.5 遍历"></a>3.5 遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//所有的节点都被串联在双向链表中，迭代器在迭代时可以利用双向链表的链接关系进行</span><br><span class="hljs-comment">//双向链表的顺序是按照插入序或访问序排列的</span><br><span class="hljs-comment">// Iterators</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedHashIterator</span> </span>&#123;<br>    LinkedHashMap.Entry&lt;K,V&gt; next;<br>    LinkedHashMap.Entry&lt;K,V&gt; current;<br>    <span class="hljs-keyword">int</span> expectedModCount;<br>    LinkedHashIterator() &#123;<br>        next = head;<br>        expectedModCount = modCount;<br>        current = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> next != <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> LinkedHashMap.<span class="hljs-function">Entry&lt;K,V&gt; <span class="hljs-title">nextNode</span><span class="hljs-params">()</span> </span>&#123;<br>        LinkedHashMap.Entry&lt;K,V&gt; e = next;<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>        current = e;<br>        next = e.after;<span class="hljs-comment">//直接访问after引用</span><br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>        Node&lt;K,V&gt; p = current;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>        current = <span class="hljs-keyword">null</span>;<br>        K key = p.key;<br>        removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);<br>        expectedModCount = modCount;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，在遍历所有节点时是通过节点的 <code>after</code> 引用进行的。这样，可以从双链表的头部遍历到到双链表的尾部。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_33642117/article/details/52049764"><strong>Java Map集合的详解</strong></a></p><p><a href="https://blog.csdn.net/qq_33709582/article/details/113337405"><strong>真正搞懂hashCode和hash算法</strong></a></p><p><a href="https://dunwu.github.io/javacore/container/java-container-map.html#_1-map-%E7%AE%80%E4%BB%8B"> <strong>Java 容器之 Map</strong> </a></p><p><a href="https://www.cnblogs.com/liyihua/p/12199448.html"><strong>对Map集合的学习</strong></a></p><p><a href="https://yanglukuan.github.io/2017/09/05/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BLinkedHashMap%E8%AF%A6%E8%A7%A3/"><strong>Java集合框架之LinkedHashMap</strong></a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java-容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-容器之List</title>
    <link href="/2021/11/24/Java-%E5%AE%B9%E5%99%A8%E4%B9%8BList/"/>
    <url>/2021/11/24/Java-%E5%AE%B9%E5%99%A8%E4%B9%8BList/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-List-简介"><a href="#1-List-简介" class="headerlink" title="1. List 简介"></a>1. List 简介</h2><p><img src="/img/work/image-20211124142643473.png" alt="ArrayList关系图"></p><p><code>List</code> 是一个接口，它继承于 <code>Collection</code> 的接口。它代表着有序的队列。</p><p><code>AbstractList</code> 是一个抽象类，它继承于 <code>AbstractCollection</code>。<code>AbstractList</code> 实现了 <code>List</code> 接口中除 <code>size()</code>、<code>get(int location)</code> 之外的函数。</p><p><code>AbstractSequentialList</code> 是一个抽象类，它继承于 <code>AbstractList</code>。<code>AbstractSequentialList</code> 实现了“链表中，根据 index 索引值操作链表的全部函数”。</p><h3 id="1-1-ArrayList-和-LinkedList"><a href="#1-1-ArrayList-和-LinkedList" class="headerlink" title="1.1. ArrayList 和 LinkedList"></a>1.1. ArrayList 和 LinkedList</h3><p><strong><code>ArrayList</code>、<code>LinkedList</code> 是 <code>List</code> 最常用的实现。</strong></p><ul><li><code>ArrayList</code> 基于动态数组实现，存在容量限制，当元素数超过最大容量时，会自动扩容；<code>LinkedList</code> 基于双向链表实现，不存在容量限制。</li><li><code>ArrayList</code> 随机访问速度较快，随机插入、删除速度较慢；<code>LinkedList</code> 随机插入、删除速度较快，随机访问速度较慢。</li><li><code>ArrayList</code> 和 <code>LinkedList</code> 都不是线程安全的。</li></ul><h3 id="1-2-Vector-和-Stack"><a href="#1-2-Vector-和-Stack" class="headerlink" title="1.2. Vector 和 Stack"></a>1.2. Vector 和 Stack</h3><p><img src="/img/work/image-20211124143305652.png" alt="Stack关系图"></p><p><code>Vector</code> 和 <code>Stack</code> 的设计目标是作为线程安全的 <code>List</code> 实现，替代 <code>ArrayList</code>。</p><ul><li><code>Vector</code> - <code>Vector</code> 和 <code>ArrayList</code> 类似，也实现了 <code>List</code> 接口。但是， <code>Vector</code> 中的主要方法都是 <code>synchronized</code> 方法，即通过互斥同步方式保证操作的线程安全。</li><li><code>Stack</code> - <code>Stack</code> 也是一个同步容器，它的方法也用 <code>synchronized</code> 进行了同步，它实际上是继承于 <code>Vector</code> 类。</li></ul><h2 id="2-ArrayList"><a href="#2-ArrayList" class="headerlink" title="2. ArrayList"></a>2. ArrayList</h2><blockquote><p>ArrayList 从数据结构角度来看，可以视为支持动态扩容的线性表。ArrayList可以存放空元素 arrayList.add(null);且可以存放多个空值，底层是用数组实现的，线程不安全，效率高。</p></blockquote><h3 id="2-1-ArrayList-要点"><a href="#2-1-ArrayList-要点" class="headerlink" title="2.1. ArrayList 要点"></a>2.1. ArrayList 要点</h3><p><code>ArrayList</code> 是一个数组队列，相当于<strong>动态数组</strong>。**<code>ArrayList</code> 默认初始容量大小为 <code>10</code> ，添加元素时，如果发现容量已满，会自动扩容为原始大小的 1.5 倍**。因此，应该尽量在初始化 <code>ArrayList</code> 时，为其指定合适的初始化容量大小，减少扩容操作产生的性能开销。</p><p><code>ArrayList</code> 定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>从 ArrayList 的定义，不难看出 ArrayList 的一些基本特性：</p><ul><li><code>ArrayList</code> 实现了 <code>List</code> 接口，并继承了 <code>AbstractList</code>，它支持所有 <code>List</code> 的操作。</li><li><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，<strong>支持随机访问</strong>。<code>RandomAccess</code> 是一个标志接口，它意味着“只要实现该接口的 <code>List</code> 类，都支持快速随机访问”。在 <code>ArrayList</code> 中，我们即可以<strong>通过元素的序号快速获取元素对象</strong>；这就是快速随机访问。</li><li><code>ArrayList</code> 实现了 <code>Cloneable</code> 接口，默认为<strong>浅拷贝</strong>。</li><li><code>ArrayList</code> 实现了 <code>Serializable</code> 接口，<strong>支持序列化</strong>，能通过序列化方式传输。</li><li><code>ArrayList</code> 是<strong>非线程安全</strong>的。</li></ul><h3 id="2-2-ArrayList-原理"><a href="#2-2-ArrayList-原理" class="headerlink" title="2.2. ArrayList 原理"></a>2.2. ArrayList 原理</h3><p><strong>ArrayList 的数据结构</strong></p><p>ArrayList 包含了两个重要的元素：<code>elementData</code> 和 <code>size</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认初始化容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 对象数组</span><br><span class="hljs-keyword">transient</span> Object[] elementData;<br><span class="hljs-comment">// 数组长度</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br></code></pre></td></tr></table></figure><ul><li><code>size</code> - 是动态数组的实际大小。</li><li><code>elementData</code> - 是一个 <code>Object</code> 数组，用于保存添加到 <code>ArrayList</code> 中的元素。</li></ul><p> <strong>ArrayList 的序列化</strong></p><p><code>ArrayList</code> 具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。为此，<code>ArrayList</code> 定制了其序列化方式。具体做法是：</p><ul><li>存储元素的 <code>Object</code> 数组（即 <code>elementData</code>）使用 <code>transient</code> 修饰，使得它可以被 Java 序列化所忽略。</li><li><code>ArrayList</code> 重写了 <code>writeObject()</code> 和 <code>readObject()</code> 来控制序列化数组中有元素填充那部分内容。</li></ul><p><strong>ArrayList 构造方法</strong></p><p>ArrayList 类实现了三个构造函数：</p><ul><li>第一个是默认构造方法，ArrayList 会创建一个空数组；</li><li>第二个是创建 ArrayList 对象时，传入一个初始化值；</li><li>第三个是传入一个集合类型进行初始化。</li></ul><p>当 ArrayList 新增元素时，如果所存储的元素已经超过其当前容量，它会计算容量后再进行动态扩容。数组的动态扩容会导致整个数组进行一次内存复制。因此，<strong>初始化 ArrayList 时，指定数组初始大小，有助于减少数组的扩容次数，从而提高系统性能</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个空数组</span><br><span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 根据初始化值创建数组大小</span><br><span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 初始化值为 0 时，创建一个空数组</span><br><span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>   initialCapacity);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ArrayList 访问元素</strong></p><p><code>ArrayList</code> 访问元素的实现主要基于以下关键性源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取第 index 个元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    rangeCheck(index);<br>    <span class="hljs-keyword">return</span> elementData(index);<br>&#125;<br><br><span class="hljs-function">E <span class="hljs-title">elementData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (E) elementData[index];<br>&#125;<br></code></pre></td></tr></table></figure><p>实现非常简单，其实就是**通过数组下标访问数组元素，其时间复杂度为 O(1)**，所以很快。</p><p><strong>ArrayList 添加元素</strong></p><p><code>ArrayList</code> 添加元素有两种方法：一种是添加元素到数组末尾，另外一种是添加元素到任意位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加元素到数组末尾</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 添加元素到任意位置</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>rangeCheckForAdd(index);<br><br>ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,<br> size - index);<br>elementData[index] = element;<br>size++;<br>&#125;<br></code></pre></td></tr></table></figure><p>两种添加元素方法的<strong>不同点</strong>是：</p><ul><li>添加元素到任意位置，会导致在<strong>该位置后的所有元素都需要重新排列</strong>；</li><li>而添加元素到数组末尾，在没有发生扩容的前提下，是不会有元素复制排序过程的。</li></ul><p>两种添加元素方法的<strong>共同点</strong>是：添加元素时，会先检查容量大小，<strong>如果发现容量不足，会自动扩容为原始大小的 1.5 倍</strong>。</p><p><code>ArrayList</code> 添加元素的实现主要基于以下关键性源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br><br>    ensureExplicitCapacity(minCapacity);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    modCount++;<br><br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;<br>    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ArrayList</code> 执行添加元素动作（<code>add</code> 方法）时，调用 <code>ensureCapacityInternal</code> 方法来保证容量足够。</p><ul><li>如果容量足够时，将数据作为数组中 <code>size+1</code> 位置上的元素写入，并将 <code>size</code> 自增 1。</li><li>如果容量不够时，需要使用 <code>grow</code> 方法进行扩容数组，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。扩容操作实际上是<strong>调用 <code>Arrays.copyOf()</code> 把原数组拷贝为一个新数组</strong>，因此最好在创建 <code>ArrayList</code> 对象时就指定大概的容量大小，减少扩容操作的次数。</li></ul><p><strong>ArrayList 删除元素</strong></p><p><code>ArrayList</code> 的删除方法和添加元素到任意位置方法有些相似。</p><p><code>ArrayList</code> 在每一次有效的删除操作后，都要进行数组的重组，并且删除的元素位置越靠前，数组重组的开销就越大。具体来说，<code>ArrayList</code> 会调用 <code>System.arraycopy()</code> 将 <code>index+1</code> 后面的元素都复制到 <code>index</code> 位置上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    rangeCheck(index);<br><br>    modCount++;<br>    E oldValue = elementData(index);<br><br>    <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index, numMoved);<br>    elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br><br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ArrayList 的 Fail-Fast</strong></p><p><code>ArrayList</code> 使用 <code>modCount</code> 来记录结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 <code>modCount</code> 是否改变，如果发生改变，<code>ArrayList</code> 会抛出 <code>ConcurrentModificationException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> java.io.IOException</span>&#123;<br>    <span class="hljs-comment">// Write out element count, and any hidden stuff</span><br>    <span class="hljs-keyword">int</span> expectedModCount = modCount;<br>    s.defaultWriteObject();<br><br>    <span class="hljs-comment">// Write out size as capacity for behavioural compatibility with clone()</span><br>    s.writeInt(size);<br><br>    <span class="hljs-comment">// Write out all elements in the proper order.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++) &#123;<br>        s.writeObject(elementData[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-vector底层结构和源码剖析"><a href="#2-3-vector底层结构和源码剖析" class="headerlink" title="2.3 vector底层结构和源码剖析"></a>2.3 vector底层结构和源码剖析</h3><p><img src="/%5Cimg%5Cwork%5CSnipaste_2021-11-24_21-56-07.png" alt="Vector与ArrayList对比图"></p><p> 可以看到，如果是无参构造，那么默认初始容量是10 </p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vector_</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//无参构造器</span><br>        <span class="hljs-comment">//有参数的构造</span><br>        Vector vector = <span class="hljs-keyword">new</span> Vector(<span class="hljs-number">8</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            vector.add(i);<br>        &#125;<br>        vector.add(<span class="hljs-number">100</span>);<br>        System.out.println(<span class="hljs-string">&quot;vector=&quot;</span> + vector);<br>      <br>        <span class="hljs-comment">//1. new Vector() 底层</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            public Vector() &#123;</span><br><span class="hljs-comment">                this(10);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">         补充：如果是  Vector vector = new Vector(8);</span><br><span class="hljs-comment">            走的方法:</span><br><span class="hljs-comment">            public Vector(int initialCapacity) &#123;</span><br><span class="hljs-comment">                this(initialCapacity, 0);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">         2. vector.add(i)</span><br><span class="hljs-comment">         2.1  //下面这个方法就添加数据到vector集合</span><br><span class="hljs-comment">            public synchronized boolean add(E e) &#123;</span><br><span class="hljs-comment">                modCount++;</span><br><span class="hljs-comment">                ensureCapacityHelper(elementCount + 1);</span><br><span class="hljs-comment">                elementData[elementCount++] = e;</span><br><span class="hljs-comment">                return true;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">          2.2  //确定是否需要扩容 条件 ： minCapacity - elementData.length&gt;0</span><br><span class="hljs-comment">            private void ensureCapacityHelper(int minCapacity) &#123;</span><br><span class="hljs-comment">                // overflow-conscious code</span><br><span class="hljs-comment">                if (minCapacity - elementData.length &gt; 0)</span><br><span class="hljs-comment">                    grow(minCapacity);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">          2.3 //如果 需要的数组大小 不够用，就扩容 , 扩容的算法</span><br><span class="hljs-comment">              //newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="hljs-comment">              //                             capacityIncrement : oldCapacity);</span><br><span class="hljs-comment">              //就是扩容两倍.</span><br><span class="hljs-comment">            private void grow(int minCapacity) &#123;</span><br><span class="hljs-comment">                // overflow-conscious code</span><br><span class="hljs-comment">                int oldCapacity = elementData.length;</span><br><span class="hljs-comment">                int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="hljs-comment">                                                 capacityIncrement : oldCapacity);</span><br><span class="hljs-comment">                if (newCapacity - minCapacity &lt; 0)</span><br><span class="hljs-comment">                    newCapacity = minCapacity;</span><br><span class="hljs-comment">                if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="hljs-comment">                    newCapacity = hugeCapacity(minCapacity);</span><br><span class="hljs-comment">                elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">         */</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-LinkedList"><a href="#3-LinkedList" class="headerlink" title="3. LinkedList"></a>3. LinkedList</h2><blockquote><p>LinkedList 从数据结构角度来看，可以视为双链表。</p></blockquote><h3 id="3-1-LinkedList-要点"><a href="#3-1-LinkedList-要点" class="headerlink" title="3.1. LinkedList 要点"></a>3.1. LinkedList 要点</h3><p><code>LinkedList</code> 基于双链表结构实现。由于是双链表，所以<strong>顺序访问会非常高效，而随机访问效率比较低。</strong></p><p><code>LinkedList</code> 定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt; </span><br><span class="hljs-class">                           <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>从 <code>LinkedList</code> 的定义，可以得出 <code>LinkedList</code> 的一些基本特性：</p><ul><li><code>LinkedList</code> 实现了 <code>List</code> 接口，并继承了 <code>AbstractSequentialList</code> ，它支持所有 <code>List</code> 的操作。</li><li><code>LinkedList</code> 实现了 <code>Deque</code> 接口，也可以被当作队列（<code>Queue</code>）或双端队列（<code>Deque</code>）进行操作，此外，也可以用来实现栈。</li><li><code>LinkedList</code> 实现了 <code>Cloneable</code> 接口，默认为<strong>浅拷贝</strong>。</li><li><code>LinkedList</code> 实现了 <code>Serializable</code> 接口，<strong>支持序列化</strong>。</li><li><code>LinkedList</code> 是<strong>非线程安全</strong>的。</li></ul><h3 id="3-2-LinkedList-原理"><a href="#3-2-LinkedList-原理" class="headerlink" title="3.2. LinkedList 原理"></a>3.2. LinkedList 原理</h3><h4 id="LinkedList-的数据结构"><a href="#LinkedList-的数据结构" class="headerlink" title="LinkedList 的数据结构"></a>LinkedList 的数据结构</h4><p><strong><code>LinkedList</code> 内部维护了一个双链表</strong></p><p><code>LinkedList</code> 通过 <code>Node</code> 类型的头尾指针（<code>first</code> 和 <code>last</code>）来访问数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 链表长度</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 链表头节点</span><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br><span class="hljs-comment">// 链表尾节点</span><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br></code></pre></td></tr></table></figure><ul><li><code>size</code> - <strong>表示双链表中节点的个数，初始为 0</strong>。</li><li><code>first</code> 和 <code>last</code> - <strong>分别是双链表的头节点和尾节点</strong>。</li></ul><p> <code>Node</code> 是 <code>LinkedList</code> 的内部类，它表示链表中的元素实例。Node 中包含三个元素： </p><ul><li><code>prev</code> 是该节点的上一个节点；</li><li><code>next</code> 是该节点的下一个节点；</li><li><code>item</code> 是该节点所包含的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>        E item;<br>        Node&lt;E&gt; next;<br>        Node&lt;E&gt; prev;<br><br>        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>            <span class="hljs-keyword">this</span>.item = element;<br>            <span class="hljs-keyword">this</span>.next = next;<br>            <span class="hljs-keyword">this</span>.prev = prev;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="LinkedList-的序列化"><a href="#LinkedList-的序列化" class="headerlink" title="LinkedList 的序列化"></a>LinkedList 的序列化</h4><p> <code>LinkedList</code> 与 <code>ArrayList</code> 一样也定制了自身的序列化方式。具体做法是： </p><ul><li>将 <code>size</code> （双链表容量大小）、<code>first</code> 和<code>last</code> （双链表的头尾节点）修饰为 <code>transient</code>，使得它们可以被 Java 序列化所忽略。</li><li>重写了 <code>writeObject()</code> 和 <code>readObject()</code> 来控制序列化时，只处理双链表中能被头节点链式引用的节点元素。</li></ul><h4 id="LinkedList-访问元素"><a href="#LinkedList-访问元素" class="headerlink" title="LinkedList 访问元素"></a>LinkedList 访问元素</h4><p> <code>LinkedList</code> 访问元素的实现主要基于以下关键性源码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>checkElementIndex(index);<br><span class="hljs-keyword">return</span> node(index).item;<br>&#125;<br><br><span class="hljs-function">Node&lt;E&gt; <span class="hljs-title">node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">// assert isElementIndex(index);</span><br><br>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>            x = x.next;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 获取 <code>LinkedList</code> 第 index 个元素的算法是： </p><ul><li>判断 index 在链表前半部分，还是后半部分。</li><li>如果是前半部分，从头节点开始查找；如果是后半部分，从尾结点开始查找。</li></ul><p> <code>LinkedList</code> 这种访问元素的性能是 <code>O(N)</code> 级别的（极端情况下，扫描 N/2 个元素）；相比于 <code>ArrayList</code> 的 <code>O(1)</code>，显然要慢不少。</p><p> <strong>推荐使用迭代器遍历 <code>LinkedList</code> ，不要使用传统的 <code>for</code> 循环</strong>。注：foreach 语法会被编译器转换成迭代器遍历，但是它的遍历过程中不允许修改 <code>List</code> 长度，即不能进行增删操作。  </p><h4 id="LinkedList-添加元素"><a href="#LinkedList-添加元素" class="headerlink" title="LinkedList 添加元素"></a>LinkedList 添加元素</h4><p> <code>LinkedList</code> 有多种添加元素方法： </p><ul><li><code>add(E e)</code>：默认添加元素方法（插入尾部）</li><li><code>add(int index, E element)</code>：添加元素到任意位置</li><li><code>addFirst(E e)</code>：在头部添加元素</li><li><code>addLast(E e)</code>：在尾部添加元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>linkLast(e);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>checkPositionIndex(index);<br><br><span class="hljs-keyword">if</span> (index == size)<br>linkLast(element);<br><span class="hljs-keyword">else</span><br>linkBefore(element, node(index));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span> </span>&#123;<br>linkFirst(e);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>linkLast(e);<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>LinkedList</code> 添加元素的实现主要基于以下关键性源码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">linkFirst</span><span class="hljs-params">(E e)</span> </span>&#123;<br><span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br><span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(<span class="hljs-keyword">null</span>, e, f);<br>first = newNode;<br><span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)<br>last = newNode;<br><span class="hljs-keyword">else</span><br>f.prev = newNode;<br>size++;<br>modCount++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br><span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br><span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(l, e, <span class="hljs-keyword">null</span>);<br>last = newNode;<br><span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)<br>first = newNode;<br><span class="hljs-keyword">else</span><br>l.next = newNode;<br>size++;<br>modCount++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkBefore</span><span class="hljs-params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;<br><span class="hljs-comment">// assert succ != null;</span><br><span class="hljs-keyword">final</span> Node&lt;E&gt; pred = succ.prev;<br><span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(pred, e, succ);<br>succ.prev = newNode;<br><span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)<br>first = newNode;<br><span class="hljs-keyword">else</span><br>pred.next = newNode;<br>size++;<br>modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><p> 算法如下： </p><ul><li>将新添加的数据包装为 <code>Node</code>；</li><li>如果往头部添加元素，将头指针 <code>first</code> 指向新的 <code>Node</code>，之前的 <code>first</code> 对象的 <code>prev</code> 指向新的 <code>Node</code>。</li><li>如果是向尾部添加元素，则将尾指针 <code>last</code> 指向新的 <code>Node</code>，之前的 <code>last</code> 对象的 <code>next</code> 指向新的 <code>Node</code>。</li></ul><h4 id="LinkedList-删除元素"><a href="#LinkedList-删除元素" class="headerlink" title="LinkedList 删除元素"></a>LinkedList 删除元素</h4><p> <code>LinkedList</code> 删除元素的实现主要基于以下关键性源码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 遍历找到要删除的元素节点</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 遍历找到要删除的元素节点</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><br><span class="hljs-function">E <span class="hljs-title">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> </span>&#123;<br>    <span class="hljs-comment">// assert x != null;</span><br>    <span class="hljs-keyword">final</span> E element = x.item;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;<br><br>    <span class="hljs-keyword">if</span> (prev == <span class="hljs-keyword">null</span>) &#123;<br>        first = next;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        prev.next = next;<br>        x.prev = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>) &#123;<br>        last = prev;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        next.prev = prev;<br>        x.next = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    x.item = <span class="hljs-keyword">null</span>;<br>    size--;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br></code></pre></td></tr></table></figure><p> 算法说明： </p><ul><li>遍历找到要删除的元素节点，然后调用 <code>unlink</code> 方法删除节点；</li><li> <code>unlink</code> 删除节点的方法： </li><li>如果当前节点有前驱节点，则让前驱节点指向当前节点的下一个节点；否则，让双链表头指针指向下一个节点。</li><li>如果当前节点有后继节点，则让后继节点指向当前节点的前一个节点；否则，让双链表尾指针指向上一个节点。</li></ul><h2 id="4-List-常见问题"><a href="#4-List-常见问题" class="headerlink" title="4. List 常见问题"></a>4. List 常见问题</h2><h3 id="4-1-Arrays-asList-问题点"><a href="#4-1-Arrays-asList-问题点" class="headerlink" title="4.1. Arrays.asList 问题点"></a>4.1. Arrays.asList 问题点</h3><p> 在业务开发中，我们常常会把原始的数组转换为 <code>List</code> 类数据结构，来继续展开各种 <code>Stream</code> 操作。通常，我们会使用 <code>Arrays.asList</code> 方法可以把数组一键转换为 <code>List</code>。 </p><p> 【示例】Arrays.asList 转换基本类型数组 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>List list = Arrays.asList(arr);<br>log.info(<span class="hljs-string">&quot;list:&#123;&#125; size:&#123;&#125; class:&#123;&#125;&quot;</span>, list, list.size(), list.get(<span class="hljs-number">0</span>).getClass());<br></code></pre></td></tr></table></figure><p> 【输出】 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">list:[[I@ae45eb6] size:1 class:class [I<br></code></pre></td></tr></table></figure><p> 数组元素个数为 3，但转换后的列表个数为 1。 </p><p> 由此可知， <code>Arrays.asList</code> 第一个问题点：<strong>不能直接使用 <code>Arrays.asList</code> 来转换基本类型数组</strong>。 </p><p> 其原因是：<code>Arrays.asList</code> 方法传入的是一个泛型 T 类型可变参数，最终 <code>int</code> 数组整体作为了一个对象成为了泛型类型 T： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">asList</span><span class="hljs-params">(T... a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(a);<br>&#125;<br></code></pre></td></tr></table></figure><p> 直接遍历这样的 <code>List</code> 必然会出现 Bug，修复方式有两种，如果使用 Java8 以上版本可以使用 <code>Arrays.stream</code> 方法来转换，否则可以把 <code>int</code> 数组声明为包装类型 <code>Integer</code> 数组： </p><p> 【示例】转换整型数组为 List 的正确方式 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr1 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>List list1 = Arrays.stream(arr1).boxed().collect(Collectors.toList());<br><br>Integer[] arr2 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>List list2 = Arrays.asList(arr2);<br></code></pre></td></tr></table></figure><p> 【示例】Arrays.asList 转换引用类型数组 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] arr = &#123; <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span> &#125;;<br>List list = Arrays.asList(arr);<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;4&quot;</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    list.add(<span class="hljs-string">&quot;5&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>    ex.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p> 抛出 <code>java.lang.UnsupportedOperationException</code>。 </p><p> 抛出异常的原因在于 <code>Arrays.asList</code> 第二个问题点：**<code>Arrays.asList</code> 返回的 <code>List</code> 不支持增删操作**。 </p><p> <code>Arrays.asList</code> 返回的 List 并不是我们期望的 <code>java.util.ArrayList</code>，而是 <code>Arrays</code> 的内部类 <code>ArrayList</code>。 </p><p> 查看源码，我们可以发现 <code>Arrays.asList</code> 返回的 <code>ArrayList</code> 继承了 <code>AbstractList</code>，但是并没有覆写 <code>add</code> 和 <code>remove</code> 方法。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">2764017481108945198L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E[] a;<br><br>    ArrayList(E[] array) &#123;<br>        a = Objects.requireNonNull(array);<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>        E oldValue = a[index];<br>        a[index] = element;<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCollection</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>Arrays.asList</code> 第三个问题点：**对原始数组的修改会影响到我们获得的那个 <code>List</code>**。<code>ArrayList</code> 其实是直接使用了原始的数组。 </p><p> 解决方法很简单，重新 <code>new</code> 一个 <code>ArrayList</code> 初始化 <code>Arrays.asList</code> 返回的 <code>List</code> 即可： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] arr = &#123; <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span> &#125;;<br>List list = <span class="hljs-keyword">new</span> ArrayList(Arrays.asList(arr));<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;4&quot;</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    list.add(<span class="hljs-string">&quot;5&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>    ex.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-List-subList-问题点"><a href="#4-2-List-subList-问题点" class="headerlink" title="4.2. List.subList 问题点"></a>4.2. List.subList 问题点</h3><p> List.subList 直接引用了原始的 List，也可以认为是共享“存储”，而且对原始 List 直接进行结构性修改会导致 SubList 出现异常。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">oom</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        List&lt;Integer&gt; rawList = IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">100000</span>).boxed().collect(Collectors.toList());<br>        data.add(rawList.subList(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 出现 OOM 的原因是，循环中的 1000 个具有 10 万个元素的 List 始终得不到回收，因为它始终被 subList 方法返回的 List 强引用。 </p><p> 解决方法是： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">oomfix</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        List&lt;Integer&gt; rawList = IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">100000</span>).boxed().collect(Collectors.toList());<br>        data.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(rawList.subList(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 【示例】子 List 强引用原始的 List </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wrong</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Integer&gt; list = IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>).boxed().collect(Collectors.toList());<br>    List&lt;Integer&gt; subList = list.subList(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);<br>    System.out.println(subList);<br>    subList.remove(<span class="hljs-number">1</span>);<br>    System.out.println(list);<br>    list.add(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        subList.forEach(System.out::println);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        ex.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 抛出 <code>java.util.ConcurrentModificationException</code>。 </p><p> 解决方法： </p><p> 一种是，不直接使用 subList 方法返回的 SubList，而是重新使用 new ArrayList，在构造方法传入 SubList，来构建一个独立的 ArrayList； </p><p>另一种是，对于 Java 8 使用 Stream 的 skip 和 limit API 来跳过流中的元素，以及限制流中元素的个数，同样可以达到 SubList 切片的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方式一：</span><br>List&lt;Integer&gt; subList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(list.subList(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>));<br><span class="hljs-comment">//方式二：</span><br>List&lt;Integer&gt; subList = list.stream().skip(<span class="hljs-number">1</span>).limit(<span class="hljs-number">3</span>).collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h2><p> <a href="https://item.jd.com/10058164.html">Java 编程思想（第 4 版）</a> </p><p><a href="https://dunwu.github.io/javacore/container/java-container-list.html#_1-list-%E7%AE%80%E4%BB%8B">java-容器之List</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java-容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-容器之简介</title>
    <link href="/2021/11/18/Java-%E5%AE%B9%E5%99%A8%E4%B9%8B%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/11/18/Java-%E5%AE%B9%E5%99%A8%E4%B9%8B%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-容器简介"><a href="#1-容器简介" class="headerlink" title="1.容器简介"></a>1.容器简介</h2><h3 id="1-1-数组与容器"><a href="#1-1-数组与容器" class="headerlink" title="1.1. 数组与容器"></a>1.1. 数组与容器</h3><p>Java 中常用的存储容器就是数组和容器，二者有以下区别：</p><ul><li>存储大小是否固定<ul><li>数组的<strong>长度固定</strong>；</li><li>容器的<strong>长度可变</strong>。</li></ul></li><li>数据类型<ul><li><strong>数组可以存储基本数据类型，也可以存储引用数据类型</strong>；</li><li><strong>容器只能存储引用数据类型，基本数据类型的变量要转换成对应的包装类才能放入容器类中。</strong></li></ul></li></ul><h3 id="1-2-容器框架"><a href="#1-2-容器框架" class="headerlink" title="1.2. 容器框架"></a>1.2. 容器框架</h3><p><img src="/img/work/image-20211122204933065.png" alt="集合关系图"></p><p>Java 容器框架主要分为 <code>Collection</code> 和 <code>Map</code> 两种。其中，<code>Collection</code> 又分为 <code>List</code>、<code>Set</code> 以及 <code>Queue</code>。</p><ul><li><code>Collection</code> - 一个独立元素的序列，这些元素都服从一条或者多条规则。<ul><li><code>List</code> - 必须按照插入的顺序保存元素。</li><li><code>Set</code> - 不能有重复的元素。</li><li><code>Queue</code> - 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。</li></ul></li><li><code>Map</code> - 一组成对的“键值对”对象，允许你使用键来查找值。</li></ul><h2 id="2-容器的基本机制"><a href="#2-容器的基本机制" class="headerlink" title="2. 容器的基本机制"></a>2. 容器的基本机制</h2><blockquote><p>Java 的容器具有一定的共性，它们或全部或部分依赖以下技术。所以，学习以下技术点，对于理解 Java 容器的特性和原理有很大的帮助。</p></blockquote><h3 id="2-1-泛型"><a href="#2-1-泛型" class="headerlink" title="2.1. 泛型"></a>2.1. 泛型</h3><p>Java 1.5 引入了泛型技术。</p><p>Java <strong>容器通过泛型技术来保证其数据的类型安全</strong>。</p><p>什么是类型安全呢？举例来说：如果有一个 <code>List&lt;Object&gt;</code> 容器，Java <strong>编译器在编译时不会对原始类型进行类型安全检查</strong>，却会对带参数的类型进行检查，通过使用 Object 作为类型，可以告知编译器该方法可以接受任何类型的对象，比如 String 或 Integer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>list.add(<span class="hljs-string">&quot;123&quot;</span>);<br>list.add(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>如果没有泛型技术，如示例中的代码那样，容器中就可能存储任意数据类型，这是很危险的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>list.add(<span class="hljs-string">&quot;123&quot;</span>);<br>list.add(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><h3 id="2-2-Iterable-和-Iterator"><a href="#2-2-Iterable-和-Iterator" class="headerlink" title="2.2. Iterable 和 Iterator"></a>2.2. Iterable 和 Iterator</h3><blockquote><p>Iterable 和 Iterator 目的在于遍历访问容器中的元素。</p></blockquote><p><code>Iterator</code> 接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">&quot;remove&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; action)</span> </span>&#123;<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">while</span> (hasNext())<br>            action.accept(next());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Iterable</code> 接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-function">Iterator&lt;T&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span> </span>&#123;<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">for</span> (T t : <span class="hljs-keyword">this</span>) &#123;<br>            action.accept(t);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Spliterator&lt;T&gt; <span class="hljs-title">spliterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Collection</code> 接口扩展了 <code>Iterable</code> 接口。</p><p>迭代其实我们可以简单地理解为遍历，是一个标准化遍历各类容器里面的所有对象的接口。它是一个经典的设计模式——迭代器模式（Iterator）。</p><p><strong>迭代器模式</strong> - <strong>提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示</strong>。</p><p><img src="/img/work/iterator-pattern.png" alt="迭代器UML"></p><p>示例：迭代器遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        list.add(<span class="hljs-number">3</span>);<br>        Iterator it = list.iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            System.out.println(it.next());<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-Comparable-和-Comparator"><a href="#2-3-Comparable-和-Comparator" class="headerlink" title="2.3. Comparable 和 Comparator"></a>2.3. Comparable 和 Comparator</h3><p><code>Comparable</code> 是排序接口。若一个类实现了 <code>Comparable</code> 接口，表示该类的实例可以比较，也就意味着支持排序。实现了 <code>Comparable</code> 接口的类的对象的列表或数组可以通过 <code>Collections.sort</code> 或 <code>Arrays.sort</code> 进行自动排序。</p><p><code>Comparable</code> 接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T o)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Comparator</code> 是比较接口，我们如果需要控制某个类的次序，而该类本身不支持排序(即没有实现 <code>Comparable</code> 接口)，那么我们就可以建立一个“该类的比较器”来进行排序，这个“比较器”只需要实现 <code>Comparator</code> 接口即可。也就是说，我们可以通过实现 <code>Comparator</code> 来新建一个比较器，然后通过这个比较器对类进行排序。</p><p><code>Comparator</code> 接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(T o1, T o2)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>;<br><br>    <span class="hljs-comment">// 反转</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Comparator&lt;T&gt; <span class="hljs-title">reversed</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Collections.reverseOrder(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Comparator&lt;T&gt; <span class="hljs-title">thenComparing</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; other)</span> </span>&#123;<br>        Objects.requireNonNull(other);<br>        <span class="hljs-keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; &#123;<br>            <span class="hljs-keyword">int</span> res = compare(c1, c2);<br>            <span class="hljs-keyword">return</span> (res != <span class="hljs-number">0</span>) ? res : other.compare(c1, c2);<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">// thenComparingXXX 方法略</span><br><br>    <span class="hljs-comment">// 静态方法略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 Java 容器中，一些可以排序的容器，如 <code>TreeMap</code>、<code>TreeSet</code>，都可以通过传入 <code>Comparator</code>，来定义内部元素的排序规则。</p><h3 id="2-4-Cloneable"><a href="#2-4-Cloneable" class="headerlink" title="2.4. Cloneable"></a>2.4. Cloneable</h3><p>Java 中 一个类要实现 <code>clone</code> 功能 必须实现 <code>Cloneable</code> 接口，否则在调用 <code>clone()</code> 时会报 <code>CloneNotSupportedException</code> 异常。</p><p>Java 中所有类都默认继承 <code>java.lang.Object</code> 类，在 <code>java.lang.Object</code> 类中有一个方法 <code>clone()</code>，这个方法将返回 <code>Object</code> 对象的一个拷贝。<code>Object</code> 类里的 <code>clone()</code> 方法仅仅用于浅拷贝（拷贝基本成员属性，对于引用类型仅返回指向改地址的引用）。</p><p>如果 Java 类需要深拷贝，需要覆写 <code>clone()</code> 方法。</p><h3 id="2-5-fail-fast"><a href="#2-5-fail-fast" class="headerlink" title="2.5. fail-fast"></a>2.5. fail-fast</h3><h4 id="fail-fast-的要点"><a href="#fail-fast-的要点" class="headerlink" title="fail-fast 的要点"></a>fail-fast 的要点</h4><p>Java 容器（如：ArrayList、HashMap、TreeSet 等）的 javadoc 中常常提到类似的描述：</p><blockquote><p>注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败（fail-fast）迭代器会尽最大努力抛出 <code>ConcurrentModificationException</code>。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。</p></blockquote><p>那么，我们不禁要问，什么是 fail-fast，为什么要有 fail-fast 机制？</p><p><strong>fail-fast 是 Java 容器的一种错误检测机制</strong>。当多个线程对容器进行结构上的改变的操作时，就可能触发 fail-fast 机制。记住是有可能，而不是一定。</p><p>例如：假设存在两个线程（线程 1、线程 2），线程 1 通过 <code>Iterator</code> 在遍历容器 A 中的元素，在某个时候线程 2 修改了容器 A 的结构（是结构上面的修改，而不是简单的修改容器元素的内容），那么这个时候程序就会抛出 <code>ConcurrentModificationException</code> 异常，从而产生 fail-fast 机制。</p><p><strong>容器在迭代操作中改变元素个数（添加、删除元素）都可能会导致 fail-fast</strong>。</p><p>示例：fail-fast 示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FailFastDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX; i++) &#123;<br>            list.add(i);<br>        &#125;<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThreadA()).start();<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThreadB()).start();<br>    &#125;<br><br>    <span class="hljs-comment">/** 迭代遍历容器所有元素 */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            Iterator&lt;Integer&gt; iterator = list.iterator();<br>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                <span class="hljs-keyword">int</span> i = iterator.next();<br>                System.out.println(<span class="hljs-string">&quot;MyThreadA 访问元素:&quot;</span> + i);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/** 遍历删除指定范围内的所有偶数 */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (i &lt; MAX) &#123;<br>                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;MyThreadB 删除元素&quot;</span> + i);<br>                    list.remove(i);<br>                &#125;<br>                i++;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>执行后，会抛出 <code>java.util.ConcurrentModificationException</code> 异常。</p><h4 id="解决-fail-fast"><a href="#解决-fail-fast" class="headerlink" title="解决 fail-fast"></a>解决 fail-fast</h4><p>fail-fast 有两种解决方案：</p><ul><li>在遍历过程中所有涉及到改变容器个数的地方全部加上 <code>synchronized</code> 或者直接使用 <code>Collections.synchronizedXXX</code> 容器，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作，影响吞吐。</li><li>使用并发容器，如：<code>CopyOnWriterArrayList</code>。</li></ul><p>参考:</p><p><a href="https://dunwu.github.io/javacore/container/java-container.html">Java 容器简介</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java-容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础-反射机制</title>
    <link href="/2021/11/09/Java%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/11/09/Java%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-反射简介"><a href="#1-反射简介" class="headerlink" title="1.反射简介"></a>1.反射简介</h2><h3 id="1-1-什么是反射"><a href="#1-1-什么是反射" class="headerlink" title="1.1 什么是反射"></a>1.1 什么是反射</h3><blockquote><p>Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为动态语言的关键。（引自百度百科）</p></blockquote><p>核心反射机制<code> java.lang.reflect</code>提供对任意类的编程访问,给定一个Class对象，你可以获得<code>Constructor</code>、<code>Method</code> 和 <code>Field</code> 实例分别代表了该 <code>Class</code> 实例所表示的类的构造器、方法和字段。这些对象提供对类 的成员名、字段类型、方法签名等的编程访问。此外，<code>Constructor</code>、<code>Method</code> 和 <code>Field</code> 实例允许你反射性地操作它们的底层对应项：你可以通过调用 <code>Constructor</code>、 <code>Method</code> 和 <code>Field</code> 实例上的方法，可以构造底层类的实例、调用底层类的方法，并访问底层类中的字段。</p><h3 id="1-2-反射的应用场景"><a href="#1-2-反射的应用场景" class="headerlink" title="1.2. 反射的应用场景"></a>1.2. 反射的应用场景</h3><p>反射的主要应用场景有：</p><ul><li><strong>开发通用框架</strong> - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</li><li><strong>动态代理</strong> - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。</li><li><strong>注解</strong> - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。</li><li><strong>可扩展性功能</strong> - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。</li></ul><h3 id="1-3-反射优点"><a href="#1-3-反射优点" class="headerlink" title="1.3.反射优点"></a>1.3.反射优点</h3><ul><li>增加程序的灵活性，避免将程序写死到代码里</li><li>代码简洁，提高代码的复用率，外部调用方便</li><li>对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法</li></ul><h3 id="1-4-反射缺点"><a href="#1-4-反射缺点" class="headerlink" title="1.4.反射缺点"></a>1.4.反射缺点</h3><ul><li><strong>失去了编译时类型检查的所有好处</strong>，包括异常检查。如果一个程序试图反射性地调用一个不存在的或不可访 问的方法，它将在运行时失败，除非你采取了特殊的预防措施。</li><li><strong>执行反射访问所需的代码既笨拙又冗长</strong>。 写起来很乏味，读起来也很困难。</li><li><strong>性能降低。</strong>反射方法调用比普通方法调用慢得多。到底慢了多少还很难说，因为有很多因素在起作用。在我的 机器上，调用一个没有输入参数和返回 int 类型的方法时，用反射执行要慢 11 倍。</li></ul><h2 id="2-反射机制"><a href="#2-反射机制" class="headerlink" title="2.反射机制"></a>2.反射机制</h2><h3 id="2-1-类加载过程"><a href="#2-1-类加载过程" class="headerlink" title="2.1. 类加载过程"></a>2.1. 类加载过程</h3><p><img src="/%5Cimg%5Cwork%5C1636379724292.png"></p><p> 类加载的完整过程如下： </p><ol><li>在编译时，Java 编译器编译好 <code>.java</code> 文件之后，在磁盘中产生 <code>.class</code> 文件。<code>.class</code> 文件是二进制文件，内容是只有 JVM 能够识别的机器码。</li><li>JVM 中的类加载器读取字节码文件，取出二进制数据，加载到内存中，解析.class 文件内的信息。类加载器会根据类的全限定名来获取此类的二进制字节流；然后，将字节流所代表的静态存储结构转化为方法区的运行时数据结构；接着，在内存中生成代表这个类的 <code>java.lang.Class</code> 对象。</li><li>加载结束后，JVM 开始进行连接阶段（包含验证、准备、初始化）。经过这一系列操作，类的变量会被初始化。</li></ol><h3 id="2-2-Class-对象"><a href="#2-2-Class-对象" class="headerlink" title="2.2. Class 对象"></a>2.2. Class 对象</h3><p>要想使用反射，首先需要获得待操作的类所对应的 Class 对象。<strong>Java 中，无论生成某个类的多少个对象，这些对象都会对应于同一个 Class 对象。这个 Class 对象是由 JVM 生成的，通过它能够获悉整个类的结构</strong>。所以，<code>java.lang.Class</code> 可以视为所有反射 API 的入口点。</p><p><strong>反射的本质就是：在运行时，把 Java 类中的各种成分映射成一个个的 Java 对象。</strong></p><p> 举例来说，假如定义了以下代码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">User user = <span class="hljs-keyword">new</span> User();<br></code></pre></td></tr></table></figure><p> 步骤说明： </p><ol><li>JVM 加载方法的时候，遇到 <code>new User()</code>，JVM 会根据 <code>User</code> 的全限定名去加载 <code>User.class</code> 。</li><li>JVM 会去本地磁盘查找 <code>User.class</code> 文件并加载 JVM 内存中。</li><li>JVM 通过调用类加载器自动创建这个类对应的 <code>Class</code> 对象，并且存储在 JVM 的方法区。注意：<strong>一个类有且只有一个 <code>Class</code> 对象</strong>。</li></ol><h3 id="2-3-方法的反射调用"><a href="#2-3-方法的反射调用" class="headerlink" title="2.3. 方法的反射调用"></a>2.3. 方法的反射调用</h3><p>方法的反射调用，也就是 <code>Method.invoke</code> 方法。</p><p><code>Method.invoke</code> 方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Method</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Executable</span> </span>&#123;<br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span> <span class="hljs-keyword">throws</span> ... </span>&#123;<br>    ... <span class="hljs-comment">// 权限检查</span><br>    MethodAccessor ma = methodAccessor;<br>    <span class="hljs-keyword">if</span> (ma == <span class="hljs-keyword">null</span>) &#123;<br>      ma = acquireMethodAccessor();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ma.invoke(obj, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Method.invoke</code> 方法实际上委派给 <code>MethodAccessor</code> 接口来处理。它有两个已有的具体实现：</p><ul><li><code>NativeMethodAccessorImpl</code>：本地方法来实现反射调用</li><li><code>DelegatingMethodAccessorImpl</code>：委派模式来实现反射调用</li></ul><p>每个 <code>Method</code> 实例的第一次反射调用都会生成一个委派实现（<code>DelegatingMethodAccessorImpl</code>），它所委派的具体实现便是一个本地实现（<code>NativeMethodAccessorImpl</code>）。本地实现非常容易理解。当进入了 Java 虚拟机内部之后，我们便拥有了 <code>Method</code> 实例所指向方法的具体地址。这时候，反射调用无非就是将传入的参数准备好，然后调用进入目标方法。</p><h3 id="2-4-反射调用的开销"><a href="#2-4-反射调用的开销" class="headerlink" title="2.4. 反射调用的开销"></a>2.4. 反射调用的开销</h3><p>方法的反射调用会带来不少性能开销，原因主要有三个：</p><ul><li>变长参数方法导致的 Object 数组</li><li>基本类型的自动装箱、拆箱</li><li>还有最重要的方法内联</li></ul><p> <code>Class.forName</code> 会调用本地方法，<code>Class.getMethod</code> 则会遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法。可想而知，这两个操作都非常费时。 </p><blockquote><p> 注意，以 <code>getMethod</code> 为代表的查找方法操作，会返回查找得到结果的一份拷贝。因此，我们应当避免在热点代码中使用返回 <code>Method</code> 数组的 <code>getMethods</code> 或者 <code>getDeclaredMethods</code> 方法，以减少不必要的堆空间消耗。在实践中，我们往往会在应用程序中缓存 <code>Class.forName</code> 和 <code>Class.getMethod</code> 的结果。 </p></blockquote><p> 下面只关注反射调用本身的性能开销。 </p><p>第一，由于 Method.invoke 是一个变长参数方法，在字节码层面它的最后一个参数会是 Object 数组（感兴趣的同学私下可以用 javap 查看）。Java 编译器会在方法调用处生成一个长度为传入参数数量的 Object 数组，并将传入参数一一存储进该数组中。</p><p>第二，由于 Object 数组不能存储基本类型，Java 编译器会对传入的基本类型参数进行自动装箱。</p><p>这两个操作除了带来性能开销外，还可能占用堆内存，使得 GC 更加频繁。（如果你感兴趣的话，可以用虚拟机参数 -XX:+PrintGC 试试。）那么，如何消除这部分开销呢？</p><h2 id="3-使用反射"><a href="#3-使用反射" class="headerlink" title="3. 使用反射"></a>3. 使用反射</h2><h3 id="3-1-java-lang-reflect-包"><a href="#3-1-java-lang-reflect-包" class="headerlink" title="3.1. java.lang.reflect 包"></a>3.1. java.lang.reflect 包</h3><p> Java 中的 <code>java.lang.reflect</code> 包提供了反射功能。<code>java.lang.reflect</code> 包中的类都没有 <code>public</code> 构造方法。 </p><p> <code>java.lang.reflect</code> 包的核心接口和类如下： </p><ul><li><code>Member</code> 接口：反映关于单个成员(字段或方法)或构造函数的标识信息。</li><li><code>Field</code> 类：提供一个类的域的信息以及访问类的域的接口。</li><li><code>Method</code> 类：提供一个类的方法的信息以及访问类的方法的接口。</li><li><code>Constructor</code> 类：提供一个类的构造函数的信息以及访问类的构造函数的接口。</li><li><code>Array</code> 类：该类提供动态地生成和访问 JAVA 数组的方法。</li><li><code>Modifier</code> 类：提供了 static 方法和常量，对类和成员访问修饰符进行解码。</li><li><code>Proxy</code> 类：提供动态地生成代理类和类实例的静态方法。</li></ul><h3 id="3-2-获取-Class-对象"><a href="#3-2-获取-Class-对象" class="headerlink" title="3.2. 获取 Class 对象"></a>3.2. 获取 Class 对象</h3><p> 获取 <code>Class</code> 对象的三种方法： </p><p> （1）**<code>Class.forName</code> 静态方法** </p><p> 【示例】使用 <code>Class.forName</code> 静态方法获取 <code>Class</code> 对象 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectClassDemo01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        Class c1 = Class.forName(<span class="hljs-string">&quot;io.github.dunwu.javacore.reflect.ReflectClassDemo01&quot;</span>);<br>        System.out.println(c1.getCanonicalName());<br><br>        Class c2 = Class.forName(<span class="hljs-string">&quot;[D&quot;</span>);<br>        System.out.println(c2.getCanonicalName());<br><br>        Class c3 = Class.forName(<span class="hljs-string">&quot;[[Ljava.lang.String;&quot;</span>);<br>        System.out.println(c3.getCanonicalName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//io.github.dunwu.javacore.reflect.ReflectClassDemo01</span><br><span class="hljs-comment">//double[]</span><br><span class="hljs-comment">//java.lang.String[][]</span><br></code></pre></td></tr></table></figure><p> 使用类的完全限定名来反射对象的类。常见的应用场景为：在 JDBC 开发中常用此方法加载数据库驱动。 </p><p> （2）<strong>类名 + <code>.class</code></strong> </p><p> 【示例】直接用类名 + <code>.class</code> 获取 <code>Class</code> 对象 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectClassDemo02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> b;<br>        <span class="hljs-comment">// Class c = b.getClass(); // 编译错误</span><br>        Class c1 = <span class="hljs-keyword">boolean</span>.class;<br>        System.out.println(c1.getCanonicalName());<br><br>        Class c2 = java.io.PrintStream.class;<br>        System.out.println(c2.getCanonicalName());<br><br>        Class c3 = <span class="hljs-keyword">int</span>[][][].class;<br>        System.out.println(c3.getCanonicalName());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//boolean</span><br><span class="hljs-comment">//java.io.PrintStream</span><br><span class="hljs-comment">//int[][][]</span><br></code></pre></td></tr></table></figure><p> （3）**<code>Object</code> 的 <code>getClass</code> 方法** </p><p><code>Object</code> 类中有 <code>getClass</code> 方法，因为所有类都继承 <code>Object</code> 类。从而调用 <code>Object</code> 类来获取 <code>Class</code> 对象。</p><p>【示例】<code>Object</code> 的 <code>getClass</code> 方法获取 <code>Class</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectClassDemo03</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">E</span> </span>&#123;A, B&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Class c = <span class="hljs-string">&quot;foo&quot;</span>.getClass();<br>        System.out.println(c.getCanonicalName());<br><br>        Class c2 = ReflectClassDemo03.E.A.getClass();<br>        System.out.println(c2.getCanonicalName());<br><br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        Class c3 = bytes.getClass();<br>        System.out.println(c3.getCanonicalName());<br><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        Class c4 = set.getClass();<br>        System.out.println(c4.getCanonicalName());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//java.lang.String</span><br><span class="hljs-comment">//io.github.dunwu.javacore.reflect.ReflectClassDemo.E</span><br><span class="hljs-comment">//byte[]</span><br><span class="hljs-comment">//java.util.HashSet</span><br></code></pre></td></tr></table></figure><h3 id="3-3-判断是否为某个类的实例"><a href="#3-3-判断是否为某个类的实例" class="headerlink" title="3.3. 判断是否为某个类的实例"></a>3.3. 判断是否为某个类的实例</h3><p>判断是否为某个类的实例有两种方式：</p><ol><li><strong>用 <code>instanceof</code> 关键字</strong></li><li><strong>用 <code>Class</code> 对象的 <code>isInstance</code> 方法</strong>（它是一个 Native 方法）</li></ol><p> 【示例】 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceofDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList arrayList = <span class="hljs-keyword">new</span> ArrayList();<br>        <span class="hljs-keyword">if</span> (arrayList <span class="hljs-keyword">instanceof</span> List) &#123;<br>            System.out.println(<span class="hljs-string">&quot;ArrayList is List&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (List.class.isInstance(arrayList)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;ArrayList is List&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//ArrayList is List</span><br><span class="hljs-comment">//ArrayList is List</span><br></code></pre></td></tr></table></figure><h3 id="3-4-创建实例"><a href="#3-4-创建实例" class="headerlink" title="3.4. 创建实例"></a>3.4. 创建实例</h3><p> 通过反射来创建实例对象主要有两种方式： </p><ul><li>用 <code>Class</code> 对象的 <code>newInstance</code> 方法。</li><li>用 <code>Constructor</code> 对象的 <code>newInstance</code> 方法。</li></ul><p>【示例】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewInstanceDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;<br>        Class&lt;?&gt; c1 = StringBuilder.class;<br>        StringBuilder sb = (StringBuilder) c1.newInstance();<br>        sb.append(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        System.out.println(sb.toString());<br><br>        <span class="hljs-comment">//获取String所对应的Class对象</span><br>        Class&lt;?&gt; c2 = String.class;<br>        <span class="hljs-comment">//获取String类带一个String参数的构造器</span><br>        Constructor constructor = c2.getConstructor(String.class);<br>        <span class="hljs-comment">//根据构造器创建实例</span><br>        String str2 = (String) constructor.newInstance(<span class="hljs-string">&quot;bbb&quot;</span>);<br>        System.out.println(str2);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//aaa</span><br><span class="hljs-comment">//bbb</span><br></code></pre></td></tr></table></figure><h3 id="3-5-创建数组实例"><a href="#3-5-创建数组实例" class="headerlink" title="3.5. 创建数组实例"></a>3.5. 创建数组实例</h3><p> 数组在 Java 里是比较特殊的一种类型，它可以赋值给一个对象引用。Java 中，<strong>通过 <code>Array.newInstance</code> 创建数组的实例</strong>。 </p><p> 【示例】利用反射创建数组 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectArrayDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        Class&lt;?&gt; cls = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br>        Object array = Array.newInstance(cls, <span class="hljs-number">25</span>);<br>        <span class="hljs-comment">//往数组里添加内容</span><br>        Array.set(array, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Scala&quot;</span>);<br>        Array.set(array, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br>        Array.set(array, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;Groovy&quot;</span>);<br>        Array.set(array, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;Scala&quot;</span>);<br>        Array.set(array, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;Clojure&quot;</span>);<br>        <span class="hljs-comment">//获取某一项的内容</span><br>        System.out.println(Array.get(array, <span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Output:</span><br><span class="hljs-comment">//Scala</span><br></code></pre></td></tr></table></figure><p> 其中的 Array 类为 <code>java.lang.reflect.Array</code> 类。我们<code>Array.newInstance</code> 的原型是： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newInstance</span><span class="hljs-params">(Class&lt;?&gt; componentType, <span class="hljs-keyword">int</span> length)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> NegativeArraySizeException </span>&#123;<br>    <span class="hljs-keyword">return</span> newArray(componentType, length);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6-Field"><a href="#3-6-Field" class="headerlink" title="3.6. Field"></a>3.6. Field</h3><p><code>Class</code> 对象提供以下方法获取对象的成员（<code>Field</code>）：</p><ul><li><code>getFiled</code> - 根据名称获取公有的（public）类成员。</li><li><code>getDeclaredField</code> - 根据名称获取已声明的类成员。但不能得到其父类的类成员。</li><li><code>getFields</code> - 获取所有公有的（public）类成员。</li><li><code>getDeclaredFields</code> - 获取所有已声明的类成员。</li></ul><p> 示例如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectFieldDemo</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldSpy</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span>[][] b = &#123; &#123;<span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>&#125;, &#123;<span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>&#125; &#125;;<br>        <span class="hljs-keyword">public</span> String name = <span class="hljs-string">&quot;Alice&quot;</span>;<br>        <span class="hljs-keyword">public</span> List&lt;Integer&gt; list;<br>        <span class="hljs-keyword">public</span> T val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException </span>&#123;<br>        Field f1 = FieldSpy.class.getField(<span class="hljs-string">&quot;b&quot;</span>);<br>        System.out.format(<span class="hljs-string">&quot;Type: %s%n&quot;</span>, f1.getType());<br><br>        Field f2 = FieldSpy.class.getField(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.format(<span class="hljs-string">&quot;Type: %s%n&quot;</span>, f2.getType());<br><br>        Field f3 = FieldSpy.class.getField(<span class="hljs-string">&quot;list&quot;</span>);<br>        System.out.format(<span class="hljs-string">&quot;Type: %s%n&quot;</span>, f3.getType());<br><br>        Field f4 = FieldSpy.class.getField(<span class="hljs-string">&quot;val&quot;</span>);<br>        System.out.format(<span class="hljs-string">&quot;Type: %s%n&quot;</span>, f4.getType());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Output:</span><br><span class="hljs-comment">//Type: class [[Z</span><br><span class="hljs-comment">//Type: class java.lang.String</span><br><span class="hljs-comment">//Type: interface java.util.List</span><br><span class="hljs-comment">//Type: class java.lang.Object</span><br></code></pre></td></tr></table></figure><h3 id="3-7-Method"><a href="#3-7-Method" class="headerlink" title="3.7. Method"></a>3.7. Method</h3><p> <code>Class</code> 对象提供以下方法获取对象的方法（<code>Method</code>）： </p><ul><li><code>getMethod</code> - 返回类或接口的特定方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。</li><li><code>getDeclaredMethod</code> - 返回类或接口的特定声明方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。</li><li><code>getMethods</code> - 返回类或接口的所有 public 方法，包括其父类的 public 方法。</li><li><code>getDeclaredMethods</code> - 返回类或接口声明的所有方法，包括 public、protected、默认（包）访问和 private 方法，但不包括继承的方法。</li></ul><p>获取一个 <code>Method</code> 对象后，可以用 <code>invoke</code> 方法来调用这个方法。</p><p><code>invoke</code> 方法的原型为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><br><span class="hljs-function">           InvocationTargetException</span><br></code></pre></td></tr></table></figure><p>【示例】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectMethodDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;<br><br>        <span class="hljs-comment">// 返回所有方法</span><br>        Method[] methods1 = System.class.getDeclaredMethods();<br>        System.out.println(<span class="hljs-string">&quot;System getDeclaredMethods 清单（数量 = &quot;</span> + methods1.length + <span class="hljs-string">&quot;）：&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Method m : methods1) &#123;<br>            System.out.println(m);<br>        &#125;<br><br>        <span class="hljs-comment">// 返回所有 public 方法</span><br>        Method[] methods2 = System.class.getMethods();<br>        System.out.println(<span class="hljs-string">&quot;System getMethods 清单（数量 = &quot;</span> + methods2.length + <span class="hljs-string">&quot;）：&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Method m : methods2) &#123;<br>            System.out.println(m);<br>        &#125;<br><br>        <span class="hljs-comment">// 利用 Method 的 invoke 方法调用 System.currentTimeMillis()</span><br>        Method method = System.class.getMethod(<span class="hljs-string">&quot;currentTimeMillis&quot;</span>);<br>        System.out.println(method);<br>        System.out.println(method.invoke(<span class="hljs-keyword">null</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-8-Constructor"><a href="#3-8-Constructor" class="headerlink" title="3.8. Constructor"></a>3.8. Constructor</h3><p><code>Class</code> 对象提供以下方法获取对象的构造方法（<code>Constructor</code>）：</p><ul><li><code>getConstructor</code> - 返回类的特定 public 构造方法。参数为方法参数对应 Class 的对象。</li><li><code>getDeclaredConstructor</code> - 返回类的特定构造方法。参数为方法参数对应 Class 的对象。</li><li><code>getConstructors</code> - 返回类的所有 public 构造方法。</li><li><code>getDeclaredConstructors</code> - 返回类的所有构造方法。</li></ul><p>获取一个 <code>Constructor</code> 对象后，可以用 <code>newInstance</code> 方法来创建类实例。</p><p>【示例】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectMethodConstructorDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;<br>        Constructor&lt;?&gt;[] constructors1 = String.class.getDeclaredConstructors();<br>        System.out.println(<span class="hljs-string">&quot;String getDeclaredConstructors 清单（数量 = &quot;</span> + constructors1.length + <span class="hljs-string">&quot;）：&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Constructor c : constructors1) &#123;<br>            System.out.println(c);<br>        &#125;<br><br>        Constructor&lt;?&gt;[] constructors2 = String.class.getConstructors();<br>        System.out.println(<span class="hljs-string">&quot;String getConstructors 清单（数量 = &quot;</span> + constructors2.length + <span class="hljs-string">&quot;）：&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Constructor c : constructors2) &#123;<br>            System.out.println(c);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;====================&quot;</span>);<br>        Constructor constructor = String.class.getConstructor(String.class);<br>        System.out.println(constructor);<br>        String str = (String) constructor.newInstance(<span class="hljs-string">&quot;bbb&quot;</span>);<br>        System.out.println(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-9-绕开访问限制"><a href="#3-9-绕开访问限制" class="headerlink" title="3.9. 绕开访问限制"></a>3.9. 绕开访问限制</h3><p>有时候，我们需要通过反射访问私有成员、方法。可以使用 <code>Constructor/Field/Method.setAccessible(true)</code> 来绕开 Java 语言的访问限制。</p><p>参考</p><hr><p><a href="/img/work/Effective.Java.pdf">Effective-Java</a></p><p>引用</p><hr><p><a href="https://dunwu.github.io/javacore/basics/java-reflection.html#_1-%E5%8F%8D%E5%B0%84%E7%AE%80%E4%BB%8B">Java反射机制</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础-注解机制</title>
    <link href="/2021/11/05/Java%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/11/05/Java%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="1-1-注解："><a href="#1-1-注解：" class="headerlink" title="1.1 注解："></a>1.1 <strong>注解：</strong></h3><blockquote><p>从本质上来说，<strong>注解是一种标签，其实质上可以视为一种特殊的注释，如果没有解析它的代码，它并不比普通注释强。</strong>。</p></blockquote><p>解析一个注解往往有两种形式：</p><ul><li><strong>编译期直接的扫描</strong> - 编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。这种情况只适用于 JDK 内置的注解类。</li><li><strong>运行期的反射</strong> - 如果要自定义注解，Java 编译器无法识别并处理这个注解，它只能根据该注解的作用范围来选择是否编译进字节码文件。如果要处理注解，必须利用反射技术，识别该注解以及它所携带的信息，然后做相应的处理。</li></ul><h3 id="1-2注解优点"><a href="#1-2注解优点" class="headerlink" title="1.2注解优点"></a>1.2<strong>注解优点</strong></h3><ul><li><p>注解的出现可以替代一些现有的系统，例如 XDoclet，它是一种独立的文档化工具，专门设计用来生成注解风格的文档。与之相比，注解是真正语言层级的概念，以前构造出来就享有编译器的类型检查保护。</p></li><li><p>注解在源代码级别保存所有信息而不是通过注释文字，这使得代码更加整洁和便于维护。通过使用拓展的 annotation API 或稍后在本章节可以看到的外部的字节码工具类库，你会拥有对源代码及字节码强大的检查与操作能力。</p></li></ul><h3 id="1-3注解缺点"><a href="#1-3注解缺点" class="headerlink" title="1.3注解缺点:"></a>1.3<strong>注解缺点:</strong></h3><ul><li><p>它是一种侵入式编程，增加程序耦合度。</p></li><li><p>自定义注解的处理需要在运行时，通过反射技术来获取属性。如果注解所修饰的元素是类的非 public 成员，也可以通过反射获取。这就违背了面向对象的封装性。</p></li><li><p>注解所产生的问题，相对而言，更难以 debug 或定位。</p></li></ul><h3 id="1-4-注解应用范围"><a href="#1-4-注解应用范围" class="headerlink" title="1.4 注解应用范围"></a><strong>1.4 注解应用范围</strong></h3><p>注解可以应用于类、字段、方法和其他程序元素的声明</p><p>JDK8 开始，注解的应用范围进一步扩大，以下是新的应用范围：</p><p>类实例初始化表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-meta">@Interned</span> MyObject();<br></code></pre></td></tr></table></figure><p>类型转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">myString = (<span class="hljs-meta">@NonNull</span> String) str;<br></code></pre></td></tr></table></figure><p>实现接口的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnmodifiableList</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span></span><br><span class="hljs-class">    @<span class="hljs-title">Readonly</span> <span class="hljs-title">List</span>&lt;@<span class="hljs-title">Readonly</span> <span class="hljs-title">T</span>&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>抛出异常声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">monitorTemperature</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> @Critical TemperatureException </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="2-内置注解及元注解"><a href="#2-内置注解及元注解" class="headerlink" title="2.内置注解及元注解"></a>2.内置注解及元注解</h2><h3 id="2-2-内置注解"><a href="#2-2-内置注解" class="headerlink" title="2.2 内置注解"></a>2.2 内置注解</h3><p>JDK 中内置了以下注解：</p><ul><li><code>@Override</code></li><li><code>@Deprecated</code></li><li><code>@SuppressWarnnings</code></li><li><code>@SafeVarargs</code>（JDK7 引入）</li><li><code>@FunctionalInterface</code>（JDK8 引入）</li></ul><h4 id="2-2-1-Override"><a href="#2-2-1-Override" class="headerlink" title="2.2.1  @Override"></a><strong>2.2.1  @Override</strong></h4><p><strong>@Override用于表明被修饰方法覆写了父类的方法。</strong></p><p>如果试图使用 <code>@Override</code> 标记一个实际上并没有覆写父类的方法时，java 编译器会告警。</p><p><code>@Override</code> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OverrideAnnotationDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;getName&quot;</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;override getName&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  放开下面的注释，编译时会告警</span><br><span class="hljs-comment">         */</span><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">        @Override</span><br><span class="hljs-comment">        public String getName2() &#123;</span><br><span class="hljs-comment">            return &quot;override getName2&quot;;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-Deprecated"><a href="#2-2-2-Deprecated" class="headerlink" title="2.2.2@Deprecated"></a><strong>2.2.2@Deprecated</strong></h4><p><strong><code>@Deprecated</code> 用于标明被修饰的类或类成员、类方法已经废弃、过时，不建议使用。</strong></p><p><code>@Deprecated</code> 有一定的<strong>延续性</strong>：如果我们在代码中通过继承或者覆盖的方式使用了过时的类或类成员，即使子类或子方法没有标记为 <code>@Deprecated</code>，但编译器仍然会告警。</p><blockquote><p> 🔔 注意： <code>@Deprecated</code> 这个注解类型和 javadoc 中的 <code>@deprecated</code> 这个 tag 是有区别的：前者是 java 编译器识别的；而后者是被 javadoc 工具所识别用来生成文档（包含程序成员为什么已经过时、它应当如何被禁止或者替代的描述）。</p></blockquote><h4 id="2-2-3-SuppressWarnnings"><a href="#2-2-3-SuppressWarnnings" class="headerlink" title="2.2.3 @SuppressWarnnings"></a><strong>2.2.3 @SuppressWarnnings</strong></h4><p><strong><code>@SuppressWarnings</code>用于关闭对类、方法、成员编译时产生的特定警告。</strong></p><p><code>@SuppressWarning</code> 不是一个标记注解。它有一个类型为 <code>String[]</code> 的数组成员，这个数组中存储的是要关闭的告警类型。对于 javac 编译器来讲，对 <code>-Xlint</code> 选项有效的警告名也同样对 <code>@SuppressWarings</code> 有效，同时编译器会忽略掉无法识别的警告名。</p><p><code>@SuppressWarning</code> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuppressWarningsAnnotationDemo</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuppressDemo</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">private</span> T value;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">var</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;deprecation&quot;&#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SuppressDemo d = <span class="hljs-keyword">new</span> SuppressDemo();<br>        d.setValue(<span class="hljs-string">&quot;南京&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;地名：&quot;</span> + d.getValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@SuppressWarnings</code> 注解的常见参数值的简单说明：</p><ul><li><code>deprecation</code> - 使用了不赞成使用的类或方法时的警告；</li><li><code>unchecked</code> - 执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型;</li><li><code>fallthrough</code> - 当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;</li><li><code>path</code> - 在类路径、源文件路径等中有不存在的路径时的警告;</li><li><code>serial</code> - 当在可序列化的类上缺少 serialVersionUID 定义时的警告;</li><li><code>finally</code> - 任何 finally 子句不能正常完成时的警告;</li><li><code>all</code> - 所有的警告。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&#123;&quot;uncheck&quot;, &quot;deprecation&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InternalAnnotationDemo</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@SuppressWarnings</span> 标记消除当前类的告警信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;deprecation&quot;&#125;)</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;call method1&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@Deprecated</span> 标记当前方法为废弃方法，不建议使用</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Deprecated</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;call method2&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Deprecated</span> 标记当前类为废弃类，不建议使用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Deprecated</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@Override</span> 标记显示指明当前方法覆写了父类或接口的方法</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        A obj = <span class="hljs-keyword">new</span> B();<br>        obj.method1();<br>        obj.method2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-4-SafeVarargs"><a href="#2-2-4-SafeVarargs" class="headerlink" title="2.2.4 @SafeVarargs"></a><strong>2.2.4 @SafeVarargs</strong></h4><p><code>@SafeVarargs</code> 在 JDK7 中引入。</p><p><strong><code>@SafeVarargs</code>的作用是：告诉编译器，在可变长参数中的泛型是类型安全的。可变长参数是使用数组存储的，而数组和泛型不能很好的混合使用。</strong></p><p>简单的说，数组元素的数据类型在编译和运行时都是确定的，而泛型的数据类型只有在运行时才能确定下来。因此，当把一个泛型存储到数组中时，编译器在编译阶段无法确认数据类型是否匹配，因此会给出警告信息；即如果泛型的真实数据类型无法和参数数组的类型匹配，会导致 <code>ClassCastException</code> 异常。</p><p><code>@SafeVarargs</code> 注解使用范围：</p><ul><li><code>@SafeVarargs</code> 注解可以用于构造方法。</li><li><code>@SafeVarargs</code> 注解可以用于 <code>static</code> 或 <code>final</code> 方法。</li></ul><p><code>@SafeVarargs</code> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SafeVarargsAnnotationDemo</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 此方法实际上并不安全，不使用此注解，编译时会告警</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SafeVarargs</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wrongMethod</span><span class="hljs-params">(List&lt;String&gt;... stringLists)</span> </span>&#123;<br>        Object[] array = stringLists;<br>        List&lt;Integer&gt; tmpList = Arrays.asList(<span class="hljs-number">42</span>);<br>        array[<span class="hljs-number">0</span>] = tmpList; <span class="hljs-comment">// 语法错误，但是编译不告警</span><br>        String s = stringLists[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>); <span class="hljs-comment">// 运行时报 ClassCastException</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;A&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;B&quot;</span>);<br><br>        List&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;2&quot;</span>);<br><br>        wrongMethod(list, list2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码，如果不使用 <code>@SafeVarargs</code> ，编译时会告警</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[WARNING] SafeVarargsAnnotationDemo.java: 某些输入文件使用了未经检查或不安全的操作。<br>[WARNING] SafeVarargsAnnotationDemo.java: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。<br></code></pre></td></tr></table></figure><h4 id="2-2-5-FunctionalInterface"><a href="#2-2-5-FunctionalInterface" class="headerlink" title="2.2.5 @FunctionalInterface"></a><strong>2.2.5 @FunctionalInterface</strong></h4><p><code>@FunctionalInterface</code> 在 JDK8 引入。</p><p><strong><code>@FunctionalInterface</code>用于指示被修饰的接口是函数式接口。</strong></p><p>需要注意的是，如果一个接口符合”函数式接口”定义，不加 <code>@FunctionalInterface</code> 也没关系；但如果编写的不是函数式接口，却使用 <code>@FunctionInterface</code>，那么编译器会报错。</p><p>什么是函数式接口？</p><p><strong>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口</strong>。函数式接口可以被隐式转换为 lambda 表达式。</p><p>函数式接口的特点：</p><ul><li>接口有且只能有个一个抽象方法（抽象方法只有方法定义，没有方法体）。</li><li>不能在接口中覆写 Object 类中的 public 方法（写了编译器也会报错）。</li><li>允许有 default 实现方法。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionalInterfaceAnnotationDemo</span> </span>&#123;<br><br>    <span class="hljs-meta">@FunctionalInterface</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Func1</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">(T message)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@FunctionalInterface</span> 修饰的接口中定义两个抽象方法，编译时会报错</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">/*@FunctionalInterface</span><br><span class="hljs-comment">    public interface Func2&lt;T&gt; &#123;</span><br><span class="hljs-comment">        void printMessage(T message);</span><br><span class="hljs-comment">        void printMessage2(T message);</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Func1 func1 = message -&gt; System.out.println(message);<br>        func1.printMessage(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        func1.printMessage(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-元注解"><a href="#2-3-元注解" class="headerlink" title="2.3 元注解"></a>2.3 元注解</h3><p>Java 语言中目前有 5 种标准注解（前面介绍过），以及 5 种元注解。元注解用于注解其他的注解</p><p><strong>@Target</strong></p><p><strong><code>@Target</code> 指定注解可以修饰的元素类型。</strong></p><p>**<code>@Target</code> **源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Target &#123;<br>    ElementType[] value();<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>ElementType</code> 是一个枚举类型，它定义了被 <code>@Target</code> 修饰的注解可以应用的范围：</p><ul><li><code>ElementType.ANNOTATION_TYPE</code> - 标记的注解可以应用于注解类型。</li><li><code>ElementType.CONSTRUCTOR</code> - 标记的注解可以应用于构造函数。</li><li><code>ElementType.FIELD</code> - 标记的注解可以应用于字段或属性。</li><li><code>ElementType.LOCAL_VARIABLE</code> - 标记的注解可以应用于局部变量。</li><li><code>ElementType.METHOD</code> - 标记的注解可以应用于方法。</li><li><code>ElementType.PACKAGE</code> - 标记的注解可以应用于包声明。</li><li><code>ElementType.PARAMETER</code> - 标记的注解可以应用于方法的参数。</li><li><code>ElementType.TYPE</code> - 标记的注解可以应用于类的任何元素。</li></ul><p><code>@Target</code> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Table &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数据表名称注解，默认值为类名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">tableName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;className&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NoDBColumn &#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>@Retention</strong></p><p><code>@Retention</code><strong>指明了注解的保留级别</strong></p><p><code>@Retention</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Retention &#123;<br>    <span class="hljs-function">RetentionPolicy <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>RetentionPolicy</code> 是一个枚举类型，它定义了被 <code>@Retention</code> 修饰的注解所支持的保留级别：</p><ul><li><code>RetentionPolicy.SOURCE</code> - 标记的注解仅在源文件中有效，编译器会忽略。</li><li><code>RetentionPolicy.CLASS</code> - 标记的注解在 class 文件中有效，JVM 会忽略。</li><li><code>RetentionPolicy.RUNTIME</code> - 标记的注解在运行时有效。</li></ul><p><code>@Retention</code> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Column &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;fieldName&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">setFuncName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;setField&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFuncName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;getField&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">defaultDBValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>@Documented</strong></p><p><code>@Documented</code>表示无论何时使用指定的注解，都应使用 Javadoc（默认情况下，注释不包含在 Javadoc 中）</p><p><code>@Documented</code> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Column &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;fieldName&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">setFuncName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;setField&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFuncName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;getField&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">defaultDBValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>@Interited</strong></p><p><strong><code>@Inherited</code> 表示注解类型可以被继承（默认情况下不是这样）</strong>。</p><p>表示自动继承注解类型。 如果注解类型声明中存在 <code>@Inherited</code> 元注解，则注解所修饰类的所有子类都将会继承此注解。</p><blockquote><p>🔔 注意：<code>@Inherited</code> 注解类型是被标注过的类的子类所继承。类并不从它所实现的接口继承注解，方法并不从它所覆写的方法继承注解。</p><p>此外，当 <code>@Inherited</code> 类型标注的注解的 <code>@Retention</code> 是 <code>RetentionPolicy.RUNTIME</code>，则反射 API 增强了这种继承性。如果我们使用 <code>java.lang.reflect</code> 去查询一个 <code>@Inherited</code> 类型的注解时，反射代码检查将展开工作：检查类和其父类，直到发现指定的注解类型被发现，或者到达类继承结构的顶层。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Greeting &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FontColor</span></span>&#123; BULE,RED,GREEN&#125;;<br>    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">FontColor <span class="hljs-title">fontColor</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> FontColor.GREEN</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>@Repeatable</strong></p><p><strong><code>@Repeatable</code> 表示注解可以重复使用（Java 8新特性）。</strong></p><p>以 Spring <code>@Scheduled</code> 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Schedules &#123;<br>Scheduled[] value();<br>&#125;<br><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Repeatable(Schedules.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Scheduled &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>应用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskRunner</span> </span>&#123;<br><br>    <span class="hljs-meta">@Scheduled(&quot;0 0/15 * * * ?&quot;)</span><br>    <span class="hljs-meta">@Scheduled(&quot;0 0 12 * ?&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">task1</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="3.基本语法"></a>3.基本语法</h2><p>在下面举例中，使用@Test对<code>testExcute</code>进行注解。该注解本身不做任何操作，但是编译器要保证类路径上有<code>@Test</code>注解的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestTable</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Executing ... &quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testExecute</span><span class="hljs-params">()</span> </span>&#123;<br>        execute();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>被注解标注的方法和其他的方法没有任何区别,注解 <code>@Test</code>可以和任何修饰符共同用于方法，诸如 <strong>public</strong>、<strong>static</strong> 或 <strong>void</strong>。从语法的角度上看，注解的使用方式和修饰符的使用方式一致。</p><h3 id="3-1-定义注解"><a href="#3-1-定义注解" class="headerlink" title="3.1 定义注解"></a>3.1 定义注解</h3><p>如下是一个注解的定义。注解的定义看起来很像接口的定义。事实上，它们和其他 Java 接口一样，也会被编译成 class 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;&#125;<br></code></pre></td></tr></table></figure><p>除了 @ 符号之外， <code>@Test</code> 的定义看起来更像一个空接口。注解的定义也需要一些元注解（meta-annoation），比如 <code>@Target</code> 和 <code>@Retention</code>。<code>@Target</code> 定义你的注解可以应用在哪里（例如是方法还是字段）。<code>@Retention</code> 定义了注解在哪里可用，在源代码中(SOURCE)，class 文件(CLASS)中或者是在运行时(RUNTIME)。</p><blockquote><p> 标记注解</p></blockquote><p>不包含任何元素的注解称为标记注解（marker annotation），例如上例中的 <code>@Test</code> 就是标记注解。</p><h3 id="3-2-注解使用"><a href="#3-2-注解使用" class="headerlink" title="3.2 注解使用"></a>3.2 注解使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> UseCase &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">String <span class="hljs-title">description</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;no description&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注意 <strong>id</strong> 和 <strong>description</strong> 与方法定义类似。由于编译器会对 <strong>id</strong> 进行类型检查，因此将跟踪数据库与用例文档和源代码相关联是可靠的方式。<strong>description</strong> 元素拥有一个 <strong>default</strong> 值，如果在注解某个方法时没有给出 <strong>description</strong> 的值。则该注解的处理器会使用此元素的默认值。</p><p>以下例子中，将有三个方法被注解为用例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PasswordUtils</span> </span>&#123;<br><br>    <span class="hljs-meta">@UseCase(id = 2,description = &quot;Passwords must contain at least one numeric&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validatePassword</span><span class="hljs-params">(String password)</span> </span>&#123;<br><br>        <span class="hljs-keyword">return</span> (password.matches(<span class="hljs-string">&quot;\\w*\\d\\w*&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-meta">@UseCase(id = 3)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encryptPassword</span><span class="hljs-params">(String passwd)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StringBuilder(passwd)<br>                .reverse().toString();<br>    &#125;<br><br>    <span class="hljs-meta">@UseCase(id = 4,description = &quot;New passwords can&#x27;t equal previously used ones&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkForNewPassword</span><span class="hljs-params">(List&lt;String&gt; prevPasswords, String passwd)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !prevPasswords.contains(passwd);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注解的元素在使用时表现为 名-值 对的形式，并且需要放置在 <code>@UseCase</code> 声明之后的括号内。在 <code>encryptPassword()</code> 方法的注解中，并没有给出 <strong>description</strong> 的默认值，所以在 <strong>@interface UseCase</strong> 的注解处理器分析处理这个类的时候会使用该元素的默认值。</p><h3 id="3-3-注解处理器"><a href="#3-3-注解处理器" class="headerlink" title="3.3 注解处理器"></a>3.3 注解处理器</h3><blockquote><p>如果没有用于读取注解的工具，那么注解不会比注释更有用。使用注解中一个很重要的部分就是，创建与使用注解处理器。Java 拓展了反射机制的 API 用于帮助你创造这类工具。同时他还提供了 javac 编译器钩子在编译时使用注解。</p></blockquote><p>下面是一个非常简单的注解处理器，我们用它来读取被注解的 <strong>PasswordUtils</strong> 类，并且使用反射机制来寻找 <strong>@UseCase</strong> 标记。给定一组 <strong>id</strong> 值，然后列出在 <strong>PasswordUtils</strong> 中找到的用例，以及缺失的用例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UseCaseTracker</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trackUseCases</span><span class="hljs-params">(List&lt;Integer&gt; useCases,Class&lt;?&gt; cl)</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span> (Method method : cl.getDeclaredMethods()) &#123;<br>            UseCase useCase = method.getAnnotation(UseCase.class);<br><br>            <span class="hljs-keyword">if</span> (useCase != <span class="hljs-keyword">null</span> ) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Found Use Case&quot;</span> + useCase.id() + <span class="hljs-string">&quot;\n&quot;</span> + useCase.description());<br>                useCases.remove(Integer.valueOf(useCase.id()));<br>            &#125;<br>        &#125;<br><br>        useCases.forEach(e -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Missing use case &quot;</span> + e);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; useCases = IntStream.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>).boxed().collect(Collectors.toList());<br><br>        trackUseCases(useCases,PasswordUtils.class);<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>这个程序用了两个反射的方法：<code>getDeclaredMethods()</code> 和 <code>getAnnotation()</code>，它们都属于 <strong>AnnotatedElement</strong> 接口（<strong>Class</strong>，<strong>Method</strong> 与 <strong>Field</strong> 类都实现了该接口）。<code>getAnnotation()</code> 方法返回指定类型的注解对象，在本例中就是 “<strong>UseCase</strong>”。如果被注解的方法上没有该类型的注解，返回值就为 <strong>null</strong>。我们通过调用 <code>id()</code> 和 <code>description()</code> 方法来提取元素值。注意 <code>encryptPassword()</code> 方法在注解的时候没有指定 <strong>description</strong> 的值，因此处理器在处理它对应的注解时，通过 <code>description()</code> 取得的是默认值 “no description”。</p><h3 id="3-4-注解元素"><a href="#3-4-注解元素" class="headerlink" title="3.4 注解元素"></a>3.4 注解元素</h3><p>在 <strong>UseCase.java</strong> 中定义的 <strong>@UseCase</strong> 的标签包含 int 元素 <strong>id</strong> 和 String 元素 <strong>description</strong>。注解元素可用的类型如下所示：</p><ul><li>所有基本类型（int、float、boolean 等）</li><li>String</li><li>Class</li><li>enum</li><li>Annotation</li><li>以上类型的数组</li></ul><p>如果你使用了其他类型，编译器就会报错。注意，也不允许使用任何包装类型，但是由于自动装箱的存在，这不算是什么限制。注解也可以作为元素的类型。稍后你会看到，注解嵌套是一个非常有用的技巧。</p><h3 id="3-5-默认值限制"><a href="#3-5-默认值限制" class="headerlink" title="3.5 默认值限制"></a>3.5 默认值限制</h3><p>编译器对于元素的默认值有些过于挑剔。首先，元素不能有不确定的值。也就是说，元素要么有默认值，要么就在使用注解时提供元素的值。</p><p>这里有另外一个限制：任何非基本类型的元素， 无论是在源代码声明时还是在注解接口中定义默认值时，都不能使用 null 作为其值。这个限制使得处理器很难表现一个元素的存在或者缺失的状态，因为在每个注解的声明中，所有的元素都存在，并且具有相应的值。为了绕开这个约束，可以自定义一些特殊的值，比如空字符串或者负数用于表达某个元素不存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// annotations/SimulatingNull.java</span><br><span class="hljs-keyword">import</span> java.lang.annotation.*;<br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SimulatingNull &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -1</span>;<br>    <span class="hljs-function">String <span class="hljs-title">description</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个在定义注解的习惯用法。</p><h2 id="4-注解使用示例"><a href="#4-注解使用示例" class="headerlink" title="4. 注解使用示例"></a>4. 注解使用示例</h2><p>知道以上语法及基本使用后，下面引用(《Tinking in Java》)例子来示例利用运行时注解来组装数据库SQL的构建语句的过程</p><blockquote><p>表注解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><span class="hljs-comment">//只能应用于类上</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-comment">//保存到运行时</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> DBTable &#123;<br>    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注解String类型的字段</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SQLString &#123;<br><br>    <span class="hljs-comment">//对应数据库表的列名</span><br>    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    <span class="hljs-comment">//列类型分配的长度，如varchar(30)的30</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;<br><br>    <span class="hljs-function">Constraints <span class="hljs-title">constraint</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> @Constraints</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注解SQLInteger类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SQLInteger &#123;<br><br>    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    <span class="hljs-function">Constraints <span class="hljs-title">constraints</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> @Constraints</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>约束注解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><span class="hljs-comment">//只能应用在字段上</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Constraints &#123;<br>    <span class="hljs-comment">//判断是否作为主键约束</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">primaryKey</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br>    <span class="hljs-comment">//判断是否允许为null</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">allowNull</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br>    <span class="hljs-comment">//判断是否唯一</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">unique</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>数据库表Member对应实例类bean</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DBTable(name = &quot;MEMBER&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Member</span> </span>&#123;<br>    <span class="hljs-meta">@SQlString(30)</span><br>    String firstName;<br><br>    <span class="hljs-meta">@SQlString(50)</span><br>    String lastName;<br><br>    <span class="hljs-meta">@SQLInteger</span><br>    Integer age;<br><br>    <span class="hljs-meta">@SQlString(value = 30,constraints = @Constraints(primaryKey = true))</span><br>    String reference;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> memberCount;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFirstName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> firstName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLastName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> lastName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getReference</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> reference;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> reference; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述定义4个注解，分别是@DBTable(用于类上)、@Constraints(用于字段上)、 @SQLString(用于字段上)、@SQLString(用于字段上)并在Member类中使用这些注解，这些注解的作用的是用于帮助注解处理器生成创建数据库表MEMBER的构建语句，在这里有点需要注意的是，我们使用了嵌套注解@Constraints，该注解主要用于判断字段是否为null或者字段是否唯一。必须清楚认识到上述提供的注解生命周期必须为@Retention(RetentionPolicy.RUNTIME)，即运行时，这样才可以使用反射机制获取其信息。有了上述注解和使用，剩余的就是编写上述的注解处理器了，前面我们聊了很多注解，其处理器要么是Java自身已提供、要么是框架已提供的，我们自己都没有涉及到注解处理器的编写，但上述定义处理SQL的注解，其处理器必须由我们自己编写了，如下:</p><h3 id="实现处理器"><a href="#实现处理器" class="headerlink" title="实现处理器"></a>实现处理器</h3><p>处理器将读取一个类文件，检查上面的数据库注解，并生成用于创建数据库的 SQL 命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TableCreator</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createTableSql</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        <span class="hljs-keyword">if</span> (args.length &lt; <span class="hljs-number">0</span>) &#123;<br>            System.out.println(<br>                    <span class="hljs-string">&quot;arguments: annotated classes&quot;</span>);<br>            System.exit(<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (String className : args) &#123;<br>            Class&lt;?&gt; cl = Class.forName(className);<br><br>            DBTable dbTable = cl.getAnnotation(DBTable.class);<br><br>            <span class="hljs-keyword">if</span> (dbTable == <span class="hljs-keyword">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;No DBTable annotations in class &quot;</span> + className);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            String tableName = dbTable.name();<br><br>            <span class="hljs-keyword">if</span> (tableName.length() &lt; <span class="hljs-number">1</span>)<br>                tableName = cl.getName().toUpperCase();<br><br>            List&lt;String&gt; columnDefs = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>            <span class="hljs-keyword">for</span> (Field field : cl.getDeclaredFields()) &#123;<br>                String columnName = <span class="hljs-keyword">null</span>;<br>                Annotation[] annotations = field.getDeclaredAnnotations();<br>                <span class="hljs-keyword">if</span> (annotations.length &lt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (annotations[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> SQLInteger) &#123;<br>                    SQLInteger sqlInteger = (SQLInteger) annotations[<span class="hljs-number">0</span>];<br><br>                    <span class="hljs-keyword">if</span> (sqlInteger.name().length() &lt; <span class="hljs-number">1</span> ) &#123;<br>                        columnName = field.getName().toUpperCase();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        columnName = sqlInteger.name();<br>                    &#125;<br><br>                    columnDefs.add(columnName + <span class="hljs-string">&quot; INT &quot;</span> + getConstraints(sqlInteger.constraints()));<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (annotations[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> SQlString) &#123;<br>                    SQlString sQlString = (SQlString) annotations[<span class="hljs-number">0</span>];<br>                    <span class="hljs-keyword">if</span> (sQlString.name().length() &lt; <span class="hljs-number">1</span>) &#123;<br>                        columnName = field.getName().toUpperCase();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        columnName = sQlString.name();<br>                    &#125;<br><br>                    columnDefs.add(columnName + <span class="hljs-string">&quot; VARCHAR(&quot;</span> + sQlString.value() + <span class="hljs-string">&quot;)&quot;</span>  + getConstraints(sQlString.constraints()));<br>                &#125;<br><br>            &#125;<br><br>            StringBuilder createCommand = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;CREATE TABLE &quot;</span> + tableName + <span class="hljs-string">&quot;(&quot;</span>);<br><br>            <span class="hljs-keyword">for</span> (String columnDef : columnDefs) &#123;<br>                createCommand.append(<span class="hljs-string">&quot;\n&quot;</span> + columnDef + <span class="hljs-string">&quot;,&quot;</span>);<br><br>            &#125;<br><br>            String tableCreate = createCommand.substring(<br>                    <span class="hljs-number">0</span>, createCommand.length() - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;);&quot;</span>;<br>            System.out.println(<span class="hljs-string">&quot;Table Creation SQL for &quot;</span> +<br>                    className + <span class="hljs-string">&quot; is:\n&quot;</span> + tableCreate);<br><br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getConstraints</span><span class="hljs-params">(Constraints con)</span> </span>&#123;<br>        String constraints = <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-keyword">if</span> (!con.allowNull())<br>            constraints += <span class="hljs-string">&quot; NOT NULL&quot;</span>;<br>        <span class="hljs-keyword">if</span> (con.primaryKey())<br>            constraints += <span class="hljs-string">&quot; PRIMARY KEY&quot;</span>;<br><br>        <span class="hljs-keyword">if</span> (con.unique())<br>            constraints += <span class="hljs-string">&quot; UNIQUE&quot;</span>;<br>        <span class="hljs-keyword">return</span> constraints;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String[] arg = &#123;<span class="hljs-string">&quot;com.example.basic.annotation.example.Member&quot;</span>&#125;;<br>        createTableSql(arg);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最终输出结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">Table Creation SQL for com.example.basic.annotation.example.Member is:<br>CREATE TABLE MEMBER(<br>FIRSTNAME VARCHAR(30),<br>LASTNAME VARCHAR(50),<br>AGE INT ,<br>REFERENCE VARCHAR(30) PRIMARY KEY);<br></code></pre></td></tr></table></figure><p>通过处理器可以看出是基于反射来进行处理，我们通过传递Member的全路径后通过Class.forName()方法获取到Member的class对象，然后利用Class对象中的方法获取所有成员字段Field，最后利用field.getDeclaredAnnotations()遍历每个Field上的注解再通过注解的类型判断来构建建表的SQL语句。这便是利用注解结合反射来构建SQL语句的简单的处理器模型。</p><p>参考:</p><p>《Thinking in Java》</p><p><a href="https://dunwu.github.io/javacore/basics/java-annotation.html#_4-1-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9A%E4%B9%89">https://dunwu.github.io/javacore/basics/java-annotation.html#_4-1-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9A%E4%B9%89</a></p><p><a href="https://blog.csdn.net/javazejian/article/details/71860633">https://blog.csdn.net/javazejian/article/details/71860633</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础-泛型</title>
    <link href="/2021/10/24/Java%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B/"/>
    <url>/2021/10/24/Java%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。<a href="http://baike.baidu.com/view/229611.htm">Java语言</a>引入泛型的好处是安全简单。</p><p>在Java SE 1.5之前，没有泛型的<a href="http://baike.baidu.com/view/780206.htm">情况</a>的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的<a href="http://baike.baidu.com/view/2886403.htm">强制类型转换</a>，而这种转换是要求开发者对<a href="http://baike.baidu.com/view/2245196.htm">实际参数</a>类型可以预知的情况下进行的。对于强制类型转换错误的情况，<a href="http://baike.baidu.com/view/487018.htm">编译器</a>可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。<br> 泛型的好处是在编译的时候检查<a href="http://baike.baidu.com/view/1965709.htm">类型安全</a>，并且所有的<a href="http://baike.baidu.com/view/965170.htm">强制转换</a>都是自动和<a href="http://baike.baidu.com/view/2852863.htm">隐式</a>的，以提高代码的重用率。</p></blockquote><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p><strong>Box类定义为一个泛型类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T object;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T object)</span> </span>&#123; <span class="hljs-keyword">this</span>.object = object; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> object; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>创建一个Box对象，不带泛型参数，发现获取对象的时候需要强制转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Box box2 = <span class="hljs-keyword">new</span> Box();<br>box2.set(<span class="hljs-keyword">new</span> Apple());<br>Apple apple = (Apple) box2.get();<br></code></pre></td></tr></table></figure><p><strong>创建一个Box对象，带泛型参数，获取对象的时候就不需要强制转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Box&lt;Apple&gt; box = <span class="hljs-keyword">new</span> Box&lt;Apple&gt;();<br>box.set(<span class="hljs-keyword">new</span> Apple());<br>Apple apple = box.get();<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>泛型省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上</strong></p><blockquote><p>泛型的核心概念是<strong>参数化类型</strong>，使用参数指定方法类型，而非硬编码。泛型的出现带给我们很多好处，其中最重要的莫过于对集合类的改进，避免了任意类型都可以丢到同一个集合里的不可靠问题。</p></blockquote><h3 id="泛型使用简介"><a href="#泛型使用简介" class="headerlink" title="泛型使用简介"></a>泛型使用简介</h3><p>泛型一般有三种使用方式：泛型类、泛型接口和泛型方法。</p><p><strong>泛型类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T member;<br>&#125;<br>...<br><span class="hljs-comment">// 初始化时指定泛型类型</span><br>Test&lt;String&gt; instance = <span class="hljs-keyword">new</span> Test&lt;String&gt;();<br></code></pre></td></tr></table></figure><p><strong>泛型接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T param)</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 实现类指定泛型类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TestInterface</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String param)</span> </span>&#123;...&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>泛型方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在方法前添加&lt;T&gt;,泛型类型可用于返回值也可用于参数</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">function</span><span class="hljs-params">(T param)</span></span>;<br>...<br>function(<span class="hljs-string">&quot;123&quot;</span>); <span class="hljs-comment">// 编译器自动识别T为String</span><br></code></pre></td></tr></table></figure><h3 id="泛型通配符T，E，K，V区别"><a href="#泛型通配符T，E，K，V区别" class="headerlink" title="泛型通配符T，E，K，V区别"></a>泛型通配符T，E，K，V区别</h3><p>T,E,K,V都属于java泛型的通配符,刚开始我看到这么多通配符，一下晕了，这几个其实<strong>没什么区别</strong>，只不过是一个约定好的代码，也就是说</p><blockquote><p><strong>使用大写字母A,B,C,D……X,Y,Z定义的，就都是泛型，把T换成A也一样，这里T只是名字上的意义而已</strong></p><ul><li><strong>？</strong> 表示不确定的java类型</li><li><strong>T (type)</strong> 表示具体的一个java类型</li><li><strong>K V (key value)</strong> 分别代表java键值中的Key Value</li><li><strong>E (element)</strong> 代表Element</li></ul></blockquote><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <br>  <span class="hljs-keyword">public</span> List&lt;T&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;T&gt;();   <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test&lt;String&gt; test = <span class="hljs-keyword">new</span> Test&lt;String&gt;();<br>        test.list.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>        System.out.println(test.list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">A</span>&gt; </span>&#123;    <br>  <span class="hljs-keyword">public</span> List&lt;A&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;A&gt;();   <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test&lt;String&gt; test = <span class="hljs-keyword">new</span> Test&lt;String&gt;();<br>        test.list.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>        System.out.println(test.list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将T换成了A，在执行效果上是没有任何区别的，只不过我们约定好了T代表type，所以还是<strong>按照约定规范来比较好</strong>，增加了代码的可读性。</p><p>如果要定义<strong>多个</strong>泛型参数，比如说两个泛型参数</p><p>很典型的一个例子是Map的key,value泛型，我们也可以定义一个这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Mymap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MymapImpl</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Mymap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> K key;<br>    <span class="hljs-keyword">private</span> V value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MymapImpl</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.key = key;<br>    <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span>   </span>&#123; <span class="hljs-keyword">return</span> key; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就可以传入任意类型，创建实例了，不用转化类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Mymap&lt;String, Integer&gt; mp1= <span class="hljs-keyword">new</span> MymapImpl&lt;String, Integer&gt;(<span class="hljs-string">&quot;Even&quot;</span>, <span class="hljs-number">8</span>);<br>Mymap&lt;String, String&gt;  mp2= <span class="hljs-keyword">new</span> MymapImpl&lt;String, String&gt;(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>Mymap&lt;Integer, Integer&gt; mp3= <span class="hljs-keyword">new</span> MymapImpl&lt;Integer, Integer&gt;(<span class="hljs-number">888</span>, <span class="hljs-number">888</span>);<br></code></pre></td></tr></table></figure><p>如果要定义<strong>超过两个，三个或三个以上</strong>的泛型参数可以使用<strong>T1, T2, …, Tn</strong>，像这</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T1</span>,<span class="hljs-title">T2</span>,<span class="hljs-title">T3</span>&gt; </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T1 t1,T2 t2,T3 t3)</span></span>&#123;<br>        System.out.println(t1.getClass());<br>        System.out.println(t2.getClass());<br>        System.out.println(t3.getClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="List-lt-T-gt-，List-lt-Object-gt-，List-lt-gt-区别"><a href="#List-lt-T-gt-，List-lt-Object-gt-，List-lt-gt-区别" class="headerlink" title="List&lt;T&gt;，List&lt; Object &gt;，List&lt;?&gt;区别"></a><code>List&lt;T&gt;</code>，List&lt; Object &gt;，List&lt;?&gt;区别</h3><blockquote><p><strong><code>ArrayList&lt;T&gt;</code> al=new ArrayList&lt; T&gt;();</strong> 指定集合元素只能是T类型</p><p><strong>ArrayList&lt; ?&gt; al=new ArrayList&lt; ?&gt;();</strong> 集合元素可以是任意类型，这种没有意义，一般是方法中，只是为了说明用法</p></blockquote><p><strong>ArrayList&lt;? extends E&gt; al=new ArrayList&lt;? extends E&gt;();</strong></p><p>泛型的限定：</p><p><strong>? extends E</strong>:接收E类型或者E的子类型。</p><p><strong>? super E</strong>:接收E类型或者E的父类型。</p><ul><li>Object和T不同点在于，Object是一个实打实的类,并没有泛指谁，而T可以泛指Object，比方<strong>public void printList(List&lt; T&gt; list){}<strong>方法中可以传入</strong>List&lt; Object&gt; list</strong>类型参数，也可以传入<strong>List&lt; String&gt; list</strong>类型参数，但是<strong>public void printList(List&lt; Object&gt; list){}<strong>就只可以传入</strong>List&lt; Object&gt; list</strong>类型参数，因为Object类型并没有泛指谁，是一个确定的类型。</li><li>?和T区别是:?是一个不确定类，？和T都表示不确定的类型 ，但如果是T的话，函数里面可以对T进行操作，比方 T car = getCar()，而不能用？ car = getCar()。</li></ul><p>以下举例比较三种情况:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDifferenceBetweenObjectAndT</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printList1</span><span class="hljs-params">(List&lt;Object&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Object elem : list)<br>            System.out.println(elem + <span class="hljs-string">&quot; &quot;</span>);<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printList2</span><span class="hljs-params">(List&lt;T&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (T elem : list)<br>            System.out.println(elem + <span class="hljs-string">&quot; &quot;</span>);<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">printList3</span><span class="hljs-params">(List&lt;?&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;list.size();i++)<br>            System.out.println(list.get(i) + <span class="hljs-string">&quot; &quot;</span>);<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; test1 = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        List&lt;String&gt;  test2 = Arrays.asList(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>);<br>        List&lt;Object&gt; test3 = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-number">1.23</span>);<br>        List&lt;Fruit&gt; test4 = Arrays.asList(<span class="hljs-keyword">new</span> Apple(), <span class="hljs-keyword">new</span> Banana());<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 下面这句会编译报错，因为参数不能转化成功</span><br><span class="hljs-comment">        * */</span><br>        printList1(test4);<br>        <span class="hljs-comment">/**/</span><br><span class="hljs-comment">        printList1(test3);</span><br><span class="hljs-comment">        printList1(test3);</span><br><span class="hljs-comment">        printList2(test1);</span><br><span class="hljs-comment">        printList2(test2);</span><br><span class="hljs-comment">        printList2(test3);</span><br><span class="hljs-comment">        printList3(test1);</span><br><span class="hljs-comment">        printList3(test2);</span><br><span class="hljs-comment">        printList3(test3);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="T，Class-lt-T-gt-，Class-lt-gt-区别"><a href="#T，Class-lt-T-gt-，Class-lt-gt-区别" class="headerlink" title="T，Class&lt;T&gt;，Class&lt;?&gt;区别"></a>T，<code>Class&lt;T&gt;</code>，Class&lt;?&gt;区别</h3><p>T是一种具体的类，例如String,List,Map……等等，这些都是属于具体的类</p><p>Class是什么呢，Class也是一个类，但Class是存放上面String,List,Map……类信息的一个类</p><p>如何获取到Class类呢，有三种方式：</p><p><strong>1.调用Object类的getClass()方法来得到Class对象，这也是最常见的产生Class对象的方法。</strong></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List list = <span class="hljs-keyword">null</span>;<br>Class clazz = list.getClass();<br></code></pre></td></tr></table></figure><p><strong>2.使用Class类的中静态forName()方法获得与字符串对应的Class对象。</strong></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clazz = Class.forName(<span class="hljs-string">&quot;xx.xx.xx.xx.People&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>3.获取Class类型对象的第三个方法非常简单。如果T是一个Java类型，那么T.class就代表了匹配的类对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clazz = List.class;<br></code></pre></td></tr></table></figure><p><strong>Class类是创建出来了，但是Class&lt; T&gt;和Class&lt;?&gt;适用于什么时候</strong></p><p>使用Class&lt; T&gt;和Class&lt; ?&gt;多发生在反射场景下，先看看如果我们不使用泛型，反射创建一个类是什么样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">People people = (People) Class.forName(<span class="hljs-string">&quot;xx.xx.People&quot;</span>).newInstance();<br></code></pre></td></tr></table></figure><p>看到了么，需要强转，如果反射的类型不是People类，就会报<strong>java.lang.ClassCastException</strong>错误。</p><p>使用Class<T>泛型后，不用强转了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">createInstance</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;<br>        <span class="hljs-keyword">return</span> clazz.newInstance();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException  </span>&#123;<br>            Fruit fruit= createInstance(Fruit .class);<br>            People people= createInstance(People.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那Class&lt; T&gt;和Class&lt; ?&gt;有什么区别呢？</p><p><strong>Class&lt; T&gt;在实例化的时候，T要替换成具体类</strong></p><p><strong>Class&lt;?&gt;它是个通配泛型，?可以代表任何类型，主要用于声明时的限制情况</strong></p><p>例如可以声明一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;?&gt; clazz;<br></code></pre></td></tr></table></figure><p>但是你不能声明一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;T&gt; clazz;<br></code></pre></td></tr></table></figure><p>因为T需要指定类型<br>所以当，不知道定声明什么类型的Class的时候可以定义一个Class&lt; ?&gt;,Class&lt;?&gt;可以用于参数类型定义，方法返回值定义等。</p><h3 id="深入Java泛型"><a href="#深入Java泛型" class="headerlink" title="深入Java泛型"></a>深入Java泛型</h3><h4 id="Java的伪泛型和类型擦除"><a href="#Java的伪泛型和类型擦除" class="headerlink" title="Java的伪泛型和类型擦除"></a>Java的伪泛型和类型擦除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; strList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;Integer&gt; intList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>System.out.println(strList.getClass() == intList.getClass()); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>对如上部分代码，相信多数人接触到泛型的第一时刻都认为这是两个不同的类型，反编译其字节码获得代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList var1 = <span class="hljs-keyword">new</span> ArrayList();<br>ArrayList var2 = <span class="hljs-keyword">new</span> ArrayList();<br>System.out.println(var1.getClass() == var2.getClass());<br></code></pre></td></tr></table></figure><p>我们发现两个列表都变成ArrayList类型，如果大家对Jdk1.5之前的版本还有印象就可以看出，这一段反编译的代码就是Java集合最初的使用形式。因此，Java泛型的是通过<strong>编译期将泛型的实际类型擦除为原始类型(通常为Object)实现的伪泛型</strong>。</p><p>所谓伪泛型，是相对C++的”真泛型”(异构扩展，可见参考第三条)，在Java中，由于编译后擦除了具体类型，在<strong>泛型代码内部</strong>，无法获得任何有关泛型参数类型的信息，在运行期代码所持有的也只是擦除后的原始类型，也就意味着在运行期可以通过反射的方式为泛型类传入任何原始类型的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; ints = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        GenericTest test = <span class="hljs-keyword">new</span> GenericTest();<br>        List&lt;GenericTest&gt; list = (List&lt;GenericTest&gt;) GenericTest.class.getDeclaredField(<span class="hljs-string">&quot;ints&quot;</span>).get(test);<br>        list.add(<span class="hljs-keyword">new</span> GenericTest());<br>        System.out.println(test.ints.get(<span class="hljs-number">0</span>));   <span class="hljs-comment">// 打印GenericTest变量地址</span><br>        <span class="hljs-keyword">int</span> number = test.ints.get(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 类型转换抛出异常</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 泛型代码内部是指泛型类或泛型方法内部。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">getTClass</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">//无法获取 &#125;</span><br>&#125;<br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Class <span class="hljs-title">getParamClass</span><span class="hljs-params">(T param)</span> </span>&#123; <span class="hljs-comment">//无法获取 &#125;</span><br><br></code></pre></td></tr></table></figure><p>在泛型外部可以获取已指定的泛型参数类型，通过<code>javap -v</code>查看<code>Constant Pool</code>，可看到具体类型记录在<code>Signature</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span><br><span class="hljs-class">    <span class="hljs-title">private</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">String</span>&gt; <span class="hljs-title">list</span> </span>= <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-comment">//可以获取list的具体类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>事实上在Java推出泛型时，C++的模板泛型已经相当成熟，设计者也并非没有能力实现包含具体类型的泛型，使用类型擦除最重要的原因还是为了保持<strong>兼容性</strong>。假设<code>ArrayList&lt;String&gt;</code>和<code>ArrayList</code>编译后是不同的class，那么为了兼容旧代码正常运行，必须平行的添加一套泛型集合并在后续版本中同时维护，而集合类作为大量使用的基础工具类，开发者不得不为此承担大量代码切换的风险(参考<code>Vector</code>和<code>HashTable</code>的带来的遗留问题)，因此相较于兼容性的取舍，采用类型擦除实现泛型算是折中方案。</p><h3 id="Java泛型的上下界"><a href="#Java泛型的上下界" class="headerlink" title="Java泛型的上下界"></a>Java泛型的上下界</h3><p>前面说到泛型会被擦除为原始类型，一般是<code>Object</code>。如果泛型声明为<code>&lt;? extends Number&gt;</code>，就会被擦除为<code>Number</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Number&gt; numbers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;Integer&gt; integers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>numbers = integers;<span class="hljs-comment">// compile error</span><br></code></pre></td></tr></table></figure><p>考虑以上代码，<code>numbers</code>可以增加<code>Integer</code>类型的元素，直觉上<code>integers</code>应该也可以赋值给<code>numbers</code>。由于类型擦除，Java在编译期限定了只有相同类型的泛型实例才可以互相赋值，但这样就违背了Java的多态，为了解决泛型转换的问题，Java引入了上下限<code>&lt;? extends A&gt;</code>和<code>&lt;? super B&gt;</code>两种机制。</p><p><strong>1.上界</strong></p><p>如果泛型声明为<code>&lt;? extends A&gt;</code>，即声明该泛型的上界也即擦除后的原始类型为<code>A</code>，同时该泛型类的实例可以引用<code>A</code>子类的泛型实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 上界保证取出来的元素一定是Number，但无法约束放入的类型</span><br>List&lt;Integer&gt; integers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;Float&gt; floats = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <br>List&lt;? extends Number&gt; numbers = integers;<span class="hljs-comment">// numbers = floats; 也可以</span><br>numbers.get(<span class="hljs-number">0</span>);<span class="hljs-comment">// ok，总能保证取出的一定是Number</span><br>numbers.put(<span class="hljs-number">1</span>);<span class="hljs-comment">// compile error，无法保证放入的是否符合约束</span><br></code></pre></td></tr></table></figure><p><strong>2.下界</strong></p><p>如果泛型声明为<code>&lt;? super B&gt;</code>，即声明该泛型的下界为<code>B</code>，原始类型仍为<code>Object</code>，同时该泛型类的实力可以引用<code>B</code>父类的泛型实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设三个继承类 Child -&gt; Father -&gt; GrandFather</span><br><span class="hljs-comment">// 下界保证写入的元素一定是Child，但无法确定取出的类型</span><br>List&lt;Father&gt; fathers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;GrandFather&gt; grandFathers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;? <span class="hljs-keyword">super</span> Child&gt; childs = fathers;<span class="hljs-comment">// childs = grandFathers; 也可以</span><br>numbers.put(<span class="hljs-keyword">new</span> Child());<span class="hljs-comment">//ok，总能保证实际容器可接受Child</span><br>Child ele = (Child) numbers.get(<span class="hljs-number">0</span>);<span class="hljs-comment">// runtime error，无法确定得到的具体类型</span><br></code></pre></td></tr></table></figure><p>在Java中，根据里式替换原则，向上转型是默认合法的，向下转型则需要强制转换，如不能转换则报错。在<code>extends</code>的<code>get</code>和<code>super</code>的<code>put</code>场景中，一定可以保证读取/放入的元素是可以向上转型的，而在<code>extends</code>的<code>put</code>和<code>super</code>的<code>get</code>中，则无法确认可转的类型，因此<code>extends</code>只能读取，<code>super</code>只能写入。</p><blockquote><p>当然如果使用super时，取出的对象以Object存放，也没有问题，因为super擦除后的原始类型为Object。</p></blockquote><p>参考《Effective Java》中给出的<code>PECS</code>使用建议。</p><blockquote><p>为了获得最大限度的灵活性，要在表示生产者或消费者的输入参数上使用通配符类型。</p><p>如果参数化类型表示一个T生产者，就使用&lt;? extends T&gt;。 producer-extends</p><p>如果参数化类型表示一个T消费者，就使用&lt;? super T&gt;。consumer-super</p><p>如果某个输入参数即是生产者又是消费者，那么通配符类型对你就没什么好处了。</p></blockquote><p><strong>个人认为</strong>对这段话的正确理解是以泛型为第一视角切入，即当<strong>泛型类型本身作为生产者提供功能</strong>(被读取)时使用<code>extends</code>，反之(被写入)使用<code>super</code>。而非常规意义上生产者要写入的容器采用<code>extends</code>，消费者读取的容器使用<code>super</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// producer，此时返回值作为生产后的结果提供给消费者</span><br>List&lt;? extends A&gt; writeBuffer(...);<br><span class="hljs-comment">// consumer，此时返回值作为消费后的结果提供给生产者</span><br>List&lt;? <span class="hljs-keyword">super</span> B&gt; readBuffer(...);<br></code></pre></td></tr></table></figure><h3 id="Java泛型的多态"><a href="#Java泛型的多态" class="headerlink" title="Java泛型的多态"></a>Java泛型的多态</h3><p>泛型类也可以被继承，泛型类主要有两种继承方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123; <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T param)</span></span>&#123;<br>    <br>  &#125; <br>&#125;<br><span class="hljs-comment">// 泛型继承，Child依然是泛型类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T param)</span></span>&#123;&#125; <br>&#125;<br><span class="hljs-comment">// 指定泛型类型，StringChild为具体类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringChild</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String param)</span></span>&#123;&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>我们知道<code>@Override</code>是保持签名不变且重写父类方法，查看<code>Father</code>类字节码，其中test方法被擦除为<code>void test(Object param)</code>；在<code>StringChild</code>中，方法签名为<code>void test(String param)</code>。到此读者可能意识到，这根本不是重写而是重载(<code>Overload</code>)。</p><p>查看<code>StringChild</code>的字节码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>#<span class="hljs-number">3</span> = Methodref<br>...<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(java.lang.String)</span></span>;<br>    ...<br>    invokespecial #<span class="hljs-number">3</span> <span class="hljs-comment">// Method StringChild.test:(Ljava/lang.Object;) V</span><br>    ...<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(java.lang.Object)</span></span>;<br></code></pre></td></tr></table></figure><p>可以看到其中实际包含了两个方法，一个参数是<code>String</code>一个是<code>Object</code>，后者才是对父类方法的重写，前者通过invoke转到对后者的调用。这个方法是JVM在编译时自动添加的，也叫做<strong>桥方法</strong>。同时还有一点需要提及，示例中的代码是以泛型参数作为入参，作为返回类型的话会产生<code>Object test()</code>和<code>String test()</code>两个方法，这两个方法在常规的编码中是无法编译通过的，但JVM为泛型多态的实现允许了这个不合规的存在。</p><h3 id="Java泛型使用的局限"><a href="#Java泛型使用的局限" class="headerlink" title="Java泛型使用的局限"></a>Java泛型使用的局限</h3><ul><li>基本类型无法擦除为原始类型<code>Object</code>，因此范型不支持基本类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;<span class="hljs-keyword">int</span>&gt; intList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <span class="hljs-comment">// 无法编译</span><br></code></pre></td></tr></table></figure><ul><li>由于类型擦除，泛型代码内部在运行期无法获得具体类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">T instance = <span class="hljs-keyword">new</span> T();   <span class="hljs-comment">// 不能直接使用泛型初始化</span><br><span class="hljs-keyword">if</span> (t instanceOf T);    <span class="hljs-comment">// 不能判断泛型类型</span><br>T[] array = <span class="hljs-keyword">new</span> T[]&#123;&#125;;  <span class="hljs-comment">// 不能创建泛型数组</span><br></code></pre></td></tr></table></figure><ul><li>由于静态资源加载先于类型实例化，不能在静态代码块引用泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Error</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T t;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> t;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>异常类型的派生类不能添加泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设继承实现一个泛型异常</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeException</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span>...</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">try</span> </span>&#123;<br>    ...<br>&#125; <span class="hljs-keyword">catch</span>(SomeException&lt;Integer&gt; | SomeException&lt;String&gt; ex) &#123;<br>    <span class="hljs-comment">//由于类型擦除，无法捕获多个泛型异常</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>参考:</p><hr><p>程序鱼:<a href="https://www.jianshu.com/p/95f349258afb">https://www.jianshu.com/p/95f349258afb</a><br>拉夫德鲁:<a href="https://juejin.cn/post/6996285441943011341">https://juejin.cn/post/6996285441943011341</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础概念</title>
    <link href="/2021/10/24/Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2021/10/24/Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h2><h3 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h3><ol><li>简单易学；</li><li>面向对象（封装，继承，多态）；</li><li>平台无关性(Java虚拟机实现平台无关性)；</li><li>支持多线程；</li><li>可靠性；</li><li>安全性；</li><li>支持网络编程并且很方便(Java语言诞生本身就是为简化网络编程设计的，因此Java语言不仅支持网络编程而且很方便)；</li><li>编译与解释并存；</li></ol><h3 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>Java虚拟机(JVM)是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现(Windows，Linux，Macos)，目的是使用相同的字节码,他们都会给出相同的结果。</p><h4 id="什么是字节码？采用字节码的"><a href="#什么是字节码？采用字节码的" class="headerlink" title="什么是字节码？采用字节码的"></a>什么是字节码？采用字节码的</h4><blockquote><p>在Java中，JVM可以理解的代码就叫做 <code>字节码</code> (即扩展名为<code>.class</code>的文件)，它不面向任何特定的处理器，只面向虚拟机。Java语言通过字节码的方式，在一定程度上解决了传统解型语言执行效率低的问题，同时又保留解释型语言可移值的特点。所以Java程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无需重新编译便可在多种不同操作系统的计算机上运行。</p></blockquote><p> <strong>Java 程序从源代码到运行一般有下面 3 步：</strong> </p><p><img src="/img/work/1634221350574.png"></p><p>我们需要格外注意的是.class -&gt; 机器码。在这一步JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了JIT编译器，而JIT编译器属于运行时编译。当JIT编译器完成第一次编译之后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定高于Java解释器的。这也解释了我们为什么经常会说Java是编译与解释共存的语言。</p><blockquote><p> HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。 </p></blockquote><p> <strong>总结：</strong> </p><p> Java 虚拟机（JVM）是运行 Java 字节码的虚拟机 。 JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，  它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。 </p><h4 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h4><p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器(javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。 </p><p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。 </p><p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。 </p><h3 id="Java-语言“编译与解释并存"><a href="#Java-语言“编译与解释并存" class="headerlink" title="Java 语言“编译与解释并存"></a>Java 语言“编译与解释并存</h3><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读， 有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p><p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>*.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。</p><h3 id="Java-和-C-的区别"><a href="#Java-和-C-的区别" class="headerlink" title="Java 和 C++的区别"></a>Java 和 C++的区别</h3><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li></ul><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>八个基本类型</p><ul><li>byte（字节型）</li><li>short（短整型）</li><li>int（整型）</li><li>long（长整型）</li><li>float（单精度浮点型）</li><li>double（双精度浮点型）</li><li>boolean（布尔型）</li><li>char（字符型）</li></ul><h3 id="对应包装类"><a href="#对应包装类" class="headerlink" title="对应包装类"></a>对应包装类</h3><ul><li>Byte</li><li>Short</li><li>Integer</li><li>Long</li><li>Float</li><li>Double</li><li>Boolean</li><li>Character</li></ul><h3 id="详细划分"><a href="#详细划分" class="headerlink" title="详细划分"></a>详细划分</h3><p><strong>具体可分为四类</strong></p><ul><li>整型 byte short int long</li><li>浮点型 float double</li><li>逻辑型 boolean</li><li>字符型 char</li></ul><h3 id="八种基本数据类型的默认值"><a href="#八种基本数据类型的默认值" class="headerlink" title="八种基本数据类型的默认值"></a>八种基本数据类型的默认值</h3><p><img src="/img/work/image-20211021215018133.png"></p><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = <span class="hljs-number">2</span>;     <span class="hljs-comment">// 装箱</span><br><span class="hljs-keyword">int</span> y = x;         <span class="hljs-comment">// 拆箱</span><br></code></pre></td></tr></table></figure><h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于:</p><ul><li>new Integer(123) 每次都会新建一个对象</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">123</span>);<br>Integer y = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">123</span>);<br>System.out.println(x == y);    <span class="hljs-comment">// false</span><br>Integer z = Integer.valueOf(<span class="hljs-number">123</span>);<br>Integer k = Integer.valueOf(<span class="hljs-number">123</span>);<br>System.out.println(z == k);   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br><br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-comment">// high value may be configured by property</span><br>    <span class="hljs-keyword">int</span> h = <span class="hljs-number">127</span>;<br>    String integerCacheHighPropValue =<br>        sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>    <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">int</span> i = parseInt(integerCacheHighPropValue);<br>            i = Math.max(i, <span class="hljs-number">127</span>);<br>            <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>            <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>        &#125;<br>    &#125;<br>    high = h;<br><br>    cache = <span class="hljs-keyword">new</span> Integer[(high - low) + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> j = low;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>        cache[k] = <span class="hljs-keyword">new</span> Integer(j++);<br><br>    <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>    <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会<strong>在缓冲池范围内的基本类型</strong>自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer m = <span class="hljs-number">123</span>;<br>Integer n = <span class="hljs-number">123</span>;<br>System.out.println(m == n); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>基本类型对应的缓冲池如下:</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><p>如果在缓冲池之外：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer m = <span class="hljs-number">323</span>;<br>Integer n = <span class="hljs-number">323</span>;<br>System.out.println(m == n); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>String 被声明为 final，因此它不可被继承。</p><p>内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br><br></code></pre></td></tr></table></figure><h3 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h3><p><strong>1. 可以缓存 hash 值</strong></p><p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p><p><strong>2. String Pool 的需要</strong></p><p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p><p><img src="/img/work/image-20211021222448391.png"></p><p><strong>3. 安全性</strong></p><p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><p><strong>4. 线程安全</strong></p><p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p><h3 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h3><p><strong>1. 可变性</strong></p><ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><p><strong>2. 线程安全</strong></p><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul><h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h3><p>使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。</p><p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用。intern() 首先把 s1 引用的对象放到 String Pool(字符串常量池)中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;aaa&quot;</span>);<br>String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;aaa&quot;</span>);<br>System.out.println(s1 == s2);           <span class="hljs-comment">// false</span><br>String s3 = s1.intern();<br>System.out.println(s1.intern() == s3);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String s4 = <span class="hljs-string">&quot;bbb&quot;</span>;<br>String s5 = <span class="hljs-string">&quot;bbb&quot;</span>;<br>System.out.println(s4 == s5);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>在 Java 7 之前，字符串常量池被放在运行时常量池中，它属于永久代。而在 Java 7，字符串常量池被移到 Native Method 中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p><p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中改变指针引用的对象，那么这两个指针此时指向的是完全不同的对象，一方改变其所指向对象的内容对另一方没有影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>    String name;<br><br>    Dog(String name) &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function">String <span class="hljs-title">getObjectAddress</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.toString();<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassByValueExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;A&quot;</span>);<br>        System.out.println(dog.getObjectAddress()); <span class="hljs-comment">// Dog@4554617c</span><br>        func(dog);<br>        System.out.println(dog.getObjectAddress()); <span class="hljs-comment">// Dog@4554617c</span><br>        System.out.println(dog.getName());          <span class="hljs-comment">// A</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Dog dog)</span> </span>&#123;<br>        System.out.println(dog.getObjectAddress()); <span class="hljs-comment">// Dog@4554617c</span><br>        dog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;B&quot;</span>);<br>        System.out.println(dog.getObjectAddress()); <span class="hljs-comment">// Dog@74a14482</span><br>        System.out.println(dog.getName());          <span class="hljs-comment">// B</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>但是如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassByValueExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;A&quot;</span>);<br>        func(dog);<br>        System.out.println(dog.getName());          <span class="hljs-comment">// B</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Dog dog)</span> </span>&#123;<br>        dog.setName(<span class="hljs-string">&quot;B&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="float-与-double"><a href="#float-与-double" class="headerlink" title="float 与 double"></a>float 与 double</h3><p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。Java 不能隐式执行向下转型，因为这会使得精度降低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">float</span> f = <span class="hljs-number">1.1</span>;  <span class="hljs-comment">//编译错误</span><br></code></pre></td></tr></table></figure><p>1.1f 字面量才是 float 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">float</span> f = <span class="hljs-number">1.1f</span>;<br></code></pre></td></tr></table></figure><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">short</span> s1 = <span class="hljs-number">1</span>;<br>s1 = s1 + <span class="hljs-number">1</span>;  <span class="hljs-comment">//编译错误</span><br></code></pre></td></tr></table></figure><p>但是使用 += 运算符可以执行隐式类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">s1 += <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">s1 = (<span class="hljs-keyword">short</span>) (s1 + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">String s = <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-keyword">switch</span> (s) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;a&quot;</span>:<br>        System.out.println(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;b&quot;</span>:<br>        System.out.println(<span class="hljs-string">&quot;bbb&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</strong></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>Java 中有三个访问权限修饰符: private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p><p>可以对类或类中的成员(字段以及方法)加上访问修饰符。</p><ul><li>类可见表示其它类可以用这个类创建实例对象。</li><li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li></ul><p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p><p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p><p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p><p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 共有字段，如果在某个时刻，我们想要使用 int 去存储 id 字段，那么就需要去修改所有的客户端代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessExample</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String id;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessExample</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id + <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = Integer.valueOf(id);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessWithInnerClassExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> x;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> InnerClass innerClass;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccessWithInnerClassExample</span><span class="hljs-params">()</span> </span>&#123;<br>        innerClass = <span class="hljs-keyword">new</span> InnerClass();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> innerClass.x;  <span class="hljs-comment">// 直接访问</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><p><strong>1. 抽象类</strong></p><p>抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</p><p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClassExample</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> y;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;func2&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractExtendClassExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClassExample</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;func1&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// AbstractClassExample ac1 = new AbstractClassExample(); // &#x27;AbstractClassExample&#x27; is abstract; cannot be instantiated</span><br>AbstractClassExample ac2 = <span class="hljs-keyword">new</span> AbstractExtendClassExample();<br>ac2.func1();<br><br></code></pre></td></tr></table></figure><p><strong>2. 接口</strong></p><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p><p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p><p>接口的成员(字段 + 方法)默认都是 public 的，并且不允许定义为 private 或者 protected。</p><p>接口的字段默认都是 static 和 final 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;func2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">123</span>;<br>    <span class="hljs-comment">// int y;               // Variable &#x27;y&#x27; might not have been initialized</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> z = <span class="hljs-number">0</span>;       <span class="hljs-comment">// Modifier &#x27;public&#x27; is redundant for interface fields</span><br>    <span class="hljs-comment">// private int k = 0;   // Modifier &#x27;private&#x27; not allowed here</span><br>    <span class="hljs-comment">// protected int l = 0; // Modifier &#x27;protected&#x27; not allowed here</span><br>    <span class="hljs-comment">// private void fun3(); // Modifier &#x27;private&#x27; not allowed here</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>3. 比较</strong></p><ul><li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li><li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li><li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li><li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li></ul><p><strong>4. 使用选择</strong></p><p>使用接口:</p><ul><li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li><li>需要使用多重继承。</li></ul><p> 使用抽象类:</p><ul><li>需要在几个相关的类中共享代码。</li><li>需要能控制继承来的成员的访问权限，而不是都为 public。</li><li>需要继承非静态和非常量字段。</li></ul><p>在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul><li>访问父类的构造函数: 可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</li><li>访问父类的成员: 如果子类重写了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperExample</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> y;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SuperExample</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.x = x;<br>        <span class="hljs-keyword">this</span>.y = y;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;SuperExample.func()&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperExtendExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> z;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SuperExtendExample</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(x, y);<br>        <span class="hljs-keyword">this</span>.z = z;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.func();<br>        System.out.println(<span class="hljs-string">&quot;SuperExtendExample.func()&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><br>SuperExample e = <span class="hljs-keyword">new</span> SuperExtendExample(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>e.func();<br><br></code></pre></td></tr></table></figure><h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><p><strong>1. 重写(Override)</strong></p><p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p><p>为了满足里式替换原则，重写有有以下两个限制:</p><ul><li>子类方法的访问权限必须大于等于父类方法；</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li></ul><p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。</p><p><strong>2. 重载(Overload)</strong></p><p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p><p>应该注意的是，返回值不同，其它都相同不算是重载。</p><h2 id="Object-通用方法"><a href="#Object-通用方法" class="headerlink" title="Object 通用方法"></a>Object 通用方法</h2><h3 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyAll</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, <span class="hljs-keyword">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p><strong>1. 等价关系</strong></p><p>(一)自反性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x.equals(x); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>(二)对称性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x.equals(y) == y.equals(x); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>(三)传递性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))<br>    x.equals(z); <span class="hljs-comment">// true;</span><br></code></pre></td></tr></table></figure><p>(四)一致性</p><p>多次调用 equals() 方法结果不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x.equals(y) == x.equals(y); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>(五)与 null 的比较</p><p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x.equals(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// false;</span><br></code></pre></td></tr></table></figure><p><strong>2. equals() 与 ==</strong></p><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br>Integer y = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br>System.out.println(x.equals(y)); <span class="hljs-comment">// true</span><br>System.out.println(x == y);      <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>3. 实现</strong></p><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断每个关键域是否相等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EqualExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> z;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EqualExample</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.x = x;<br>        <span class="hljs-keyword">this</span>.y = y;<br>        <span class="hljs-keyword">this</span>.z = z;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        EqualExample that = (EqualExample) o;<br><br>        <span class="hljs-keyword">if</span> (x != that.x) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (y != that.y) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> z == that.z;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p><p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">EqualExample e1 = <span class="hljs-keyword">new</span> EqualExample(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>EqualExample e2 = <span class="hljs-keyword">new</span> EqualExample(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>System.out.println(e1.equals(e2)); <span class="hljs-comment">// true</span><br>HashSet&lt;EqualExample&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>set.add(e1);<br>set.add(e2);<br>System.out.println(set.size());   <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p><p>一个数与 31 相乘可以转换成移位和减法: <code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">17</span>;<br>    result = <span class="hljs-number">31</span> * result + x;<br>    result = <span class="hljs-number">31</span> * result + y;<br>    result = <span class="hljs-number">31</span> * result + z;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToStringExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ToStringExample</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.number = number;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ToStringExample example = <span class="hljs-keyword">new</span> ToStringExample(<span class="hljs-number">123</span>);<br>System.out.println(example.toString());<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ToStringExample@4554617c<br></code></pre></td></tr></table></figure><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p><strong>1. cloneable</strong></p><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">CloneExample e1 = <span class="hljs-keyword">new</span> CloneExample();<br><span class="hljs-comment">// CloneExample e2 = e1.clone(); // &#x27;clone()&#x27; has protected access in &#x27;java.lang.Object&#x27;</span><br></code></pre></td></tr></table></figure><p>重写 clone() 得到以下实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> CloneExample <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> (CloneExample)<span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">CloneExample e1 = <span class="hljs-keyword">new</span> CloneExample();<br><span class="hljs-keyword">try</span> &#123;<br>    CloneExample e2 = e1.clone();<br>&#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.CloneNotSupportedException: CloneExample<br></code></pre></td></tr></table></figure><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. 浅拷贝</strong></p><p>拷贝对象和原始对象的引用类型引用同一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShallowCloneExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ShallowCloneExample</span><span class="hljs-params">()</span> </span>&#123;<br>        arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            arr[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        arr[index] = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> arr[index];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> ShallowCloneExample <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> (ShallowCloneExample) <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">ShallowCloneExample e1 = <span class="hljs-keyword">new</span> ShallowCloneExample();<br>ShallowCloneExample e2 = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    e2 = e1.clone();<br>&#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br>e1.set(<span class="hljs-number">2</span>, <span class="hljs-number">222</span>);<br>System.out.println(e2.get(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 222</span><br><br></code></pre></td></tr></table></figure><p><strong>3. 深拷贝</strong></p><p>拷贝对象和原始对象的引用类型引用不同对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeepCloneExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DeepCloneExample</span><span class="hljs-params">()</span> </span>&#123;<br>        arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            arr[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        arr[index] = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> arr[index];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> DeepCloneExample <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        DeepCloneExample result = (DeepCloneExample) <span class="hljs-keyword">super</span>.clone();<br>        result.arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            result.arr[i] = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">DeepCloneExample e1 = <span class="hljs-keyword">new</span> DeepCloneExample();<br>DeepCloneExample e2 = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    e2 = e1.clone();<br>&#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br>e1.set(<span class="hljs-number">2</span>, <span class="hljs-number">222</span>);<br>System.out.println(e2.get(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 2</span><br><br></code></pre></td></tr></table></figure><p><strong>4. clone() 的替代方案</strong></p><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneConstructorExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CloneConstructorExample</span><span class="hljs-params">()</span> </span>&#123;<br>        arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            arr[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CloneConstructorExample</span><span class="hljs-params">(CloneConstructorExample original)</span> </span>&#123;<br>        arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[original.arr.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; original.arr.length; i++) &#123;<br>            arr[i] = original.arr[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        arr[index] = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> arr[index];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">CloneConstructorExample e1 = <span class="hljs-keyword">new</span> CloneConstructorExample();<br>CloneConstructorExample e2 = <span class="hljs-keyword">new</span> CloneConstructorExample(e1);<br>e1.set(<span class="hljs-number">2</span>, <span class="hljs-number">222</span>);<br>System.out.println(e2.get(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 2</span><br><br></code></pre></td></tr></table></figure><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p><strong>1. 数据</strong></p><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// x = 2;  // cannot assign value to final variable &#x27;x&#x27;</span><br><span class="hljs-keyword">final</span> A y = <span class="hljs-keyword">new</span> A();<br>y.a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><strong>2. 方法</strong></p><p>声明方法不能被子类重写。</p><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p><p><strong>3. 类</strong></p><p>声明类不允许被继承。</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>1. 静态变量</strong></p><p>静态变量: 又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。</p><p>实例变量: 每创建一个实例就会产生一个实例变量，它与该实例同生共死。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x;         <span class="hljs-comment">// 实例变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> y;  <span class="hljs-comment">// 静态变量</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// int x = A.x;  // Non-static field &#x27;x&#x27; cannot be referenced from a static context</span><br>        A a = <span class="hljs-keyword">new</span> A();<br>        <span class="hljs-keyword">int</span> x = a.x;<br>        <span class="hljs-keyword">int</span> y = A.y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. 静态方法</strong></p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法(abstract)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>&#123;<br>    &#125;<br>    <span class="hljs-comment">// public abstract static void func2();  // Illegal combination of modifiers: &#x27;abstract&#x27; and &#x27;static&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> y;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> a = x;<br>        <span class="hljs-comment">// int b = y;  // Non-static field &#x27;y&#x27; cannot be referenced from a static context</span><br>        <span class="hljs-comment">// int b = this.y;     // &#x27;A.this&#x27; cannot be referenced from a static context</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. 静态语句块</strong></p><p>静态语句块在类初始化时运行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;123&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        A a1 = <span class="hljs-keyword">new</span> A();<br>        A a2 = <span class="hljs-keyword">new</span> A();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p><strong>4. 静态内部类</strong></p><p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClass</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// InnerClass innerClass = new InnerClass(); // &#x27;OuterClass.this&#x27; cannot be referenced from a static context</span><br>        OuterClass outerClass = <span class="hljs-keyword">new</span> OuterClass();<br>        InnerClass innerClass = outerClass.<span class="hljs-function">new <span class="hljs-title">InnerClass</span><span class="hljs-params">()</span></span>;<br>        StaticInnerClass staticInnerClass = <span class="hljs-keyword">new</span> StaticInnerClass();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态内部类不能访问外部类的非静态的变量和方法。</p><p><strong>5. 静态导包</strong></p><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> com.xxx.ClassName.*<br></code></pre></td></tr></table></figure><p><strong>6. 初始化顺序</strong></p><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String staticField = <span class="hljs-string">&quot;静态变量&quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;静态语句块&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String field = <span class="hljs-string">&quot;实例变量&quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>    System.out.println(<span class="hljs-string">&quot;普通语句块&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后才是构造函数的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InitialOrderTest</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;构造函数&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>存在继承的情况下，初始化顺序为:</p><ul><li>父类(静态变量、静态语句块)</li><li>子类(静态变量、静态语句块)</li><li>父类(实例变量、普通语句块)</li><li>父类(构造函数)</li><li>子类(实例变量、普通语句块)</li><li>子类(构造函数)</li></ul><p>引用自:</p><hr><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md</a></p><p><a href="https://www.pdai.tech/md/java/basic/java-basic-lan-basic.html">https://www.pdai.tech/md/java/basic/java-basic-lan-basic.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础-面向对象</title>
    <link href="/2021/10/12/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/10/12/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="一、封装"><a href="#一、封装" class="headerlink" title="一、封装"></a>一、封装</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>类的封装，是指将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象的内部信息，而是通过该类所提供的方法来实现对内部信息的操作。即<strong>封装就是把同一类事物的共性（包括属性和方法）归到同一类中，方便使用。</strong>    </p><p>封装和继承几乎都是为多态而准备的。 </p><p>封装也称信息隐藏，是指利用抽象数据类型把数据和基于数据的操作封装起来，使其成为一个不可分割的整体，数据隐藏在抽象数据内部，尽可能的隐藏数据细节，只保留一些接口使其与外界发生联系。也就是说用户无需知道内部的数据和方法的具体实现细节，只需根据留在外部的接口进行操作就行。 </p><h4 id="2-封装的实现"><a href="#2-封装的实现" class="headerlink" title="2. 封装的实现"></a>2. <strong>封装的实现</strong></h4><ul><li> 需要修改属性的访问控制符（修改为private）； </li><li> 创建getter/setter方法（用于属性的读写）； </li><li> 在getter/setter方法中加入属性控制语句（用于判断属性值的合法性）; </li></ul><p><strong>属性 (成员变量 ) 随对象存放在堆中</strong></p><p>直接通过对象调用属性，修改属性值是不安全的，那<strong>怎么办</strong>？</p><p>具体实现过程：在定义一个类时，将类中的属性私有化，即使用private关键字来修饰，私有属性只能在它所在类中被访问，如果外界想要访问私有属性，需要提供一些使用public修饰的共有方法，其中包括用于获取属性值的getXxx()方法和设置属性值的setXxx()方法。</p><p>Boolean的get方法默认名为isXXX（）</p><p>把成员变量设置为私有的，只能在本类中使用，所以属性也叫<strong>全局变量</strong>。</p><h4 id="3-封装的优缺点"><a href="#3-封装的优缺点" class="headerlink" title="3.封装的优缺点"></a>3.封装的优缺点</h4><blockquote><p>优点</p></blockquote><ul><li> 将变化隔离 </li><li> 便于使用 </li><li> 提高重用性 </li><li> 提高安全性 </li></ul><blockquote><p>缺点</p></blockquote><p> 将变量等使用private修饰，或者封装进方法内，使其不能直接被访问，增加了访问步骤与难度！ </p><p><strong>实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;<br> <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">     * 对属性的封装一个人的姓名、年龄</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">     */</span><br> <br>    <span class="hljs-keyword">private</span> String name;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">     * setter()、getter()是该对象对外开发的接口</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">     */</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br> <br>        <span class="hljs-keyword">return</span> name;<br> <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br> <br>        <span class="hljs-keyword">this</span>.name = name;<br> <br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br> <br>        <span class="hljs-keyword">return</span> age;<br> <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br> <br>        <span class="hljs-keyword">this</span>.age = age;<br> <br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h3><p> 继承关键字：<code>extends</code> </p><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h4><p>在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类称作子类，现有类被称作父类或基类，子类会自动拥有父类所有可继承的属性和方法。</p><p><strong>简单的说</strong>:  继承是类与类的一种关系，比较像集合中的从属于关系。比如说，狗属于动物。就可以看成狗类继承了动物类，那么狗类就是动物类的子类（派生类），动物类就是狗类的父类（基类）。在Java中是单继承的，也就是说一个子类只有一个父类。 </p><h4 id="2-继承的特点："><a href="#2-继承的特点：" class="headerlink" title="2. 继承的特点："></a><strong>2. 继承的特点：</strong></h4><p>（1） 子类比父类强大<br>（2）java是单继承，不能进行多继承。但是可以继承多层子类（<strong>不建议继承超过3层</strong>）<br>（3）子类继承父类，但是对父类的成员变量是无法直接操作，只能通过父类继承过来的setter和getter方法. </p><h4 id="3-继承优缺点"><a href="#3-继承优缺点" class="headerlink" title="3.继承优缺点"></a>3.继承优缺点</h4><blockquote><p>优点</p></blockquote><p>  (1)  减少代码量，能很好的提高复用率。<br>  (2)  使类与类之间存在继承关系，是实现多态操作的前提。 </p><blockquote><p>缺点</p></blockquote><p>继承使得多个类之间具有了子父类关系，当一个类存在多个子类的时候，如果父类发生变化，那么这些子类会跟着一同变化，造成类与类之间的“强耦合”关系！ </p><h4 id="4-继承注意点"><a href="#4-继承注意点" class="headerlink" title="4.继承注意点"></a><strong>4.继承注意点</strong></h4><p> (1) 不要仅仅为了获取某个类的某个功能而去继承这个类<br> (2) 类与类之间要存在所属关系，不能够随意继承 </p><h4 id="5-何时使用继承"><a href="#5-何时使用继承" class="headerlink" title="5.何时使用继承"></a><strong>5.何时使用继承</strong></h4><p>（1）具有公共的属性与行为操作的时候，提高复用性<br>（2）具有is–a的所属关系的类与类之间 </p><h4 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a><strong>7. 结论</strong></h4><p>（1）执行构造方法创建对象完成对象的初始化时，先执行父类的构造，完成父类的初始化，再执行本类的初始化工作。</p><p>（2）第一次创建Phone（父）类，是直接继承Object,而Object是jdk提供的工具类，自然不会有属性，所以Object类只提供了无参的构造，在执行Phone方法时，无论是无参还是有参都会先执行父类Object的无参构造。</p><p>（3）但是对于Phone的子类Mobile，必须也要有自己的构造方法，由于构造执行的特性，对于无参构造，先执行了Phone的无参构造，对于有参构造，则先执行父类Phone的有参，然后才执行本类属性sex的初始化。</p><p>（4）构造方法constructor中,无论是否显式还是隐式调用super(),子类在创建对象调用时都会执行super();</p><p>（5）显式调用构造是在需要通过父类的带参构造来完成子类的带参构造。例如Mobile类带参构造中显示调用的Super(brand,price,service)</p><p>（6）对于父类私有的属性，即使子类继承，但是在test.java中，子类是无法直接访问的，在制定子类的带参构造方法时，只能通过调用父类的带参构造来完成。对于父类非私有的属性，子类对象可以直接调用。</p><h3 id="三、多态"><a href="#三、多态" class="headerlink" title="三、多态"></a>三、多态</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h4><p>多态指的是对象的多种形态。 多态有两种：引用多态和方法多态。<strong>继承是多态的实现基础。</strong>Java的多态是由类的继承、方法重写以及父类引用指向子类对象体现的。由于一个父类可以有多个子类，多个子类都可以重写父类方法，并且多个不同的子类对象也可以指向同一个父类；这样，程序只有在运行时才能知道具体代表的是哪个子类对象，这就体现了多态。</p><p><strong>实例</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义抽象类Animal</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><br><span class="hljs-comment">//定义 Cat类继承Animal抽象类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-comment">//实现shout()方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;喵喵。。。&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//定义Dog类继承Animal抽象类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-comment">//实现shout()方法</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;汪汪。。。&quot;</span>)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//定义测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Animal an1 = <span class="hljs-keyword">new</span> Cat();<br>        Animal an2 = <span class="hljs-keyword">new</span> Dog();<br>        <br>        an1.shout();<br>        an2.shout();<br>    &#125;<br>&#125;<br><br><br><br><br></code></pre></td></tr></table></figure><h4 id="2-多态存在的前提（多态的三要素）"><a href="#2-多态存在的前提（多态的三要素）" class="headerlink" title="2. 多态存在的前提（多态的三要素）"></a>2. <strong>多态存在的前提（多态的三要素）</strong></h4><p>(1)  必须有子类和父类，具有继承或实现（继承） </p><p>(2) 子类必须重写父类的方法（重写）</p><p>(3) 父类的引用变量指向子类的对象（向上转型）  </p><h4 id="3-多态优缺点"><a href="#3-多态优缺点" class="headerlink" title="3.多态优缺点"></a>3.多态优缺点</h4><blockquote><p>优点</p></blockquote><p>  A. 可替换性，多态对一存在的代码具有可替代性</p><p>  B. 可扩充性：增加的子类不影响已存在的类的特性的运行和操作</p><p>  C. 接口性：多态时超类通过方法签名想子类提供了一个公共的接口，由子类来完善或者覆盖它而实现的</p><p>  D. 灵活性：在应用中体现了灵活多样的操作，提高了使用的效率</p><p>  E. 简化性： 多态简化对应用软件的代码的编写和修改过程，尤其在处理大量的对象的运算和操作时，这个特点尤为突出和重要</p><blockquote><p>缺点</p></blockquote><p>只能使用父类的引用访问父类的成员 </p><h4 id="4-多态中的成员特点"><a href="#4-多态中的成员特点" class="headerlink" title="4. 多态中的成员特点"></a>4. <strong>多态中的成员特点</strong></h4><p>  成员变量：编译与运行时期都看父类！ 成员方法：编译时期看父类，运行时期看子类 </p><p>参考：</p><hr><p><a href="https://blog.csdn.net/hellosweet1/article/details/81320384">https://blog.csdn.net/hellosweet1/article/details/81320384</a></p><p>Java基础入门第二版</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis缓存穿透和雪崩</title>
    <link href="/2021/10/11/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/"/>
    <url>/2021/10/11/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="服务的高可用问题"><a href="#服务的高可用问题" class="headerlink" title="服务的高可用问题"></a>服务的高可用问题</h3><p>​       Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一 些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。 另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。  </p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><blockquote><p>概念  </p></blockquote><p>​    缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中,于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中(秒杀!)，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了 缓存穿透。 </p><p><img src="/img/work/1633962251731.png"></p><blockquote><p>解决方案  </p></blockquote><p><strong>布隆过滤器</strong>  </p><p>​     布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则 丢弃，从而避免了对底层存储系统的查询压力； </p><p><img src="/img/work/1633962830773.png"></p><p><strong>缓存空对象</strong> </p><p>​    当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数 据将会从缓存中获取，保护了后端数据源；  </p><p>但是这种方法会存在两个问题： </p><p>1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多 的空值的键； </p><p>2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于 需要保持一致性的业务会有影响。 </p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><blockquote><p>概述 </p></blockquote><p>​      这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中 对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一 个屏障上凿开了一个洞。 </p><p>​     当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访 问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。 </p><p><strong>解决方案</strong></p><blockquote><p>设置热点数据永不过期   </p></blockquote><p>​     从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。  </p><p> <strong>加互斥锁</strong></p><p>​     分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布 式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考 验很大。  </p><p><img src="/img/work/1633963512731.png"></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p> <strong>概念</strong>  </p><p>​      缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机！ </p><p>​      产生雪崩的原因之一，比如双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。 </p><p><img src="/img/work/1633963929642.png"></p><p>​      其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知 的，很有可能瞬间就把数据库压垮。 </p><blockquote><p>解决方案  </p></blockquote><p><strong>redis高可用</strong> </p><p>​      这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。</p><p><strong>限流降级</strong></p><p>​      这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 </p><p><strong>数据预热</strong> </p><p>​     数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数 据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。 </p><p>引用:</p><hr><p>狂神说Java:<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0</a></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis三种集群模式之Cluster模式</title>
    <link href="/2021/10/07/redis-cluster%E9%9B%86%E7%BE%A4/"/>
    <url>/2021/10/07/redis-cluster%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1、redis-cluter设计"><a href="#1、redis-cluter设计" class="headerlink" title="1、redis-cluter设计"></a>1、redis-cluter设计</h2><p> Redis集群搭建的方式有多种，开始使用主从模式做集群，若master宕机需要手动配置slave转为master；后来为了高可用提出来(redis-sentinel)<strong>哨兵</strong>模式，该模式下有一个哨兵监视master和slave，若master宕机可自动将slave转为master，但它也有一个问题，就是不能动态扩充；从redis 3.0之后版本支持redis-cluster集群. </p><p> Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。其redis-cluster架构图如下： </p><p><img src="/img/work/1633829297415.png"></p><p> 其结构特点： </p><ol><li> 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。 </li><li> 节点的fail是通过集群中超过半数的节点检测失效时才生效。 </li><li> 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。 </li><li> redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配）,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value。 </li><li> Redis集群预分好16384个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。 </li></ol><h2 id="2、redis-cluster节点分配"><a href="#2、redis-cluster节点分配" class="headerlink" title="2、redis cluster节点分配"></a>2、redis cluster节点分配</h2><p>现在我们是三个节点分别是：A,B,C 三个节点，它们可以是一台机器上的三个端口，也可以是三台不同服务器。那么，采用哈希槽（hash solt）的方式来分配16384个solt的话，他们三个节点分别承担的solt区间是：</p><ul><li><p>节点A覆盖0－5460; </p></li><li><p>节点B覆盖5461－10922; </p></li><li><p>节点C覆盖10923－16383；</p></li></ul><p> 获取数据： </p><p>​     如果存入一个值，按照redis-cluster哈希槽的算法：CRC16(‘key’)%16384 = 6782。那么就会把这个key的存储分配到 B 上。同样，当我连接（A，B，C）任何一个节点，想获取’key’这个key时，也会这样的算法，然后内部跳转到B节点上获取数据新增一个主节点：</p><p> 新增一个节点D，redis cluster的这种做法是从各个节点的前面各拿取一部分slot到D上，我会在接下来的实践中实验。大致就会变成这样： </p><ul><li>节点A覆盖1365-5460</li><li> 节点B覆盖6827-10922</li><li> 节点C覆盖12288-16383</li><li> 节点D覆盖0-1364,5461-6826,10923-12287 </li></ul><h2 id="3、-Redis-Cluster主从模式"><a href="#3、-Redis-Cluster主从模式" class="headerlink" title="3、 Redis Cluster主从模式"></a>3、 <strong>Redis Cluster主从模式</strong></h2><p>​        redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。</p><p>​       上面那个例子里, 集群有ABC三个主节点, 如果这3个节点都没有加入从节点，如果B挂掉了，我们就无法访问整个集群了。A和C的slot也无法访问。所以我们在集群建立的时候，一定要为每个主节点都添加了从节点, 比如像这样, 集群包含主节点A、B、C, 以及从节点A1、B1、C1, 那么即使B挂掉系统也可以继续正确工作。B1节点替代了B节点，所以Redis集群将会选择B1节点作为新的主节点，集群将会继续正确地提供服务。 当B重新开启后，它就会变成B1的从节点。不过需要注意，如果节点B和B1同时挂了，Redis集群就无法继续正确地提供服务了。</p><h2 id="4、redis6-2-5-集群部署"><a href="#4、redis6-2-5-集群部署" class="headerlink" title="4、redis6.2.5 集群部署"></a><strong>4、redis6.2.5 集群部署</strong></h2><p><strong>集群中至少应该有奇数个节点，所以至少有三个节点，每个节点至少有一个备份节点，所以下面使用6节点（主节点、备份节点由redis-cluster集群确定）。</strong></p><h3 id="4-1-准备工作"><a href="#4-1-准备工作" class="headerlink" title="4.1 准备工作"></a><strong>4.1 准备工作</strong></h3><p>   本文使用两台centOS7主机，一台机器3个节点，创建出3 master、3 salve 环境，master（192.168.1.8） salve(192.168.1.10) </p><h3 id="4-2-创建Redis节点"><a href="#4-2-创建Redis节点" class="headerlink" title="4.2 创建Redis节点"></a>4.2 创建Redis节点</h3><p>首先在指定目录下创建  redis_cluster </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /software01/redis_cluster<br></code></pre></td></tr></table></figure><p> 在 redis_cluster 目录下，创建名为 6379、6380、6381的目录，并将 redis.conf 拷贝到这六个目录中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> mkdir 6379 6380 6381、6382、6383、6384</span><br><span class="hljs-meta">#</span><span class="bash"> cp redis.conf redis_cluster/6379</span><br><span class="hljs-meta">#</span><span class="bash"> cp redis.conf redis_cluster/6380</span> <br><span class="hljs-meta">#</span><span class="bash"> cp redis.conf redis_cluster/6381</span><br></code></pre></td></tr></table></figure><p> 分别修改这三个配置文件，修改如下内容 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">port 6379　　　　　　#端口6379 6380 6381、6382、6383、6384 <br>bind 本机ip 　　　　 #默认ip为127.0.0.1 需要改为其他节点机器可访问的ip 否则创建集群时无法访问对应的端口，无法创建集群 <br>daemonize yes 　　  #redis后台运行 <br>pidfile /var/run/redis_6379.pid 　　#pidfile文件对应6379,6380,6381 <br>cluster-enabled yes 　　　　　　　　　#开启集群 <br>cluster-config-file nodes_6379.conf #集群的配置 配置文件首次启动自动生成 6379,6380,6381 <br>cluster-node-timeout 15000 　　　　　　#请求超时 默认15秒，可自行设置  <br>appendonly yes 　　　　　　　　　　　　#aof日志开启 有需要就开启，它会每次写操作都记录一条日志<br></code></pre></td></tr></table></figure><p>接着在另外一台机器上（192.168.1.10），的操作重复以上三步，只是把目录改为6382、6383、6384，对应的配置文件也按照这个规则修改即可. </p><h3 id="4-3-启动各节点"><a href="#4-3-启动各节点" class="headerlink" title="4.3 启动各节点"></a>4.3 启动各节点</h3><p> 第一台机器上执行: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# redis-server /root/software01/redis_cluster/6379/redis.conf <br>[root@centos7 bin]# redis-server /root/software01/redis_cluster/6380/redis.conf <br>[root@centos7 bin]# redis-server /root/software01/redis_cluster/6381/redis.conf <br></code></pre></td></tr></table></figure><p> 另外一台机器上执行: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# redis-server /root/software01/redis_cluster/6382/redis.conf <br>[root@centos7 bin]# redis-server /root/software01/redis_cluster/6383/redis.conf <br>[root@centos7 bin]# redis-server /root/software01/redis_cluster/6384/redis.conf <br></code></pre></td></tr></table></figure><h3 id="4-4-检查-redis-启动情况"><a href="#4-4-检查-redis-启动情况" class="headerlink" title="4.4 检查 redis 启动情况"></a>4.4 检查 redis 启动情况</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> ps -ef | grep redis //查看redis启动情况</span><br></code></pre></td></tr></table></figure><p><img src="/img/work/1633850372740.png"></p><p><img src="/img/work/1633850438157.png"></p><h3 id="4-5-创建集群"><a href="#4-5-创建集群" class="headerlink" title="4.5 创建集群"></a>4.5 创建集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# ./redis-cli --cluster create 192.168.1.10:6379 192.168.1.10:6380 192.168.1.10:6381 192.168.1.8:6382 192.168.1.8:6383 192.168.1.8:6384 --cluster-replicas 1<br></code></pre></td></tr></table></figure><p> <strong>注意：Redis Cluster最低要求是3个主节点，如果需要集群需要认证，则在最后加入 -a xx 即可。</strong> </p><p>以上命令执行完成后</p><p><img src="/img/work/1633868265946.png"></p><p>输入yes之后将会出现以下信息</p><p><img src="/img/work/1633868317543.png"></p><h3 id="4-6-测试"><a href="#4-6-测试" class="headerlink" title="4.6 测试"></a>4.6 测试</h3><p> 在第一台机器上连接集群的6379端口的节点，在另外一台连接6382节点，连接方式为  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -h 192.168.1.10 -c -p 6379  #-h 连接主机的ip <br>                                      #-c连接集群结点时使用，此选项可防止moved和ask异常 <br>                                      #-p 端口   <br>                                      #-a 如果设置密码 可加上-a进行密码验证登录 <br></code></pre></td></tr></table></figure><p>在6379节点设置key值，然后在6382获取key的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">在节点6379上设置值</span><br>192.168.1.10:6379&gt; set k1 v1<br><span class="hljs-meta">-&gt;</span><span class="bash"> Redirected to slot [12706] located at 192.168.1.10:6380</span><br>OK<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">在6382也可以获取值</span><br>192.168.1.8:6382&gt; get k1<br><span class="hljs-meta">-&gt;</span><span class="bash"> Redirected to slot [12706] located at 192.168.1.10:6380</span><br>&quot;v1&quot;<br></code></pre></td></tr></table></figure><p>结果分别如下：</p><p><img src="/img/work/1633869331466.png"></p><p><img src="/img/work/1633869348246.png"></p><h2 id="5-Cluster模式的优缺点"><a href="#5-Cluster模式的优缺点" class="headerlink" title="5. Cluster模式的优缺点"></a>5. Cluster模式的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>无中心架构，数据按照slot分布在多个节点。</li><li>集群中的每个节点都是平等的关系，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</li><li>可线性扩展到1000多个节点，节点可动态添加或删除</li><li>能够实现自动故障转移，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色转换</li></ol><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol><li>客户端实现复杂，驱动要求实现Smart Client，缓存slots mapping信息并及时更新，提高了开发难度。目前仅JedisCluster相对成熟，异常处理还不完善，比如常见的“max redirect exception”</li><li>节点会因为某些原因发生阻塞（阻塞时间大于 cluster-node-timeout）被判断下线，这种failover是没有必要的</li><li>数据通过异步复制，不保证数据的强一致性</li><li>slave充当“冷备”，不能缓解读压力</li><li>批量操作限制，目前只支持具有相同slot值的key执行批量操作，对mset、mget、sunion等操作支持不友好</li><li>key事务操作支持有线，只支持多key在同一节点的事务操作，多key分布不同节点时无法使用事务功能</li><li>不支持多数据库空间，单机redis可以支持16个db，集群模式下只能使用一个，即db 0</li></ol><p> <strong>Redis Cluster模式不建议使用pipeline和multi-keys操作，减少max redirect产生的场景。</strong> </p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>Redis集群方案的三种模式，其中主从复制模式能实现读写分离，但是不能自动故障转移；哨兵模式基于主从复制模式，能实现自动故障转移，达到高可用，但与主从复制模式一样，不能在线扩容，容量受限于单机的配置；Cluster模式通过无中心化架构，实现分布式存储，可进行线性扩展，也能高可用，但对于像批量操作、事务操作等的支持性不够好。三种模式各有优缺点，可根据实际场景进行选择。</p><h2 id="附：Redis集群各种参数设置"><a href="#附：Redis集群各种参数设置" class="headerlink" title="附：Redis集群各种参数设置"></a>附：Redis集群各种参数设置</h2><h3 id="1-创建集群主节点"><a href="#1-创建集群主节点" class="headerlink" title="1. 创建集群主节点"></a>1. 创建集群主节点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --cluster create 192.168.1.10:6379 192.168.1.10:6380 192.168.1.10:6381<br></code></pre></td></tr></table></figure><h3 id="2-创建集群主从节点"><a href="#2-创建集群主从节点" class="headerlink" title="2. 创建集群主从节点"></a>2. 创建集群主从节点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/redis-cli --cluster create 192.168.1.10:6379 192.168.1.10:6380 192.168.1.10:6381 192.168.1.8:6382 192.168.1.8:6383 192.168.1.8:6384 --cluster-replicas 1<br></code></pre></td></tr></table></figure><p> <strong>说明：–cluster-replicas 参数为数字，1表示每个主节点需要1个从节点。</strong> </p><p>通过该方式创建的带有从节点的机器不能够自己手动指定主节点，所以如果需要指定的话，需要自己手动指定，先使用1或3创建好主节点后，再通过4来处理。 </p><h3 id="3-添加集群主节点"><a href="#3-添加集群主节点" class="headerlink" title="3. 添加集群主节点"></a>3. 添加集群主节点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --cluster add-node 192.168.1.8:6382 192.168.1.10:6379 <br></code></pre></td></tr></table></figure><p>说明：为一个指定集群添加节点，需要先连到该集群的任意一个节点IP（192.168.1.10:6379），再把新节点加入。该2个参数的顺序有要求：新加入的节点放前 </p><h3 id="4-添加集群从节点"><a href="#4-添加集群从节点" class="headerlink" title="4. 添加集群从节点"></a>4. 添加集群从节点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --cluster add-node 192.168.1.8:6382 192.168.1.10:6379 --cluster-slave --cluster-master-id 117457eab5071954faab5e81c3170600d5192270<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">说明：把6382节点加入到6379节点的集群中，并且当做node_id:17ea90fd81280b5ee7999cbf0313f89206688242的从节点。如果不指定 --cluster-master-id 会随机分配到任意一个主节点。</span><br></code></pre></td></tr></table></figure><h3 id="5-删除节点"><a href="#5-删除节点" class="headerlink" title="5. 删除节点"></a>5. 删除节点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --cluster del-node 192.168.1.8:6384 f6a6957421b80409106cb36be3c7ba41f3b603ff<br></code></pre></td></tr></table></figure><p>说明：指定IP、端口和node_id 来删除一个节点，从节点可以直接删除，有slot分配的主节点不能直接删除。</p><p>注意：当被删除掉的节点重新起来之后不能自动加入集群，但其和主的复制还是正常的，也可以通过该节点看到集群信息（通过其他正常节点已经看不到该被del-node节点的信息）。</p><p>如果想要再次加入集群，则需要先在该节点执行cluster reset，再用add-node进行添加，进行增量同步复制。</p><h3 id="6-检查集群"><a href="#6-检查集群" class="headerlink" title="6. 检查集群"></a>6. 检查集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --cluster check 192.168.1.8:6384 --cluster-search-multiple-owners<br></code></pre></td></tr></table></figure><p> 说明：任意连接一个集群节点，进行集群状态检查 </p><h3 id="7-集群信息查看"><a href="#7-集群信息查看" class="headerlink" title="7. 集群信息查看"></a>7. 集群信息查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --cluster info 192.168.1.8:6384<br></code></pre></td></tr></table></figure><p> 说明：检查key、slots、从节点个数的分配情况 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# redis-cli --cluster info 192.168.1.8:6384<br>192.168.1.10:6379 (17ea90fd...) -&gt; 1 keys | 5461 slots | 1 slaves.<br>192.168.1.8:6382 (4a8b3637...) -&gt; 0 keys | 5462 slots | 1 slaves.<br>192.168.1.10:6380 (4c4710e3...) -&gt; 1 keys | 5461 slots | 1 slaves.<br>[OK] 2 keys in 3 masters.<br>0.00 keys per slot on average.<br></code></pre></td></tr></table></figure><h3 id="8-修复集群"><a href="#8-修复集群" class="headerlink" title="8. 修复集群"></a>8. 修复集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --cluster fix 192.168.1.8:6384 --cluster-search-multiple-owners<br></code></pre></td></tr></table></figure><p> 说明：修复集群和槽的重复分配问题 </p><h3 id="9-设置集群的超时时间"><a href="#9-设置集群的超时时间" class="headerlink" title="9. 设置集群的超时时间"></a>9. 设置集群的超时时间</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --cluster set-timeout 192.168.1.8:6382 10000<br></code></pre></td></tr></table></figure><p> 说明：连接到集群的任意一节点来设置集群的超时时间参数cluster-node-timeout </p><h3 id="10-集群中执行相关命令"><a href="#10-集群中执行相关命令" class="headerlink" title="10. 集群中执行相关命令"></a>10. 集群中执行相关命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --cluster call 192.168.1.10:6381 config set requirepass cc<br>redis-cli -a cc --cluster call 192.168.1.10:6381 config set masterauth cc<br>redis-cli -a cc --cluster call 192.168.1.10 config rewrite<br></code></pre></td></tr></table></figure><p> 说明：连接到集群的任意一节点来对整个集群的所有节点进行设置。 </p><p>到此，相关集群的基本操作已经介绍完，现在说明集群迁移的相关操作。</p><p>Redis 6.0 新增了几个命令：</p><p>1，fix 的子命令：–cluster-fix-with-unreachable-masters</p><p>2，call的子命令：–cluster-only-masters、–cluster-only-replicas</p><p>3，集群节点备份：backup</p><h2 id="迁移相关"><a href="#迁移相关" class="headerlink" title="迁移相关"></a>迁移相关</h2><h3 id="在线迁移slot-："><a href="#在线迁移slot-：" class="headerlink" title="在线迁移slot ："></a><strong>在线迁移slot</strong> ：</h3><p>​       在线把集群的一些slot从集群原来slot节点迁移到新的节点，即可以完成集群的在线横向扩容和缩容。有2种方式进行迁移</p><p>一、是根据提示来进行操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">直接连接到集群的任意一节点</span><br>redis-cli -a cc --cluster reshard 192.168.1.10:6379<br></code></pre></td></tr></table></figure><p>​       二、是根据参数进行操作： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -a cc --cluster reshard 192.168.1.10:6379 --cluster-from 117457eab5071954faab5e81c3170600d5192270 --cluster-to 815da8448f5d5a304df0353ca10d8f9b77016b28 --cluster-slots 10 --cluster-yes --cluster-timeout 5000 --cluster-pipeline 10 --cluster-replace<br></code></pre></td></tr></table></figure><p>​       说明：连接到集群的任意一节点来对指定节点指定数量的slot进行迁移到指定的节点。  </p><h3 id="平衡（rebalance）slot-："><a href="#平衡（rebalance）slot-：" class="headerlink" title="平衡（rebalance）slot ："></a>平衡（rebalance）<strong>slot</strong> ：</h3><p>1）  平衡集群中各个节点的slot数量 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -a cc --cluster rebalance 192.168.163.132:6379<br></code></pre></td></tr></table></figure><p>2）根据集群中各个节点设置的权重等平衡slot数量（不执行，只模拟） </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -a cc --cluster rebalance --cluster-weight 117457eab5071954faab5e81c3170600d5192270=5 815da8448f5d5a304df0353ca10d8f9b77016b28=4 56005b9413cbf225783906307a2631109e753f8f=3 --cluster-simulate 192.168.1.10:6379<br></code></pre></td></tr></table></figure><ol start="3"><li> 导入集群 </li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --cluster import 192.168.1.10:6379 --cluster-from 192.168.1.10:9021 --cluster-replace<br></code></pre></td></tr></table></figure><p> 说明：外部Redis实例（9021）导入到集群中的任意一节点。 </p><p> 注意：测试下来发现参数–cluster-replace没有用，如果集群中已经包含了某个key，在导入的时候会失败，不会覆盖，只有清空集群key才能导入。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">*** Importing 97847 keys from DB 0<br>Migrating 9223372011174675807 to 192.168.1.10:6381: Source 192.168.1.10:9021 replied with error:<br>ERR Target instance replied with error: BUSYKEY Target key name already exists<br></code></pre></td></tr></table></figure><p> 并且发现如果集群设置了密码，也会导入失败，需要设置集群密码为空才能进行导入（call）。通过monitor（9021）的时候发现，在migrate的时候需要密码进行auth认证 </p><p><strong>Redis Cluster 通过redis-cli –cluster来创建和管理集群的方式和 redis-trib.rb脚本绝大部分都是一样的，所以对于比较熟悉 redis-trib.rb 脚本的，使用–cluster也非常顺手。</strong> </p><p>参考：</p><hr><p><a href="https://www.cnblogs.com/zhoujinyi/p/11606935.html">https://www.cnblogs.com/zhoujinyi/p/11606935.html</a></p><p><a href="https://www.cnblogs.com/saneri/p/12409173.html">https://www.cnblogs.com/saneri/p/12409173.html</a></p><p>半路雨歌链接：<a href="https://juejin.cn/post/6844904097116585991">https://juejin.cn/post/6844904097116585991</a></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis三种集群模式之哨兵模式</title>
    <link href="/2021/10/06/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/10/06/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p> 主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工 干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑 哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题 。</p><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独 立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例</strong> </p><p><img src="/img/work/1633534256141.png"></p><p> 这里的哨兵有两个作用:</p><ul><li> 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器 </li><li> 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服 务器，修改配置文件，让它们切换主机 </li></ul><p> 然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。 各个哨兵之间还会进行监控，这样就形成了多哨兵模式。 </p><p><img src="/img/work/1633534636100.png"> </p><h3 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2.工作原理"></a>2.工作原理</h3><ol><li>首先主节点的信息是配置在哨兵(Sentinel)的配置文件中</li><li>哨兵节点会和配置的主节点建立起两条连接<code>命令连接</code>和<code>订阅连接</code></li><li>哨兵会通过<code>命令连接</code>每10s发送一次<code>INFO</code>命令，通过<code>INFO命令</code>，主节点会返回自己的run_id和自己的<code>从节点信息</code></li><li>哨兵会对这些从节点也建立两条连接<code>命令连接</code>和<code>订阅连接</code></li><li>哨兵通过<code>命令连接</code>向从节点发送<code>INFO</code>命令，获取到他的一些信息<br>a. run_id<br>b. role<br>c. 从服务器的复制偏移量 offset等</li><li>因为哨兵对与集群中的其他节点(主从节点)当前都有两条连接，<code>命令连接</code>和<code>订阅连接</code><br> a. 通过<code>命令连接</code>向服务器的<code>_sentinel:hello</code>频道发送一条消息，内容包括自己的ip端口、run_id、配置纪元(后续投票的时候会用到)等<br> b. 通过<code>订阅连接</code>对服务器的<code>_sentinel:hello</code>频道做了监听，所以所有的向该频道发送的哨兵的消息都能被接受到<br> c. 解析监听到的消息，进行分析提取，就可以知道还有那些别的哨兵服务节点也在监听这些主从节点了，更新结构体将这些哨兵节点记录下来<br> d. 向观察到的其他的哨兵节点建立<code>命令连接</code>—-没有<code>订阅连接</code></li></ol><h3 id="3-哨兵模式下的故障迁移"><a href="#3-哨兵模式下的故障迁移" class="headerlink" title="3.哨兵模式下的故障迁移"></a>3.哨兵模式下的故障迁移</h3><h4 id="3-2主观下线"><a href="#3-2主观下线" class="headerlink" title="3.2主观下线"></a><strong>3.2主观下线</strong></h4><p>哨兵(Sentinel)节点会每秒一次的频率向建立了命令连接的实例发送PING命令，如果在<code>down-after-milliseconds</code>毫秒内没有做出有效响应包括(PONG/LOADING/MASTERDOWN)以外的响应，哨兵就会将该实例在本结构体中的状态标记为<code>SRI_S_DOWN</code>主观下线</p><h4 id="3-3客观下线"><a href="#3-3客观下线" class="headerlink" title="3.3客观下线"></a><strong>3.3客观下线</strong></h4><p>当一个哨兵节点发现主节点处于主观下线状态是，会向其他的哨兵节点发出询问，该节点是不是已经主观下线了。如果超过配置参数<code>quorum</code>个节点认为是主观下线时，该哨兵节点就会将自己维护的结构体中该主节点标记为<code>SRI_O_DOWN</code>客观下线<br> 询问命令<code>SENTINEL is-master-down-by-addr    </code></p><p><img src="/img/work/1633535070130.png"></p><h4 id="3-4-leader选举"><a href="#3-4-leader选举" class="headerlink" title="3.4 leader选举"></a>3.4 <strong>leader选举</strong></h4><p>在认为主节点<code>客观下线</code>的情况下,哨兵节点间会发起一次选举，命令还是上面的命令<code>SENTINEL is-master-down-by-addr    </code>,只是<code>run_id</code>这次会将<code>自己的run_id</code>带进去，希望接受者将自己设置为主节点。如果超过半数以上的节点返回将该节点标记为leader的情况下，会有该leader对故障进行迁移</p><h4 id="3-5故障迁移"><a href="#3-5故障迁移" class="headerlink" title="3.5故障迁移"></a><strong>3.5故障迁移</strong></h4><ol><li>在从节点中挑选出新的主节点<br> a. 通讯正常<br> b. 优先级排序<br> c. 优先级相同是选择offset最大的</li><li>将该节点设置成新的主节点 <code>SLAVEOF no one</code>,并确保在后续的INGO命令时，该节点返回状态为master</li><li>将其他的从节点设置成从新的主节点复制, <code>SLAVEOF命令</code> </li><li>将旧的主节点变成新的主节点的从节点</li></ol><h3 id="4-部署示例"><a href="#4-部署示例" class="headerlink" title="4.部署示例"></a>4.部署示例</h3><p> 哨兵模式基于前文的主从复制模式。当前示例为一主二从模式</p><p>4.1首先在reids解压后的文件中将sentinel.conf文件复制到redis.conf文件的目录下</p><p><img src="/img/work/1633536145531.png"></p><p>4.2在配置文件中进行如下配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> mymaster定义一个master数据库的名称，后面是master的ip， port，1表示至少需要一个Sentinel进程同意才能将master判断为失效，如果不满足这个条件，则自动故障转移（failover）不会执行</span><br>sentinel monitor mymaster 127.0.0.1 6379 1 <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> master的密码</span><br>sentinel auth-pass mymaster 123456 <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 5s未回复PING，则认为master主观下线，默认为30s</span><br>sentinel down-after-milliseconds mymaster 5000 <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 指定在执行故障转移时，最多可以有多少个slave实例在同步新的master实例，在slave实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长</span><br>sentinel parallel-syncs mymaster 2  <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 如果在该时间（ms）内未能完成故障转移操作，则认为故障转移失败，生产环境需要根据数据量设置该值</span><br>sentinel failover-timeout mymaster 300000 <br></code></pre></td></tr></table></figure><p> <strong>一个哨兵可以监控多个master数据库，只需按上述配置添加多套</strong> </p><p>4.3 分别以26379,36379,46379端口启动三个sentinel </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# redis-sentinel etc/sentinel1.conf <br>[root@centos7 bin]# redis-sentinel etc/sentinel2.conf <br>[root@centos7 bin]# redis-sentinel etc/sentinel3.conf <br></code></pre></td></tr></table></figure><p>4.4测试Master挂掉场景</p><p><img src="/img/work/1633537126366.png"></p><p> 执行 <code>kill -9 4965</code> 将master进程干掉，进入slave中执行 <code>info replication</code>查看 </p><p><strong>哨兵服务输出信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">12292:X 07 Oct 2021 18:56:28.858 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.<br>12292:X 07 Oct 2021 18:56:28.858 # Sentinel ID is 0d12a3731fac0690b3cf55d7a424b8a5c0bb2889<br>12292:X 07 Oct 2021 18:56:28.858 # +monitor master mymaster 127.0.0.1 6380 quorum 1<br>12292:X 07 Oct 2021 18:56:38.924 * +convert-to-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 18:59:29.468 * +fix-slave-config slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.021 # +sdown master mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.021 # +odown master mymaster 127.0.0.1 6380 #quorum 1/1<br>12292:X 07 Oct 2021 19:01:59.021 # +new-epoch 2<br>12292:X 07 Oct 2021 19:01:59.021 # +try-failover master mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.023 # +vote-for-leader 0d12a3731fac0690b3cf55d7a424b8a5c0bb2889 2<br>12292:X 07 Oct 2021 19:01:59.023 # +elected-leader master mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.023 # +failover-state-select-slave master mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.078 # +selected-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.078 * +failover-state-send-slaveof-noone slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.140 * +failover-state-wait-promotion slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:00.090 # +promoted-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:00.090 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:00.157 * +slave-reconf-sent slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:01.134 * +slave-reconf-inprog slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:01.134 * +slave-reconf-done slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:01.220 # +failover-end master mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:01.220 # +switch-master mymaster 127.0.0.1 6380 127.0.0.1 6379<br>12292:X 07 Oct 2021 19:02:01.221 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379<br>12292:X 07 Oct 2021 19:02:01.221 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379<br>12292:X 07 Oct 2021 19:02:06.230 # +sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379<br></code></pre></td></tr></table></figure><p>从以上信息，可以看出6380的master已经被移除，选举出了6379为master。</p><p><strong>如果当我们再次启动6380服务，已经变为从节点</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6380&gt; info replication<br><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:slave #从节点角色<br>master_host:127.0.0.1<br>master_port:6379<br></code></pre></td></tr></table></figure><h3 id="5-优缺点"><a href="#5-优缺点" class="headerlink" title="5.优缺点"></a>5.优缺点</h3><h4 id="5-1优点"><a href="#5-1优点" class="headerlink" title="5.1优点"></a>5.1优点</h4><ol><li> 哨兵集群，基于主从复制模式，所有的主从配置优点，它全有 </li><li> 主从可以切换，故障可以转移，系统的可用性就会更好 </li><li> 哨兵模式就是主从模式的升级，手动到自动，更加健壮！ </li></ol><h4 id="5-2缺点"><a href="#5-2缺点" class="headerlink" title="5.2缺点"></a>5.2缺点</h4><ol><li>同样也继承了主从模式难以在线扩容的缺点，Redis的容量受限于单机配置</li><li>需要额外的资源来启动sentinel进程，实现相对复杂一点，同时slave节点作为备份节点不提供服务</li></ol><h3 id="6-哨兵模式全部配置"><a href="#6-哨兵模式全部配置" class="headerlink" title="6.哨兵模式全部配置"></a>6.哨兵模式全部配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Example sentinel.conf</span><br><span class="hljs-meta">#</span><span class="bash"> 哨兵sentinel实例运行的端口 默认26379</span><br>port 26379<br><span class="hljs-meta">#</span><span class="bash"> 哨兵sentinel的工作目录</span><br>dir /tmp<br><span class="hljs-meta">#</span><span class="bash"> 哨兵sentinel监控的redis主节点的 ip port</span><br><span class="hljs-meta">#</span><span class="bash"> master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符<span class="hljs-string">&quot;.-_&quot;</span>组成。</span><br><span class="hljs-meta">#</span><span class="bash"> quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br>sentinel monitor mymaster 127.0.0.1 6379 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span><br><span class="hljs-meta">#</span><span class="bash"> 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br>sentinel auth-pass mymaster MySUPER--secret-0123passw0rd<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br>sentinel down-after-milliseconds mymaster 30000<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br>sentinel parallel-syncs mymaster 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span><br><span class="hljs-meta">#</span><span class="bash">1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span><br><span class="hljs-meta">#</span><span class="bash">2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span><br><span class="hljs-meta">#</span><span class="bash">3.当想要取消一个正在进行的failover所需要的时间。</span><br><span class="hljs-meta">#</span><span class="bash">4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><br><span class="hljs-meta">#</span><span class="bash"> 默认三分钟</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br>sentinel failover-timeout mymaster 180000<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> SCRIPTS EXECUTION</span><br><span class="hljs-meta">#</span><span class="bash">配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span><br><span class="hljs-meta">#</span><span class="bash">对于脚本的运行结果有以下规则：</span><br><span class="hljs-meta">#</span><span class="bash">若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><br><span class="hljs-meta">#</span><span class="bash">若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><br><span class="hljs-meta">#</span><span class="bash">如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><br><span class="hljs-meta">#</span><span class="bash">一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span><br><span class="hljs-meta">#</span><span class="bash">通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><br><span class="hljs-meta">#</span><span class="bash">通知脚本</span><br><span class="hljs-meta">#</span><span class="bash"> shell编程</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span><br>sentinel notification-script mymaster /var/redis/notify.sh<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 客户端重新配置主节点参数脚本</span><br><span class="hljs-meta">#</span><span class="bash"> 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><br><span class="hljs-meta">#</span><span class="bash"> 以下参数将会在调用脚本时传给脚本:</span><br><span class="hljs-meta">#</span><span class="bash"> &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><span class="hljs-meta">#</span><span class="bash"> 目前&lt;state&gt;总是“failover”,</span><br><span class="hljs-meta">#</span><span class="bash"> &lt;role&gt;是“leader”或者“observer”中的一个。</span><br><span class="hljs-meta">#</span><span class="bash"> 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span><br><span class="hljs-meta">#</span><span class="bash"> 这个脚本应该是通用的，能被多次调用，不是针对性的。</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span><br>sentinel client-reconfig-script mymaster /var/redis/reconfig.sh # 一般都是由运维来配置！<br></code></pre></td></tr></table></figure><p>参考：</p><hr><p>狂神说Java：<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0</a></p><p>半路雨歌：<a href="https://juejin.cn/post/6844904097116585991#heading-1">https://juejin.cn/post/6844904097116585991#heading-1</a></p><p><a href="https://www.jianshu.com/p/d6d2325a5ec7">https://www.jianshu.com/p/d6d2325a5ec7</a></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis三种集群模式之主从复制</title>
    <link href="/2021/10/06/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <url>/2021/10/06/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader),后者称为从节点(slave/flollower);<strong>数据的复制是单向的，只能由主节点到从节点，Master以写为主，Slave以读为主</strong>。</p><h3 id="1-1主从复制的作用主要包括："><a href="#1-1主从复制的作用主要包括：" class="headerlink" title="1.1主从复制的作用主要包括："></a>1.1主从复制的作用主要包括：</h3><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 （即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写 少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li>高可用(集群)基石： 除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复 制是Redis高可用的基础 </li></ol><p><strong>注意：如redis运用于工程项目中，不能使用单机redis，原因如下：</strong></p><ol><li> 从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大。</li><li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存为256G，也不能将所有内存作用于Redis存储内存，一般单台Redis最大使用内存不应该超过20G。</li></ol><p>一般结构架构如下：</p><p><img src="/img/work/1633523383473.png"></p><h2 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2.基本原理"></a>2.基本原理</h2><p> 主从复制模式中包含一个主数据库实例(master)与一个或多个从数据库实例(slave)，客户端可对主数据库进行读写操作，对从数据库进行读操作，主数据库写入的数据会实时自动同步给从数据库 </p><h3 id="2-1复制原理图"><a href="#2-1复制原理图" class="headerlink" title="2.1复制原理图"></a>2.1复制原理图</h3><p><img src="/img/work/1633524169754.png"></p><h3 id="2-3具体步骤"><a href="#2-3具体步骤" class="headerlink" title="2.3具体步骤"></a>2.3具体步骤</h3><ol><li> 从服务器连接主服务器，发送SYNC命令 ；</li><li> 主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；</li><li> 主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；  </li><li>  从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； </li><li> 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； </li><li>  从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令； </li></ol><h2 id="3-部署示例"><a href="#3-部署示例" class="headerlink" title="3.部署示例"></a>3.部署示例</h2><p>只配置从库，不用配置主库，主库具体配置，可以参考前面文章《Redis.Conf详解》及《Redis持久化》,我这里配置的是<strong>一主两从</strong></p><h3 id="3-1-查看主库信息"><a href="#3-1-查看主库信息" class="headerlink" title="3.1 查看主库信息"></a>3.1 查看主库信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看当前库的信息</span><br>127.0.0.1:6379&gt;info replication<br><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:master  #角色<br>connected_slaves:0  #从机信息<br>master_failover_state:no-failover<br>master_replid:e3d0ce67427f5c928650af42bc66dd0c294f5dbe<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:0<br>second_repl_offset:-1<br>repl_backlog_active:0<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:0<br>repl_backlog_histlen:0<br><br></code></pre></td></tr></table></figure><h3 id="2-2-配置文件"><a href="#2-2-配置文件" class="headerlink" title="2.2 配置文件"></a>2.2 配置文件</h3><ol><li><p>复制三个redis.conf文件，然后修改对应信息，例如slave1.conf,slave2.conf</p></li><li><p>分别修改端口信息</p></li><li><p>分别修改配置文件中pid名称</p></li><li><p>分别修改log文件名称</p></li><li><p>分别修改dump.rdb名称</p></li></ol><h3 id="3-3-启动服务"><a href="#3-3-启动服务" class="headerlink" title="3.3 启动服务"></a>3.3 启动服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# redis-server etc/slave1.conf #启动从库1<br>[root@centos7 bin]# redis-server etc/slave2.conf #启动从库2<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查看redis服务信息</span><br>[root@centos7 bin]# ps -ef | grep redis<br>root       2766      1  0 05:33 ?        00:00:02 redis-server 127.0.0.1:6379 <br>root       3250      1  0 06:05 ?        00:00:00 redis-server 127.0.0.1:6380<br>root       3263      1  0 06:05 ?        00:00:00 redis-server 127.0.0.1:6381<br>root       3293   2715  0 06:09 pts/1    00:00:00 grep --color=auto redis<br><br></code></pre></td></tr></table></figure><h3 id="3-4-一主两从命令方式设置"><a href="#3-4-一主两从命令方式设置" class="headerlink" title="3.4 一主两从命令方式设置"></a>3.4 一主两从命令方式设置</h3><p> 默认情况下，每台Redis服务器都是主节点 ，一般我们配置从机即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">分别登录从服务器</span><br>[root@centos7 bin]# redis-cli -p 6380<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">设置主master,也就找那一台当主节点</span><br>127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379  #寻找主节点，找谁当老大<br>OK<br><br>127.0.0.1:6380&gt; INFO replication<br><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:slave  # 当前角色是从机<br>master_host:127.0.0.1 # 可以的看到主机的信息<br>master_port:6379  #主机端口<br>master_link_status:down<br>master_last_io_seconds_ago:-1<br>master_sync_in_progress:0<br>slave_repl_offset:1<br>master_link_down_since_seconds:-1<br>slave_priority:100<br>slave_read_only:1<br>replica_announced:1<br>connected_slaves:0<br>master_failover_state:no-failover<br>master_replid:449ba98d5fcd3c32154dfd049716ce5ca3ee4d4b<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:0<br>second_repl_offset:-1<br>repl_backlog_active:0<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:0<br>repl_backlog_histlen:0<br></code></pre></td></tr></table></figure><p>回到6379中查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:master<br>connected_slaves:1 #一个从节点<br>slave0:ip=127.0.0.1,port=6380,state=online,offset=28,lag=0  #从节点信息<br>master_failover_state:no-failover<br>master_replid:b717806873adac0ac99646e873b92a744d2406df<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:28<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:28<br></code></pre></td></tr></table></figure><p>第二个从节点根据上面配置即可</p><p><strong>注意：使用命令方式配置只是暂时的，重启服务即失效，推荐在配置文件中配置</strong></p><h3 id="3-5-一主两从配置文件方式设置（推荐）"><a href="#3-5-一主两从配置文件方式设置（推荐）" class="headerlink" title="3.5 一主两从配置文件方式设置（推荐）"></a>3.5 一主两从配置文件方式设置（推荐）</h3><p>在从数据配置文件中添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">replicaof 127.0.0.1 6379 # master的ip，port<br>masterauth 123456 # master的密码<br>replica-serve-stale-data no # 如果slave无法与master同步，设置成slave不可读，方便监控脚本发现问题<br></code></pre></td></tr></table></figure><p>分别启动两个从服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# redis-server etc/slave1.conf <br>[root@centos7 bin]# redis-server etc/slave2.conf <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">然后再在主服务器输入以下信息即可查看到两个从服务器信息</span><br>127.0.0.1:6379&gt; INFO replication<br><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:master<br>connected_slaves:2  #两个从数据库<br>slave0:ip=127.0.0.1,port=6380,state=online,offset=1008,lag=1<br>slave1:ip=127.0.0.1,port=6381,state=online,offset=1008,lag=1<br>master_failover_state:no-failover<br>master_replid:b717806873adac0ac99646e873b92a744d2406df<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:1008<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:1008<br></code></pre></td></tr></table></figure><blockquote><p>数据测试</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">主数据库写</span><br>127.0.0.1:6379&gt; set k1 v1<br>OK<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">从数据读</span><br>127.0.0.1:6380&gt; get k1<br>&quot;v1&quot;<br></code></pre></td></tr></table></figure><blockquote><p>细节</p></blockquote><p> 主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动被从机保存！ </p><p>主机写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set k1 v1<br>OK<br></code></pre></td></tr></table></figure><p>从机写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6380&gt; set k1 v1<br>(error) READONLY You can&#x27;t write against a read only replica. #不能写入<br><br></code></pre></td></tr></table></figure><h2 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4.优缺点"></a>4.优缺点</h2><h3 id="4-1优点"><a href="#4-1优点" class="headerlink" title="4.1优点"></a>4.1优点</h3><ul><li>master能自动将数据同步到slave，可以进行读写分离，分担master的读压力</li><li>master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求</li></ul><h3 id="4-2缺点"><a href="#4-2缺点" class="headerlink" title="4.2缺点"></a>4.2缺点</h3><ul><li>不具备自动容错与恢复功能，master或slave的宕机都可能导致客户端请求失败，需要等待机器重启或手动切换客户端IP才能恢复</li><li>master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题</li><li>难以支持在线扩容，Redis的容量受限于单机配置</li></ul><p>参考：</p><hr><p>狂神说Java：<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0</a></p><p>半路雨歌：<a href="https://juejin.cn/post/6844904097116585991#heading-1">https://juejin.cn/post/6844904097116585991#heading-1</a></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis持久化</title>
    <link href="/2021/09/30/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2021/09/30/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://redis.io/">Redis</a>有两种持久化的方式：快照（<code>RDB</code>文件）和追加式文件（<code>AOF</code>文件）：</p><ul><li>RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。</li><li>AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。</li><li>Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。</li><li>两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。</li></ul><h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><blockquote><p>工作原理</p></blockquote><ul><li>Redis调用fork()，产生一个子进程</li><li>子进程把数据写到一个临时的RDB文件</li><li>当子进程写完新的RDB文件后，把旧的RDB文件替换掉</li></ul><p><img src="/img/work/image-20210930171854270.png"></p><p>一般在主从复制中,rdb做备用在从机上</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>RDB文件是一个很简洁的单文件，它保存了某个时间点的Redis数据，很适合用于做备份。你可以设定一个时间点对RDB文件进行归档，这样就能在需要的时候很轻易的把数据恢复到不同的版本</li><li>基于上面所描述的特性，RDB很适合用于灾备。单文件很方便就能传输到远程的服务器上</li><li>RDB的性能很好，需要进行持久化时，主进程会fork一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的I/O操作</li><li>比起AOF，在数据量比较大的情况下，RDB的启动速度更快</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>RDB容易造成数据的丢失。假设每5分钟保存一次快照，如果Redis因为某些原因不能正常工作，那么从上次产生快照到Redis出现问题这段时间的数据就会丢失了</li><li>RDB使用<code>fork()</code>产生子进程进行数据的持久化，如果数据比较大的话可能就会花费点时间，造成Redis停止服务几毫秒。如果数据量很大且CPU性能不是很好的时候，停止服务的时间甚至会到1秒</li></ol><h3 id="文件路径和名称"><a href="#文件路径和名称" class="headerlink" title="文件路径和名称"></a>文件路径和名称</h3><p>默认Redis会把快照文件存储为当前目录下一个名为<code>dump.rdb</code>的文件。要修改文件的存储路径和名称，可以通过修改配置文件<code>redis.conf</code>实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> RDB文件名，默认为dump.rdb。</span><br>dbfilename dump.rdb<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 文件存放的目录，AOF文件同样存放在此目录下。默认为当前工作目录。</span><br>dir ./<br></code></pre></td></tr></table></figure><h3 id="保存点（RDB的启用和禁用）"><a href="#保存点（RDB的启用和禁用）" class="headerlink" title="保存点（RDB的启用和禁用）"></a>保存点（RDB的启用和禁用）</h3><p>可以配置保存点，使Redis如果在每N秒后数据发生了M次改变就保存快照文件。例如下面这个保存点配置表示每60秒，如果数据发生了1000次以上的变动，Redis就会自动保存快照文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">save &lt;seconds&gt; &lt;changes&gt; 格式</span><br>save 60 1000   #60S内如果1000个key发生了修改，Redis就会自动保存快照文件<br></code></pre></td></tr></table></figure><p>保存点可以设置多个，Redis的配置文件就默认设置了3个保存点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 可以设置多个</span><br>save 900 1 #900秒后至少1个key有变动<br>save 300 10 #300秒后至少10个key有变动<br>save 60 10000 #60秒后至少10000个key有变动<br></code></pre></td></tr></table></figure><p>如果想禁用快照保存的功能，可以通过注释掉所有”save”配置达到，或者在最后一条”save”配置后添加如下的配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">save &quot;&quot;<br></code></pre></td></tr></table></figure><blockquote><p>触发机制说明</p></blockquote><ol><li>save的规则满足的情况下，会自动触发rdb规则</li><li>执行 flushall 命令，也会触发rdb规则！</li><li>退出redis，也会产生 rdb 文件</li></ol><blockquote><p>如何恢复rdb文件</p></blockquote><ol><li>只需要将rdb文件放在redis启动目录即可，redis启动的时候会自动检查dump.rdb 恢复其中 的数据</li><li>查看存放目录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; config get dir<br>1) &quot;dir&quot;<br>2) &quot;/usr/local/bin&quot; # 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据<br></code></pre></td></tr></table></figure><h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>快照并不是很可靠。如果你的电脑突然宕机了，或者电源断了，又或者不小心杀掉了进程，那么最新的数据就会丢失。而AOF文件则提供了一种更为可靠的持久化方式。每当Redis接受到会修改数据集的命令时，就会把命令追加到AOF文件里，当你重启Redis时，AOF里的命令会被重新执行一次，重建数据。</p><blockquote><p>工作原理</p></blockquote><p><img src="/img/work/image-20210930180234429.png"></p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol><li>比RDB可靠。你可以制定不同的fsync策略：不进行fsync、每秒fsync一次和每次查询进行fsync。默认是每秒fsync一次。这意味着你最多丢失一秒钟的数据。</li><li>AOF日志文件是一个纯追加的文件。就算是遇到突然停电的情况，也不会出现日志的定位或者损坏问题。甚至如果因为某些原因（例如磁盘满了）命令只写了一半到日志文件里，我们也可以用<code>redis-check-aof</code>这个工具很简单的进行修复</li><li> 当AOF文件太大时，Redis会自动在后台进行重写。重写很安全，因为重写是在一个新的文件上进行，同时Redis会继续往旧的文件追加数据。新文件上会写入能重建当前数据集的最小操作命令的集合。当新文件重写完，Redis会把新旧文件进行切换，然后开始把数据写到新文件上 </li><li> AOF把操作命令以简单易懂的格式一条接一条的保存在文件里，很容易导出来用于恢复数据。例如我们不小心用<code>FLUSHALL</code>命令把所有数据刷掉了，只要文件没有被重写，我们可以把服务停掉，把最后那条命令删掉，然后重启服务，这样就能把被刷掉的数据恢复回来 </li></ol><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li> 在相同的数据集下，AOF文件的大小一般会比RDB文件大 </li><li> 在某些fsync策略下，AOF的速度会比RDB慢。通常fsync设置为每秒一次就能获得比较高的性能，而在禁止fsync的情况下速度可以达到RDB的水平 </li><li> 在过去曾经发现一些很罕见的BUG导致使用AOF重建的数据跟原数据不一致的问题 </li></ol><h3 id="启用AOF"><a href="#启用AOF" class="headerlink" title="启用AOF"></a>启用AOF</h3><p> 把配置项<code>appendonly</code>设为<code>yes</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">设置开启aof</span><br>appendonly yes<br></code></pre></td></tr></table></figure><h3 id="文件路径和名称-1"><a href="#文件路径和名称-1" class="headerlink" title="文件路径和名称"></a>文件路径和名称</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 文件存放目录，与RDB共用。默认为当前工作目录。</span><br>dir ./<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 默认文件名为appendonly.aof</span><br>appendfilename &quot;appendonly.aof&quot;<br></code></pre></td></tr></table></figure><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p> 你可以配置Redis调用fsync的频率，有三个选项： </p><ol><li>每当有新命令追加到AOF的时候调用fsync。速度最慢，但是最安全</li><li> 每秒fsync一次。速度快（2.4版本跟快照方式速度差不多），安全性不错（最多丢失1秒的数据） </li><li> 从不fsync，交由系统去处理。这个方式速度最快，但是安全性一般 </li></ol><p> 推荐使用每秒fsync一次的方式（默认的方式），因为它速度快，安全性也不错。相关配置如下： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> appendfsync always</span><br>appendfsync everysec<br><span class="hljs-meta">#</span><span class="bash"> appendfsync no</span><br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="日志重写"><a href="#日志重写" class="headerlink" title="日志重写"></a>日志重写</h3><p>​       随着写操作的不断增加，AOF文件会越来越大。例如你递增一个计数器100次，那么最终结果就是数据集里的计数器的值为最终的递增结果，但是AOF文件里却会把这100次操作完整的记录下来。而事实上要恢复这个记录，只需要1个命令就行了，也就是说AOF文件里那100条命令其实可以精简为1条。所以Redis支持这样一个功能：在不中断服务的情况下在后台重建AOF文件 </p><p> <strong>工作原理如下 :</strong></p><ol><li> Redis调用fork()，产生一个子进程 </li><li> 子进程把新的AOF写到一个临时文件里 </li><li> 主进程持续把新的变动写到内存里的buffer，同时也会把这些新的变动写到旧的AOF里，这样即使重写失败也能保证数据的安全 </li><li> 当子进程完成文件的重写后，主进程会获得一个信号，然后把内存里的buffer追加到子进程生成的那个新AOF里 </li></ol><p><strong>我们可以通过配置设置日志重写的条件：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Redis会记住自从上一次重写后AOF文件的大小（如果自Redis启动后还没重写过，则记住启动时使用的AOF文件的大小）。</span><br><span class="hljs-meta">#</span><span class="bash"> 如果当前的文件大小比起记住的那个大小超过指定的百分比，则会触发重写。</span><br><span class="hljs-meta">#</span><span class="bash"> 同时需要设置一个文件大小最小值，只有大于这个值文件才会重写，以防文件很小，但是已经达到百分比的情况。</span><br><br>auto-aof-rewrite-percentage 100<br>auto-aof-rewrite-min-size 64mb<br></code></pre></td></tr></table></figure><p> 要禁用自动的日志重写功能，我们可以把百分比设置为0： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">auto-aof-rewrite-percentage 0<br></code></pre></td></tr></table></figure><p><strong>Redis 2.4以上才可以自动进行日志重写，之前的版本需要手动运行<a href="http://redis.io/commands/bgrewriteaof">BGREWRITEAOF</a>这个命令。</strong> </p><h3 id="数据损坏修复"><a href="#数据损坏修复" class="headerlink" title="数据损坏修复"></a>数据损坏修复</h3><p> 如果因为某些原因（例如服务器崩溃）AOF文件损坏了，导致Redis加载不了，可以通过以下方式进行修复： </p><ul><li> 备份AOF文件 </li><li> 使用<code>redis-check-aof</code>命令修复原始的AOF文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-check-aof --fix   aof文件<br></code></pre></td></tr></table></figure><ul><li> 可以使用<code>diff -u</code>命令看下两个文件的差异 </li><li> 使用修复过的文件重启Redis服务 </li></ul><h3 id="从RDB切换到AOF"><a href="#从RDB切换到AOF" class="headerlink" title="从RDB切换到AOF"></a>从RDB切换到AOF</h3><p> 这里只说Redis &gt;= 2.2版本的方式： </p><ul><li><p>备份一个最新的<code>dump.rdb</code>的文件，并把备份文件放在一个安全的地方。</p></li><li><p>运行以下两条命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ redis-cli<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span> appendonly <span class="hljs-literal">yes</span><br>$ redis-cli<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span> save <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>确保数据跟切换前一致。</p></li><li><p>确保数据正确的写到AOF文件里。</p></li></ul><p><strong>第二条命令是用来禁用RDB的持久化方式，但是这不是必须的，因为你可以同时启用两种持久化方式。</strong></p><p><strong>记得对配置文件<code>redis.conf</code>进行编辑启用AOF，因为命令行方式修改配置在重启Redis后就会失效。</strong></p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h3 id="建议的备份方法："><a href="#建议的备份方法：" class="headerlink" title="建议的备份方法："></a>建议的备份方法：</h3><ul><li>创建一个定时任务，每小时和每天创建一个快照，保存在不同的文件夹里。</li><li>定时任务运行时，把太旧的文件进行删除。例如只保留48小时的按小时创建的快照和一到两个月的按天创建的快照。</li><li>每天确保一次把快照文件传输到数据中心外的地方进行保存，至少不能保存在Redis服务所在的服务器。</li></ul><p>参考：</p><hr><p>​      <a href="https://segmentfault.com/a/1190000002906345">https://segmentfault.com/a/1190000002906345</a></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis.conf详解</title>
    <link href="/2021/09/29/redis-conf%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/09/29/redis-conf%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>以下将从配置文件中顺序往下讲解</strong>,<strong>涉及主从复制，持久化将会另起讲解</strong></p><h4 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h4><p><img src="/img/work/1632924192904.png"></p><p>1.配置文件unit单位大小写不敏感</p><h4 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h4><p><img src="/img/work/1632924269484.png"></p><p>类似我们nginx中的include中的包含文件</p> <span id="more"></span><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">bind 127.0.0.1 # 绑定的ip<br>protected-mode yes # 保护模式<br>port 6379 #端口设置<br></code></pre></td></tr></table></figure><h4 id="通用-GENERAL"><a href="#通用-GENERAL" class="headerlink" title="通用 GENERAL"></a>通用 GENERAL</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"> daemonize yes #以守护进程的方式运行，默认是no，当我们需要后台启动时需要我们手动设置为yes<br> <br> pidfile /var/run/redis_6379.pid  #如果我们以后台方式运行，我们就需要指定一个pid文件<br> <br><span class="hljs-meta"> </span><br><span class="hljs-meta">#</span><span class="bash">日志</span> <br><span class="hljs-meta">#</span><span class="bash"> Specify the server verbosity level.</span><br><span class="hljs-meta">#</span><span class="bash">ze yes This can be one of:</span><br><span class="hljs-meta">#</span><span class="bash"> debug (a lot of information, useful <span class="hljs-keyword">for</span> development/testing)</span><br><span class="hljs-meta">#</span><span class="bash"> verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="hljs-meta">#</span><span class="bash"> notice (moderately verbose, what you want <span class="hljs-keyword">in</span> production probably) 生产环境</span><br><span class="hljs-meta">#</span><span class="bash"> warning (only very important / critical messages are logged)</span><br>loglevel notice<br><br>logfile &quot;&quot; #日志的文件位置名<br><br>databases 16  #数据库的数量，默认是16个数据库<br><br>always-show-logo no #是否总是显示日志<br><br> <br></code></pre></td></tr></table></figure><h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p><strong>持久化，在规定的时间内，执行了多少次操作，则会持久化到文件.rdb.aof</strong>, <strong>redis是内存数据库,如果没有持久化，那么数据断电即丢失</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">如果3600s内，如果至少有一个key进行了修改，即进行持久化操作</span><br>save 3600 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">如果300S内，如果至少300S内，至少有10个可以进行了修改，即进行持久化操作</span><br>save 300 10<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">如果60S内，如果至少10000个进行了修改，即进行持久化操作</span><br>save 60 10000<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">后续持久化配置需要用到这里</span><br><br>stop-writes-on-bgsave-error yes #持久化如果出错，是否继续持久化<br><br>rdbcompression yes #是否压缩rdb文件,会消耗一些CPU资源<br><br>rdbchecksum yes  #保存rdb文件的时候，进行错误的核查校验！<br><br>dbfilename dump.rdb # 指定本地数据库文件名，一般采用默认的 dump.rdb<br><br>dir ./  #指定本地数据库存放目录，一般也用默认配置<br><br><br><br><br><br></code></pre></td></tr></table></figure><h4 id="SECURITY-安全"><a href="#SECURITY-安全" class="headerlink" title="SECURITY 安全"></a>SECURITY 安全</h4><p><img src="/img/work/1632927510924.png"></p><p> <strong>可以在这里设置redis的密码，默认是没有密码！</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">               <br>requirepass 123456  #设置密码，设置后需要重启服务才有效,这里设置的是123456<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">当我们登录之后，执行命令将会出现以下提示需要认证</span><br>(error) NOAUTH Authentication required.<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">认证即可正常操作</span><br>127.0.0.1:6379&gt; auth 123456<br>OK<br><br>127.0.0.1:6379&gt; set k1 v1<br>OK<br>127.0.0.1:6379&gt; get k1<br>&quot;v1&quot;<br><br></code></pre></td></tr></table></figure><h4 id="限制-CLIENTS"><a href="#限制-CLIENTS" class="headerlink" title="限制 CLIENTS"></a>限制 CLIENTS</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>maxclients 10000  #设置能连接上redis的最大客户端的数量<br><br>maxmemory &lt;bytes&gt; #redis配置最大的内存容量<br><br><br><br>maxmemory-policy noeviction # 内存达到上限后的处理策略<br><span class="hljs-meta">#</span><span class="bash"> volatile-lru -&gt; Evict using approximated LRU, only keys with an expire <span class="hljs-built_in">set</span>.</span><br><span class="hljs-meta">#</span><span class="bash"> allkeys-lru -&gt; Evict any key using approximated LRU.</span><br><span class="hljs-meta">#</span><span class="bash"> volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire <span class="hljs-built_in">set</span>.</span><br><span class="hljs-meta">#</span><span class="bash"> allkeys-lfu -&gt; Evict any key using approximated LFU.</span><br><span class="hljs-meta">#</span><span class="bash"> volatile-random -&gt; Remove a random key having an expire <span class="hljs-built_in">set</span>.</span><br><span class="hljs-meta">#</span><span class="bash"> allkeys-random -&gt; Remove a random key, any key.</span><br><span class="hljs-meta">#</span><span class="bash"> volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span><br><span class="hljs-meta">#</span><span class="bash"> noeviction -&gt; Don<span class="hljs-string">&#x27;t evict anything, just return an error on write operations.</span></span><br>        1. volatile-lru: 只对设置了过期时间的key进行LRU(默认值)<br>        2. allkeys-lru： 删除lru算法的key<br>        3. volatile-random：随机删除即将过期key<br>        4. allkeys-random：随机删除<br>        5. volatile-ttl： 删除即将过期的<br>        6. noeviction ： 永不过期，返回错误<br>        7. volatile-lfu：使用近似 LFU 驱逐，只有设置过期的键<br><br></code></pre></td></tr></table></figure><h4 id="APPEND-ONLY-模式-aof配置"><a href="#APPEND-ONLY-模式-aof配置" class="headerlink" title="APPEND ONLY 模式 aof配置"></a>APPEND ONLY 模式 aof配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">appendonly no #默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！<br>appendfilename &quot;appendonly.aof&quot; #持久化名称<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> appendfsync always   <span class="hljs-comment">#每次修改都会sync。消耗性能</span></span><br>appendfsync everysec   #每秒执行一次sync，可能会丢失这1S的数据<br><span class="hljs-meta">#</span><span class="bash"> appendfsync no       <span class="hljs-comment">#不执行 sync，这个时候操作系统自己同步数据，速度最快！</span></span><br></code></pre></td></tr></table></figure><p>参考：</p><p>​       B站狂神说Java:<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0</a></p><p>​      Redis.Conf配置文件</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis事务</title>
    <link href="/2021/09/28/Redis%E4%BA%8B%E5%8A%A1/"/>
    <url>/2021/09/28/Redis%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>事务</p></blockquote><p> redis单条命令是原子性的，但是事务不保证原子性 </p><p>redis事务本质：一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行的过程中，会按照顺序执行</p><p> <strong>一次性、顺序性、排他性</strong>！执行一系列命令！ </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">------ 队列 set set set 执行------<br></code></pre></td></tr></table></figure><p> <strong>事务没有隔离级别的概念</strong> </p><p>所有的命令在事务中，并没有被执行！只有发起执行的命令的时候才会执行！Exec</p><p><strong>Redis单条命令式保存原子性的，但是事务不保证原子性！</strong></p><p>redis事务:</p><ul><li>开始事务(multi)</li><li>命令入队(。。）</li><li>执行事务(exec)</li></ul> <span id="more"></span><blockquote><p>正常执行事务</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi # 开启事务<br>OK<br><span class="hljs-meta">#</span><span class="bash"> 命令入队</span><br>127.0.0.1:6379&gt; set k1 v1<br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; get k2<br>QUEUED<br>127.0.0.1:6379&gt; set k3 v3<br>QUEUED<br>127.0.0.1:6379&gt; exec # 执行事务<br>1) OK<br>2) OK<br>3) &quot;v2&quot;<br>4) OK<br></code></pre></td></tr></table></figure><blockquote><p>放弃事务</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; set key1 v1<br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2 <br>QUEUED<br>127.0.0.1:6379&gt; set k3 v3<br>QUEUED<br>127.0.0.1:6379&gt; set k4 v4<br>QUEUED<br>127.0.0.1:6379&gt; DISCARD  # 取消事务<br>OK<br>127.0.0.1:6379&gt; GET k4  # 事务队列中命令都不会被执行<br>(nil)<br></code></pre></td></tr></table></figure><blockquote><p> 编译型异常(代码有问题，命令有错误)，事务中所有的命令都不会被执行 </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; MULTI <br>OK<br>127.0.0.1:6379&gt; set k1 v1 <br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2 <br>QUEUED<br>127.0.0.1:6379&gt; set k3 v3 <br>QUEUED<br>127.0.0.1:6379&gt; getset k3  # 错误的命令<br>(error) ERR wrong number of arguments for &#x27;getset&#x27; command<br>127.0.0.1:6379&gt; et k4 v4  # 错误的命令<br>(error) ERR unknown command `et`, with args beginning with: `k4`, `v4`, <br>127.0.0.1:6379&gt; set k4 v4<br>QUEUED<br>127.0.0.1:6379&gt; exec<br>(error) EXECABORT Transaction discarded because of previous errors.<br>127.0.0.1:6379&gt; get k4 # 所有的命令都不会被执行！<br>(nil)<br></code></pre></td></tr></table></figure><blockquote><p> 运行时异常（1/0）， 如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行 的，错误命令抛出异常！  </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set k1 &quot;v1&quot;<br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; incr k1 # 会执行的时候失败！<br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; set k3 v3<br>QUEUED<br>127.0.0.1:6379&gt; get k3<br>QUEUED<br>127.0.0.1:6379&gt; exec<br>1) (error) ERR value is not an integer or out of range # 虽然第一条命令报错了，但是<br>依旧正常执行成功了！<br>2) OK<br>3) OK<br>4) &quot;v3&quot;<br>127.0.0.1:6379&gt; get k2<br>&quot;v2&quot;<br>127.0.0.1:6379&gt; get k3<br>&quot;v3&quot;<br></code></pre></td></tr></table></figure><blockquote><p> 监控！ Watch （面试常问！）  </p></blockquote><p> <strong>悲观锁</strong>：</p><ul><li>很悲观，认为什么时候都会出问题，无论做什么都会加锁！ </li></ul><p> 乐观锁： </p><ul><li> 很乐观，认为什么时候都不会出问题，所以不会上锁！ 更新数据的时候去判断一下，在此期间是否 有人修改过这个数据， 获取version </li><li> 更新的时候比较 version</li></ul><blockquote><p> Redis测监视测试 </p></blockquote><p> 正常执行成功！ </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set money 100<br>OK<br>127.0.0.1:6379&gt; set out 0<br>OK<br>127.0.0.1:6379&gt; watch money # 监视 money 对象<br>OK<br>127.0.0.1:6379&gt; multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！<br>OK<br>127.0.0.1:6379&gt; DECRBY money 20<br>QUEUED<br>127.0.0.1:6379&gt; INCRBY out 20<br>QUEUED<br>127.0.0.1:6379&gt; exec<br>1) (integer) 80<br>2) (integer) 20<br></code></pre></td></tr></table></figure><p> 测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！ </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; watch money # 监视 money<br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; DECRBY money 10<br>QUEUED<br>127.0.0.1:6379&gt; INCRBY out 10<br>QUEUED<br>127.0.0.1:6379&gt; exec # 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失<br>败！<br>(nil)<br></code></pre></td></tr></table></figure><p> 如果修改失败，获取最新的值就好  </p><p>参考：<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=8440565446323209776&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=8440565446323209776&amp;spm_id_from=333.337.0.0</a></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis的三种特殊类型</title>
    <link href="/2021/09/26/Redis%E7%9A%84%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/09/26/Redis%E7%9A%84%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial 地理位置"></a>Geospatial 地理位置</h3><p><strong>朋友的定位，附近的人，打车距离计算？ Redis 的 Geo 在Redis3.2 版本就推出了！ 这个功能可以推算地理位置的信息，两地之间的距离，方圆 几里的人！</strong> </p> <span id="more"></span><p>官方文档：<a href="https://www.redis.net.cn/order/3685.html">https://www.redis.net.cn/order/3685.html</a></p><p>从官网中我们可以看到此数据类型只有<strong>六个命令</strong></p><p><img src="/img/work/1632661034050.png"></p><p>下面就分别举例来做介绍</p><blockquote><h4 id="GEOADD"><a href="#GEOADD" class="headerlink" title="GEOADD"></a><strong>GEOADD</strong></h4></blockquote><p>官方说明：将指定的地理空间位置（纬度、经度、名称）添加到指定的key中</p><p> 该命令以采用标准格式的参数x,y,所以经度必须在纬度之前 ， 规定有如下</p><ol><li> 有效的经度从-180度到180度 </li><li>有效的纬度从-85.05112878度到85.05112878度。</li><li> 当坐标位置超出上述指定范围时，该命令将会返回一个错误。 </li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">geo使用举例</span><br><span class="hljs-meta">#</span><span class="bash">通过百度坐标拾取可以获取指定城市坐标 106.680848,26.642216 当前我获取的是自己所在城市的坐标</span><br>127.0.0.1:6379&gt; GEOADD china:city 106.680848 26.642216 guiyang<br>(integer) 1<br><br>127.0.0.1:6379&gt; GEOADD china:city 121.466742 31.231236 shanghai<br>(integer) 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">可以同时添加多个坐标</span><br>127.0.0.1:6379&gt; GEOADD china:city 114.100924 22.675499 shengzhen  106.561887 29.564724 chongqing<br>(integer) 2<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>GEOPOS</strong>  </p></blockquote><p> 从<code>key</code>里返回所有给定位置元素的位置（经度和纬度） </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">需要先指定</span><br>127.0.0.1:6379&gt; GEOPOS china:city shanghai shengzhen<br>1) 1) &quot;121.46674007177352905&quot;<br>   2) &quot;31.23123598368359666&quot;<br>2) 1) &quot;114.10092204809188843&quot;<br>   2) &quot;22.6755001616335008&quot;<br></code></pre></td></tr></table></figure><blockquote><p> <strong>GEODIST</strong> </p></blockquote><p>获取两个给定位置之间的距离, 如果两个位置之间的其中一个不存在， 那么命令返回空值 </p><p>指定单位的参数 unit 必须是以下单位的其中一个：</p><ul><li><strong>m</strong> 表示单位为米。</li><li><strong>km</strong> 表示单位为千米。</li><li><strong>mi</strong> 表示单位为英里。</li><li><strong>ft</strong> 表示单位为英尺。</li></ul><p>如果用户没有显式地指定单位参数， 那么 <code>GEODIST</code> 默认使用米作为单位。</p><p><code>GEODIST</code> 命令在计算距离时会假设地球为完美的球形， 在极限情况下， 这一假设最大会造成 0.5% 的误差。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">输入两个城市  并指定计量单位 这里指定的km</span><br>127.0.0.1:6379&gt; GEODIST china:city shanghai chongqing km<br>&quot;1440.7483&quot;<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>GEORADIUS</strong></p></blockquote><p>给定的经纬度为中心， 找出某一半径内的元素</p><p>范围可以使用以下其中一个单位：</p><ul><li><strong>m</strong> 表示单位为米。</li><li><strong>km</strong> 表示单位为千米。</li><li><strong>mi</strong> 表示单位为英里。</li><li><strong>ft</strong> 表示单位为英尺。</li></ul><p>在给定以下可选项时， 命令会返回额外的信息：</p><ul><li><code>WITHDIST</code>: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</li><li><code>WITHCOORD</code>: 将位置元素的经度和维度也一并返回。</li><li><code>WITHHASH</code>: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</li></ul><p>命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式：</p><ul><li><code>ASC</code>: 根据中心的位置， 按照从近到远的方式返回位置元素。</li><li><code>DESC</code>: 根据中心的位置， 按照从远到近的方式返回位置元素。</li></ul><p>例如：</p><p> 我附近的人？ （获得所有附近的人的地址，定位！）通过半径来查询！ 获得指定数量的人</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">以110，30 这个经度为中心寻找方圆一千公里以内的城市</span><br>127.0.0.1:6379&gt; GEORADIUS china:city  110 30 1000 km<br>1) &quot;guiyang&quot;<br>2) &quot;chongqing&quot;<br>3) &quot;shengzhen&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 将具体距离、经纬度信息也一并返回</span><br>127.0.0.1:6379&gt; GEORADIUS china:city  110 30 1000 km WITHCOORD WITHDIST<br>1) 1) &quot;guiyang&quot;<br>   2) &quot;495.0114&quot;<br>   3) 1) &quot;106.68084830045700073&quot;<br>      2) &quot;26.64221710938331711&quot;<br>2) 1) &quot;chongqing&quot;<br>   2) &quot;335.3982&quot;<br>   3) 1) &quot;106.56188696622848511&quot;<br>      2) &quot;29.56472525888953129&quot;<br>3) 1) &quot;shengzhen&quot;<br>   2) &quot;911.2583&quot;<br>   3) 1) &quot;114.10092204809188843&quot;<br>      2) &quot;22.6755001616335008&quot;<br></code></pre></td></tr></table></figure><blockquote><p>GEORADIUSBYMEMBER</p></blockquote><p>找出位于指定范围内的元素，中心点是由给定的位置元素决定</p><p>这个命令和 <a href="https://www.redis.net.cn/order/3689.html">GEORADIUS</a> 命令一样， 都可以找出位于指定范围内的元素， 但是 <code>GEORADIUSBYMEMBER</code> 的中心点是由给定的位置元素决定的， 而不是像 <a href="https://www.redis.net.cn/order/3689.html">GEORADIUS</a> 那样， 使用输入的经度和纬度来决定中心点 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 找出位于指定元素周围的其他元素！</span><br>127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city chongqing 500 km<br>1) &quot;guiyang&quot;<br>2) &quot;chongqing&quot;<br></code></pre></td></tr></table></figure><p> GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; ZRANGE china:city 0 -1 # 查看地图中全部的元素<br>1) &quot;chongqi&quot;<br>2) &quot;xian&quot;<br>3) &quot;shengzhen&quot;<br>4) &quot;hangzhou&quot;<br>5) &quot;shanghai&quot;<br>6) &quot;beijing&quot;<br>127.0.0.1:6379&gt; zrem china:city beijing # 移除指定元素！<br>(integer) 1<br>127.0.0.1:6379&gt; ZRANGE china:city 0 -1<br>1) &quot;chongqi&quot;<br>2) &quot;xian&quot;<br>3) &quot;shengzhen&quot;<br>4) &quot;hangzhou&quot;<br>5) &quot;shanghai&quot;<br></code></pre></td></tr></table></figure><h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><blockquote><p>什么是基数？</p></blockquote><p> 比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。 </p><blockquote><p>简介</p></blockquote><p>Redis 2.8.9 版本就更新了 Hyperloglog 数据结构！ Redis Hyperloglog 基数统计的算法！</p><p>优点：占用的内存是固定，2^64 不同的元素的技术，只需要废 12KB内存！如果要从内存角度来比较的话 Hyperloglog 首选！</p><p>网页的 UV （一个人访问一个网站多次，但是还是算作一个人！）</p><p>传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 ! 这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id；</p><p>0.81% 错误率！ 统计UV任务，可以忽略不计的！</p><blockquote><p>实例</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> PFADD w3ckey &quot;redis&quot;<br> <br><span class="hljs-number">1</span>) (<span class="hljs-type">integer</span>) <span class="hljs-number">1</span><br> <br>redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> PFADD w3ckey &quot;mongodb&quot;<br> <br><span class="hljs-number">1</span>) (<span class="hljs-type">integer</span>) <span class="hljs-number">1</span><br> <br>redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> PFADD w3ckey &quot;mysql&quot;<br> <br><span class="hljs-number">1</span>) (<span class="hljs-type">integer</span>) <span class="hljs-number">1</span><br> <br>redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> PFCOUNT w3ckey<br> <br>(<span class="hljs-type">integer</span>) <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>如果允许容错，那么一定可以使用 Hyperloglog</p><p>如果不允许容错，就使用 set 或者自己的数据类型即可</p><h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><blockquote><p>位存储</p></blockquote><p>统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡，365打卡！ 两个状态的，都可以使用Bitmaps！ Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！ 365 天 = 365 bit 1字节 = 8bit 46 个字节左右！</p><blockquote><p>测试</p></blockquote><p>使用bitmap 来记录 周一到周日的打卡！</p><p>周一：1 周二：0 周三：0 周四：1 ……</p><p><img src="/img/work/1632664931110.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">0</span> <span class="hljs-number">1</span> <br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">1</span> <span class="hljs-number">0</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">2</span> <span class="hljs-number">0</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">3</span> <span class="hljs-number">1</span> <br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">4</span> <span class="hljs-number">1</span> <br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">5</span> <span class="hljs-number">1</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">6</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>查看某一天是否有打卡！</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> getbit sign <span class="hljs-number">3</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> getbit sign <span class="hljs-number">6</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>统计操作，统计 打卡的天数！</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> bitcount sign # 统计这周的打卡记录，就可以看到是否有全勤！<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>参考：</p><p>​       Redis官网：<a href="https://www.redis.net.cn/">https://www.redis.net.cn/</a></p><p>​       B站狂神说Java:<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0</a></p><p>​      </p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis基础</title>
    <link href="/2021/09/25/redis%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/09/25/redis%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Redis是什么？</p></blockquote><p> Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由<a href="https://baike.baidu.com/item/Pivotal">Pivotal</a>赞助。 </p><p> 免费和开源！是当下最热门的 NoSQL 技术之一！也被人们称之为结构化数据库！ </p> <span id="more"></span><blockquote><p>Redis作用于那些</p></blockquote><ol><li> 内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof） </li><li> 效率高，可以用于高速缓存 </li><li> 发布订阅系统 </li><li> 地图信息分析  </li><li> 计时器、计数器（浏览量！）  </li><li>…</li></ol><blockquote><p>主要特性</p></blockquote><ol><li> 多样的数据类型 </li></ol><p>   2、持久化</p><p>   3、集群 </p><p>   4、事务 </p><h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><blockquote><p>Linux安装</p></blockquote><p>Redis官网地址: <a href="https://redis.io/">https://redis.io/</a></p><p><img src="/img/work/1632572684797.png"></p><p>1.下载后,可获得一个tar压缩，我这里放到了 /opt目录下</p><p><img src="/img/work/1632573739375.png"></p><p>2.解压Redis安装包 解压命令: tar zxvf redis-6.2.5.tar.gz</p><p><img src="/img/work/1632574069385.png"></p><p>3.解压之后可以看到一个redis目录,进入Redis目录可以看到redis.conf的一个文件</p><p><img src="/img/work/1632574182949.png"></p><p>4.在redis下我们首先进行基本安装及编译安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">基础环境安装</span><br>yum install gcc-c++<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">编译</span><br>make<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">安装 redis安装之后默认安装在 /usr/<span class="hljs-built_in">local</span>/bin 下</span><br>make install<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">make PREFIX=/data/redis install  指定目录安装</span><br><br></code></pre></td></tr></table></figure><p><img src="/img/work/1632575400027.png"></p><p>5.在安装目录下复制redis.conf文件复制到安装目录下即：/usr/local/bin</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp redis.conf /usr/local/bin/<br></code></pre></td></tr></table></figure><p>6.修改redis启动方式，因为redis默认启动方式不是后台启动，因此我们需要进入redis.conf中修改为yes</p><p><img src="/img/work/1632575702117.png"></p><p>7.启动redis服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">启动redis服务</span><br>redis-server etc/redis.conf   #在bin目录下创建了etc目录  redis启动需要将配置文件一同操作<br><br></code></pre></td></tr></table></figure><p>8.连接测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">连接客户端命令 -p 指定端口</span><br>redis-cli -p 6379<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">可以看到连接并ping通</span><br>127.0.0.1:6379&gt; ping<br>PONG<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">连接之后如何正常退出？</span><br>127.0.0.1:6379&gt; shutdown #先关闭，防止有数据被中断<br>not connected&gt; exit  #退出<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">此时通过查看进程是否存在</span><br>ps -ef | grep redis<br><br></code></pre></td></tr></table></figure><p>9.查看redis进程</p><p><img src="/img/work/1632576417517.png"></p><p>当客户端连接退出后，任务进程将会不存在</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="redis默认数据库"><a href="#redis默认数据库" class="headerlink" title="redis默认数据库"></a>redis默认数据库</h3><p>通过查看配置文件</p><p><strong>redis默认有16个数据库，默认使用第0个数据库</strong> </p><p><img src="/img/work/1632576644195.png"></p><p>我们可以对数据库进行选择</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">数据使用选择，redis默认界面，我们可以使用table键进行命令补全</span><br>127.0.0.1:6379&gt; SELECT 2<br>OK<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查看库大小</span><br>127.0.0.1:6379[2]&gt; DBSIZE<br>(integer) 0<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查看所有key</span><br>127.0.0.1:6379[2]&gt; KEYS *<br></code></pre></td></tr></table></figure><p><strong>清除当前数据库 flushdb</strong></p><p><strong>清除全部数据库的内容 FLUSHALL</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; KEYS * <br>1) &quot;name&quot;<br>127.0.0.1:6379&gt; FLUSHDB<br>OK<br>127.0.0.1:6379&gt; KEYS * <br>(empty array)<br>127.0.0.1:6379&gt; <br><br></code></pre></td></tr></table></figure><blockquote><p>Redis是单线程</p></blockquote><p> 大家应该知道Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据 机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了！所有就使用了单线程了！</p><p> Redis 是C 语言写的，官方提供的数据为 100000+ 的QPS，完全不比同样是使用 key-vale的 Memecache差！ </p><h3 id="Redis单线程为什么还这么快？"><a href="#Redis单线程为什么还这么快？" class="headerlink" title="Redis单线程为什么还这么快？"></a>Redis单线程为什么还这么快？</h3><p>了解计算机原理的应该知道   CPU &gt;  内存 &gt; 磁盘</p><p><strong>核心：redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程 （CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高 的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！</strong></p><h2 id="五大类型"><a href="#五大类型" class="headerlink" title="五大类型"></a>五大类型</h2><blockquote><p>官方文档说明</p></blockquote><p> Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="http://www.redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a href="http://www.redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a href="http://www.redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）。 </p><blockquote><p>下面命令需要我们记住，现在我们一般使用的spring boot，Jedis方法基本都是这些命令</p></blockquote><h3 id="Redis基本操作"><a href="#Redis基本操作" class="headerlink" title="Redis基本操作"></a>Redis基本操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查询所有key</span><br>127.0.0.1:6379&gt; KEYS * <br>(empty array)<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">set</span> key</span><br>127.0.0.1:6379&gt; SET name pudewu<br>OK<br><br><br>127.0.0.1:6379&gt; KEYS * <br>1) &quot;name&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">判断key值是不是存在</span><br>127.0.0.1:6379&gt; EXISTS name<br>(integer) 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 移除当前的key</span><br>127.0.0.1:6379&gt; MOVE name 1<br>(integer) 1<br><br><br>127.0.0.1:6379&gt; KEYS *<br>(empty array)<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取key</span><br>127.0.0.1:6379&gt; get name<br>&quot;pudewu&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 设置key的过期时间，单位是秒</span><br>127.0.0.1:6379&gt; EXPIRE name 20<br>(integer) 1<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 查看当前key的剩余时间</span><br>127.0.0.1:6379&gt; TTL name<br>(integer) 17<br>127.0.0.1:6379&gt; TTL name<br>(integer) 13<br>127.0.0.1:6379&gt; TTL name<br>(integer) 12<br>127.0.0.1:6379&gt; TTL name<br>(integer) 11<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查看key的类型</span><br>127.0.0.1:6379&gt; type name<br>string<br></code></pre></td></tr></table></figure><p><strong>如果对有些命令不会的可以在官网查看帮助命令</strong></p><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>相信这个命令是我们经常使用到的</p><blockquote><p>添加Key，获取Key</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; SET k2 v2<br>OK<br>127.0.0.1:6379&gt; GET k2<br>&quot;v2&quot;<br>127.0.0.1:6379&gt; EXISTS k2<br>(integer) 1<br>127.0.0.1:6379&gt; APPEND k2 &quot;hello&quot;<br>(integer) 7<br>127.0.0.1:6379&gt; get k2<br>&quot;v2hello&quot;<br>127.0.0.1:6379&gt; STRLEN k2<br>(integer) 7<br>127.0.0.1:6379&gt; APPEND k2 &quot;redis学习&quot;<br>(integer) 18<br>127.0.0.1:6379&gt; STRLEN k2<br>(integer) 18<br>127.0.0.1:6379&gt; GET k2<br>&quot;v2helloredis\xe5\xad\xa6\xe4\xb9\xa0&quot;<br></code></pre></td></tr></table></figure><blockquote><p>String自增自减</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">设置默认值为0</span><br>127.0.0.1:6379&gt; set number 0<br>OK<br>127.0.0.1:6379&gt; get number<br>&quot;0&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">自增1</span><br>127.0.0.1:6379&gt; INCR number <br>(integer) 1<br>127.0.0.1:6379&gt; INCR number <br>(integer) 2<br>127.0.0.1:6379&gt; INCR number <br>(integer) 3<br>127.0.0.1:6379&gt; INCR number <br>(integer) 4<br>127.0.0.1:6379&gt; get number<br>&quot;4&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">自减1</span><br>127.0.0.1:6379&gt; DECR number <br>(integer) 3<br>127.0.0.1:6379&gt; DECR number <br>(integer) 2<br>127.0.0.1:6379&gt; DECR number <br>(integer) 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">自定义 增加值</span><br>127.0.0.1:6379&gt; INCRBY number 10<br>(integer) 11<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">自定义 减值</span><br>127.0.0.1:6379&gt; DECRBY number 5<br>(integer) 6<br></code></pre></td></tr></table></figure><blockquote><p>字符串范围</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 设置 key的值</span><br>127.0.0.1:6379&gt; set key &quot;hello redis&quot;<br>OK<br>127.0.0.1:6379&gt; get key1<br>(nil)<br>127.0.0.1:6379&gt; get key<br>&quot;hello redis&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 截取字符串 [0,3]</span><br>127.0.0.1:6379&gt; GETRANGE key 0 3<br>&quot;hell&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 获取全部的字符串 和 get key是一样的</span><br>127.0.0.1:6379&gt; GETRANGE key 0 -1<br>&quot;hello redis&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 替换！</span><br>127.0.0.1:6379&gt; set key2 &quot;redis fast&quot;<br>OK<br>127.0.0.1:6379&gt; get key2<br>&quot;redis fast&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 替换指定位置开始的字符串！</span><br>127.0.0.1:6379&gt; SETRANGE key2 1 realy<br>(integer) 10<br>127.0.0.1:6379&gt; get key2<br>&quot;rrealyfast&quot;<br></code></pre></td></tr></table></figure><blockquote><p> 设置过期时间 </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> setex (<span class="hljs-built_in">set</span> with expire) <span class="hljs-comment"># 设置过期时间</span></span><br><span class="hljs-meta">#</span><span class="bash"> setnx (<span class="hljs-built_in">set</span> <span class="hljs-keyword">if</span> not exist) <span class="hljs-comment"># 不存在在设置 （在分布式锁中会常常使用！）</span></span><br>127.0.0.1:6379&gt; setex key3 30 &quot;hello&quot; # 设置key3 的值为 hello,30秒后过期<br>OK<br>127.0.0.1:6379&gt; ttl key3<br>(integer) 26<br>127.0.0.1:6379&gt; get key3<br>&quot;hello&quot;<br>127.0.0.1:6379&gt; setnx mykey &quot;redis&quot; # 如果mykey 不存在，创建mykey<br>(integer) 1<br>127.0.0.1:6379&gt; keys *<br>1) &quot;key2&quot;<br>2) &quot;mykey&quot;<br>3) &quot;key1&quot;<br>127.0.0.1:6379&gt; ttl key3<br>(integer) -2<br>127.0.0.1:6379&gt; setnx mykey &quot;MongoDB&quot; # 如果mykey存在，创建失败！<br>(integer) 0<br>127.0.0.1:6379&gt; get mykey<br>&quot;redis&quot;<br></code></pre></td></tr></table></figure><blockquote><p>mset mget</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 # 同时设置多个值<br>OK<br>127.0.0.1:6379&gt; keys *<br>1) &quot;k1&quot;<br>2) &quot;k2&quot;<br>3) &quot;k3&quot;<br>127.0.0.1:6379&gt; mget k1 k2 k3 # 同时获取多个值<br>1) &quot;v1&quot;<br>2) &quot;v2&quot;<br>3) &quot;v3&quot;<br>127.0.0.1:6379&gt; msetnx k1 v1 k4 v4 # msetnx 是一个原子性的操作，要么一起成功，要么一起<br>失败！<br>(integer) 0<br>127.0.0.1:6379&gt; get k4<br>(nil)<br><span class="hljs-meta">#</span><span class="bash"> 对象</span><br>set user:1 &#123;name:zhangsan,age:3&#125; # 设置一个user:1 对象 值为 json字符来保存一个对象！<br><span class="hljs-meta">#</span><span class="bash"> 这里的key是一个巧妙的设计： user:&#123;id&#125;:&#123;filed&#125; , 如此设计在Redis中是完全OK了！</span><br>127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2<br>OK<br>127.0.0.1:6379&gt; mget user:1:name user:1:age<br>1) &quot;zhangsan&quot;<br>2) &quot;2&quot;<br></code></pre></td></tr></table></figure><blockquote><p><strong>getset</strong> </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; getset db redis # 如果不存在值，则返回 nil<br>(nil)<br>127.0.0.1:6379&gt; get db<br>&quot;redis<br>127.0.0.1:6379&gt; getset db mongodb # 如果存在值，获取原来的值，并设置新的值<br>&quot;redis&quot;<br>127.0.0.1:6379&gt; get db<br>&quot;mongodb&quot;<br></code></pre></td></tr></table></figure><h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h3><p> 在redis里面，我们可以把list玩成 ，栈、队列、阻塞队列！ 所有的list命令都是用l开头的，Redis不区分大小命令  </p><blockquote><p>lrange list 0 -1 查询list中所有 </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 将一个值或者多个值，插入到列表头部 （左）</span><br>127.0.0.1:6379&gt; lpush list one<br><br>127.0.0.1:6379&gt; lpush list two<br><br>127.0.0.1:6379&gt; lpush list three<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 0 -1 表示查询当前key下所有值</span><br>127.0.0.1:6379&gt; lrange list 0 -1<br><br>1) &quot;three&quot;<br>2) &quot;two&quot;<br>3) &quot;one&quot;<br></code></pre></td></tr></table></figure><blockquote><p> RPush将一个值或多个值，插入到列表位部(右) </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; Rpush list righr<br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>1) &quot;three&quot;<br>2) &quot;two&quot;<br>3) &quot;one&quot;<br>4) &quot;righr&quot;<br></code></pre></td></tr></table></figure><blockquote><p><strong>Lpop左移除列表</strong>  <strong>Rpop右移除列表</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 移除第一个元素</span><br>127.0.0.1:6379&gt; Lpop list<br>&quot;three&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">移除最后一个元素</span><br>127.0.0.1:6379&gt; Rpop list<br>&quot;righr&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查询list中所有数据</span><br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>1) &quot;two&quot;<br>2) &quot;one&quot;<br></code></pre></td></tr></table></figure><blockquote><h3 id="Lindex"><a href="#Lindex" class="headerlink" title="Lindex"></a>Lindex</h3></blockquote><p>通过下表获得list中的某一个值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; lindex list 1<br>&quot;one&quot;<br></code></pre></td></tr></table></figure><blockquote><p> Llen获取列表长度 </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; llen list<br>(integer) 4<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">指定移除列</span>   <br>127.0.0.1:6379&gt; lrem list 1 one<br></code></pre></td></tr></table></figure><blockquote><p>小结</p></blockquote><ul><li>他实际上是一个链表，before Node after ， left，right 都可以插入值</li><li>如果key 不存在，创建新的链表</li><li>如果key存在，新增内容</li><li>如果移除了所有值，空链表，也代表不存在！</li><li>在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~</li></ul><p><strong>在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~</strong></p><h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h3><p> set中的值不能重复,无序 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># set集合中添加元素  SADD</span></span><br>127.0.0.1:6379&gt; sadd myset &quot;hello set&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查询<span class="hljs-built_in">set</span>中所有元素 SMEMBERS</span> <br>127.0.0.1:6379&gt; Smembers myset<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> SISMEMBER 查询<span class="hljs-built_in">set</span>中某个值是否存在</span><br>127.0.0.1:6379&gt; SISMEMBER myset hello<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取Set中集合元素个数</span><br>127.0.0.1:6379&gt; scard myset<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">rem 移除<span class="hljs-built_in">set</span>中元素</span><br>127.0.0.1:6379&gt; srem myset yes<br>(integer) 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> SRANDMEMBER 随机抽取<span class="hljs-built_in">set</span>集合中数据</span><br>127.0.0.1:6379&gt; SRANDMEMBER myset<br><br><br>==============================================================================<br>删除指定Set数据、随机删除Set数据<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">SMOVE  将一个指定的值，移动到另一个<span class="hljs-built_in">set</span>值中</span><br>127.0.0.1:6379&gt; smove myset myset2 &quot;dewu1&quot;    <br><br><br>==============================================================================<br>数字集合类：<br>- 差集 SDIFF<br>- 交集<br>- 并集<br><br>127.0.0.1:6379&gt; SDIFF key1 key2  # 差集<br><br>127.0.0.1:6379&gt; SINTER key1 key2 # 交集 共同好友就可以这样实现<br><br>127.0.0.1:6379&gt; SUNION key1 key2 # 并集<br></code></pre></td></tr></table></figure><h3 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash(哈希)"></a>Hash(哈希)</h3><p> <strong>Map集合，key-map! 时候这个值是一个map集合！ 本质和String类型没有太大区别，还是一个简单的 key-vlaue！</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 添加hash值  hset</span></span><br>127.0.0.1:6379&gt; hset myhash field kuangshen<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 获取<span class="hljs-built_in">hash</span>值  hget</span><br>127.0.0.1:6379&gt; hget myhash field<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">set</span>多个 key-vlaue</span><br>127.0.0.1:6379&gt; hmset myhash field1 hello field2 world<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取多个<span class="hljs-built_in">hash</span>值</span><br>127.0.0.1:6379&gt; hmget myhash field1 field2<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取所有<span class="hljs-built_in">hash</span>中的值</span><br>127.0.0.1:6379&gt;  hgetall myhash<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">删除<span class="hljs-built_in">hash</span>操作  hdel</span><br>127.0.0.1:6379&gt; hdel myhash field1<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 只获得所有field</span><br><span class="hljs-meta">#</span><span class="bash"> 只获得所有value</span><br>127.0.0.1:6379&gt; hkeys myhash # 只获得所有field<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">只获得所有value</span><br>127.0.0.1:6379&gt; hvals myhash<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">incr decr</span><br>127.0.0.1:6379&gt; hset myhash field3 5 #指定增量！<br>127.0.0.1:6379&gt; HINCRby myhash field3 1<br>127.0.0.1:6379&gt; hincrby myhash field3 -1<br><br>127.0.0.1:6379&gt; hsetnx myhash field4 hello # 如果不存在则可以设置<br>127.0.0.1:6379&gt; hsetnx myhash field4 world # 如果存在则不能设置<br></code></pre></td></tr></table></figure><p> <strong>hash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！ hash 更适合于对象的 存储，String更加适合字符串存储！</strong> </p><h3 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset(有序集合)"></a>Zset(有序集合)</h3><p> <strong>在set基础上增加了一个值，set k1 v1   zset k1 score1  v1</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">添加有序集合</span><br>127.0.0.1:6379&gt; zadd dewu 1 redis<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">多个添加</span><br>127.0.0.1:6379&gt; zadd dewu 2 two 3 three<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查询集合元素</span><br>127.0.0.1:6379&gt; zrange dewu 0 -1<br><br><br>=====================================================<br>排序如何实现<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">添加三个用户</span><br>127.0.0.1:6379&gt; zadd salary 2500 xiaoming <br>(integer) 1<br>127.0.0.1:6379&gt; zadd salary 3000 xiaohong <br>(integer) 1<br>127.0.0.1:6379&gt; zadd salary 3500 zhangsan<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> ZRANGEBYSCORE key min max</span><br>127.0.0.1:6379&gt;  ZRANGEBYSCORE salary -inf +inf<br>1) &quot;xiaoming&quot;<br>2) &quot;xiaohong&quot;<br>3) &quot;zhangsan&quot;  # 显示全部的用户 从小到大！<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">从大到小排序</span><br>127.0.0.1:6379&gt; zrevrange salary 0 -1<br>1) &quot;zhangsan&quot;<br>2) &quot;xiaohong&quot;<br>3) &quot;xiaoming&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">显示全部用户并且附带成绩</span><br>127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores<br>1) &quot;xiaoming&quot;<br>2) &quot;2500&quot;<br>3) &quot;xiaohong&quot;<br>4) &quot;3000&quot;<br>5) &quot;zhangsan&quot;<br>6) &quot;3500&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">显示工资小于2500的员工升序排序</span><br>127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 withscores<br>1) &quot;xiaoming&quot;<br>2) &quot;2500&quot;<br><br><br>=================================================================<br><span class="hljs-meta">#</span><span class="bash"> 移除rem中的元素</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">移除集合中指定元素</span><br>127.0.0.1:6379&gt; zrem salary xiaoming<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取有序集合中的个数</span><br>127.0.0.1:6379&gt; zcard salary<br><br>==================================================================<br><br>127.0.0.1:6379&gt; zadd xiaolong 1 hello<br>127.0.0.1:6379&gt; zadd xiaolong 2 world 3 kuangsheng<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取指定区间的成员数量！</span><br>127.0.0.1:6379&gt; zcount xiaolong 1 3<br> <br></code></pre></td></tr></table></figure><p>参考：<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=8440565446323209776&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=8440565446323209776&amp;spm_id_from=333.337.0.0</a></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot整合Flowable工作流(1)</title>
    <link href="/2021/09/17/SpringBoot%E6%95%B4%E5%90%88Flowable%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <url>/2021/09/17/SpringBoot%E6%95%B4%E5%90%88Flowable%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Flowable流程图"><a href="#Flowable流程图" class="headerlink" title="Flowable流程图"></a>Flowable流程图</h1><h3 id="Flowable是什么？"><a href="#Flowable是什么？" class="headerlink" title="Flowable是什么？"></a>Flowable是什么？</h3><p> Flowable是一个使用Java编写的轻量级业务流程引擎。Flowable流程引擎可用于部署BPMN 2.0流程定义（用于定义流程的行业XML标准）， 创建这些流程定义的流程实例，进行查询，访问运行中或历史的流程实例与相关数据，等等。</p><p> Flowable可以十分灵活地加入你的应用/服务/构架。可以将JAR形式发布的Flowable库加入应用或服务，来<em>嵌入</em>引擎。 以JAR形式发布使Flowable可以轻易加入任何Java环境：Java SE；Tomcat、Jetty或Spring之类的servlet容器；JBoss或WebSphere之类的Java EE服务器，等等。 另外，也可以使用Flowable REST API进行HTTP调用。也有许多Flowable应用（Flowable Modeler, Flowable Admin, Flowable IDM 与 Flowable Task），提供了直接可用的UI示例，可以使用流程与任务。 </p> <span id="more"></span><p>Flowable流程需要先画流程图，然后再根据流程图引用自项目中，所以以下先画好流程图，然后再进行集成Spring boot生成</p><blockquote><p>部署FlowableUi</p></blockquote><ol><li><p>官方网址下载FlowableUI：<a href="https://flowable.com/open-source/downloads/">https://flowable.com/open-source/downloads/</a></p></li><li><p>将下载好之后的压缩包进行解压进入文件夹之后会看到一个war包文件下，打开文件夹将会有一个（flowable-ui.war）文件</p></li><li><p>安装部署Tomcat，安装部署就略过了百度都有，将上面的war包放入tomcat的webapps目录下，并在当前目录下执行以下命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>flowable-ui.war<br></code></pre></td></tr></table></figure></li><li><p>启动之后，有一行日志：Tomcat started on port(s): 8080 (http) with context path ‘/flowable-ui’，从以上可以看出端口默认为8080，路径为：/flowable-ui 。即访问：<a href="http://localhost:8080/flowable-ui%EF%BC%8C">http://localhost:8080/flowable-ui，</a></p><p>  账号：admin 密码：test </p></li></ol><blockquote><p>画流程图</p></blockquote><p><strong>登录之后</strong> </p><p>![](/img/work/ <a href="https://res.cloudinary.com/dlzf16hlo/image/upload/v1632027508/blog/1632027486_1_qqpru0.png">https://res.cloudinary.com/dlzf16hlo/image/upload/v1632027508/blog/1632027486_1_qqpru0.png</a> )</p><p><strong>选择建模器应用程序</strong></p>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
