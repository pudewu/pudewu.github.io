<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM体系结构</title>
    <url>/2022/06/25/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/img/work/image-20220622203711721.png" alt="JVM体系"></p>
<h2 id="1-虚拟机与Java虚拟机"><a href="#1-虚拟机与Java虚拟机" class="headerlink" title="1. 虚拟机与Java虚拟机"></a>1. 虚拟机与Java虚拟机</h2><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为<strong>系统虚拟机</strong>和<strong>程序虚拟机</strong>。</p>
<ul>
<li>Visaual Box，VMware 就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台</li>
<li>程序虚拟机的典型代表就是 Java 虚拟机，它专门为执行单个计算机程序而设计，在 Java 虚拟机中执行的指令我们称为 Java 字节码指令</li>
</ul>
<p><img src="/img/work/image-20220623090738586.png" alt="JVM虚拟机所处位置"></p>
<h2 id="2-JVM-是什么"><a href="#2-JVM-是什么" class="headerlink" title="2. JVM 是什么"></a>2. JVM 是什么</h2><p><code>JVM</code> 是 <code>Java Virtual Machine</code>（<strong>Java虚拟机</strong>)的缩写，<code>JVM</code>是一种用于计算设备的<strong>规范</strong>，它是一个<strong>虚构</strong>的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p>
<p>Java 虚拟机是二进制字节码的运行环境，负责装载<strong>字节码</strong>到其内部，解释/编译为对应平台的机器指令执行。每一条 Java 指令，Java 虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p>
<h3 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h3><ul>
<li>一次编译，到处运次（跨平台）</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
<h3 id="2-2-字节码"><a href="#2-2-字节码" class="headerlink" title="2.2 字节码"></a>2.2 字节码</h3><p>我们平时所说的 java 字节码，指的是用 java 语言编写的字节码，准确的说任何能在 jvm 平台上执行的字节码格式都是一样的，所以应该统称为 <strong>jvm字节码</strong>。</p>
<p>不同的编译器可以编译出相同的字节码文件，字节码文件也可以在不同的 jvm 上运行。</p>
<p>Java 虚拟机与 Java 语言没有必然的联系，它只与特定的二进制文件格式——Class 文件格式关联，Class 文件中包含了 Java 虚拟机指令集（或者称为字节码、Bytecodes）和符号集，还有一些其他辅助信息。</p>
<h3 id="2-3-Java-代码执行过程"><a href="#2-3-Java-代码执行过程" class="headerlink" title="2.3 Java 代码执行过程"></a>2.3 Java 代码执行过程</h3><p><img src="/img/work/image-20220622205607578.png"></p>
<h2 id="3-JVM-的位置"><a href="#3-JVM-的位置" class="headerlink" title="3.  JVM 的位置"></a>3.  JVM 的位置</h2><p>JVM 是运行在操作系统之上的，它与硬件没有直接的交互。</p>
<p><code>JDK</code>(Java Development Kit) 是 <code>Java</code> 语言的软件开发工具包（<code>SDK</code>）。<code>JDK</code> 物理存在，是 <code>Java Language</code>、<code>Tools</code>、<code>JRE</code> 和 <code>JVM</code> 的一个集合。</p>
<p><img src="/img/work/image-20220622205956516.png"></p>
<p><img src="/img/work/image-20220622210054216.png"></p>
<h2 id="4-JVM-整体结构"><a href="#4-JVM-整体结构" class="headerlink" title="4. JVM 整体结构"></a>4. JVM 整体结构</h2><p>HotSpot VM是现在市面上高性能虚拟机的代表作之一，它采用解释器和即时编译器并存的架构。 下图是JVM的执行流程：</p>
<p><img src="/img/work/1656081717643.png"></p>
<p>图中的方法区和堆是多线程共享的，而Java栈（现改名为虚拟机栈）、本地方法栈、程序计数器是每个线程独有一份的。</p>
<p><img src="/img/work/image-20220622211258907.png" alt="JVM结构"></p>
<p><strong>Java代码执行过程:</strong></p>
<p><img src="/img/work/1656081900581.png"></p>
<h2 id="5-JVM-的架构模型"><a href="#5-JVM-的架构模型" class="headerlink" title="5. JVM 的架构模型"></a>5. JVM 的架构模型</h2><p>Java 编译器输入的指令流基本上是一种基于<strong>栈的指令集架构</strong>，另外一种指令集架构则是基于<strong>寄存器的指令集架构</strong>。 </p>
<p>两种架构之间的区别： </p>
<p><strong>基于栈式架构的特点</strong> </p>
<ul>
<li>设计和实现更简单，适用于资源受限的系统；</li>
<li>避开了寄存器的分配难题，使用零地址指令方式分配；</li>
<li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现；</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台</li>
</ul>
<p><strong>基于寄存器架构的特点</strong> </p>
<ul>
<li>典型的应用是X86的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机；</li>
<li>指令集架构则完全依赖硬件，可移植性差；</li>
<li>性能优秀和执行更高效；</li>
<li>花费更少的指令去完成一项操作；</li>
<li>大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</li>
</ul>
<p>由于跨平台性的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的，优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。 </p>
<h3 id="5-1-分析基于栈式架构的JVM代码执行过程"><a href="#5-1-分析基于栈式架构的JVM代码执行过程" class="headerlink" title="5.1 分析基于栈式架构的JVM代码执行过程"></a>5.1 分析基于栈式架构的JVM代码执行过程</h3><p>进入 class 文件所在目录，执行<code>javap -v xx.class</code>反解析（或者通过IDEA插件<code>Jclasslib</code>直接查看），可以看到当前类对应的 code 区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等信息。 </p>
<p><img src="/img/work/1656084051077.png"></p>
<p>以上图中的 1+2 为例说明: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Classfile /Users/starfish/workspace/myCode/starfish-learning/starfish-learn/target/classes/priv/starfish/jvm/JVM1.class<br>  Last modified <span class="hljs-number">2020</span>-<span class="hljs-number">2</span>-<span class="hljs-number">7</span>; size <span class="hljs-number">487</span> bytes<br>  MD5 checksum 1a9653128b55585b2745270d13b17aaf<br>  Compiled from <span class="hljs-string">&quot;JVM1.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">priv</span>.<span class="hljs-title">starfish</span>.<span class="hljs-title">jvm</span>.<span class="hljs-title">JVM1</span></span><br><span class="hljs-class">  <span class="hljs-title">SourceFile</span>: &quot;<span class="hljs-title">JVM1</span>.<span class="hljs-title">java</span>&quot;</span><br><span class="hljs-class">  <span class="hljs-title">minor</span> <span class="hljs-title">version</span>: 0</span><br><span class="hljs-class">  <span class="hljs-title">major</span> <span class="hljs-title">version</span>: 52</span><br><span class="hljs-class">  <span class="hljs-title">flags</span>: <span class="hljs-title">ACC_PUBLIC</span>, <span class="hljs-title">ACC_SUPER</span></span><br><span class="hljs-class"><span class="hljs-title">Constant</span> <span class="hljs-title">pool</span>:</span><br><span class="hljs-class">   #1 </span>= Methodref          #<span class="hljs-number">3.</span>#<span class="hljs-number">22</span>         <span class="hljs-comment">//  java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = Class              #<span class="hljs-number">23</span>            <span class="hljs-comment">//  priv/starfish/jvm/JVM1</span><br>   #<span class="hljs-number">3</span> = Class              #<span class="hljs-number">24</span>            <span class="hljs-comment">//  java/lang/Object</span><br>   #<span class="hljs-number">4</span> = Utf8               &lt;init&gt;<br>   #<span class="hljs-number">5</span> = Utf8               ()V<br>   #<span class="hljs-number">6</span> = Utf8               Code<br>   #<span class="hljs-number">7</span> = Utf8               LineNumberTable<br>   #<span class="hljs-number">8</span> = Utf8               LocalVariableTable<br>   #<span class="hljs-number">9</span> = Utf8               <span class="hljs-keyword">this</span><br>  #<span class="hljs-number">10</span> = Utf8               Lpriv/starfish/jvm/JVM1;<br>  #<span class="hljs-number">11</span> = Utf8               main<br>  #<span class="hljs-number">12</span> = Utf8               ([Ljava/lang/String;)V<br>  #<span class="hljs-number">13</span> = Utf8               args<br>  #<span class="hljs-number">14</span> = Utf8               [Ljava/lang/String;<br>  #<span class="hljs-number">15</span> = Utf8               i<br>  #<span class="hljs-number">16</span> = Utf8               I<br>  #<span class="hljs-number">17</span> = Utf8               j<br>  #<span class="hljs-number">18</span> = Utf8               k<br>  #<span class="hljs-number">19</span> = Utf8               MethodParameters<br>  #<span class="hljs-number">20</span> = Utf8               SourceFile<br>  #<span class="hljs-number">21</span> = Utf8               JVM1.java<br>  #<span class="hljs-number">22</span> = NameAndType        #<span class="hljs-number">4</span>:#<span class="hljs-number">5</span>          <span class="hljs-comment">//  &quot;&lt;init&gt;&quot;:()V</span><br>  #<span class="hljs-number">23</span> = Utf8               priv/starfish/jvm/JVM1<br>  #<span class="hljs-number">24</span> = Utf8               java/lang/Object<br>&#123;<br>  <span class="hljs-keyword">public</span> priv.starfish.jvm.JVM1();<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0       <br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>        <br>      LineNumberTable:<br>        line <span class="hljs-number">3</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>               <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lpriv/starfish/jvm/JVM1;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: iconst_1      <span class="hljs-comment">//冒号前的数字表示程序计数器的数，常量1入栈</span><br>         <span class="hljs-number">1</span>: istore_1      <span class="hljs-comment">//保存到1的操作数栈中,这里的1表示操作数栈的索引位置</span><br>         <span class="hljs-number">2</span>: iconst_2      <br>         <span class="hljs-number">3</span>: istore_2      <br>         <span class="hljs-number">4</span>: iload_1       <span class="hljs-comment">//加载</span><br>         <span class="hljs-number">5</span>: iload_2       <br>         <span class="hljs-number">6</span>: iadd          <span class="hljs-comment">//常量出栈，求和</span><br>         <span class="hljs-number">7</span>: istore_3      <span class="hljs-comment">//存储到索引为3的操作数栈</span><br>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span>        <br>      LineNumberTable:<br>        line <span class="hljs-number">6</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">7</span>: <span class="hljs-number">2</span><br>        line <span class="hljs-number">8</span>: <span class="hljs-number">4</span><br>        line <span class="hljs-number">9</span>: <span class="hljs-number">8</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>               <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>               <span class="hljs-number">2</span>       <span class="hljs-number">7</span>     <span class="hljs-number">1</span>     i   I<br>               <span class="hljs-number">4</span>       <span class="hljs-number">5</span>     <span class="hljs-number">2</span>     j   I<br>               <span class="hljs-number">8</span>       <span class="hljs-number">1</span>     <span class="hljs-number">3</span>     k   I<br>      MethodParameters: length = <span class="hljs-number">0x5</span><br>       <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0D</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6-JVM-生命周期"><a href="#6-JVM-生命周期" class="headerlink" title="6. JVM 生命周期"></a>6. JVM 生命周期</h2><h3 id="6-1-虚拟机的启动"><a href="#6-1-虚拟机的启动" class="headerlink" title="6.1 虚拟机的启动"></a>6.1 虚拟机的启动</h3><p>Java 虚拟机的启动是通过引导类加载器（Bootstrap Class Loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。 </p>
<h3 id="6-2-虚拟机的执行"><a href="#6-2-虚拟机的执行" class="headerlink" title="6.2 虚拟机的执行"></a>6.2 虚拟机的执行</h3><ul>
<li>一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序</li>
<li>程序开始执行时它才运行，程序结束时它就停止</li>
<li>执行一个所谓的 Java 程序的时候，真正执行的是一个叫做 Java 虚拟机的进程</li>
<li>你在同一台机器上运行三个程序，就会有三个运行中的 Java 虚拟机。 Java 虚拟机总是开始于一个 <strong>main()</strong> 方法，这个方法必须是公有、返回 void、只接受一个字符串数组。在程序执行时，你必须给 Java 虚拟机指明这个包含 main() 方法的类名。</li>
</ul>
<h3 id="6-3-虚拟机的退出"><a href="#6-3-虚拟机的退出" class="headerlink" title="6.3 虚拟机的退出"></a>6.3 虚拟机的退出</h3><p>有以下几种情况： </p>
<ul>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致 Java 虚拟机进程终止</li>
<li>某线程调用 Runtime 类或 System 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作</li>
<li>除此之外，JNI(Java Native Interface)规范描述了用<code>JNI Invocation API</code>来加载或卸载 Java 虚拟机时，Java 虚拟机的退出情况</li>
</ul>
<h2 id="7-JVM-发展历程"><a href="#7-JVM-发展历程" class="headerlink" title="7. JVM 发展历程"></a>7. JVM 发展历程</h2><p>JDK 版本升级不仅仅体现在语言和功能特性上，还包括了其编译和执行的 Java 虚拟机的升级。 </p>
<ul>
<li>1990 年，在 Sun 计算机公司中，由 Patrick Naughton、MikeSheridan 及 James Gosling 领导的小组 Green Team，开发出的新的程序语言，命名为 Oak，后期命名为 Java</li>
<li>1995 年，Sun 正式发布 Java 和 HotJava 产品，Java 首次公开亮相</li>
<li>1996 年，JDK 1.0 发布时，提供了纯解释执行的 Java 虚拟机实现：Sun Classic VM。</li>
<li>1997 年，JDK 1.1 发布时，虚拟机没有做变更，依然使用 Sun Classic VM 作为默认的虚拟机</li>
<li>1998 年，JDK 1.2 发布时，提供了运行在 Solaris 平台的 Exact VM 虚拟机，但此时还是用 Sun Classic VM 作为默认的 Java 虚拟机，同时发布了JSP/Servlet、EJB规范，以及将Java分成J2EE、J2SE、J2ME</li>
<li>2000 年，JDK1.3 发布，默认的 Java 虚拟机由 Sun Classic VM 改为 Sun HotSopt VM，而 Sun Classic VM 则作为备用虚拟机</li>
<li>2002 年，JDK 1.4 发布，Sun Classic VM 退出商用虚拟机舞台，直接使用 Sun HotSpot VM 作为默认虚拟机一直到现在</li>
<li>2003 年，Java 平台的 Scala 正式发布，同年 Groovy 也加入了 Java 阵营</li>
<li>2004 年，JDK1.5 发布，同时 JDK1.5 改名为 JDK5.0</li>
<li>2006 年，JDK6 发布，同年，Java 开源并建立了 OpenJDK。顺理成章，Hotspot 虚拟机也成为了 OpenJDK 默认虚拟机</li>
<li>2008 年，Oracle 收购 BEA，得到了 JRockit 虚拟机</li>
<li>2010 年，Oracle 收购了 Sun，获得 Java 商标和 HotSpot 虚拟机</li>
<li>2011 年，JDK7 发布，在 JDK1.7u4 中，正式启用了新的垃圾回收器 G1</li>
<li>2014 年，JDK8 发布，用元空间 MetaSpace 取代了 PermGen</li>
<li>2017 年，JDK9 发布，将 G1 设置为默认 GC，替代 CMS</li>
<li>2018年3月，JDK10发布， 垃圾收集器改善、GC改进、性能提升、线程管控等一批新特性 。</li>
<li> 2018年9月,JDK11发布， Java 11是Java的一个长期支持版本LTS（Long Term Support），而上一个长期支持版本是2014年发布的Java 8 。 Java 11的技术支持时间直到2023年9月份，补丁和扩展支持直到2026年9月份。同时甲骨文公司公布的Java后续版本路线图展示新的长期支持版本将每三年发布一次，根据后续的发布计划，下一个长期支持版Java 17将于2021年发布。 </li>
<li> 2019年3月19日，Java 12正式发布， 针对G1，提供可中止的混合垃圾收集,及时释放已申请但未使用的内存 。 </li>
<li> 2019年9月17日，Java 13发布,   ZGC取消提交未使用存储器, 重新实现旧版 Socket API  。 </li>
<li> 2020年3月17日，在全球抗疫背景下，Java 14正式发布。 </li>
</ul>
<h3 id="7-1-Sun-Classic-VM"><a href="#7-1-Sun-Classic-VM" class="headerlink" title="7.1 Sun Classic VM"></a>7.1 Sun Classic VM</h3><ul>
<li>世界上第一款商用 Java 虚拟机。1996年随着Java1.0的发布而发布，JDK1.4时完全被淘汰；</li>
<li>这款虚拟机内部只提供解释器；</li>
<li>如果使用 JIT 编译器，就需要进行外挂。但是一旦使用了 JIT 编译器，JIT 就会接管虚拟机的执行系统，解释器就不再工作，解释器和编译器不能配合工作；</li>
<li>现在 hotspot 内置了此虚拟机</li>
</ul>
<h3 id="7-2-Exact-VM"><a href="#7-2-Exact-VM" class="headerlink" title="7.2 Exact VM"></a>7.2 Exact VM</h3><ul>
<li>它的执行系统已经具备了现代高性能虚拟机的雏形：如热点探测、两级即时编译器、编译器与解析器混合工作模式等；</li>
<li>使用准确式内存管理：虚拟机可以知道内存中某个位置的数据具体是什么类型；</li>
<li>在商业应用上只存在了很短暂的时间就被更优秀的 HotSpot VM 所取代</li>
</ul>
<h3 id="7-3-Sun-HotSpot-VM"><a href="#7-3-Sun-HotSpot-VM" class="headerlink" title="7.3 Sun HotSpot VM"></a>7.3 Sun HotSpot VM</h3><ul>
<li>HotSpot历史 最初由一家名为“Longview Technologies”的小公司设计 1997年，该公司被Sun收购；2009年，Sun公司被甲骨文收购… JDK1.3时，HotSpot VM 成为默认虚拟机</li>
</ul>
<ul>
<li>它是 Sun JDK 和 OpenJDK 中所带的虚拟机，也是目前使用范围最广的 Java 虚拟机；</li>
<li>继承了 Sun 之前两款商用虚拟机的优点（如准确式内存管理），也使用了许多自己新的技术优势，如热点代码探测技术（通过执行计数器找出最具有编译价值的代码，然后通知 JIT 编译器以方法为单位进行编译；</li>
<li>Oracle 公司分别收购了 BEA 和 Sun，并在 JDK8 的时候，整合了 JRokit VM 和 HotSpot VM，如使用了 JRokit 的垃圾回收器与 MissionControl 服务，使用了 HotSpot 的 JIT 编译器与混合的运行时系统。</li>
</ul>
<h3 id="7-4-BEA-JRockit-VM"><a href="#7-4-BEA-JRockit-VM" class="headerlink" title="7.4 BEA JRockit VM"></a>7.4 BEA JRockit VM</h3><ul>
<li><p>专注于服务器端应用 它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行</p>
</li>
<li><p>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM 使用JRockit产品，客户已经体验到显著的性能提高和硬件成本的减少</p>
</li>
<li><p>优势：全面的Java运行时解决方案组合 JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要 MissionControl服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</p>
</li>
<li><p>Oracle表达了整合了两大优秀虚拟机的工作，大致在JDK 8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</p>
</li>
</ul>
<h3 id="7-5-IBM-J9-VM"><a href="#7-5-IBM-J9-VM" class="headerlink" title="7.5 IBM J9 VM"></a>7.5 IBM J9 VM</h3><ul>
<li>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</li>
<li>市场定位于HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM</li>
<li>目前是有影响力的三大商用虚拟机之一</li>
</ul>
<p>虚拟机有很多，此外还有Azul VM、Liquid VM、Apache Harmony、TaobaoJVM、Graal VM等 </p>
<h3 id="7-6-TaobaoJVM"><a href="#7-6-TaobaoJVM" class="headerlink" title="7.6 TaobaoJVM"></a>7.6 TaobaoJVM</h3><ul>
<li>由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</li>
<li>基于OpenJDK开发了自己的定制版本的AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。</li>
<li>基于OpenJDK HotSpot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机 创新的GCIH（GC invisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。 GCIH中的对象还能够在多个Java虚拟机进程中实现共享 使用crc32指令实现JVM intrinsic 降低JNI的调用开销 PMU hardware的Java profiling tool和诊断协调功能 针对大数据场景的ZenGC</li>
<li>taobao vm应用在阿里产品上性能高，硬件严重依赖Intel的CPU，损失了兼容性，但提高了性能 目前已经在淘宝、天猫上线，把Oracle官方JVM版本全部替换了</li>
</ul>
<h2 id="8-参考"><a href="#8-参考" class="headerlink" title="8. 参考"></a>8. 参考</h2><p> 《深入理解Java虚拟机》 </p>
<p> 《尚硅谷JVM》 </p>
<p><a href="https://javakeeper.starfish.ink/java/JVM/JVM-Java.html#bea-jrockit-vm">https://javakeeper.starfish.ink/java/JVM/JVM-Java.html#bea-jrockit-vm</a></p>
<p><a href="https://www.xiaoguantongxue.com/blog/9">https://www.xiaoguantongxue.com/blog/9</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM体系</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-IO模型</title>
    <url>/2022/01/23/Java-IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-UNIX-I-O-模型"><a href="#1-UNIX-I-O-模型" class="headerlink" title="1 UNIX I/O 模型"></a>1 UNIX I/O 模型</h2><blockquote>
<p>UNIX 系统下的 I/O 模型有 5 种:</p>
</blockquote>
<ul>
<li><p>同步阻塞 I/O</p>
</li>
<li><p>同步非阻塞 I/O</p>
</li>
<li><p>I/O 多路复用</p>
</li>
<li><p>信号驱动 I/O</p>
</li>
<li><p>异步 I/O</p>
</li>
</ul>
<blockquote>
<p>如何去理解 UNIX I/O 模型，大致有以下两个维度：</p>
</blockquote>
<ul>
<li>区分同步或异步（synchronous/asynchronous）。简单来说，同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；而异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系。</li>
<li>区分阻塞与非阻塞（blocking/non-blocking）。在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。</li>
</ul>
<blockquote>
<p>不能一概而论认为同步或阻塞就是低效，具体还要看应用和系统特征。对于一个网络 I/O 通信过程，比如网络数据读取，会涉及两个对象，一个是调用这个 I/O 操作的用户线程，另外一个就是操作系统内核。一个进程的地址空间分为用户空间和内核空间，用户线程不能直接访问内核空间。</p>
</blockquote>
<p>当用户线程发起 I/O 操作后，网络数据读取操作会经历两个步骤：</p>
<ul>
<li><strong>用户线程等待内核将数据从网卡拷贝到内核空间。</strong></li>
<li><strong>内核将数据从内核空间拷贝到用户空间。</strong></li>
</ul>
<p>各种 I/O 模型的区别就是：它们实现这两个步骤的方式是不一样的。</p>
<h3 id="1-1-同步阻塞-I-O"><a href="#1-1-同步阻塞-I-O" class="headerlink" title="1.1 同步阻塞 I/O"></a>1.1 同步阻塞 I/O</h3><blockquote>
<p>用户线程发起 read 调用后就阻塞了，让出 CPU。内核等待网卡数据到来，把数据从网卡拷贝到内核空间，接着把数据拷贝到用户空间，再把用户线程叫醒。</p>
</blockquote>
<p><img src="/img/work/20201121163321.jpg"></p>
<h3 id="1-2-同步非阻塞-I-O"><a href="#1-2-同步非阻塞-I-O" class="headerlink" title="1.2 同步非阻塞 I/O"></a>1.2 同步非阻塞 I/O</h3><blockquote>
<p>用户线程不断的发起 read 调用，数据没到内核空间时，每次都返回失败，直到数据到了内核空间，这一次 read 调用后，在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的，等数据到了用户空间再把线程叫醒。</p>
</blockquote>
<p><img src="/img/work/20201121163344.jpg"></p>
<h3 id="1-3-I-O-多路复用"><a href="#1-3-I-O-多路复用" class="headerlink" title="1.3 I/O 多路复用"></a>1.3 I/O 多路复用</h3><blockquote>
<p>用户线程的读取操作分成两步了，线程先发起 select 调用，目的是问内核数据准备好了吗？等内核把数据准备好了，用户线程再发起 read 调用。在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的。那为什么叫 I/O 多路复用呢？因为一次 select 调用可以向内核查多个数据通道（Channel）的状态，所以叫多路复用。</p>
</blockquote>
<p><img src="/img/work/20201121163408.jpg"></p>
<h3 id="1-4-信号驱动-I-O"><a href="#1-4-信号驱动-I-O" class="headerlink" title="1.4 信号驱动 I/O"></a>1.4 信号驱动 I/O</h3><blockquote>
<p>首先开启 Socket 的信号驱动 I/O 功能，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函数处理数据。<strong>信号驱动式 I/O 模型的优点是我们在数据报到达期间进程不会被阻塞，我们只要等待信号处理函数的通知即可</strong></p>
</blockquote>
<h3 id="1-5-异步-I-O"><a href="#1-5-异步-I-O" class="headerlink" title="1.5 异步 I/O"></a>1.5 异步 I/O</h3><blockquote>
<p>用户线程发起 read 调用的同时注册一个回调函数，read 立即返回，等内核将数据准备好后，再调用指定的回调函数完成处理。在这个过程中，用户线程一直没有阻塞。</p>
</blockquote>
<p><img src="/img/work/20201121163428.jpg"></p>
<p>2 传统IO</p>
<h2 id="2-参考"><a href="#2-参考" class="headerlink" title="2.参考"></a>2.参考</h2><p><a href="https://dunwu.github.io/javacore/io/java-io.html">JavaIO模型</a></p>
<p><a href="https://book.douban.com/subject/2130190/">《Java 编程思想（Thinking in java）》</a></p>
<p><a href="https://book.douban.com/subject/26880667/">《Java 核心技术 卷 I 基础知识》</a></p>
<p><a href="https://item.jd.com/12555860.html">《Java 从入门到精通》</a></p>
<p><a href="https://time.geekbang.org/column/intro/100006701">《Java 核心技术面试精讲》</a></p>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/BIO-NIO-AIO.md">BIO,NIO,AIO 总结</a></p>
<p><a href="https://time.geekbang.org/column/intro/100027701">深入拆解 Tomcat &amp; Jetty</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>IO模型,IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-容器之简介</title>
    <url>/2021/11/18/Java-%E5%AE%B9%E5%99%A8%E4%B9%8B%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-容器简介"><a href="#1-容器简介" class="headerlink" title="1.容器简介"></a>1.容器简介</h2><h3 id="1-1-数组与容器"><a href="#1-1-数组与容器" class="headerlink" title="1.1. 数组与容器"></a>1.1. 数组与容器</h3><p>Java 中常用的存储容器就是数组和容器，二者有以下区别：</p>
<ul>
<li>存储大小是否固定<ul>
<li>数组的<strong>长度固定</strong>；</li>
<li>容器的<strong>长度可变</strong>。</li>
</ul>
</li>
<li>数据类型<ul>
<li><strong>数组可以存储基本数据类型，也可以存储引用数据类型</strong>；</li>
<li><strong>容器只能存储引用数据类型，基本数据类型的变量要转换成对应的包装类才能放入容器类中。</strong></li>
</ul>
</li>
</ul>
<h3 id="1-2-容器框架"><a href="#1-2-容器框架" class="headerlink" title="1.2. 容器框架"></a>1.2. 容器框架</h3><p><img src="/img/work/image-20211122204933065.png" alt="集合关系图"></p>
<p>Java 容器框架主要分为 <code>Collection</code> 和 <code>Map</code> 两种。其中，<code>Collection</code> 又分为 <code>List</code>、<code>Set</code> 以及 <code>Queue</code>。</p>
<ul>
<li><code>Collection</code> - 一个独立元素的序列，这些元素都服从一条或者多条规则。<ul>
<li><code>List</code> - 必须按照插入的顺序保存元素。</li>
<li><code>Set</code> - 不能有重复的元素。</li>
<li><code>Queue</code> - 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。</li>
</ul>
</li>
<li><code>Map</code> - 一组成对的“键值对”对象，允许你使用键来查找值。</li>
</ul>
<h2 id="2-容器的基本机制"><a href="#2-容器的基本机制" class="headerlink" title="2. 容器的基本机制"></a>2. 容器的基本机制</h2><blockquote>
<p>Java 的容器具有一定的共性，它们或全部或部分依赖以下技术。所以，学习以下技术点，对于理解 Java 容器的特性和原理有很大的帮助。</p>
</blockquote>
<h3 id="2-1-泛型"><a href="#2-1-泛型" class="headerlink" title="2.1. 泛型"></a>2.1. 泛型</h3><p>Java 1.5 引入了泛型技术。</p>
<p>Java <strong>容器通过泛型技术来保证其数据的类型安全</strong>。</p>
<p>什么是类型安全呢？举例来说：如果有一个 <code>List&lt;Object&gt;</code> 容器，Java <strong>编译器在编译时不会对原始类型进行类型安全检查</strong>，却会对带参数的类型进行检查，通过使用 Object 作为类型，可以告知编译器该方法可以接受任何类型的对象，比如 String 或 Integer。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>list.add(<span class="hljs-string">&quot;123&quot;</span>);<br>list.add(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure>

<p>如果没有泛型技术，如示例中的代码那样，容器中就可能存储任意数据类型，这是很危险的行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>list.add(<span class="hljs-string">&quot;123&quot;</span>);<br>list.add(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure>

<h3 id="2-2-Iterable-和-Iterator"><a href="#2-2-Iterable-和-Iterator" class="headerlink" title="2.2. Iterable 和 Iterator"></a>2.2. Iterable 和 Iterator</h3><blockquote>
<p>Iterable 和 Iterator 目的在于遍历访问容器中的元素。</p>
</blockquote>
<p><code>Iterator</code> 接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">&quot;remove&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; action)</span> </span>&#123;<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">while</span> (hasNext())<br>            action.accept(next());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Iterable</code> 接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-function">Iterator&lt;T&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span> </span>&#123;<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">for</span> (T t : <span class="hljs-keyword">this</span>) &#123;<br>            action.accept(t);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Spliterator&lt;T&gt; <span class="hljs-title">spliterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Collection</code> 接口扩展了 <code>Iterable</code> 接口。</p>
<p>迭代其实我们可以简单地理解为遍历，是一个标准化遍历各类容器里面的所有对象的接口。它是一个经典的设计模式——迭代器模式（Iterator）。</p>
<p><strong>迭代器模式</strong> - <strong>提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示</strong>。</p>
<p><img src="/img/work/iterator-pattern.png" alt="迭代器UML"></p>
<p>示例：迭代器遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        list.add(<span class="hljs-number">3</span>);<br>        Iterator it = list.iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            System.out.println(it.next());<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-3-Comparable-和-Comparator"><a href="#2-3-Comparable-和-Comparator" class="headerlink" title="2.3. Comparable 和 Comparator"></a>2.3. Comparable 和 Comparator</h3><p><code>Comparable</code> 是排序接口。若一个类实现了 <code>Comparable</code> 接口，表示该类的实例可以比较，也就意味着支持排序。实现了 <code>Comparable</code> 接口的类的对象的列表或数组可以通过 <code>Collections.sort</code> 或 <code>Arrays.sort</code> 进行自动排序。</p>
<p><code>Comparable</code> 接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T o)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Comparator</code> 是比较接口，我们如果需要控制某个类的次序，而该类本身不支持排序(即没有实现 <code>Comparable</code> 接口)，那么我们就可以建立一个“该类的比较器”来进行排序，这个“比较器”只需要实现 <code>Comparator</code> 接口即可。也就是说，我们可以通过实现 <code>Comparator</code> 来新建一个比较器，然后通过这个比较器对类进行排序。</p>
<p><code>Comparator</code> 接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(T o1, T o2)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>;<br><br>    <span class="hljs-comment">// 反转</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Comparator&lt;T&gt; <span class="hljs-title">reversed</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Collections.reverseOrder(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Comparator&lt;T&gt; <span class="hljs-title">thenComparing</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; other)</span> </span>&#123;<br>        Objects.requireNonNull(other);<br>        <span class="hljs-keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; &#123;<br>            <span class="hljs-keyword">int</span> res = compare(c1, c2);<br>            <span class="hljs-keyword">return</span> (res != <span class="hljs-number">0</span>) ? res : other.compare(c1, c2);<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">// thenComparingXXX 方法略</span><br><br>    <span class="hljs-comment">// 静态方法略</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 Java 容器中，一些可以排序的容器，如 <code>TreeMap</code>、<code>TreeSet</code>，都可以通过传入 <code>Comparator</code>，来定义内部元素的排序规则。</p>
<h3 id="2-4-Cloneable"><a href="#2-4-Cloneable" class="headerlink" title="2.4. Cloneable"></a>2.4. Cloneable</h3><p>Java 中 一个类要实现 <code>clone</code> 功能 必须实现 <code>Cloneable</code> 接口，否则在调用 <code>clone()</code> 时会报 <code>CloneNotSupportedException</code> 异常。</p>
<p>Java 中所有类都默认继承 <code>java.lang.Object</code> 类，在 <code>java.lang.Object</code> 类中有一个方法 <code>clone()</code>，这个方法将返回 <code>Object</code> 对象的一个拷贝。<code>Object</code> 类里的 <code>clone()</code> 方法仅仅用于浅拷贝（拷贝基本成员属性，对于引用类型仅返回指向改地址的引用）。</p>
<p>如果 Java 类需要深拷贝，需要覆写 <code>clone()</code> 方法。</p>
<h3 id="2-5-fail-fast"><a href="#2-5-fail-fast" class="headerlink" title="2.5. fail-fast"></a>2.5. fail-fast</h3><h4 id="fail-fast-的要点"><a href="#fail-fast-的要点" class="headerlink" title="fail-fast 的要点"></a>fail-fast 的要点</h4><p>Java 容器（如：ArrayList、HashMap、TreeSet 等）的 javadoc 中常常提到类似的描述：</p>
<blockquote>
<p>注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败（fail-fast）迭代器会尽最大努力抛出 <code>ConcurrentModificationException</code>。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。</p>
</blockquote>
<p>那么，我们不禁要问，什么是 fail-fast，为什么要有 fail-fast 机制？</p>
<p><strong>fail-fast 是 Java 容器的一种错误检测机制</strong>。当多个线程对容器进行结构上的改变的操作时，就可能触发 fail-fast 机制。记住是有可能，而不是一定。</p>
<p>例如：假设存在两个线程（线程 1、线程 2），线程 1 通过 <code>Iterator</code> 在遍历容器 A 中的元素，在某个时候线程 2 修改了容器 A 的结构（是结构上面的修改，而不是简单的修改容器元素的内容），那么这个时候程序就会抛出 <code>ConcurrentModificationException</code> 异常，从而产生 fail-fast 机制。</p>
<p><strong>容器在迭代操作中改变元素个数（添加、删除元素）都可能会导致 fail-fast</strong>。</p>
<p>示例：fail-fast 示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FailFastDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX; i++) &#123;<br>            list.add(i);<br>        &#125;<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThreadA()).start();<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThreadB()).start();<br>    &#125;<br><br>    <span class="hljs-comment">/** 迭代遍历容器所有元素 */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            Iterator&lt;Integer&gt; iterator = list.iterator();<br>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                <span class="hljs-keyword">int</span> i = iterator.next();<br>                System.out.println(<span class="hljs-string">&quot;MyThreadA 访问元素:&quot;</span> + i);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/** 遍历删除指定范围内的所有偶数 */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (i &lt; MAX) &#123;<br>                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;MyThreadB 删除元素&quot;</span> + i);<br>                    list.remove(i);<br>                &#125;<br>                i++;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行后，会抛出 <code>java.util.ConcurrentModificationException</code> 异常。</p>
<h4 id="解决-fail-fast"><a href="#解决-fail-fast" class="headerlink" title="解决 fail-fast"></a>解决 fail-fast</h4><p>fail-fast 有两种解决方案：</p>
<ul>
<li>在遍历过程中所有涉及到改变容器个数的地方全部加上 <code>synchronized</code> 或者直接使用 <code>Collections.synchronizedXXX</code> 容器，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作，影响吞吐。</li>
<li>使用并发容器，如：<code>CopyOnWriterArrayList</code>。</li>
</ul>
<p>参考:</p>
<p><a href="https://dunwu.github.io/javacore/container/java-container.html">Java 容器简介</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java-容器</category>
      </categories>
      <tags>
        <tag>Java容器</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaIO之BIO</title>
    <url>/2022/01/23/JavaIO%E4%B9%8BBIO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Java-BIO"><a href="#Java-BIO" class="headerlink" title="Java BIO"></a>Java BIO</h2><h3 id="1-IO模型"><a href="#1-IO模型" class="headerlink" title="1 IO模型"></a>1 IO模型</h3><h4 id="1-1-模型基本说明"><a href="#1-1-模型基本说明" class="headerlink" title="1.1 模型基本说明"></a>1.1 模型基本说明</h4><ol>
<li><code>I/O</code> 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。</li>
<li><code>Java</code> 共支持 <code>3</code> 种网络编程模型 <code>I/O</code> 模式：<code>BIO</code>、<code>NIO</code>、<code>AIO</code>。</li>
<li><code>Java BIO</code>：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。【简单示意图】</li>
</ol>
<p><img src="/img/work/chapter02_01.png"></p>
<ol start="4">
<li><code>Java NIO</code>：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 <code>I/O</code> 请求就进行处理。【简单示意图】</li>
</ol>
<p><img src="/img/work/chapter02_02.png"></p>
<ol start="5">
<li><code>Java AIO(NIO.2)</code>：异步非阻塞，<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</li>
</ol>
<h3 id="2-BIO、NIO、AIO-使用场景分析"><a href="#2-BIO、NIO、AIO-使用场景分析" class="headerlink" title="2 BIO、NIO、AIO 使用场景分析"></a>2 BIO、NIO、AIO 使用场景分析</h3><ol>
<li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，但程序简单易理解。</li>
<li><code>NIO</code> 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，<code>JDK1.4</code> 开始支持。</li>
<li><code>AIO</code> 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 <code>OS</code> 参与并发操作，编程比较复杂，<code>JDK7</code> 开始支持。</li>
</ol>
<h3 id="3-Java-BIO基本介绍"><a href="#3-Java-BIO基本介绍" class="headerlink" title="3 Java BIO基本介绍"></a>3 Java BIO基本介绍</h3><ol>
<li><code>Java BIO</code> 就是传统的 <code>Java I/O</code> 编程，其相关的类和接口在 <code>java.io</code>。</li>
<li><code>BIO(BlockingI/O)</code>：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）。【后有应用实例】</li>
<li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，程序简单易理解。</li>
</ol>
<h3 id="4-Java-BIO机制"><a href="#4-Java-BIO机制" class="headerlink" title="4 Java BIO机制"></a>4 Java BIO机制</h3><p><img src="/img/work/chapter02_03.png"></p>
<p>对 <code>BIO</code> 编程流程的梳理</p>
<ol>
<li>服务器端启动一个 <code>ServerSocket</code>。</li>
<li>客户端启动 <code>Socket</code> 对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯。</li>
<li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。</li>
<li>如果有响应，客户端线程会等待请求结束后，在继续执行。</li>
</ol>
<h3 id="5-Java-BIO应用实例"><a href="#5-Java-BIO应用实例" class="headerlink" title="5 Java BIO应用实例"></a>5 Java BIO应用实例</h3><p>实例说明：</p>
<ol>
<li><p>使用 <code>BIO</code> 模型编写一个服务器端，监听 <code>6666</code> 端口，当有客户端连接时，就启动一个线程与之通讯。</p>
</li>
<li><p>要求使用线程池机制改善，可以连接多个客户端。</p>
</li>
<li><p>服务器端可以接收客户端发送的数据（<code>telnet</code> 方式即可）。</p>
</li>
<li><p>代码演示：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.bio;<br><br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BIOServer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//线程池机制</span><br>        <span class="hljs-comment">//思路</span><br>        <span class="hljs-comment">//1. 创建一个线程池</span><br>        <span class="hljs-comment">//2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span><br>        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();<br>        <span class="hljs-comment">//创建ServerSocket</span><br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>        System.out.println(<span class="hljs-string">&quot;服务器启动了&quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-comment">//监听，等待客户端连接</span><br>            System.out.println(<span class="hljs-string">&quot;等待连接....&quot;</span>);<br>            <span class="hljs-keyword">final</span> Socket socket = serverSocket.accept();<br>            System.out.println(<span class="hljs-string">&quot;连接到一个客户端&quot;</span>);<br>            <span class="hljs-comment">//就创建一个线程，与之通讯(单独写一个方法)</span><br>            newCachedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//我们重写</span><br>                    <span class="hljs-comment">//可以和客户端通讯</span><br>                    handler(socket);<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//编写一个handler方法，和客户端通讯</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(Socket socket)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-comment">//通过socket获取输入流</span><br>            InputStream inputStream = socket.getInputStream();<br>            <span class="hljs-comment">//循环的读取客户端发送的数据</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());<br>                System.out.println(<span class="hljs-string">&quot;read....&quot;</span>);<br>                <span class="hljs-keyword">int</span> read = inputStream.read(bytes);<br>                <span class="hljs-keyword">if</span> (read != -<span class="hljs-number">1</span>) &#123;<br>                    System.out.println(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, read));<span class="hljs-comment">//输出客户端发送的数据</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;关闭和client的连接&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                socket.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="6-Java-BIO问题分析"><a href="#6-Java-BIO问题分析" class="headerlink" title="6 Java BIO问题分析"></a>6 Java BIO问题分析</h3><ol>
<li>每个请求都需要创建独立的线程，与对应的客户端进行数据 <code>Read</code>，业务处理，数据 <code>Write</code>。</li>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 <code>Read</code> 操作上，造成线程资源浪费。</li>
</ol>
<h3 id="7-参考"><a href="#7-参考" class="headerlink" title="7.参考"></a>7.参考</h3><p><a href="https://dongzl.github.io/netty-handbook/#/_content/chapter02">Java BIO编程</a></p>
<p><a href="https://www.bilibili.com/video/av76227904/">尚硅谷Ntty视频教程</a></p>
<p><a href="https://ke.qq.com/course/463900">尚硅谷Netty视频教程</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>BIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-面向对象</title>
    <url>/2021/10/12/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="一、封装"><a href="#一、封装" class="headerlink" title="一、封装"></a>一、封装</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>类的封装，是指将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象的内部信息，而是通过该类所提供的方法来实现对内部信息的操作。即<strong>封装就是把同一类事物的共性（包括属性和方法）归到同一类中，方便使用。</strong>    </p>
<p>封装和继承几乎都是为多态而准备的。 </p>
<p>封装也称信息隐藏，是指利用抽象数据类型把数据和基于数据的操作封装起来，使其成为一个不可分割的整体，数据隐藏在抽象数据内部，尽可能的隐藏数据细节，只保留一些接口使其与外界发生联系。也就是说用户无需知道内部的数据和方法的具体实现细节，只需根据留在外部的接口进行操作就行。 </p>
<h4 id="2-封装的实现"><a href="#2-封装的实现" class="headerlink" title="2. 封装的实现"></a>2. <strong>封装的实现</strong></h4><ul>
<li> 需要修改属性的访问控制符（修改为private）； </li>
<li> 创建getter/setter方法（用于属性的读写）； </li>
<li> 在getter/setter方法中加入属性控制语句（用于判断属性值的合法性）; </li>
</ul>
<p><strong>属性 (成员变量 ) 随对象存放在堆中</strong></p>
<p>直接通过对象调用属性，修改属性值是不安全的，那<strong>怎么办</strong>？</p>
<p>具体实现过程：在定义一个类时，将类中的属性私有化，即使用private关键字来修饰，私有属性只能在它所在类中被访问，如果外界想要访问私有属性，需要提供一些使用public修饰的共有方法，其中包括用于获取属性值的getXxx()方法和设置属性值的setXxx()方法。</p>
<p>Boolean的get方法默认名为isXXX（）</p>
<p>把成员变量设置为私有的，只能在本类中使用，所以属性也叫<strong>全局变量</strong>。</p>
<h4 id="3-封装的优缺点"><a href="#3-封装的优缺点" class="headerlink" title="3.封装的优缺点"></a>3.封装的优缺点</h4><blockquote>
<p>优点</p>
</blockquote>
<ul>
<li> 将变化隔离 </li>
<li> 便于使用 </li>
<li> 提高重用性 </li>
<li> 提高安全性 </li>
</ul>
<blockquote>
<p>缺点</p>
</blockquote>
<p> 将变量等使用private修饰，或者封装进方法内，使其不能直接被访问，增加了访问步骤与难度！ </p>
<p><strong>实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;<br> <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">     * 对属性的封装一个人的姓名、年龄</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">     */</span><br> <br>    <span class="hljs-keyword">private</span> String name;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">     * setter()、getter()是该对象对外开发的接口</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">     */</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br> <br>        <span class="hljs-keyword">return</span> name;<br> <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br> <br>        <span class="hljs-keyword">this</span>.name = name;<br> <br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br> <br>        <span class="hljs-keyword">return</span> age;<br> <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br> <br>        <span class="hljs-keyword">this</span>.age = age;<br> <br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h3><p> 继承关键字：<code>extends</code> </p>
<h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h4><p>在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类称作子类，现有类被称作父类或基类，子类会自动拥有父类所有可继承的属性和方法。</p>
<p><strong>简单的说</strong>:  继承是类与类的一种关系，比较像集合中的从属于关系。比如说，狗属于动物。就可以看成狗类继承了动物类，那么狗类就是动物类的子类（派生类），动物类就是狗类的父类（基类）。在Java中是单继承的，也就是说一个子类只有一个父类。 </p>
<h4 id="2-继承的特点："><a href="#2-继承的特点：" class="headerlink" title="2. 继承的特点："></a><strong>2. 继承的特点：</strong></h4><p>（1） 子类比父类强大<br>（2）java是单继承，不能进行多继承。但是可以继承多层子类（<strong>不建议继承超过3层</strong>）<br>（3）子类继承父类，但是对父类的成员变量是无法直接操作，只能通过父类继承过来的setter和getter方法. </p>
<h4 id="3-继承优缺点"><a href="#3-继承优缺点" class="headerlink" title="3.继承优缺点"></a>3.继承优缺点</h4><blockquote>
<p>优点</p>
</blockquote>
<p>  (1)  减少代码量，能很好的提高复用率。<br>  (2)  使类与类之间存在继承关系，是实现多态操作的前提。 </p>
<blockquote>
<p>缺点</p>
</blockquote>
<p>继承使得多个类之间具有了子父类关系，当一个类存在多个子类的时候，如果父类发生变化，那么这些子类会跟着一同变化，造成类与类之间的“强耦合”关系！ </p>
<h4 id="4-继承注意点"><a href="#4-继承注意点" class="headerlink" title="4.继承注意点"></a><strong>4.继承注意点</strong></h4><p> (1) 不要仅仅为了获取某个类的某个功能而去继承这个类<br> (2) 类与类之间要存在所属关系，不能够随意继承 </p>
<h4 id="5-何时使用继承"><a href="#5-何时使用继承" class="headerlink" title="5.何时使用继承"></a><strong>5.何时使用继承</strong></h4><p>（1）具有公共的属性与行为操作的时候，提高复用性<br>（2）具有is–a的所属关系的类与类之间 </p>
<h4 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a><strong>7. 结论</strong></h4><p>（1）执行构造方法创建对象完成对象的初始化时，先执行父类的构造，完成父类的初始化，再执行本类的初始化工作。</p>
<p>（2）第一次创建Phone（父）类，是直接继承Object,而Object是jdk提供的工具类，自然不会有属性，所以Object类只提供了无参的构造，在执行Phone方法时，无论是无参还是有参都会先执行父类Object的无参构造。</p>
<p>（3）但是对于Phone的子类Mobile，必须也要有自己的构造方法，由于构造执行的特性，对于无参构造，先执行了Phone的无参构造，对于有参构造，则先执行父类Phone的有参，然后才执行本类属性sex的初始化。</p>
<p>（4）构造方法constructor中,无论是否显式还是隐式调用super(),子类在创建对象调用时都会执行super();</p>
<p>（5）显式调用构造是在需要通过父类的带参构造来完成子类的带参构造。例如Mobile类带参构造中显示调用的Super(brand,price,service)</p>
<p>（6）对于父类私有的属性，即使子类继承，但是在test.java中，子类是无法直接访问的，在制定子类的带参构造方法时，只能通过调用父类的带参构造来完成。对于父类非私有的属性，子类对象可以直接调用。</p>
<h3 id="三、多态"><a href="#三、多态" class="headerlink" title="三、多态"></a>三、多态</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h4><p>多态指的是对象的多种形态。 多态有两种：引用多态和方法多态。<strong>继承是多态的实现基础。</strong>Java的多态是由类的继承、方法重写以及父类引用指向子类对象体现的。由于一个父类可以有多个子类，多个子类都可以重写父类方法，并且多个不同的子类对象也可以指向同一个父类；这样，程序只有在运行时才能知道具体代表的是哪个子类对象，这就体现了多态。</p>
<p><strong>实例</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义抽象类Animal</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><br><span class="hljs-comment">//定义 Cat类继承Animal抽象类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-comment">//实现shout()方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;喵喵。。。&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//定义Dog类继承Animal抽象类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-comment">//实现shout()方法</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;汪汪。。。&quot;</span>)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//定义测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Animal an1 = <span class="hljs-keyword">new</span> Cat();<br>        Animal an2 = <span class="hljs-keyword">new</span> Dog();<br>        <br>        an1.shout();<br>        an2.shout();<br>    &#125;<br>&#125;<br><br><br><br><br></code></pre></td></tr></table></figure>

<h4 id="2-多态存在的前提（多态的三要素）"><a href="#2-多态存在的前提（多态的三要素）" class="headerlink" title="2. 多态存在的前提（多态的三要素）"></a>2. <strong>多态存在的前提（多态的三要素）</strong></h4><p>(1)  必须有子类和父类，具有继承或实现（继承） </p>
<p>(2) 子类必须重写父类的方法（重写）</p>
<p>(3) 父类的引用变量指向子类的对象（向上转型）  </p>
<h4 id="3-多态优缺点"><a href="#3-多态优缺点" class="headerlink" title="3.多态优缺点"></a>3.多态优缺点</h4><blockquote>
<p>优点</p>
</blockquote>
<p>  A. 可替换性，多态对一存在的代码具有可替代性</p>
<p>  B. 可扩充性：增加的子类不影响已存在的类的特性的运行和操作</p>
<p>  C. 接口性：多态时超类通过方法签名想子类提供了一个公共的接口，由子类来完善或者覆盖它而实现的</p>
<p>  D. 灵活性：在应用中体现了灵活多样的操作，提高了使用的效率</p>
<p>  E. 简化性： 多态简化对应用软件的代码的编写和修改过程，尤其在处理大量的对象的运算和操作时，这个特点尤为突出和重要</p>
<blockquote>
<p>缺点</p>
</blockquote>
<p>只能使用父类的引用访问父类的成员 </p>
<h4 id="4-多态中的成员特点"><a href="#4-多态中的成员特点" class="headerlink" title="4. 多态中的成员特点"></a>4. <strong>多态中的成员特点</strong></h4><p>  成员变量：编译与运行时期都看父类！ 成员方法：编译时期看父类，运行时期看子类 </p>
<p>参考：</p>
<hr>
<p><a href="https://blog.csdn.net/hellosweet1/article/details/81320384">https://blog.csdn.net/hellosweet1/article/details/81320384</a></p>
<p>Java基础入门第二版</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器之Queue</title>
    <url>/2021/12/16/Java%E5%AE%B9%E5%99%A8%E4%B9%8BQueue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-什么是Queue"><a href="#1-什么是Queue" class="headerlink" title="1.什么是Queue"></a>1.什么是Queue</h2><p><code>Queue</code>也就是队列，是一种基本的<code>线性数据结构</code>，与之类似的其他数据结构还有数组、链表、栈等。</p>
<p>Queue是一种遵循<strong>先进先出</strong>（<code>FIFO: First In, First Out</code>）原则的数据集合，数据在Queue中的流动是单向的，从队尾流向队首。</p>
<p>如下图所示，元素的插入发生在队尾，删除发生在队首；通常一个元素从队首中取出后，该元素从Queue中删除；非队首的元素，无法直接对其进行读取。</p>
<p><img src="/img/work/image-20211216094638623.png" alt="Queue队列"></p>
<p>在现实世界中队列非常常见，比如排队等待购票、上车的乘客，流水线上一个个等待处理的产品，都是一种队列模型；而且程序设计的世界中队列使用也非常广泛：比如多线程中等待处理的任务、排队等待获取某个锁的线程等。</p>
<h2 id="2-Java中的Queue接口"><a href="#2-Java中的Queue接口" class="headerlink" title="2. Java中的Queue接口"></a>2. Java中的Queue接口</h2><p><img src="/img/work/Queue-diagrams.png" alt="Queue类关系图"></p>
<h3 id="2-1-Queue接口定义"><a href="#2-1-Queue接口定义" class="headerlink" title="2.1 Queue接口定义"></a>2.1 Queue接口定义</h3><p>在Java中，队列是一种基本的集合类型，提供了队列接口<code>Queue</code>，定义在 其中<code>java.util</code>包中；其中<code>Queue</code>接口继承了基础集合接口<code>Collection</code>。</p>
<p>Queue接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">element</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在Queue接口中，定义基本的元素插入和删除的方法，主要方法及其含义分别如下：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>boolean add(E e)</code></td>
<td align="left">向队列中添加一个元素；如果有空间则添加成功返回true，否则则抛出<code>IllegalStateException</code>异常</td>
</tr>
<tr>
<td align="left"><code>boolean offer(E e)</code></td>
<td align="left">向队列中添加一个元素；如果有空间则添加成功返回true，否则返回false</td>
</tr>
<tr>
<td align="left"><code>E remove()</code></td>
<td align="left">从队列中删除一个元素；如果元素存在则返回队首元素，否则抛出<code>NoSuchElementException</code>异常</td>
</tr>
<tr>
<td align="left"><code>E poll();</code></td>
<td align="left">从队列中删除一个元素；如果元素存在则返回队首元素，否则返回null</td>
</tr>
<tr>
<td align="left"><code>E element()</code></td>
<td align="left">从队列获取一个元素，但是不删除；如果元素存在则返回队首元素，否则抛出<code>NoSuchElementException</code>异常</td>
</tr>
<tr>
<td align="left"><code>E peek()</code></td>
<td align="left">从队列获取一个元素，但是不删除；如果元素存在则返回队首元素，否则返回null</td>
</tr>
</tbody></table>
<h3 id="2-2-双端队列：Deque接口"><a href="#2-2-双端队列：Deque接口" class="headerlink" title="2.2 双端队列：Deque接口"></a>2.2 双端队列：Deque接口</h3><p>在上面的Queue接口定义中，实现了最基本的元素插入和删除方法，也就是从队尾进行元素插入，在队首进行元素删除；而Java还提供了另一个功能强大的<code>Deque接口</code>，实现了<strong>双端队列</strong>的功能。</p>
<p><strong>什么是双端队列？</strong></p>
<p>双端队列就是可以支持在队首或者队尾，都可以进行元素的插入和删除操作的队列，如下图所示。在双端队列中，分别使用<code>front</code>和<code>back</code>表示队列的首、尾两端，而在插入或删除元素时，可以通过指定在队列的哪一端进行操作。</p>
<p>比如：<code>push_front()</code>表示在队首进行元素的插入，<code>pop_back()</code>表示在队尾进行元素的删除。</p>
<p><img src="/img/work/image-20211216103519826.png"></p>
<p><strong>Deque接口的定义如下</strong>：</p>
<p><img src="/img/work/d3f650e5a9b846eab201c5aadcd703d2.png" alt="Deque类图"></p>
<p>可以看到，<code>Deque</code>接口继承了<code>Queue</code>接口，除了基本的<code>Queue</code>接口的方法外，<code>Deque</code>还提供了<strong>双端队列</strong>的操作方法，如代码所示，每个操作方法与<code>Queue</code>的操作方法类似，只是指定了在队首还是队尾进行元素操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">// 向队首添加一个元素；如果有空间则添加成功返回true，否则则抛出`IllegalStateException`异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span></span>;<br>    <span class="hljs-comment">// 向队尾添加一个元素；如果有空间则添加成功返回true，否则则抛出`IllegalStateException`异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span></span>;<br>	<br>    <span class="hljs-comment">// 向队首添加一个元素；如果有空间则添加成功返回true，否则返回false</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span></span>;<br>    <span class="hljs-comment">// 向队尾添加一个元素；如果有空间则添加成功返回true，否则返回false</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offerLast</span><span class="hljs-params">(E e)</span></span>;<br>  <br>    <span class="hljs-comment">// 从队首删除一个元素；如果元素存在则返回队首元素，否则抛出`NoSuchElementException`异常</span><br>    <span class="hljs-function">E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 从队尾删除一个元素；如果元素存在则返回队尾元素，否则抛出`NoSuchElementException`异常</span><br>    <span class="hljs-function">E <span class="hljs-title">removeLast</span><span class="hljs-params">()</span></span>;<br>		<br>    <span class="hljs-comment">// 从队首删除一个元素；如果元素存在则返回队首元素，否则返回null</span><br>    <span class="hljs-function">E <span class="hljs-title">pollFirst</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 从队尾删除一个元素；如果元素存在则返回队首元素，否则返回null</span><br>    <span class="hljs-function">E <span class="hljs-title">pollLast</span><span class="hljs-params">()</span></span>;<br>  <br>    <span class="hljs-comment">// 从队首获取一个元素，但是不删除；如果元素存在则返回队首元素，否则抛出`NoSuchElementException`异常</span><br>    <span class="hljs-function">E <span class="hljs-title">getFirst</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 从队尾获取一个元素，但是不删除；如果元素存在则返回队尾元素，否则抛出`NoSuchElementException`异常</span><br>    <span class="hljs-function">E <span class="hljs-title">getLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 从队首获取一个元素，但是不删除；如果元素存在则返回队首元素，否则返回null</span><br>    <span class="hljs-function">E <span class="hljs-title">peekFirst</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 从队尾获取一个元素，但是不删除；如果元素存在则返回队尾元素，否则返回null</span><br>    <span class="hljs-function">E <span class="hljs-title">peekLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 如果元素o存在，则从队列中删除第一次出现的该元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span></span>;<br>    <span class="hljs-comment">// 如果元素o存在，则从队列中删除最后一次出现的该元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeLastOccurrence</span><span class="hljs-params">(Object o)</span></span>;<br>    <span class="hljs-comment">// 其他方法省略....</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-3-实现类-LinkedList"><a href="#2-3-实现类-LinkedList" class="headerlink" title="2.3 实现类 LinkedList"></a>2.3 实现类 LinkedList</h3><p>在前面，我们了解了Java中定义的两个队列接口<code>Queue</code>和<code>Deque</code>，而两个接口的实现类是通过<code>LinkedList</code>来实现的。从类名定义上可以看出来，<code>LinkedList</code>其实是基于链表实现的List的一个数据集合，而且<code>LinkedList</code>还实现了<code>Queue</code>接口和<code>Deque</code>接口。我们可以直接使用<code>LinkedList</code>来实现队列的操作。下面是其定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializableb</span> </span>&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面是一个基于<code>LinkedList</code>实现的双端队列的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  Deque&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  <span class="hljs-comment">// 元素入队</span><br>  queue.offer(<span class="hljs-string">&quot;1&quot;</span>);<br>  queue.offer(<span class="hljs-string">&quot;2&quot;</span>);<br>  queue.offer(<span class="hljs-string">&quot;3&quot;</span>);<br>  queue.offerFirst(<span class="hljs-string">&quot;0&quot;</span>);  <span class="hljs-comment">// 队首添加元素0</span><br>  queue.offerLast(<span class="hljs-string">&quot;4&quot;</span>);   <span class="hljs-comment">// 队尾添加元素4</span><br><br>  System.out.println(queue);  <span class="hljs-comment">// 此时队列中的元素为：[0, 1, 2, 3, 4]</span><br><br>  <span class="hljs-comment">// 元素出队</span><br>  System.out.println(queue.poll());       <span class="hljs-comment">// 删除队首元素，打印值：0</span><br>  System.out.println(queue.pollFirst());  <span class="hljs-comment">// 删除队首元素，打印值：1</span><br>  System.out.println(queue.pollLast());   <span class="hljs-comment">// 删除队尾元素，打印值：4</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>OK，到这儿我们已经了解了队列接口的定义以及实现类LinkedList的定义以及使用方法，下面我们简单看下LinkedList底层是如何实现的队列功能。</p>
<h2 id="3-LinkedList如何实现队列功能"><a href="#3-LinkedList如何实现队列功能" class="headerlink" title="3. LinkedList如何实现队列功能"></a>3. LinkedList如何实现队列功能</h2><h3 id="3-1-链表的定义"><a href="#3-1-链表的定义" class="headerlink" title="3.1 链表的定义"></a>3.1 链表的定义</h3><p>上面我们了解到，<code>LinkedList</code>其实是基于链表实现的一个数据集合，并实现了队列的接口功能。我们再来看下<code>LinkedList</code>的定义和成员变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">// 元素数量</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 队首元素节点</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br>    <span class="hljs-comment">// 队尾元素节点</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，在LinkedList中有两个成员变量<code>first</code>和<code>last</code>，类型为<code>Node&lt;E&gt;</code>，分别表示队列中队首和队尾的节点，其实也就是链表中的首尾节点。<code>Node&lt;E&gt;</code>是链表的一个节点，下面是其定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// 元素值</span><br>  E item;<br>  <span class="hljs-comment">// 后一个节点</span><br>  Node&lt;E&gt; next;<br>  <span class="hljs-comment">// 前一个节点</span><br>  Node&lt;E&gt; prev;<br><br>  Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>    <span class="hljs-keyword">this</span>.item = element;<br>    <span class="hljs-keyword">this</span>.next = next;<br>    <span class="hljs-keyword">this</span>.prev = prev;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>Node&lt;E&gt;</code>中，成员变量<code>item</code>用来存储具体的元素值，另外两个<code>Node&lt;E&gt;</code>类型的变量<code>next</code>和<code>prev</code>分别表示该节点的<strong>后一个节点</strong>和<strong>上一个节点</strong>。</p>
<p>到此，我们就可以知道，<code>LinkedList</code>其实是由一个<strong>双向链表</strong>构成，并通过<code>first</code>和<code>last</code>分别表示链表的首尾节点。然后我们可以画出下面这个链表的示意图。</p>
<p><img src="/img/work/image-20211216150618309.png" alt="双向链表"></p>
<h3 id="3-2-元素的插入"><a href="#3-2-元素的插入" class="headerlink" title="3.2 元素的插入"></a>3.2 元素的插入</h3><p>在前面的介绍中，我们知道，元素的插入可以使用<code>add</code>和<code>offer</code>两个方法，不同的是当队列容量不足时，<code>add</code>方法会抛除异常，而<code>offer</code>方法会返回false。但是<code>LinkedList</code>是基于双向链表实现，理论上该链表是无界的，只要程序内存允许，可以一直插入新的元素。</p>
<p>下面我们看下<code>offer</code>方法插入元素的实现逻辑，代码如下（已添加相关注释）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt; .....</span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 插入元素</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-comment">// 此处直接调用了add方法</span><br>    <span class="hljs-keyword">return</span> add(e);<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 插入元素</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-comment">// 调用linkLast方法</span><br>    linkLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在链表尾部，添加一个新元素，并作为新的last节点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-comment">// 当前last节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-comment">// 创建新节点，prev节点指向当前last节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(l, e, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// 新节点作为新的last节点</span><br>    last = newNode;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)<br>      <span class="hljs-comment">// 如果原last节点为null，表示该链表为空，则将节点同时作为first节点</span><br>      first = newNode;<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-comment">// 链表不为空，则将新节点，作为原last节点的next节点</span><br>      l.next = newNode;<br>    <span class="hljs-comment">// 元素数量+1</span><br>    size++;<br>    <span class="hljs-comment">// 集合修改次数+1</span><br>    modCount++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从代码中可以很容易的看出，<code>offer</code>方法直接调用了<code>add</code>方法，<code>add</code>方法中调用了<code>linkLast</code>方法，并直接返回了true，表示该元素肯定可以插入成功。具体执行元素插入的逻辑在<code>linkLast</code>方法中完成，通过上面代码中的注释可以看出，<code>linkLast</code>方法主要功能是在链表尾端添加一个新节点，具体操作示意图如下：</p>
<p><img src="/img/work/583d7c2d5af44dec8a42e053e04e411d~tplv-k3u1fbpfcp-watermark.image.png" alt="链表的尾插入"></p>
<p><strong><code>offerFirst</code>和<code>offerLast</code>是如何实现的？</strong></p>
<p>当了解了<code>offer</code>方法后，我们再看下<code>offerFirst</code>和<code>offerLast</code>的实现。从下面代码中可以知道，<code>offerFirst</code>和<code>offerLast</code>方法分别调用了<code>addFirst</code>和<code>addLast</code>方法，然后在<code>addFirst</code>和<code>addLast</code>方法中，又分别调用了<code>linkFirst</code>和<code>linkLast</code>方法。</p>
<p><code>linkLast</code>方法上已经讲到，主要功能是在链表尾端添加一个新节点；而<code>linkFirst</code>方法，其主要功能是在链表首端添加一个新节点，具体逻辑与<code>linkLast</code>方法类似，本处不再赘述，可以参考下面代码中的注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt; .....</span>&#123;<br>  <span class="hljs-comment">// 队首插入元素</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerFirst</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    addFirst(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br>  <span class="hljs-comment">// 队尾插入元素</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    addLast(e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br>  <span class="hljs-comment">// 队首插入元素</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    linkFirst(e);<br>  &#125;<br>  <span class="hljs-comment">// 队尾插入元素</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    linkLast(e);<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在链表头部，添加一个新元素，并作为新的first节点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">linkFirst</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-comment">// 当前first节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-comment">// 创建新节点，next节点指向当前first节点</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(<span class="hljs-keyword">null</span>, e, f);<br>    <span class="hljs-comment">// 新节点作为新的first节点</span><br>    first = newNode;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)<br>      <span class="hljs-comment">// 如果原first节点为null，表示该链表为空，则将节点同时作为last节点</span><br>      last = newNode;<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-comment">// 链表不为空，则将新节点，作为原first节点的prev节点</span><br>      f.prev = newNode;<br>    <span class="hljs-comment">// 元素数量+1</span><br>    size++;<br>    <span class="hljs-comment">// 集合修改次数+1</span><br>    modCount++;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在链表尾部，添加一个新元素，并作为新的last节点</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-comment">// 本处省略，详见上一代码块</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此我们已经了解了元素是如何插入的，并且分别介绍了双端队列中在队首和队尾插入元素的实现逻辑，下面我们再简单看下元素是如何实现删除的。</p>
<h3 id="3-3-元素的删除"><a href="#3-3-元素的删除" class="headerlink" title="3.3 元素的删除"></a>3.3 元素的删除</h3><p>前面了解了元素的插入流程，我们再看删除流程就很清晰了，主要功能就是将队列头或者队尾的节点删除。删除节点的方法主要有<code>poll</code>和<code>pollFirst</code>和<code>pollLast</code>，以及<code>delete</code>、<code>deleteFirst</code>和<code>deleteLast</code>。这几个方法最终调用的都是两个链表的操作方法<code>unlinkFirst</code>和<code>unlinkLast</code>，表示删除链表头部和链表尾部的节点。</p>
<p>下面是<code>unlinkFirst</code>和<code>unlinkLast</code>方法的代码逻辑，此处不再赘述，可以直接看代码注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt; .....</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除链表头结点f，f不为空</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkFirst</span><span class="hljs-params">(Node&lt;E&gt; f)</span> </span>&#123;<br>        <span class="hljs-comment">// assert f == first &amp;&amp; f != null;</span><br>        <span class="hljs-comment">// 获取头结点的元素</span><br>        <span class="hljs-keyword">final</span> E element = f.item;<br>        <span class="hljs-comment">// 获取头结点的next结点</span><br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; next = f.next;<br>        f.item = <span class="hljs-keyword">null</span>;<br>        f.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>        <span class="hljs-comment">// 将next结点作为头结点</span><br>        first = next;<br>        <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-comment">// next结点为null，表示删除完成后链表为空，则last结点置为null</span><br>            last = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 删除完成后链表非空，则当前头结点的prev结点为null</span><br>            next.prev = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 元素数量-1</span><br>        size--;<br>        <span class="hljs-comment">// 集合修改次数-1</span><br>        modCount++;<br>        <span class="hljs-comment">// 返回删除结点的元素</span><br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除链表尾结点l，l不为空</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkLast</span><span class="hljs-params">(Node&lt;E&gt; l)</span> </span>&#123;<br>        <span class="hljs-comment">// assert l == last &amp;&amp; l != null;</span><br>        <span class="hljs-comment">// 获取尾结点的元素</span><br>        <span class="hljs-keyword">final</span> E element = l.item;<br>        <span class="hljs-comment">// 获取尾结点的prev结点</span><br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = l.prev;<br>        l.item = <span class="hljs-keyword">null</span>;<br>        l.prev = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>        <span class="hljs-comment">// 将prev结点作为尾结点</span><br>        last = prev;<br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-comment">// prev结点为null，表示删除完成后链表为空，则first结点置为null</span><br>            first = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 删除完成后链表非空，则当前尾结点的next结点为null</span><br>            prev.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 元素数量-1</span><br>        size--;<br>        <span class="hljs-comment">// 集合修改次数-1</span><br>        modCount++;<br>        <span class="hljs-comment">// 返回删除结点的元素</span><br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文主要介绍了Java中Queue的基础用法以及相关底层原理，使用Queue我们可以实现一些任务排队处理的功能等。</p>
<p>但是在上面分析过程中，我们可以发现Java中Queue的实现其实是<strong>非线程安全</strong>的，如果在多线程环境下进行Queue的入队和出队操作，会产生不一致的情况。所以Java也提供了线程安全的队列类——阻塞队列<code>BlockingQueue</code>。</p>
<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><p><a href="http://soiiy.com/Java/16298">深入理解Java系列 | Queue用法详解</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java-容器</category>
      </categories>
      <tags>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器之Set</title>
    <url>/2021/12/15/Java%E5%AE%B9%E5%99%A8%E4%B9%8BSet/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基于<code>jdk1.8</code>介绍<code>Set</code>接口下的常用实现类。</p>
<h2 id="1-java-集合框架"><a href="#1-java-集合框架" class="headerlink" title="1 java 集合框架"></a>1 java 集合框架</h2><p><img src="/img/work/image-20211122204933065.png" alt="集合关系图"></p>
<p>由类图我们可以看到，<code>set</code>接口继承自<code>Collection</code>接口且有四个实现类，分别为<code>AbstractSet</code>、<code>HashSet</code>、<code>LinkedHashSet</code>和<code>TreeSet</code>，其中<code>AbstractSet</code>为抽象类，继承自<code>AbstractCollection</code>，实现了最基本的<code>Collection</code>骨架。下面我们分别来看一下其余三个实现类的实现原理。</p>
<h2 id="2-HashSet"><a href="#2-HashSet" class="headerlink" title="2.HashSet"></a>2.HashSet</h2><p><img src="/img/work/image-20211215104248593.png" alt="HashSet类图"></p>
<p>对于<code>HashSet</code>而言，它是基于<code>HashMap</code>实现的，可以看作是对<code>HashMap</code>的封装，<code>HashSet</code>底层使用<code>HashMap</code>来保存所有元素，因此<code>HashSet</code>的实现比较简单，相关<code>HashSet</code>的操作，基本上都是直接调用底层<code>HashMap</code>的相关方法来完成.</p>
<h3 id="2-1-成员变量"><a href="#2-1-成员变量" class="headerlink" title="2.1 成员变量"></a>2.1 成员变量</h3><p>首先看一下两个成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<span class="hljs-comment">//存储元素的map</span><br><span class="hljs-comment">// Dummy value to associate with an Object in the backing Map</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object(); <span class="hljs-comment">//元素的默认vlaue</span><br></code></pre></td></tr></table></figure>

<p>通过这两个成员变量我们可以看到，在<code>HashSet</code>的内部维护着一个<code>HashMap</code>类型的变量<code>map</code>，这个<code>map</code>就是用来存储元素的容器。那我们知道，<code>HashMap</code>存储的是<code>key-value</code>形式的键值对，而<code>set</code>是一个单值对象，这要怎么存储呢？那就要看第二个成员变量<code>PRESENT</code>了，<code>PRESENT</code>是一个<code>Object</code>对象，这个对象就是充当键值对的值的，也就是说，我们只会把需要存储的元素当作<code>map</code>的<code>key</code>，而对应的<code>value</code>则默认为这个<code>Object</code>对象，这就是<code>HashSet</code>内部实现存储元素的数据结构。所以由<code>HashMap</code>的特性我们可以知道，<code>HashSet</code>存储的元素是无序的，元素是不可重复的并且可以为<code>null</code>，基于这个元素不允许重复的特性，<code>HashSet</code>经常被用来做元素的去重。</p>
<h3 id="2-2-构造方法"><a href="#2-2-构造方法" class="headerlink" title="2.2 构造方法"></a>2.2 构造方法</h3><p>下面我们看一下<code>HashSet</code>提供的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造一个使用HashMap的默认容量大小16和默认加载因子0.75初始化map的HashSet</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">()</span> </span>&#123;<br>     map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br> &#125;<br><br><br><span class="hljs-comment">//根据 Collection 接口构造一个HashSet</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>     map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="hljs-keyword">int</span>) (c.size()/<span class="hljs-number">.75f</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">16</span>));<br>     addAll(c);<br> &#125;<br><br> <span class="hljs-comment">//使用指定的初始容量大小和加载因子初始化map，构造一个HashSet</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>     map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);<br> &#125;<br><br><span class="hljs-comment">//使用指定的初始容量大小初始化map，构造一个HashSet</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>     map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(initialCapacity);<br> &#125;<br><br> <span class="hljs-comment">//构造一个LinkedHashMap，不对外公开 </span><br> HashSet(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor, <span class="hljs-keyword">boolean</span> dummy) &#123;<br>     map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);<br> &#125;<br></code></pre></td></tr></table></figure>

<p><code>HashSet</code>一共提供了5个构造方法，由构造方法也可以看到，底层是用了<code>HashMap</code>的数据结构实现，构造方法也跟<code>HashMap</code>比较类似，这里重点要说一下<code>HashSet(int initialCapacity, float loadFactor, boolean dummy)</code>这个构造方法，这个构造方法是不对外部公开的，其实放在这里实现是为了给<code>LinkedHashSet</code>使用，下文我们会讲到这一点。</p>
<h3 id="2-3-存取实现"><a href="#2-3-存取实现" class="headerlink" title="2.3 存取实现"></a>2.3 存取实现</h3><p>添加元素</p>
<p>由于底层使用了<code>HashMap</code>作存储结构，这里直接调用了<code>HashMap</code>的<code>put</code>方法插入元素，元素被作为<code>key</code>插入的<code>map</code>中，而<code>value</code>则是使用的默认值<code>Object</code>对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;<span class="hljs-comment">//直接将元素作为map的key插入</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>遍历</p>
<p><code>HashSet</code>支持两种遍历方式，<code>Iterator</code>方式，<code>foreach</code>方式，不支持随机访问方式遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Set&lt;String&gt; set=<span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br> hashset.add(<span class="hljs-string">&quot;1&quot;</span>);<br> hashset.add(<span class="hljs-string">&quot;2&quot;</span>);<br><span class="hljs-comment">//Iterator遍历  </span><br><span class="hljs-keyword">for</span>(Iterator iterator = set.iterator();<br>      iterator.hasNext(); ) &#123; <br>   iterator.next();<br>&#125;<br><span class="hljs-comment">//foreach遍历</span><br> <span class="hljs-keyword">for</span> (String str:set)&#123;<br>    System.out.println(str);<br> &#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-4-特性总结"><a href="#2-4-特性总结" class="headerlink" title="2.4 特性总结"></a>2.4 特性总结</h3><p>1、由于底层基于<code>HashMap</code>实现，内部使用基于哈希表的数组+链表方式存储，所以不保证元素的存取顺序。<br>2、基于<code>key</code>的<code>hash</code>值存储，同样的对象<code>hash</code>值相同，所以元素不可重复，但是可以为<code>null</code>，可以快速查找是否包含某个元素。</p>
<h2 id="3-LinkedHashSet"><a href="#3-LinkedHashSet" class="headerlink" title="3.LinkedHashSet"></a>3.LinkedHashSet</h2><p><img src="/img/work/image-20211215111633626.png" alt="LinkedHashSet类关系图"></p>
<p>由类图我们可以看到，<code>LinkedHashSet</code>继承自<code>HashSet</code>，内部是基于<code>LinkedHashMap</code>来实现的。<code>LinkedHashSet</code>底层使用<code>LinkedHashMap</code>来保存所有元素，其所有的方法操作上又与<code>HashSet</code>相同，因此<code>LinkedHashSet</code> 的实现上非常简单，只提供了四个构造方法和一个<code>spliterator</code>方法，并通过传递一个标识参数，调用父类的构造方法，上文我们说到<code>HashSet</code>预留了一个不对外部公开的构造方法，就是用在这里。底层构造一个<code>LinkedHashMap来实现</code>，在相关操作上与父类<code>HashSet</code>的操作相同，直接调用父类<code>HashSet</code>的方法即可。</p>
<p><code>LinkedHashSet</code>源码，由于底层使用<code>LinkedHashMap</code>作为存储结构，继承了<code>HashSet</code>的各种方法,在此只做简单说明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用指定的初始容量大小和加载因子初始化map，构造一个LinkedHashSet</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>     <span class="hljs-keyword">super</span>(initialCapacity, loadFactor, <span class="hljs-keyword">true</span>);<br> &#125;<br><span class="hljs-comment">//使用指定的初始容量大小初始化map，构造一个LinkedHashSet</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>     <span class="hljs-keyword">super</span>(initialCapacity, <span class="hljs-number">.75f</span>, <span class="hljs-keyword">true</span>);<br> &#125;<br> <span class="hljs-comment">// 构造一个使用HashMap的默认容量大小16和默认加载因子0.75初始化map的LinkedHashSet</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashSet</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">super</span>(<span class="hljs-number">16</span>, <span class="hljs-number">.75f</span>, <span class="hljs-keyword">true</span>);<br> &#125;<br>  <span class="hljs-comment">//根据 Collection 接口构造一个inkedHashSet</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashSet</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>     <span class="hljs-keyword">super</span>(Math.max(<span class="hljs-number">2</span>*c.size(), <span class="hljs-number">11</span>), <span class="hljs-number">.75f</span>, <span class="hljs-keyword">true</span>);<br>     addAll(c);<br> &#125;<br> <span class="hljs-comment">// 调用Spliterator接口中的spliterator()方法，将集合分割后遍历</span><br> <span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> Spliterator&lt;E&gt; <span class="hljs-title">spliterator</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> Spliterators.spliterator(<span class="hljs-keyword">this</span>, Spliterator.DISTINCT | Spliterator.ORDERED);<br> &#125;<br></code></pre></td></tr></table></figure>



<h3 id="3-1-特性总结"><a href="#3-1-特性总结" class="headerlink" title="3.1 特性总结"></a>3.1 特性总结</h3><p>1、底层存储基于<code>LinkedHashMap</code>实现，内部使用双向链表存储元素，所以保证了元素的顺序性。<br>2、基于<code>key</code>的<code>hash</code>值存储，同样的对象<code>hash</code>值相同，所以元素不可重复，但是可以为<code>null</code>，可以快速查找是否包含某个元素。</p>
<h2 id="4-TreeSet"><a href="#4-TreeSet" class="headerlink" title="4.TreeSet"></a>4.TreeSet</h2><p><img src="/img/work/image-20211215115341761.png" alt="TreeSet类关系图"></p>
<p>还是先看类图，<code>TreeSet</code>继承自<code>AbstractSet</code>，实现了<code>NavigableSet</code>接口，<code>AbstractSet</code>为抽象类，继承自<code>AbstractCollection</code>，实现了最基本的<code>Collection</code>骨架。<code>TreeSet</code>是基于<code>TreeMap</code>实现的有序集合，<code>TreeSet</code>中含有一个<code>NavigableMap</code>类型的成员变量<code>m</code>，而<code>m</code>实际上是<code>TreeMap</code>的实例。我们知道<code>TreeMap</code>内部是用红黑树实现元素存储从而保证元素的顺序性的，那么同理<code>TreeSet</code>同样也是一个有序的集合。通过源码我们知道<code>TreeSet</code>继承自<code>AbstractSet</code>，实现<code>NavigableSet</code>、<code>Cloneable</code>、<code>Serializable</code>接口。其中<code>AbstractSet</code>提供 <code>Set</code> 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。<code>NavigableSet</code>是扩展的 <code>SortedSet</code>，具有了为给定搜索目标报告最接近匹配项的导航方法，这就意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。<code>Cloneable</code>支持克隆，<code>Serializable</code>支持序列化。</p>
<p>成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">//NavigableMap 对象</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> NavigableMap&lt;E,Object&gt; m;<br><span class="hljs-comment">//map的value值</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();<br></code></pre></td></tr></table></figure>



<p>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造由指定的可导航映射支持的集合。</span><br>TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;<br>    <span class="hljs-keyword">this</span>.m = m;<br>&#125;<br><span class="hljs-comment">//默认构造方法  根据其元素的自然顺序进行排序 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> TreeMap&lt;E,Object&gt;());<br>&#125;<br><span class="hljs-comment">//构造一个包含指定 collection 的TreeSet，它按照其元素的顺序进行排序</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; comparator)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> TreeMap&lt;&gt;(comparator));<br>&#125;<br><span class="hljs-comment">//构造一个指定Collection参数的TreeSet</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>();<br>    addAll(c);<br>&#125;<br><span class="hljs-comment">//构造一个指定SortedMap的TreeSet，根据SortedMap的比较器来来维持TreeSet的顺序</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">(SortedSet&lt;E&gt; s)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(s.comparator());<br>    addAll(s);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-1-特性总结"><a href="#4-1-特性总结" class="headerlink" title="4.1 特性总结"></a>4.1 特性总结</h3><p>1、底层存储基于<code>TreeMap</code>实现，内部使用红黑树结构表存储元素，所以保证了元素的顺序性。<br>2、元素不可为<code>null</code>。<br>2、遍历时不支持随机访问，只能通过迭代器和<code>for-each</code>遍进行遍历。</p>
<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><p><a href="https://yanglukuan.github.io/2017/09/09/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BSet%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/">Java集合框架之Set接口详解</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java-容器</category>
      </categories>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式-单例模式</title>
    <url>/2022/05/10/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>非常重要，单例模式是各个Java项目中必不可少的一种设计模式。本文的关注点将重点放在<strong>单例模式的写法</strong>以及<strong>每种写法的线程安全性</strong>上。所谓”线程安全性”的意思就是保证在创建单例对象的时候不存在竞争，只会创建出一个单例对象。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><strong>单例模式</strong></h2><p>作为对象的创建模式，<strong>单例模式确保其某一个类只有一个实例</strong>，而且自行实例化并向整个系统提供这个实例，这个类称为单例类。单例模式有以下特点：</p>
<ul>
<li>单例类只能有一个实例</li>
<li>单例类必须自己创建自己的唯一实例</li>
<li>单例类必须给其他所有对象提供这一实例</li>
</ul>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a><strong>饿汉式</strong></h2><p>顾名思义，饿汉式，就是使用类的时候不管用的是不是类中的单例部分，都直接创建出单例类，看一下饿汉式的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EagerSingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> EagerSingleton instance = <span class="hljs-keyword">new</span> EagerSingleton();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EagerSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EagerSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的例子中，在这个类被加载时，静态变量instance会被初始化，此时类的私有构造子会被调用。这时候，单例类的唯一实例就被创建出来了。</p>
<p>饿汉式其实是一种比较形象的称谓。既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在装载类的时候就创建对象实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> EagerSingleton instance = <span class="hljs-keyword">new</span> EagerSingleton();<br></code></pre></td></tr></table></figure>

<p><strong>饿汉式是典型的空间换时间</strong>，当类装载的时候就会创建类的实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断，节省了运行时间。</p>
<p>这种写法会不会造成竞争，引发线程安全问题呢？答案是不会。可能有人会觉得奇怪：</p>
<p>CPU执行线程A，实例化一个EagerSingleton，没有实例化完，CPU就从线程A切换到线程B了，线程B此时也实例化这个EagerSingleton，然后EagerSingleton被实例化出来了两次，有两份内存地址，不就有线程安全问题了吗？</p>
<p>没关系，我们完全不需要担心这个问题，JDK已经帮我们想到了,虚拟机采用了CAS配上失败重试的方式保证更新更新操作的原子性和TLAB两种方式来解决这个问题.</p>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a><strong>懒汉式</strong></h2><p>同样，顾名思义，这个人比较懒，只有当单例类用到的时候才会去创建这个单例类，看一下懒汉式的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazySingleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LazySingleton instance = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LazySingleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 静态工厂方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> LazySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> LazySingleton();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的懒汉式单例类实现里对静态工厂方法使用了同步化，以处理多线程环境。</p>
<p>懒汉式其实是一种比较形象的称谓。既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作，因此在装载对象的时候不创建对象实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LazySingleton instance = <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure>

<p><strong>懒汉式是典型的时间换空间</strong>,就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。当然，如果一直没有人使用的话，那就不会创建实例，则节约内存空间</p>
<p>由于懒汉式的实现是线程安全的，这样会降低整个访问的速度，而且每次都要判断。那么有没有更好的方式实现呢？</p>
<h2 id="双重检查加锁"><a href="#双重检查加锁" class="headerlink" title="双重检查加锁"></a>双重检查加锁</h2><p>可以使用“双重检查加锁”的方式来实现，就可以既实现线程安全，又能够使性能不受很大的影响。那么什么是“双重检查加锁”机制呢？</p>
<p>所谓“双重检查加锁”机制，指的是：并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。</p>
<p>“双重检查加锁”机制的实现会使用关键字volatile，它的意思是：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。</p>
<p><strong>注意：在java1.4及以前版本中，很多JVM对于volatile关键字的实现的问题，会导致“双重检查加锁”的失败，因此“双重检查加锁”机制只只能用在java5及以上的版本。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//先检查实例是否存在,如果不存在才进入下面的同步块</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//同步块、线程安全的创建实例</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">//再次检查实例是否存在，如果不存在才真正的创建实例</span><br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种实现方式既可以实现线程安全地创建实例，而又不会对性能造成太大的影响。它只是第一次创建实例的时候同步，以后就不需要同步了，从而加快了运行速度。</p>
<p><strong>提示：由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。因此一般建议，没有特别的需要，不要使用。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。</strong></p>
<p>根据上面的分析，常见的两种单例实现方式都存在小小的缺陷，那么有没有一种方案，既能实现延迟加载，又能实现线程安全呢？</p>
<h2 id="Lazy-initialization-holder-class模式"><a href="#Lazy-initialization-holder-class模式" class="headerlink" title="Lazy initialization holder class模式"></a>Lazy initialization holder class模式</h2><p> 这个模式综合使用了Java的类级内部类和多线程缺省同步锁的知识，很巧妙地同时实现了延迟加载和线程安全。 </p>
<h3 id="1-相应的基础知识"><a href="#1-相应的基础知识" class="headerlink" title="1.相应的基础知识"></a>1.相应的基础知识</h3><ul>
<li>什么是类级内部类？</li>
</ul>
<p><strong>简单点说，类级内部类指的是，有static修饰的成员式内部类。如果没有static修饰的成员式内部类被称为对象级内部类。</strong> </p>
<p><strong>类级内部类相当于其外部类的static成分，它的对象与外部类对象间不存在依赖关系，因此可直接创建。而对象级内部类的实例，是绑定在外部对象实例中的。</strong> </p>
<p><strong>类级内部类中，可以定义静态的方法。在静态方法中只能够引用外部类中的静态成员方法或者成员变量。</strong> </p>
<p><strong>类级内部类相当于其外部类的成员，只有在第一次被使用的时候才被会装载。</strong></p>
<ul>
<li>多线程缺省同步锁的知识</li>
</ul>
<p><strong>大家都知道，在多线程开发中，为了解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制。但是在某些情况中，JVM已经隐含地为您执行了同步，这些情况下就不用自己再来进行同步控制了。这些情况包括：</strong> </p>
<p> 1.由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时 </p>
<p> 2.访问final字段时 </p>
<p> 3.在创建线程之前创建对象时 </p>
<p> 4.线程可以看见它将要处理的对象时 </p>
<h3 id="2-解决方案的思路"><a href="#2-解决方案的思路" class="headerlink" title="2.解决方案的思路"></a>2.解决方案的思路</h3><p>要想很简单地实现线程安全，可以采用静态初始化器的方式，它可以由JVM来保证线程的安全性。比如前面的饿汉式实现方式。但是这样一来，不是会浪费一定的空间吗？因为这种实现方式，会在类装载的时候就初始化对象，不管你需不需要。 </p>
<p>如果现在有一种方法能够让类装载的时候不去初始化对象，那不就解决问题了？一种可行的方式就是采用类级内部类，在这个类级内部类里面去创建对象实例。这样一来，只要不使用到这个类级内部类，那就不会创建对象实例，从而同时实现延迟加载和线程安全。 </p>
<p>示例代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SingletonDemo</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *    类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例</span><br><span class="hljs-comment">     *    没有绑定关系，而且只有被调用到时才会装载，从而实现了延迟加载。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 静态初始化器，由JVM来保证线程安全</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo instance = <span class="hljs-keyword">new</span> SingletonDemo();<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当getInstance方法第一次被调用的时候，它第一次读取SingletonHolder.instance，导致SingletonHolder类得到初始化；而这个类在装载并被初始化的时候，会初始化它的静态域，从而创建Singleton的实例，由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性。 </p>
<p>这个模式的优势在于，getInstance方法并没有被同步，并且只是执行一个域的访问，因此延迟初始化并没有增加任何访问成本。</p>
<h2 id="单例和枚举"><a href="#单例和枚举" class="headerlink" title="单例和枚举"></a>单例和枚举</h2><p>按照《高效Java 第二版》中的说法：单元素的枚举类型已经成为实现Singleton的最佳方法。用枚举来实现单例非常简单，只需要编写一个包含单个元素的枚举类型即可。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义一个枚举的元素，它就代表了Singleton的一个实例。</span><br><span class="hljs-comment">     */</span><br>    <br>    uniqueInstance;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单例可以有自己的操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">singletonOperation</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//功能处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。 </p>
<h2 id="单例模式在Java中的应用及解读"><a href="#单例模式在Java中的应用及解读" class="headerlink" title="单例模式在Java中的应用及解读"></a><strong>单例模式在Java中的应用及解读</strong></h2><p>Runtime是一个典型的例子，看下JDK API对于这个类的解释”每个Java应用程序都有一个Runtime类实例，使应用程序能够与其运行的环境相连接，可以通过getRuntime方法获取当前运行时。应用程序不能创建自己的Runtime类实例。”，这段话，有两点很重要： </p>
<p> 1、每个应用程序都有一个Runtime类实例 </p>
<p> 2、应用程序不能创建自己的Runtime类实例 </p>
<p>只有一个、不能自己创建，是不是典型的单例模式？看一下，Runtime类的写法： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runtime</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Runtime currentRuntime = <span class="hljs-keyword">new</span> Runtime();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the runtime object associated with the current Java application.</span><br><span class="hljs-comment">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance </span><br><span class="hljs-comment">     * methods and must be invoked with respect to the current runtime object. </span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span><br><span class="hljs-comment">     *          Java application.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title">getRuntime</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-keyword">return</span> currentRuntime;<br>    &#125;<br><br>    <span class="hljs-comment">/** Don&#x27;t let anyone else instantiate this class */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Runtime</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看到Runtime使用getRuntime()方法并让构造方法私有保证程序中只有一个Runtime实例且Runtime实例不可以被用户创建。 </p>
<h2 id="单例模式的好处"><a href="#单例模式的好处" class="headerlink" title="单例模式的好处"></a><strong>单例模式的好处</strong></h2><p>作为一种重要的设计模式，单例模式的好处有： </p>
<p> 1、控制资源的使用，通过线程同步来控制资源的并发访问 </p>
<p> 2、控制实例的产生，以达到节约资源的目的 </p>
<p> 3、控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信 </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/xrq730/p/4905711.html">五月的仓吉-单例模式</a></p>
<p><a href="https://www.cnblogs.com/java-my-life/archive/2012/03/31/2425631.html">java_my_life-单例模式</a></p>
]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Java设计模式-原型模式</title>
    <url>/2022/05/21/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>原型模式(Prototype Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 </p>
<p>原型模式是一种对象创建型模式。</p>
<p>原型模式的工作原理很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。  </p>
<p>原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。 </p>
<p>需要注意的是通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。 通过不同的方式修改可以得到一系列相似但不完全相同的对象。 </p>
<h3 id="2-角色"><a href="#2-角色" class="headerlink" title="2.角色"></a>2.角色</h3><ul>
<li>Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。</li>
<li>ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。</li>
<li>Client（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。 由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。</li>
</ul>
<h3 id="3-核心"><a href="#3-核心" class="headerlink" title="3.核心"></a>3.核心</h3><p>原型模式的核心在于如何实现克隆方法。 </p>
<p><strong>使用原始模式的时候一定要注意为深克隆还是浅克隆。</strong> </p>
<h3 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4.适用场景"></a>4.适用场景</h3><p>创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。 </p>
<h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5.注意事项"></a>5.注意事项</h3><p>使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。</p>
<p>还记得单例模式吗？单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。   </p>
<p><strong>深拷贝与浅拷贝：</strong>  </p>
<ul>
<li>Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是<strong>浅拷贝</strong>。</li>
<li> 如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。 </li>
</ul>
<p>PS：深拷贝与浅拷贝问题中，会发生深拷贝的有java中的8种基本类型以及他们的封装类型，另外还有String类型。其余的都是浅拷贝。</p>
<h3 id="6-代码示例"><a href="#6-代码示例" class="headerlink" title="6.代码示例"></a>6.代码示例</h3><p>定义产品 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Product</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">(String word)</span></span>;<br><br>    <span class="hljs-function">Product <span class="hljs-title">createClone</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setCh</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 第一种实现 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Underline</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span> </span>&#123;<br><br>    <span class="hljs-keyword">char</span> ch;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Underline</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.ch = ch;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        System.out.print(ch);<br>        System.out.print(word);<br>        System.out.println(ch);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.getBytes().length + <span class="hljs-number">1</span>; i++) &#123;<br>            System.out.print(ch);<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createClone</span><span class="hljs-params">()</span> </span>&#123;<br><br>        Product p = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            p = (Product) clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCh</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.ch = ch;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p> 第二种实现 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageBox</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> ch;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageBox</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.ch = ch;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.getBytes().length + <span class="hljs-number">1</span>; i++) &#123;<br>            System.out.print(ch);<br>        &#125;<br>        System.out.println();<br><br>        System.out.print(ch);<br>        System.out.print(word);<br>        System.out.println(ch);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.getBytes().length + <span class="hljs-number">1</span>; i++) &#123;<br>            System.out.print(ch);<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createClone</span><span class="hljs-params">()</span> </span>&#123;<br>        Product p = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            p = (Product) clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCh</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.ch = ch;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 管理类 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> </span>&#123;<br><br>    HashMap hashmap = <span class="hljs-keyword">new</span> HashMap();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(String key, Product p)</span> </span>&#123;<br>        hashmap.put(key, p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">create</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        Product p = (Product) hashmap.get(key);<br>        <span class="hljs-keyword">return</span> p.createClone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrototypeMain</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Manager m = <span class="hljs-keyword">new</span> Manager();<br>        Product p1 = <span class="hljs-keyword">new</span> Underline(<span class="hljs-string">&#x27;@&#x27;</span>);<br>        m.register(<span class="hljs-string">&quot;line&quot;</span>, p1);<br><br>        Product p2 = <span class="hljs-keyword">new</span> MessageBox(<span class="hljs-string">&#x27;$&#x27;</span>);<br>        m.register(<span class="hljs-string">&quot;msg&quot;</span>, p2);<br>        Product p3 = m.create(<span class="hljs-string">&quot;line&quot;</span>);<br>        p3.setCh(<span class="hljs-string">&#x27;%&#x27;</span>);<br>        Product p4 = m.create(<span class="hljs-string">&quot;msg&quot;</span>);<br>        p4.setCh(<span class="hljs-string">&#x27;^&#x27;</span>);<br>        p1.use(<span class="hljs-string">&quot;fire&quot;</span>);<br>        p2.use(<span class="hljs-string">&quot;huo&quot;</span>);<br>        p3.use(<span class="hljs-string">&quot;love&quot;</span>);<br>        p4.use(<span class="hljs-string">&quot;1314&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 运行结果 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@fire</span>@<br>@@@@@<br>$$$$<br>$huo$<br>$$$$<br>%love%<br>%%%%%<br>^^^^^<br>^<span class="hljs-number">1314</span>^<br>^^^^^<br></code></pre></td></tr></table></figure>

<h3 id="7-Java语言提供的clone-方法"><a href="#7-Java语言提供的clone-方法" class="headerlink" title="7.Java语言提供的clone()方法"></a>7.Java语言提供的clone()方法</h3><p>学过Java语言的人都知道，所有的Java类都继承自 java.lang.Object。事实上，Object 类提供一个 clone() 方法，可以将一个Java对象复制一份。因此在Java中可以直接使用 Object 提供的 clone() 方法来实现对象的克隆，Java语言中的原型模式实现很简单。 </p>
<p>需要注意的是能够实现克隆的Java类必须实现一个 标识接口 Cloneable，表示这个Java类支持被复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个 CloneNotSupportedException 异常。 </p>
<h3 id="8-原型模式的典型应用"><a href="#8-原型模式的典型应用" class="headerlink" title="8.原型模式的典型应用"></a>8.原型模式的典型应用</h3><h5 id="8-1-Object-类中的-clone-接口"><a href="#8-1-Object-类中的-clone-接口" class="headerlink" title="8.1 Object 类中的 clone 接口"></a>8.1 Object 类中的 clone 接口</h5><p> Cloneable 接口的实现类，可以看到至少一千多个，找几个例子譬如： </p>
<h5 id="8-2-ArrayList-对-clone-的重写如下："><a href="#8-2-ArrayList-对-clone-的重写如下：" class="headerlink" title="8.2 ArrayList 对 clone 的重写如下："></a>8.2 ArrayList 对 clone 的重写如下：</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="hljs-keyword">super</span>.clone();<br>            v.elementData = Arrays.copyOf(elementData, size);<br>            v.modCount = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> v;<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-comment">// this shouldn&#x27;t happen, since we are Cloneable</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 调用 super.clone(); 之后把 elementData 数据 copy 了一份 </p>
<h5 id="8-3-HashMap-对-clone-方法的重写"><a href="#8-3-HashMap-对-clone-方法的重写" class="headerlink" title="8.3 HashMap 对 clone 方法的重写"></a>8.3 HashMap 对 clone 方法的重写</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>        HashMap&lt;K,V&gt; result;<br>        <span class="hljs-keyword">try</span> &#123;<br>            result = (HashMap&lt;K,V&gt;)<span class="hljs-keyword">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-comment">// this shouldn&#x27;t happen, since we are Cloneable</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e);<br>        &#125;<br>        result.reinitialize();<br>        result.putMapEntries(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="8-4-mybatis-中的-org-apache-ibatis-cache-CacheKey-对-clone-方法的重写："><a href="#8-4-mybatis-中的-org-apache-ibatis-cache-CacheKey-对-clone-方法的重写：" class="headerlink" title="8.4 mybatis 中的 org.apache.ibatis.cache.CacheKey 对 clone 方法的重写："></a>8.4 mybatis 中的 org.apache.ibatis.cache.CacheKey 对 clone 方法的重写：</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheKey</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Object&gt; updateList;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CacheKey <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        CacheKey clonedCacheKey = (CacheKey)<span class="hljs-keyword">super</span>.clone();<br>        clonedCacheKey.updateList = <span class="hljs-keyword">new</span> ArrayList(<span class="hljs-keyword">this</span>.updateList);<br>        <span class="hljs-keyword">return</span> clonedCacheKey;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 这里又要注意，updateList 是 List 类型，所以可能是值类型的List，也可能是引用类型的List，克隆的结果需要注意是否为深克隆或者浅克隆 </p>
<h3 id="9-原型模式的优缺点"><a href="#9-原型模式的优缺点" class="headerlink" title="9. 原型模式的优缺点"></a>9. 原型模式的优缺点</h3><h4 id="9-1-优点"><a href="#9-1-优点" class="headerlink" title="9.1 优点"></a>9.1 优点</h4><p> 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。 </p>
<h4 id="9-2-缺点"><a href="#9-2-缺点" class="headerlink" title="9.2 缺点"></a>9.2 缺点</h4><p> 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。 </p>
<h3 id="10-参考"><a href="#10-参考" class="headerlink" title="10.参考"></a>10.参考</h3><p><a href="https://fhfirehuo.github.io/Attacking-Java-Rookie/Chapter04/Prototype.html">https://fhfirehuo.github.io/Attacking-Java-Rookie/Chapter04/Prototype.html</a></p>
]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式-工厂方法模式</title>
    <url>/2022/04/27/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a><strong>工厂方法模式</strong></h3><p><strong>概念:</strong></p>
<blockquote>
<p> 工厂方法模式是类的创建模式。工厂方法模式的用意是<strong>定义一个创建产品对象的工厂接口，将实际创建工厂推迟到子类中</strong>。 </p>
</blockquote>
<p><strong>工厂方法模式说明</strong></p>
<p>工厂方法模式是对简单工厂模式进一步抽象的结果，假如不使用反射的工厂方法模式，那么所有的if…else if … else 都放在工厂类中，势必造成工厂类的无限臃肿； 这时候就需要工厂方法模式来处理这个问题了。  </p>
<p>核心的工厂类不再负责所有对象的创建，  而是将具体的创建工作交给子类去做。  这个类则摇身一变变成了一个抽象工厂角色，  仅仅负责给出具体工厂子类必须实现的接口。  这一步的改进，使得系统可以在不修改具体工厂角色的情况下引入新的产品。 </p>
<h3 id="工厂方法模式结构"><a href="#工厂方法模式结构" class="headerlink" title="工厂方法模式结构"></a><strong>工厂方法模式结构</strong></h3><p> 使用工厂方法模式的系统涉及到以下角色： </p>
<p><strong>1.抽象工厂角色</strong></p>
<p>担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。 </p>
<p><strong>2.具体工厂角色</strong></p>
<p>担任这个角色的是实现了抽象工厂接口的具体JAVA类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建导出类 </p>
<p><strong>3.抽象导出角色</strong> </p>
<p>工厂方法模式所创建的对象的超类，也就是所有导出类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。 </p>
<p> <strong>4.具体导出角色</strong> </p>
<p>这个角色实现了抽象导出角色所声明的接口，工厂方法模式所创建的每一个对象都是某个具体导出角色的实例。 </p>
<h3 id="工厂方法模式的示例"><a href="#工厂方法模式的示例" class="headerlink" title="工厂方法模式的示例"></a><strong>工厂方法模式的示例</strong></h3><p>首先是抽象工厂角色源代码。它声明了一个工厂方法，要求所有的具体工厂角色都实现这个工厂方法。参数type表示导出的格式是哪一种结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExportFactory</span> </span>&#123;<br>    <span class="hljs-function">ExportFile <span class="hljs-title">factory</span><span class="hljs-params">(String type)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>它有两个实现类，分别是导出HTML文件的工厂和导出PDF文件的工厂： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExportHtmlFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExportFactory</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ExportFile <span class="hljs-title">factory</span><span class="hljs-params">(String type)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;standard&quot;</span>.equals(type))<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ExportStandardHtmlFile();<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;financial&quot;</span>.equals(type))<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ExportFinancialHtmlFile();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExportPdfFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExportFactory</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ExportFile <span class="hljs-title">factory</span><span class="hljs-params">(String type)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;standard&quot;</span>.equals(type))<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ExportStandardPdfFile();<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;financial&quot;</span>.equals(type))<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ExportFinancialPdfFile();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>抽象产品角色，一个导出文件： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExportFile</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">export</span><span class="hljs-params">(String data)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>具体产品角色： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExportFinancialHtmlFile</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExportFile</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">export</span><span class="hljs-params">(String data)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;导出财务版HTML文件&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExportFinancialPdfFile</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExportFile</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">export</span><span class="hljs-params">(String data)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;导出财务版PDF文件&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExportStandardHtmlFile</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExportFile</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">export</span><span class="hljs-params">(String data)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;导出标准HTML文件&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExportStandardPdfFile</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExportFile</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">export</span><span class="hljs-params">(String data)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;导出标准PDF文件&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>模拟客户端调用，实例化出一个具体的工厂角色，根据传入的参数返回不同的产品角色： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String data = <span class="hljs-string">&quot;&quot;</span>;<br>        ExportFactory htmlFactory = <span class="hljs-keyword">new</span> ExportHtmlFactory();<br>        ExportFile exportFile = htmlFactory.factory(<span class="hljs-string">&quot;financial&quot;</span>);<br>        exportFile.export(data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>客户端创建ExportHtmlFactory对象，这时客户端所持有变量的静态类型为ExportFactory，而实际类型为ExportHtmlFactory。然后客户端调用ExportHtmlFactory对象的工厂方法factory()，接着后者调用ExportFinancialHtmlFile的构造子创建出导出对象。 </p>
<h3 id="工厂方法模式和简单工厂模式"><a href="#工厂方法模式和简单工厂模式" class="headerlink" title="工厂方法模式和简单工厂模式"></a>工厂方法模式和简单工厂模式</h3><p>工厂方法模式和简单工厂模式在结构上的不同很明显。工厂方法模式的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上。 </p>
<p>工厂方法模式退化后可以变得很像简单工厂模式。 设想如果非常确定一个系统只需要一个具体工厂类，那么不妨把抽象工厂类合并到具体工厂类中去。  由于只有一个具体工厂类，所以不妨将工厂方法改为静态方法，这时候就得到了简单工厂模式。 </p>
<h3 id="工厂方法模式在Java中的应用及解读"><a href="#工厂方法模式在Java中的应用及解读" class="headerlink" title="工厂方法模式在Java中的应用及解读"></a><strong>工厂方法模式在Java中的应用及解读</strong></h3><p>拿ThreadFactory举个例子，顾名思义，这是一个生产线程的接口 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a new &#123;<span class="hljs-doctag">@code</span> Thread&#125;.  Implementations may also initialize</span><br><span class="hljs-comment">     * priority, name, daemon status, &#123;<span class="hljs-doctag">@code</span> ThreadGroup&#125;, etc.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r a runnable to be executed by new thread instance</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> constructed thread, or &#123;<span class="hljs-doctag">@code</span> null&#125; if the request to</span><br><span class="hljs-comment">     *         create a thread is rejected</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>具体的线程工厂可以implements这个接口并实现newThread(Runnable r)方法， 来生产具体线程工厂想要生产的线程。  JDK在Executors给开发者提供了一个静态内部类DefaultThreadFactory，当然开发者也可以自行实现这个接口，写自定义的线程工厂。 </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>对于系统的设计应该足够灵活并尽可能降低代码之间的耦合度，当修改或增加一个新的功能时，使得使用者尽可能修改少的地方即可。假如设计不够灵活，将无法面对多变的需求，可能一个极小的需求变更，都会使代码结构发生改变，并导致其他使用的人都要修改他们的代码。牵一发而动全身，系统日后的维护将变得艰难。 </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h3><p><a href="https://www.cnblogs.com/xrq730/p/4905578.html">五月的仓吉-工厂方法模式</a></p>
<p><a href="https://www.cnblogs.com/java-my-life/archive/2012/03/25/2416227.html">java_my_life-工厂方法模式</a></p>
]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Java设计模式-抽象工厂模式</title>
    <url>/2022/05/06/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>概念:</strong></p>
<p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂;该超级工厂又称为其他工厂的工厂。 </p>
<p>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式，提供了一种创建对象的最佳方式。 </p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 </p>
<p>在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品。 </p>
<p>抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。 </p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>每一个模式都是针对一定问题的解决方案。抽象工厂模式与工厂方法模式的最大区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。 </p>
<p>在学习抽象工厂具体实例之前，应该明白两个重要的概念：产品族和产品等级。 </p>
<p>所谓产品族，是指位于不同产品等级结构中，功能相关联的产品组成的家族。比如AMD的主板、芯片组、CPU组成一个家族，Intel的主板、芯片组、CPU组成一个家族。而这两个家族都来自于三个产品等级：主板、芯片组、CPU。一个等级结构是由相同的结构的产品组成 。 </p>
<p><img src="/img/work/product_factory.png"></p>
<p>显然，每一个产品族中含有产品的数目，与产品等级结构的数目是相等的。产品的等级结构与产品族将产品按照不同方向划分，形成一个二维的坐标系。横轴表示产品的等级结构，纵轴表示产品族，上图共有两个产品族，分布于三个不同的产品等级结构中。只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一的确定这个产品。 </p>
<p>上面所给出的三个不同的等级结构具有平行的结构。因此，如果采用工厂方法模式，就势必要使用三个独立的工厂等级结构来对付这三个产品等级结构。由于这三个产品等级结构的相似性，会导致三个平行的工厂等级结构。随着产品等级结构的数目的增加，工厂方法模式所给出的工厂等级结构的数目也会随之增加。如下图： </p>
<p><img src="/img/work/1651879472655.png"></p>
<p>那么，是否可以使用同一个工厂等级结构来对付这些相同或者极为相似的产品等级结构呢？当然可以的，而且这就是抽象工厂模式的好处。同一个工厂等级结构负责三个不同产品等级结构中的产品对象的创建。 </p>
<p><img src="/img/work/1651879655132.png"></p>
<p>可以看出，一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象。显然，这时候抽象工厂模式比简单工厂模式、工厂方法模式更有效率。对应于每一个产品族都有一个具体工厂。而每一个具体工厂负责创建属于同一个产品族，但是分属于不同等级结构的产品。 </p>
<h3 id="抽象工厂模式结构"><a href="#抽象工厂模式结构" class="headerlink" title="抽象工厂模式结构"></a>抽象工厂模式结构</h3><p>抽象工厂模式是对象的创建模式，它是工厂方法模式的进一步推广。 </p>
<p>假设一个子系统需要一些产品对象，而这些产品又属于一个以上的产品等级结构。那么为了将消费这些产品对象的责任和创建这些产品对象的责任分割开来，可以引进抽象工厂模式。这样的话，消费产品的一方不需要直接参与产品的创建工作，而只需要向一个公用的工厂接口请求所需要的产品。 </p>
<p>通过使用抽象工厂模式，可以处理具有相同（或者相似）等级结构中的多个产品族中的产品对象的创建问题。如下图所示： </p>
<p><img src="/img/work/1651879841948.png"></p>
<p>由于这两个产品族的等级结构相同，因此使用同一个工厂族也可以处理这两个产品族的创建问题，这就是抽象工厂模式。 </p>
<p>根据产品角色的结构图，就不难给出工厂角色的结构设计图。 </p>
<p><img src="/img/work/1651879946313.png"></p>
<p>可以看出，每一个工厂角色都有两个工厂方法，分别负责创建分属不同产品等级结构的产品对象。 </p>
<p><img src="/img/work/1651879997092.png"></p>
<h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a><strong>代码实例</strong></h3><p>CPU接口与具体实现 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Cpu</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntelCpu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cpu</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * CPU的针脚数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pins = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-title">IntelCpu</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pins)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.pins = pins;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        System.out.println(<span class="hljs-string">&quot;Intel CPU的针脚数：&quot;</span> + pins);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AmdCpu</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">Cpu</span></span>&#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * CPU的针脚数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pins = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-title">AmdCpu</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pins)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.pins = pins;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        System.out.println(<span class="hljs-string">&quot;AMD CPU的针脚数：&quot;</span> + pins);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主板接口与具体实现 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Mainboard</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">installCPU</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntelMainboard</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Mainboard</span></span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * CPU插槽的孔数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cpuHoles = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造方法，传入CPU插槽的孔数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cpuHoles</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IntelMainboard</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpuHoles)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.cpuHoles = cpuHoles;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">installCPU</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        System.out.println(<span class="hljs-string">&quot;Intel主板的CPU插槽孔数是：&quot;</span> + cpuHoles);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AmdMainboard</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Mainboard</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * CPU插槽的孔数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cpuHoles = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造方法，传入CPU插槽的孔数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cpuHoles</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AmdMainboard</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cpuHoles)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.cpuHoles = cpuHoles;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">installCPU</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        System.out.println(<span class="hljs-string">&quot;AMD主板的CPU插槽孔数是：&quot;</span> + cpuHoles);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>抽象工厂类和实现类： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建CPU对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> CPU对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Cpu <span class="hljs-title">createCpu</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建主板对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 主板对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Mainboard <span class="hljs-title">createMainboard</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AmdFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AbstractFactory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Cpu <span class="hljs-title">createCpu</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AmdCpu(<span class="hljs-number">938</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mainboard <span class="hljs-title">createMainboard</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AmdMainboard(<span class="hljs-number">938</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntelFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Cpu <span class="hljs-title">createCpu</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IntelCpu(<span class="hljs-number">755</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mainboard <span class="hljs-title">createMainboard</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IntelMainboard(<span class="hljs-number">755</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>与简单工厂模式主要的变化是: 从客户端不再传入选择CPU和主板的参数，而是直接传入客户已经选择好的产品对象。这样就避免了单独去选择CPU和主板所带来的兼容性问题，客户要选就是一套，就是一个系列。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComputerEngineer</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义组装机需要的CPU</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Cpu cpu = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义组装机需要的主板</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Mainboard mainboard = <span class="hljs-keyword">null</span>;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeComputer</span><span class="hljs-params">(AbstractFactory af)</span> </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 组装机器的基本步骤</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//1:首先准备好装机所需要的配件</span><br>        prepareHardwares(af);<br>        <span class="hljs-comment">//2:组装机器</span><br>        <span class="hljs-comment">//3:测试机器</span><br>        <span class="hljs-comment">//4：交付客户</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareHardwares</span><span class="hljs-params">(AbstractFactory af)</span> </span>&#123;<br>        <span class="hljs-comment">//这里要去准备CPU和主板的具体实现，为了示例简单，这里只准备这两个</span><br>        <span class="hljs-comment">//可是，装机工程师并不知道如何去创建，怎么办呢？</span><br>        <span class="hljs-comment">//直接找相应的工厂获取</span><br>        <span class="hljs-keyword">this</span>.cpu = af.createCpu();<br>        <span class="hljs-keyword">this</span>.mainboard = af.createMainboard();<br><br>        <span class="hljs-comment">//测试配件是否好用</span><br>        <span class="hljs-keyword">this</span>.cpu.calculate();<br>        <span class="hljs-keyword">this</span>.mainboard.installCPU();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建装机工程师对象</span><br>        ComputerEngineer computerEngineer = <span class="hljs-keyword">new</span> ComputerEngineer();<br><br>        <span class="hljs-comment">//客户选择并创建需要使用的产品对象</span><br>        AbstractFactory intelFactory = <span class="hljs-keyword">new</span> IntelFactory();<br><br>        <span class="hljs-comment">//告诉装机工程师自己选择的产品，让装机工程师组装电脑</span><br>        computerEngineer.makeComputer(intelFactory);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Intel CPU的针脚数：<span class="hljs-number">755</span><br>Intel主板的CPU插槽孔数是：<span class="hljs-number">755</span><br></code></pre></td></tr></table></figure>



<h3 id="在什么情况下应当使用抽象工厂模式"><a href="#在什么情况下应当使用抽象工厂模式" class="headerlink" title="在什么情况下应当使用抽象工厂模式"></a>在什么情况下应当使用抽象工厂模式</h3><p> 　<strong>1.一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的</strong> </p>
<p> 　<strong>2.这个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</strong> </p>
<p>​     <strong>3.同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。</strong>（比如：Intel主板必须使用Intel CPU、Intel芯片组） </p>
<p>​    <strong>4.系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。</strong> </p>
<h3 id="抽象工厂模式的起源"><a href="#抽象工厂模式的起源" class="headerlink" title="抽象工厂模式的起源"></a><strong>抽象工厂模式的起源</strong></h3><p>抽象工厂模式的起源或者最早的应用，是用于创建分属于不同操作系统的视窗构建。比如：命令按键（Button）与文字框（Text)都是视窗构建，在UNIX操作系统的视窗环境和Windows操作系统的视窗环境中，这两个构建有不同的本地实现，它们的细节有所不同。 </p>
<p>在每一个操作系统中，都有一个视窗构建组成的构建家族。在这里就是Button和Text组成的产品族。而每一个视窗构件都构成自己的等级结构，由一个抽象角色给出抽象的功能描述，而由具体子类给出不同操作系统下的具体实现。</p>
<p><img src="/img/work/1651881684625.png"></p>
<p>可以发现在上面的产品类图中，有两个产品的等级结构，分别是Button等级结构和Text等级结构。同时有两个产品族，也就是UNIX产品族和Windows产品族。UNIX产品族由UNIX Button和UNIX Text产品构成；而Windows产品族由Windows Button和Windows Text产品构成。 </p>
<p><img src="/img/work/1651881726678.png"></p>
<p>系统对产品对象的创建需求由一个工程的等级结构满足，其中有两个具体工程角色，即UnixFactory和WindowsFactory。UnixFactory对象负责创建Unix产品族中的产品，而WindowsFactory对象负责创建Windows产品族中的产品。这就是抽象工厂模式的应用，抽象工厂模式的解决方案如下图： </p>
<p><img src="/img/work/1651881763504.png"></p>
<h3 id="抽象工厂模式的优点"><a href="#抽象工厂模式的优点" class="headerlink" title="抽象工厂模式的优点"></a>抽象工厂模式的优点</h3><ul>
<li><strong>分离接口和实现</strong></li>
</ul>
<p>　　客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已。也就是说，客户端从具体的产品实现中解耦。</p>
<ul>
<li><strong>使切换产品族变得容易</strong></li>
</ul>
<p>　　因为一个具体的工厂实现代表的是一个产品族，比如上面例子的从Intel系列到AMD系列只需要切换一下具体工厂。</p>
<h3 id="抽象工厂模式的缺点"><a href="#抽象工厂模式的缺点" class="headerlink" title="抽象工厂模式的缺点"></a>抽象工厂模式的缺点</h3><ul>
<li><strong>不太容易扩展新的产品</strong></li>
</ul>
<p>　　如果需要给整个产品族添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h3><p><a href="https://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html">java_my_life</a></p>
<p><a href="https://fhfirehuo.github.io/Attacking-Java-Rookie/Chapter04/AbstractFactory.html">进击的Java菜鸟</a></p>
]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式-策略模式</title>
    <url>/2022/04/06/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>概述：<strong>策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得算法可以在不影响到客户端的情况下发生变化。</strong></p>
</blockquote>
<h2 id="1-策略模式的结构"><a href="#1-策略模式的结构" class="headerlink" title="1.策略模式的结构"></a>1.策略模式的结构</h2><p>策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。下面就以一个示意性的实现讲解策略模式实例的结构。</p>
<p><img src="/img/work/58B2D081-A431-4439-A18C-7BC8D5F6EF5D.png" alt="策略模式结构"></p>
<p>这个模式涉及到三个角色：</p>
<ul>
<li><p>**环境(Context)角色:**持有一个Strategy的引用。</p>
</li>
<li><p><strong>抽象策略(Strategy)角色：</strong>这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</p>
</li>
<li><p><strong>具体策略(ConcreteStrategy)角色：</strong>包装了相关的算法或行为。</p>
</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h3><p><strong>抽象折扣类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MemberStrategy</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算价格</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> booksPrice 书价</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> double</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">calcPrice</span><span class="hljs-params">(<span class="hljs-keyword">double</span> booksPrice)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>初级会员折扣类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrimaryMemberStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MemberStrategy</span></span>&#123;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcPrice</span><span class="hljs-params">(<span class="hljs-keyword">double</span> booksPrice)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;对于初级会员的没有折扣&quot;</span>);<br>        <span class="hljs-keyword">return</span> booksPrice;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>中级会员折扣类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntermediateMemberStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MemberStrategy</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcPrice</span><span class="hljs-params">(<span class="hljs-keyword">double</span> booksPrice)</span> </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;对于中级会员的折扣为10%&quot;</span>);<br>        <span class="hljs-keyword">return</span> booksPrice * <span class="hljs-number">0.9</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>高级会员折扣类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdvancedMemberStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MemberStrategy</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcPrice</span><span class="hljs-params">(<span class="hljs-keyword">double</span> booksPrice)</span> </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;对于高级会员折扣为20%&quot;</span>);<br>        <span class="hljs-keyword">return</span> booksPrice * <span class="hljs-number">0.8</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>价格环境类(根据类创建具体计算)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriceContext</span> </span>&#123;<br><br>    <span class="hljs-comment">//持有一个具体的策略对象</span><br>    <span class="hljs-keyword">private</span> MemberStrategy strategy;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PriceContext</span><span class="hljs-params">(MemberStrategy strategy)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.strategy = strategy;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算图书的价格</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bookPrice 书价</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 计算出打折的价格</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">quote</span><span class="hljs-params">(<span class="hljs-keyword">double</span> bookPrice)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.strategy.calcPrice(bookPrice);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>客户创建消费获取价格</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemberConsume</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//高级会员消费,选择高级会员的策略</span><br>        MemberStrategy strategy = <span class="hljs-keyword">new</span> AdvancedMemberStrategy();<br><br>        <span class="hljs-comment">//创建环境</span><br>        PriceContext context = <span class="hljs-keyword">new</span> PriceContext(strategy);<br><br>        <span class="hljs-comment">//计算价格</span><br>        <span class="hljs-keyword">double</span> quote = context.quote(<span class="hljs-number">300</span>);<br>        System.out.println(<span class="hljs-string">&quot;图书的价格为：&quot;</span> + quote);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的示例可以看出，策略模式仅仅封装算法，提供新的算法插入到已有系统中，以及老算法从系统中“退休”的方法，策略模式并不决定在何时使用何种算法。在什么情况下使用什么算法是由客户端决定的。</p>
<h2 id="2-认识策略模式"><a href="#2-认识策略模式" class="headerlink" title="2.认识策略模式"></a>2.认识策略模式</h2><p><strong>策略模式的重心</strong></p>
<p>策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。</p>
<p><strong>算法的平等性</strong></p>
<p>策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。</p>
<p>所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。</p>
<p><strong>运行时策略的唯一性</strong></p>
<p>运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。</p>
<p><strong>公有的行为</strong></p>
<p>经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。</p>
<p>这其实也是典型的将代码向继承等级结构的上方集中的标准做法。</p>
<p><img src="/img/work/78A227A5-0A7E-4227-B77B-637FFD7D515A.png"></p>
<h2 id="3-策略模式的优点"><a href="#3-策略模式的优点" class="headerlink" title="3.策略模式的优点"></a>3.策略模式的优点</h2><p>（1）策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</p>
<p>（2）使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。</p>
<h2 id="4-策略模式的缺点"><a href="#4-策略模式的缺点" class="headerlink" title="4.策略模式的缺点"></a>4.策略模式的缺点</h2><p>（1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</p>
<p>（2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</p>
<h2 id="5-策略模式在Java中的应用及解读"><a href="#5-策略模式在Java中的应用及解读" class="headerlink" title="5.策略模式在Java中的应用及解读"></a>5.<strong>策略模式在Java中的应用及解读</strong></h2><p>策略模式在Java中的应用，<strong>Comparator接口</strong>。Collections里面有一个sort方法，因为集合里面的元素有可能是复合对象，复合对象并不像基本数据类型，可以根据大小排序，复合对象怎么排序呢？基于这个问题考虑，Java要求如果定义的复合对象要有排序的功能，就自行实现Comparable接口或Comparator接口，看一下sort带Comparator的重载方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(List&lt;T&gt; list, Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; c)</span> </span>&#123;<br>     Object[] a = list.toArray();<br>     Arrays.sort(a, (Comparator)c);<br>     ListIterator i = list.listIterator();<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;a.length; j++) &#123;<br>         i.next();<br>         i.set(a[j]);<br>     &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>跟一下第3行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] a, Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; c)</span> </span>&#123;<br>    T[] aux = (T[])a.clone();<br>        <span class="hljs-keyword">if</span> (c==<span class="hljs-keyword">null</span>)<br>            mergeSort(aux, a, <span class="hljs-number">0</span>, a.length, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">else</span><br>            mergeSort(aux, a, <span class="hljs-number">0</span>, a.length, <span class="hljs-number">0</span>, c);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>传入的c不为null，跟一下第6行的mergeSort：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(Object[] src,</span></span><br><span class="hljs-params"><span class="hljs-function">                  Object[] dest,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> off,</span></span><br><span class="hljs-params"><span class="hljs-function">                  Comparator c)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> length = high - low;<br><br>    <span class="hljs-comment">// Insertion sort on smallest arrays</span><br>    <span class="hljs-keyword">if</span> (length &lt; INSERTIONSORT_THRESHOLD) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=low; i&lt;high; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=i; j&gt;low &amp;&amp; c.compare(dest[j-<span class="hljs-number">1</span>], dest[j])&gt;<span class="hljs-number">0</span>; j--)<br>            swap(dest, j, j-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>        <span class="hljs-comment">// Recursively sort halves of dest into src</span><br>        <span class="hljs-keyword">int</span> destLow  = low;<br>        <span class="hljs-keyword">int</span> destHigh = high;<br>        low  += off;<br>        high += off;<br>        <span class="hljs-keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        mergeSort(dest, src, low, mid, -off, c);<br>        mergeSort(dest, src, mid, high, -off, c);<br><br>        <span class="hljs-comment">// If list is already sorted, just copy from src to dest.  This is an</span><br>        <span class="hljs-comment">// optimization that results in faster sorts for nearly ordered lists.</span><br>        <span class="hljs-keyword">if</span> (c.compare(src[mid-<span class="hljs-number">1</span>], src[mid]) &lt;= <span class="hljs-number">0</span>) &#123;<br>           System.arraycopy(src, low, dest, destLow, length);<br>           <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Merge sorted halves (now in src) into dest</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123;<br>            <span class="hljs-keyword">if</span> (q &gt;= high || p &lt; mid &amp;&amp; c.compare(src[p], src[q]) &lt;= <span class="hljs-number">0</span>)<br>                dest[i] = src[p++];<br>            <span class="hljs-keyword">else</span><br>                dest[i] = src[q++];<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>第10行，根据Comparator接口实现类的compare方法的返回结果决定是否要swap（交换）。</p>
<p>这就是策略模式，我们可以给Collections的sort方法传入不同的Comparator的实现类作为不同的比较策略。不同的比较策略，对同一个集合，可能会产生不同的排序结果。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/xrq730/p/4906313.html">Java设计模式6：策略模式</a></p>
<p><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html">《JAVA与模式》之策略模式</a></p>
]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式-简单工厂模式</title>
    <url>/2022/04/07/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p><strong>简单工厂模式是类的创建模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。</strong></p>
</blockquote>
<h2 id="为什么要使用简单工厂模式"><a href="#为什么要使用简单工厂模式" class="headerlink" title="为什么要使用简单工厂模式"></a><strong>为什么要使用简单工厂模式</strong></h2><p>原因: 解耦</p>
<p>A对象如果要调用B对象，最简单的做法就是直接new一个B出来。这么做有一个问题，假如C类和B类实现了同一个接口/继承自同一个类，系统需要把B类修改成C类，程序不得不重写A类代码。如果程序中有100个地方new了B对象，那么就要修改100处。</p>
<p>这就是典型的代码耦合度太高导致的”牵一发动全身”。所以，有一个办法就是写一个工厂IFactory，A与IFactory耦合，修改一下，让所有的类都实现C接口并且IFactory生产出C的实例就可以了。</p>
<h2 id="简单工厂模式示例"><a href="#简单工厂模式示例" class="headerlink" title="简单工厂模式示例"></a><strong>简单工厂模式示例</strong></h2><p>水果为例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Fruit</span> </span>&#123;<br><br>    <span class="hljs-comment">//生产</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//收货</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">harveset</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//种植</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">plant</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>有两个子类苹果和葡萄：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Fruit</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Apple.grow()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">harveset</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Apple.harveset()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">plant</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Apple.plant()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grape</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Fruit</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Grape.grow()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">harveset</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Grape.harveset()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">plant</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Grape.plant()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>有一个园丁，专门负责生产出各种水果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gardener</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Fruit <span class="hljs-title">getFruit</span><span class="hljs-params">(String fruit)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;apple&quot;</span>.equalsIgnoreCase(fruit)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Apple();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;grape&quot;</span>.equalsIgnoreCase(fruit)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Grape();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>想要什么水果就问园丁拿就好了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Fruit fruit = Gardener.getFruit(<span class="hljs-string">&quot;apple&quot;</span>);<br>        fruit.grow();<br>        Fruit fruit1 = Gardener.getFruit(<span class="hljs-string">&quot;grape&quot;</span>);<br>        fruit1.harveset();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>程序优点：</strong></p>
<ol>
<li>用户不自己去生产产品，只需要负责去拿自己需要的东西就好了，这样用户–&gt;产品之间的耦合度就降低了</li>
<li>代码模块职责更明确了，有专门消费的模块、有专门生产的模块</li>
</ol>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a><strong>改进</strong></h2><p>上面的代码虽然实现了用户–&gt;产品之间的分离，但还是有一个问题，工厂并不知道有多少种产品，所以每一次新增产品的时候，都需要新增else if分支，这样是不是不便呢？所以我们又想了一个办法，就是反射，园丁可以这么修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gardener</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Fruit <span class="hljs-title">getFruit</span><span class="hljs-params">(String fruit)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;<br>        Class&lt;?&gt; aClass = Class.forName(fruit);<br>        <span class="hljs-keyword">return</span> (Fruit) aClass.newInstance();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用的地方可以写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException, ClassNotFoundException </span>&#123;<br>        Fruit fruit = Gardener.getFruit(<span class="hljs-string">&quot;com.dewu.design.factory.simpl.Apple&quot;</span>);<br>        fruit.grow();<br>        Fruit fruit1 = Gardener.getFruit(<span class="hljs-string">&quot;com.dewu.design.factory.simpl.Grape&quot;</span>);<br>        fruit1.harveset();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然，这么写其实也有一点点问题，假如有一天我的项目想进行一个重构，重整类路径，包路径，比方说生产Apple的地方有100处，岂不是要修改100处？当然不用，有以下三种方法推荐：</p>
<ol>
<li>写一个接口FruitPath，里面定义常量：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FruitPath</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String apple = <span class="hljs-string">&quot;com.dewu.design.factory.simpl.Apple&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String grape = <span class="hljs-string">&quot;com.dewu.design.factory.simpl.Grape&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>写一个Fruit.properties文件，里面定义水果和类路径的对应关系：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Apple=com.dewu.design.factory.simpl.Apple<br>Grape=com.dewu.design.factory.simpl.Grape<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>写一个Fruit.xml文件，里面定义水果和类路径的对应关系：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;apple&gt;com.dewu.design.factory.simpl.Apple&lt;/apple&gt;<br>&lt;grape&gt;com.dewu.design.factory.simpl.Grape&lt;/grape&gt;<br></code></pre></td></tr></table></figure>

<p>第一种方式不说了，第二种方式.properties可以用Java自带的Properties类来解析，第三种方式.xml可以用DOM4J来解析。这样， 假设我以后要修改水果的路径，修改一个文件就可以了。</p>
<p>从设计模式的角度讲，这么修改也有很大的优点。现在不管我新增还是删除水果，园丁（类工厂）都不用变了，只需要告诉工厂我需要哪种水果就够了，工厂自然会给调用者返回。这种写法，也是Spring的基础。</p>
<p><strong>简单工厂模式或者说工厂模式的关注点并不在于在工厂中是如何生产出来需要的类的，而在于将创建产品与消费产品分离</strong>。前面使用过if…else if…else、反射，除了这些方法，还可以有别的方法可以创建产品，比如传入一个具体产品的标识，根据这个标识去数据库里面查询。</p>
<h2 id="简单工厂模式在Java中的应用及解读"><a href="#简单工厂模式在Java中的应用及解读" class="headerlink" title="简单工厂模式在Java中的应用及解读"></a><strong>简单工厂模式在Java中的应用及解读</strong></h2><p>JDK中的简单工厂模式有很多应用，比较典型的比如线程池，我们使用线程池的时候，可以使用ThreadPoolExecutor，根据自己的喜好传入corePoolSize、maximumPoolSize、keepAliveTimem、unit、workQueue、threadFactory、handler这几个参数，new出一个指定的ThreadPoolExecutor出来。</p>
<p>JDK给开发者提供了Executors这个类，可以让用户产生ThreadPoolExecutor和使用ThreadPoolExecutor分离开，比如可以让Executors提供一个单线程的线程池Executors.newSingleThreadExecutor()、让Executors提供一个无界线程池Executors.newCachedThreadPool()等，这样，开发者可以不用关心线程池是如何去实现的，直接使用Executors方法提供给开发者的ThreadPoolExecutor就可以了。</p>
<h2 id="工厂模式的优缺点"><a href="#工厂模式的优缺点" class="headerlink" title="工厂模式的优缺点"></a><strong>工厂模式的优缺点</strong></h2><p><strong>优点:</strong></p>
<p>1、简单优化了软件体系结构，明确了各自功能模块的职责和权利</p>
<p>2、通过工厂类，外界不需要直接创建具体产品对象，只需要负责消费，不需要关心内部如何创建对象</p>
<p><strong>缺点:</strong></p>
<p>1、改进前的简单工厂模式全部创建逻辑都集中在一个工厂类中，能创建的类只能是考虑到的，如果需要添加新的类，就必须改变工厂类了</p>
<p>2、改进前的简单工厂模式随着具体产品的不断增多，可能会出现共产类根据不同条件创建不同实例的需求，这种对条件的判断和对具体产品类型的判断交错在一起，很难避免功能模块的蔓延，对系统的维护和扩展不利</p>
<p>3、改进后的简单工厂模式主要是使用反射效率会低一些</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p>以上文章引用自:<a href="https://www.cnblogs.com/xrq730/p/4902597.html">Java设计模式-简单工厂模式</a></p>
]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式-适配器模式</title>
    <url>/2022/05/22/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h3><p><strong>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</strong> </p>
<h3 id="适配器模式的用途"><a href="#适配器模式的用途" class="headerlink" title="适配器模式的用途"></a><strong>适配器模式的用途</strong></h3><p>用电器做例子，笔记本电脑的插头一般都是三相的，即除了阳极、阴极外，还有一个地极。而有些地方的电源插座却只有两极，没有地极。电源插座与笔记本电脑的电源插头不匹配使得笔记本电脑无法使用。这时候一个三相到两相的转换器（适配器）就能解决此问题，而这正像是本模式所做的事情。 </p>
<h3 id="适配器模式的结构"><a href="#适配器模式的结构" class="headerlink" title="适配器模式的结构"></a>适配器模式的结构</h3><p>适配器模式有<strong>类的适配器模式</strong>和<strong>对象的适配器模式</strong>两种不同的形式。 </p>
<h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><p>类的适配器模式把适配的类的API转换成为目标类的API。 </p>
<p><img src="/img/work/1653183356330.png"></p>
<p>在上图中可以看出，Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，提供一个中间环节，即类Adapter，把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的： </p>
<p>模式所涉及的角色有： </p>
<ul>
<li> <strong>目标(Target)角色：</strong>这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。 </li>
<li> <strong>源(Adaptee)角色：</strong>现在需要适配的接口。 </li>
<li> <strong>适配器(Adapter)角色：</strong>适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。 </li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Target</span> </span>&#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这是源类Adaptee也有的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sampleOperation1</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这是源类Adapteee没有的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sampleOperation2</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面给出的是目标角色的源代码，这个角色是以一个JAVA接口的形式实现的。可以看出，这个接口声明了两个方法：sampleOperation1()和sampleOperation2()。而源角色Adaptee是一个具体类，它有一个sampleOperation1()方法，但是没有sampleOperation2()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sampleOperation1</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>适配器角色Adapter扩展了Adaptee,同时又实现了目标(Target)接口。由于Adaptee没有提供sampleOperation2()方法，而目标接口又要求这个方法，因此适配器角色Adapter实现了这个方法。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Target</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 由于源类Adaptee没有方法sampleOperation2()</span><br><span class="hljs-comment">     * 因此适配器补充上这个方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sampleOperation2</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//写相关的代码</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h3><p>与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。 </p>
<p><img src="/img/work/1653183812284.png"></p>
<p>从上图可以看出，Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，需要提供一个包装(Wrapper)类Adapter。这个包装类包装了一个Adaptee的实例，从而此包装类能够把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是委派关系，这决定了适配器模式是对象的。 </p>
<p><strong>代码示例</strong></p>
<p>目标类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Target</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这是源类Adaptee也有的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sampleOperation1</span><span class="hljs-params">()</span></span>; <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这是源类Adapteee没有的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sampleOperation2</span><span class="hljs-params">()</span></span>; <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sampleOperation1</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Adaptee adaptee;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Adapter</span><span class="hljs-params">(Adaptee adaptee)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.adaptee = adaptee;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 源类Adaptee有方法sampleOperation1</span><br><span class="hljs-comment">     * 因此适配器类直接委派即可</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sampleOperation1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.adaptee.sampleOperation1();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 源类Adaptee没有方法sampleOperation2</span><br><span class="hljs-comment">     * 因此由适配器类需要补充此方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sampleOperation2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//写相关的代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="类适配器和对象适配器的权衡"><a href="#类适配器和对象适配器的权衡" class="headerlink" title="类适配器和对象适配器的权衡"></a>类适配器和对象适配器的权衡</h3><p><strong>类适配器：</strong></p>
<ul>
<li><strong>类适配器</strong>使用对象继承的方式，是静态的定义方式；</li>
<li> <strong>对于类适配器</strong>，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了。 </li>
<li> 适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。 </li>
<li> <strong>对于类适配器</strong>，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。 </li>
</ul>
<p><strong>对象适配器:</strong></p>
<ul>
<li> <strong>对象适配器</strong>使用对象组合的方式，是动态组合的方式。 </li>
<li>  <strong>对于对象适配器</strong>，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。 </li>
<li> <strong>对于对象适配器</strong>，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。 </li>
<li><strong>对于对象适配器</strong>，需要额外的引用来间接得到Adaptee。</li>
</ul>
<p>建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的。 </p>
<h3 id="适配器模式的优点"><a href="#适配器模式的优点" class="headerlink" title="适配器模式的优点"></a>适配器模式的优点</h3><ul>
<li><p> <strong>更好的复用性:</strong> 系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。 </p>
</li>
<li><p><strong>更好的扩展性:</strong>  在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。 </p>
</li>
</ul>
<h3 id="适配器模式的缺点"><a href="#适配器模式的缺点" class="headerlink" title="适配器模式的缺点"></a>适配器模式的缺点</h3><p>过多使用适配器会使得系统非常凌乱，明明调用的是A接口，内部却被适配成了B接口。因此除非必要，不推荐使用适配器，而是直接对系统重构 </p>
<h3 id="适配器模式典型应用"><a href="#适配器模式典型应用" class="headerlink" title="适配器模式典型应用"></a><strong>适配器模式典型应用</strong></h3><p><strong>spring MVC中的适配器模式</strong> </p>
<p>Spring MVC中的适配器模式主要用于执行目标 Controller 中的请求处理方法。 </p>
<p>在Spring MVC中，DispatcherServlet 作为用户，HandlerAdapter 作为期望接口，具体的适配器实现类用于对目标类进行适配，Controller 作为需要适配的类。 </p>
<p>为什么要在 Spring MVC 中使用适配器模式？Spring MVC 中的 Controller 种类众多，不同类型的 Controller 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，DispatcherServlet 直接获取对应类型的 Controller，需要的自行来判断，像下面这段代码一样： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(mappedHandler.getHandler() <span class="hljs-keyword">instanceof</span> MultiActionController)&#123;  <br>   ((MultiActionController)mappedHandler.getHandler()).xxx  <br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mappedHandler.getHandler() <span class="hljs-keyword">instanceof</span> XXX)&#123;  <br>    ...  <br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(...)&#123;  <br>   ...  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样假设如果我们增加一个 HardController,就要在代码中加入一行 if(mappedHandler.getHandler() instanceof HardController)，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。 </p>
<p>我们来看看源码，首先是适配器接口 HandlerAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HandlerAdapter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Object var1)</span></span>;<br><br>    <span class="hljs-function">ModelAndView <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest var1, HttpServletResponse var2, Object var3)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getLastModified</span><span class="hljs-params">(HttpServletRequest var1, Object var2)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>现该接口的适配器每一个 <code>Controller</code> 都有一个适配器与之对应，这样的话，每自定义一个 <code>Controller</code> 需要定义一个实现 <code>HandlerAdapter</code> 的适配器。 </p>
<p>springmvc 中提供的 <code>Controller</code> 实现类有如下 </p>
<p><img src="/img/work/1653232383431.png"></p>
<p>springmvc 中提供的 <code>HandlerAdapter</code> 实现类如下 </p>
<p><img src="/img/work/1653232435596.png"></p>
<p><code>HttpRequestHandlerAdapter</code> 这个适配器代码如下 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpRequestHandlerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerAdapter</span> </span>&#123;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Object handler)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> (handler <span class="hljs-keyword">instanceof</span> HttpRequestHandler);<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-meta">@Nullable</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="hljs-function">			<span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>		((HttpRequestHandler) handler).handleRequest(request, response);<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getLastModified</span><span class="hljs-params">(HttpServletRequest request, Object handler)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> LastModified) &#123;<br>			<span class="hljs-keyword">return</span> ((LastModified) handler).getLastModified(request);<br>		&#125;<br>		<span class="hljs-keyword">return</span> -<span class="hljs-number">1L</span>;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>当Spring容器启动后，会将所有定义好的适配器对象存放在一个List集合中，当一个请求来临时，<code>DispatcherServlet</code> 会通过 <code>handler</code> 的类型找到对应适配器，并将该适配器对象返回给用户，然后就可以统一通过适配器的 <code>hanle()</code> 方法来调用 <code>Controller</code> 中的用于处理请求的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DispatcherServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FrameworkServlet</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;<br>    <br>    <span class="hljs-comment">//初始化handlerAdapters</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initHandlerAdapters</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;<br>        <span class="hljs-comment">//..省略...</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 遍历所有的 HandlerAdapters，通过 supports 判断找到匹配的适配器</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> HandlerAdapter <span class="hljs-title">getHandlerAdapter</span><span class="hljs-params">(Object handler)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>		<span class="hljs-keyword">for</span> (HandlerAdapter ha : <span class="hljs-keyword">this</span>.handlerAdapters) &#123;<br>			<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>				logger.trace(<span class="hljs-string">&quot;Testing handler adapter [&quot;</span> + ha + <span class="hljs-string">&quot;]&quot;</span>);<br>			&#125;<br>			<span class="hljs-keyword">if</span> (ha.supports(handler)) &#123;<br>				<span class="hljs-keyword">return</span> ha;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">// 分发请求，请求需要找到匹配的适配器来处理</span><br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		HttpServletRequest processedRequest = request;<br>		HandlerExecutionChain mappedHandler = <span class="hljs-keyword">null</span>;<br><br>		<span class="hljs-comment">// Determine handler for the current request.</span><br>		mappedHandler = getHandler(processedRequest);<br>			<br>		<span class="hljs-comment">// 确定当前请求的匹配的适配器.</span><br>		HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());<br><br>		ha.getLastModified(request, mappedHandler.getHandler());<br>					<br>		mv = ha.handle(processedRequest, response, mappedHandler.getHandler());<br>    &#125;<br>	<span class="hljs-comment">// ...省略...</span><br>&#125;	<br><br></code></pre></td></tr></table></figure>

<p>通过适配器模式我们将所有的 <code>controller</code> 统一交给 <code>HandlerAdapter</code> 处理，免去了写大量的 <code>if-else</code> 语句对 <code>Controller</code> 进行判断，也更利于扩展新的 <code>Controller</code> 类型。 </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.cn/post/6844903682136342541#heading-12">https://juejin.cn/post/6844903682136342541#heading-12</a></p>
<p><a href="https://www.cnblogs.com/xrq730/p/4906487.html">https://www.cnblogs.com/xrq730/p/4906487.html</a></p>
<p><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html">https://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html</a></p>
]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL锁</title>
    <url>/2022/07/01/MySQL%E9%94%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/img/work/1656687465931.png"></p>
<h2 id="1-悲观锁和乐观锁"><a href="#1-悲观锁和乐观锁" class="headerlink" title="1. 悲观锁和乐观锁"></a>1. 悲观锁和乐观锁</h2><p>确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性，<strong>乐观锁和悲观锁是并发控制主要采用的技术手段。</strong> </p>
<ul>
<li> <strong><code>悲观锁</code></strong>  - 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 </li>
<li>在查询完数据的时候就把事务锁起来，直到提交事务（<code>COMMIT</code>）</li>
<li>实现方式：<strong>使用数据库中的锁机制</strong>。</li>
<li> <strong><code>乐观锁</code></strong> - 假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 </li>
<li>在修改数据的时候把事务锁起来，通过 version 的方式来进行锁定</li>
<li>实现方式：<strong>使用 version 版本或者时间戳</strong>。</li>
</ul>
<p>【示例】乐观锁示例 </p>
<p>商品 goods 表中有一个字段 status，status 为 1 代表商品未被下单，status 为 2 代表商品已经被下单，那么我们对某个商品下单时必须确保该商品 status 为 1。假设商品的 id 为 1。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> (status,status,version) <span class="hljs-keyword">from</span> t_goods <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>#&#123;id&#125;<br><br>update t_goods<br><span class="hljs-keyword">set</span> status<span class="hljs-operator">=</span><span class="hljs-number">2</span>,version<span class="hljs-operator">=</span>version<span class="hljs-operator">+</span><span class="hljs-number">1</span><br><span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>#&#123;id&#125; <span class="hljs-keyword">and</span> version<span class="hljs-operator">=</span>#&#123;version&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="2-表级锁和行级锁"><a href="#2-表级锁和行级锁" class="headerlink" title="2. 表级锁和行级锁"></a>2. 表级锁和行级锁</h2><p>从数据库的锁粒度来看，MySQL 中提供了两种封锁粒度：行级锁和表级锁。 </p>
<ul>
<li><strong>表级锁（table lock）</strong> - 锁定整张表。用户对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他用户才能获得读锁，读锁之间不会相互阻塞。</li>
<li><strong>行级锁（row lock）</strong> - 锁定指定的行记录。这样其它进程还是可以对同一个表中的其它记录进行操作。</li>
</ul>
<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。<strong>锁定的数据量越少，锁竞争的发生频率就越小，系统的并发程度就越高</strong>。但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此<strong>锁粒度越小，系统开销就越大</strong>。 </p>
<p>在选择锁粒度时，需要在锁开销和并发程度之间做一个权衡。 </p>
<p>在 <code>InnoDB</code> 中，<strong>行锁是通过给索引上的索引项加锁来实现的</strong>。<strong>如果没有索引，<code>InnoDB</code> 将会通过隐藏的聚簇索引来对记录加锁</strong>。 </p>
<h2 id="3-读写锁"><a href="#3-读写锁" class="headerlink" title="3. 读写锁"></a>3. 读写锁</h2><ul>
<li>独享锁（Exclusive），简写为 X 锁，又称写锁：加了X锁的记录，不允许其他事务再加S锁或者X锁。使用方式：<code>SELECT ... FOR UPDATE;</code></li>
<li>共享锁（Shared），简写为 S 锁，又称读锁：加了S锁的记录，允许其他事务再加S锁，不允许其他事务再加X锁。使用方式：<code>SELECT ... LOCK IN SHARE MODE;</code></li>
</ul>
<p>写锁和读锁的关系，简言之：<strong>独享锁存在，其他事务就不能做任何操作</strong>。 </p>
<p><strong><code>InnoDB</code> 下的行锁、间隙锁、next-key 锁统统属于独享锁</strong>。 </p>
<h2 id="4-意向锁"><a href="#4-意向锁" class="headerlink" title="4. 意向锁"></a>4. 意向锁</h2><p><strong>当存在表级锁和行级锁的情况下，必须先申请意向锁（表级锁，但不是真的加锁），再获取行级锁</strong>。使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。 </p>
<p><strong>意向锁是 <code>InnoDB</code> 自动加的，不需要用户干预</strong>。 </p>
<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。 </p>
<p>意向锁规定： </p>
<ul>
<li><p>意向共享锁（IS锁）：一个事务在获得某个数据行的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</p>
</li>
<li><p>意向排他锁（IX锁）：一个事务在获得某个数据行的 X 锁之前，必须先获得表的 IX 锁。</p>
</li>
<li><p>IX/IS 是表锁；</p>
</li>
<li><p>X/S 是行锁。</p>
</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>各种锁的兼容关系如下：</p>
<table>
<thead>
<tr>
<th align="center">-</th>
<th align="center">X(独享锁)</th>
<th align="center">IX(意向排他锁)</th>
<th align="center"><strong>S</strong>(共享锁)</th>
<th align="center">IS(意向共享锁)</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>X</strong></td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
</tr>
<tr>
<td align="center"><strong>IX</strong></td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
</tr>
<tr>
<td align="center"><strong>S</strong></td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
<tr>
<td align="center"><strong>IS</strong></td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
</tbody></table>
<p>解释如下：</p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li>
<li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li>
<li>表级S锁和X、IX锁不兼容：因为上了表级S锁后，不允许其他事务再加X锁。</li>
<li>表级X锁和 IS、IX、S、X不兼容：因为上了表级X锁后，会修改数据，所以即使是行级排他锁，因为表级锁定的行肯定包括行级锁定的行，所以表级X和IX、X都不兼容。</li>
</ul>
<p><strong>注意：上了行级X锁后，行级X锁不会因为有别的事务上了IX而堵塞，一个mysql是允许多个行级X锁同时存在的，只要他们不是针对相同的数据行。</strong></p>
<h2 id="5-MVCC"><a href="#5-MVCC" class="headerlink" title="5. MVCC"></a>5. MVCC</h2><p><strong>多版本并发控制（Multi-Version Concurrency Control, MVCC）可以视为行级锁的一个变种。它在很多情况下都避免了加锁操作，因此开销更低</strong>。不仅是 Mysql，包括 Oracle、PostgreSQL 等其他数据库都实现了各自的 MVCC，实现机制没有统一标准。</p>
<p>MVCC 是 <code>InnoDB</code> 存储引擎实现隔离级别的一种具体方式，<strong>用于实现提交读和可重复读这两种隔离级别</strong>。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h3 id="5-1-MVCC-思想"><a href="#5-1-MVCC-思想" class="headerlink" title="5.1. MVCC 思想"></a>5.1. MVCC 思想</h3><p>加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的。</p>
<p>mvcc的思想是:</p>
<ul>
<li><strong>保存数据在某个时间点的快照，写操作（DELETE、INSERT、UPDATE）更新最新的版本快照；而读操作去读旧版本快照，没有互斥关系</strong>。这一点和 <code>CopyOnWrite</code> 类似。</li>
<li>脏读和不可重复读最根本的原因是<strong>事务读取到其它事务未提交的修改</strong>。在事务进行读取操作时，为了解决脏读和不可重复读问题，<strong>MVCC 规定只能读取已经提交的快照</strong>。当然一个事务可以读取自身未提交的快照，这不算是脏读。</li>
</ul>
<h3 id="5-2-版本号"><a href="#5-2-版本号" class="headerlink" title="5.2. 版本号"></a>5.2. 版本号</h3><p>InnoDB 的 MVCC 实现是：在每行记录后面保存两个隐藏列，一个列保存行的创建时间，另一个列保存行的过期时间（这里的时间是指系统版本号）。每开始一个新事务，系统版本号会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<ul>
<li>系统版本号 <code>SYS_ID</code>：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号 <code>TRX_ID</code> ：事务开始时的系统版本号。</li>
</ul>
<h3 id="5-3-Undo-日志"><a href="#5-3-Undo-日志" class="headerlink" title="5.3. Undo 日志"></a>5.3. Undo 日志</h3><p>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 <code>ROLL_PTR</code> 把一个数据行的所有快照连接起来。</p>
<p>例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t(id, x) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, &quot;a&quot;);<br>UPDATE t <span class="hljs-keyword">SET</span> x<span class="hljs-operator">=</span>&quot;b&quot; <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br>UPDATE t <span class="hljs-keyword">SET</span> x<span class="hljs-operator">=</span>&quot;c&quot; <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>因为没有使用 <code>START TRANSACTION</code> 将上面的操作当成一个事务来执行，根据 MySQL 的 <code>AUTOCOMMIT</code> 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。</p>
<p><code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 操作会创建一个日志，并将事务版本号 <code>TRX_ID</code> 写入。<code>DELETE</code> 可以看成是一个特殊的 <code>UPDATE</code>，还会额外将 DEL 字段设置为 1。</p>
<h3 id="5-4-ReadView"><a href="#5-4-ReadView" class="headerlink" title="5.4. ReadView"></a>5.4. ReadView</h3><p>MVCC 维护了一个一致性读视图 <code>consistent read view</code> ，主要包含了当前系统<strong>未提交的事务列表</strong> <code>TRX_IDs &#123;TRX_ID_1, TRX_ID_2, ...&#125;</code>，还有该列表的最小值 <code>TRX_ID_MIN</code> 和 <code>TRX_ID_MAX</code>。</p>
<p><img src="/img/work/image-20220702144555778.png"></p>
<p>这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：</p>
<ol>
<li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li>
<li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li>
<li>如果落在黄色部分，那就包括两种情况 a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见； b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ol>
<p>在进行 <code>SELECT</code> 操作时，根据数据行快照的 <code>TRX_ID</code> 与 <code>TRX_ID_MIN</code> 和 <code>TRX_ID_MAX</code> 之间的关系，从而判断数据行快照是否可以使用：</p>
<ul>
<li><code>TRX_ID</code> &lt; <code>TRX_ID_MIN</code>，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。</li>
<li><code>TRX_ID</code> &gt; <code>TRX_ID_MAX</code>，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</li>
<li><code>TRX_ID_MIN</code> &lt;= <code>TRX_ID</code> &lt;= <code>TRX_ID_MAX</code>，需要根据隔离级别再进行判断：<ul>
<li>提交读：如果 <code>TRX_ID</code> 在 <code>TRX_IDs</code> 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li>
<li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li>
</ul>
</li>
</ul>
<p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。</p>
<h3 id="5-5-快照读与当前读"><a href="#5-5-快照读与当前读" class="headerlink" title="5.5. 快照读与当前读"></a>5.5. 快照读与当前读</h3><p>快照读</p>
<p>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> ...;<br></code></pre></td></tr></table></figure>

<p>当前读</p>
<p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span>;<br>UPDATE;<br><span class="hljs-keyword">DELETE</span>;<br></code></pre></td></tr></table></figure>

<p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> ? lock <span class="hljs-keyword">in</span> share mode;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> ? <span class="hljs-keyword">for</span> update;<br></code></pre></td></tr></table></figure>

<h2 id="6-行锁"><a href="#6-行锁" class="headerlink" title="6. 行锁"></a>6. 行锁</h2><p>行锁的具体实现算法有三种：record lock、gap lock 以及 next-key lock。</p>
<ul>
<li><code>Record Lock</code> - <strong>行锁对索引项加锁，若没有索引则使用表锁</strong>。</li>
<li><code>Gap Lock</code> - <strong>对索引项之间的间隙加锁</strong>。锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句,其它事务就不能在 t.c 中插入 15：<code>SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;</code>。在 MySQL 中，gap lock 默认是开启的，即 <code>innodb_locks_unsafe_for_binlog</code> 参数值是 disable 的，且 MySQL 中默认的是 RR 事务隔离级别。</li>
<li><code>Next-key lock</code> -它是 <code>Record Lock</code> 和 <code>Gap Lock</code> 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间。</li>
</ul>
<p>只在可重复读或以上隔离级别下的特定操作才会取得 gap lock 或 next-key lock。在 <code>Select</code>、<code>Update</code> 和 <code>Delete</code> 时，除了基于唯一索引的查询之外，其它索引查询时都会获取 gap lock 或 next-key lock，即锁住其扫描的范围。主键索引也属于唯一索引，所以主键索引是不会使用 gap lock 或 next-key lock。</p>
<p>MVCC 不能解决幻读问题，<strong>Next-Key 锁就是为了解决幻读问题</strong>。在可重复读（<code>REPEATABLE READ</code>）隔离级别下，使用 <strong>MVCC + Next-Key 锁</strong> 可以解决幻读问题。</p>
<p>索引分为主键索引和非主键索引两种，如果一条 SQL 语句操作了主键索引，MySQL 就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL 会先锁定该非主键索引，再锁定相关的主键索引。在 <code>UPDATE</code>、<code>DELETE</code> 操作时，MySQL 不仅锁定 <code>WHERE</code> 条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的 <code>next-key lock</code>。</p>
<p>当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。发生死锁后，<code>InnoDB</code> 一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。</p>
<h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7.参考资料"></a>7.参考资料</h2><ul>
<li><p><a href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></p>
</li>
<li><p><a href="https://time.geekbang.org/column/intro/100028001">《Java 性能调优实战》</a></p>
</li>
<li><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md">数据库系统原理</a></p>
</li>
<li><p><a href="https://juejin.im/post/5b55b842f265da0f9e589e79">数据库两大神器【索引和锁】</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/laoyeye/p/8097684.html">使用 mysql 乐观锁解决并发问题</a></p>
</li>
<li><p><a href="https://dunwu.github.io/waterdrop/pages/f1f151/#_1-%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81">MySQL锁</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis事务</title>
    <url>/2021/09/28/Redis%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>事务</p>
</blockquote>
<p> redis单条命令是原子性的，但是事务不保证原子性 </p>
<p>redis事务本质：一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行的过程中，会按照顺序执行</p>
<p> <strong>一次性、顺序性、排他性</strong>！执行一系列命令！ </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">------ 队列 set set set 执行------<br></code></pre></td></tr></table></figure>



<p> <strong>事务没有隔离级别的概念</strong> </p>
<p>所有的命令在事务中，并没有被执行！只有发起执行的命令的时候才会执行！Exec</p>
<p><strong>Redis单条命令式保存原子性的，但是事务不保证原子性！</strong></p>
<p>redis事务:</p>
<ul>
<li>开始事务(multi)</li>
<li>命令入队(。。）</li>
<li>执行事务(exec)</li>
</ul>
 <span id="more"></span>

<blockquote>
<p>正常执行事务</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi # 开启事务<br>OK<br><span class="hljs-meta">#</span><span class="bash"> 命令入队</span><br>127.0.0.1:6379&gt; set k1 v1<br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; get k2<br>QUEUED<br>127.0.0.1:6379&gt; set k3 v3<br>QUEUED<br>127.0.0.1:6379&gt; exec # 执行事务<br>1) OK<br>2) OK<br>3) &quot;v2&quot;<br>4) OK<br></code></pre></td></tr></table></figure>



<blockquote>
<p>放弃事务</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; set key1 v1<br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2 <br>QUEUED<br>127.0.0.1:6379&gt; set k3 v3<br>QUEUED<br>127.0.0.1:6379&gt; set k4 v4<br>QUEUED<br>127.0.0.1:6379&gt; DISCARD  # 取消事务<br>OK<br>127.0.0.1:6379&gt; GET k4  # 事务队列中命令都不会被执行<br>(nil)<br></code></pre></td></tr></table></figure>



<blockquote>
<p> 编译型异常(代码有问题，命令有错误)，事务中所有的命令都不会被执行 </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; MULTI <br>OK<br>127.0.0.1:6379&gt; set k1 v1 <br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2 <br>QUEUED<br>127.0.0.1:6379&gt; set k3 v3 <br>QUEUED<br>127.0.0.1:6379&gt; getset k3  # 错误的命令<br>(error) ERR wrong number of arguments for &#x27;getset&#x27; command<br>127.0.0.1:6379&gt; et k4 v4  # 错误的命令<br>(error) ERR unknown command `et`, with args beginning with: `k4`, `v4`, <br>127.0.0.1:6379&gt; set k4 v4<br>QUEUED<br>127.0.0.1:6379&gt; exec<br>(error) EXECABORT Transaction discarded because of previous errors.<br>127.0.0.1:6379&gt; get k4 # 所有的命令都不会被执行！<br>(nil)<br></code></pre></td></tr></table></figure>



<blockquote>
<p> 运行时异常（1/0）， 如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行 的，错误命令抛出异常！  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set k1 &quot;v1&quot;<br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; incr k1 # 会执行的时候失败！<br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; set k3 v3<br>QUEUED<br>127.0.0.1:6379&gt; get k3<br>QUEUED<br>127.0.0.1:6379&gt; exec<br>1) (error) ERR value is not an integer or out of range # 虽然第一条命令报错了，但是<br>依旧正常执行成功了！<br>2) OK<br>3) OK<br>4) &quot;v3&quot;<br>127.0.0.1:6379&gt; get k2<br>&quot;v2&quot;<br>127.0.0.1:6379&gt; get k3<br>&quot;v3&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p> 监控！ Watch （面试常问！）  </p>
</blockquote>
<p> <strong>悲观锁</strong>：</p>
<ul>
<li>很悲观，认为什么时候都会出问题，无论做什么都会加锁！ </li>
</ul>
<p> 乐观锁： </p>
<ul>
<li> 很乐观，认为什么时候都不会出问题，所以不会上锁！ 更新数据的时候去判断一下，在此期间是否 有人修改过这个数据， 获取version </li>
<li> 更新的时候比较 version</li>
</ul>
<blockquote>
<p> Redis测监视测试 </p>
</blockquote>
<p> 正常执行成功！ </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set money 100<br>OK<br>127.0.0.1:6379&gt; set out 0<br>OK<br>127.0.0.1:6379&gt; watch money # 监视 money 对象<br>OK<br>127.0.0.1:6379&gt; multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！<br>OK<br>127.0.0.1:6379&gt; DECRBY money 20<br>QUEUED<br>127.0.0.1:6379&gt; INCRBY out 20<br>QUEUED<br>127.0.0.1:6379&gt; exec<br>1) (integer) 80<br>2) (integer) 20<br></code></pre></td></tr></table></figure>

<p> 测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！ </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; watch money # 监视 money<br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; DECRBY money 10<br>QUEUED<br>127.0.0.1:6379&gt; INCRBY out 10<br>QUEUED<br>127.0.0.1:6379&gt; exec # 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失<br>败！<br>(nil)<br></code></pre></td></tr></table></figure>

<p> 如果修改失败，获取最新的值就好  </p>
<p>参考：<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=8440565446323209776&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=8440565446323209776&amp;spm_id_from=333.337.0.0</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis持久化</title>
    <url>/2021/09/30/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://redis.io/">Redis</a>有两种持久化的方式：快照（<code>RDB</code>文件）和追加式文件（<code>AOF</code>文件）：</p>
<ul>
<li>RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。</li>
<li>AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。</li>
<li>Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。</li>
<li>两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。</li>
</ul>
<h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><blockquote>
<p>工作原理</p>
</blockquote>
<ul>
<li>Redis调用fork()，产生一个子进程</li>
<li>子进程把数据写到一个临时的RDB文件</li>
<li>当子进程写完新的RDB文件后，把旧的RDB文件替换掉</li>
</ul>
<p><img src="/img/work/image-20210930171854270.png"></p>
<p>一般在主从复制中,rdb做备用在从机上</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>RDB文件是一个很简洁的单文件，它保存了某个时间点的Redis数据，很适合用于做备份。你可以设定一个时间点对RDB文件进行归档，这样就能在需要的时候很轻易的把数据恢复到不同的版本</li>
<li>基于上面所描述的特性，RDB很适合用于灾备。单文件很方便就能传输到远程的服务器上</li>
<li>RDB的性能很好，需要进行持久化时，主进程会fork一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的I/O操作</li>
<li>比起AOF，在数据量比较大的情况下，RDB的启动速度更快</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>RDB容易造成数据的丢失。假设每5分钟保存一次快照，如果Redis因为某些原因不能正常工作，那么从上次产生快照到Redis出现问题这段时间的数据就会丢失了</li>
<li>RDB使用<code>fork()</code>产生子进程进行数据的持久化，如果数据比较大的话可能就会花费点时间，造成Redis停止服务几毫秒。如果数据量很大且CPU性能不是很好的时候，停止服务的时间甚至会到1秒</li>
</ol>
<h3 id="文件路径和名称"><a href="#文件路径和名称" class="headerlink" title="文件路径和名称"></a>文件路径和名称</h3><p>默认Redis会把快照文件存储为当前目录下一个名为<code>dump.rdb</code>的文件。要修改文件的存储路径和名称，可以通过修改配置文件<code>redis.conf</code>实现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> RDB文件名，默认为dump.rdb。</span><br>dbfilename dump.rdb<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 文件存放的目录，AOF文件同样存放在此目录下。默认为当前工作目录。</span><br>dir ./<br></code></pre></td></tr></table></figure>



<h3 id="保存点（RDB的启用和禁用）"><a href="#保存点（RDB的启用和禁用）" class="headerlink" title="保存点（RDB的启用和禁用）"></a>保存点（RDB的启用和禁用）</h3><p>可以配置保存点，使Redis如果在每N秒后数据发生了M次改变就保存快照文件。例如下面这个保存点配置表示每60秒，如果数据发生了1000次以上的变动，Redis就会自动保存快照文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">save &lt;seconds&gt; &lt;changes&gt; 格式</span><br>save 60 1000   #60S内如果1000个key发生了修改，Redis就会自动保存快照文件<br></code></pre></td></tr></table></figure>



<p>保存点可以设置多个，Redis的配置文件就默认设置了3个保存点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 可以设置多个</span><br>save 900 1 #900秒后至少1个key有变动<br>save 300 10 #300秒后至少10个key有变动<br>save 60 10000 #60秒后至少10000个key有变动<br></code></pre></td></tr></table></figure>



<p>如果想禁用快照保存的功能，可以通过注释掉所有”save”配置达到，或者在最后一条”save”配置后添加如下的配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">save &quot;&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>触发机制说明</p>
</blockquote>
<ol>
<li>save的规则满足的情况下，会自动触发rdb规则</li>
<li>执行 flushall 命令，也会触发rdb规则！</li>
<li>退出redis，也会产生 rdb 文件</li>
</ol>
<blockquote>
<p>如何恢复rdb文件</p>
</blockquote>
<ol>
<li>只需要将rdb文件放在redis启动目录即可，redis启动的时候会自动检查dump.rdb 恢复其中 的数据</li>
<li>查看存放目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; config get dir<br>1) &quot;dir&quot;<br>2) &quot;/usr/local/bin&quot; # 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据<br></code></pre></td></tr></table></figure>



<h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>快照并不是很可靠。如果你的电脑突然宕机了，或者电源断了，又或者不小心杀掉了进程，那么最新的数据就会丢失。而AOF文件则提供了一种更为可靠的持久化方式。每当Redis接受到会修改数据集的命令时，就会把命令追加到AOF文件里，当你重启Redis时，AOF里的命令会被重新执行一次，重建数据。</p>
<blockquote>
<p>工作原理</p>
</blockquote>
<p><img src="/img/work/image-20210930180234429.png"></p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol>
<li>比RDB可靠。你可以制定不同的fsync策略：不进行fsync、每秒fsync一次和每次查询进行fsync。默认是每秒fsync一次。这意味着你最多丢失一秒钟的数据。</li>
<li>AOF日志文件是一个纯追加的文件。就算是遇到突然停电的情况，也不会出现日志的定位或者损坏问题。甚至如果因为某些原因（例如磁盘满了）命令只写了一半到日志文件里，我们也可以用<code>redis-check-aof</code>这个工具很简单的进行修复</li>
<li> 当AOF文件太大时，Redis会自动在后台进行重写。重写很安全，因为重写是在一个新的文件上进行，同时Redis会继续往旧的文件追加数据。新文件上会写入能重建当前数据集的最小操作命令的集合。当新文件重写完，Redis会把新旧文件进行切换，然后开始把数据写到新文件上 </li>
<li> AOF把操作命令以简单易懂的格式一条接一条的保存在文件里，很容易导出来用于恢复数据。例如我们不小心用<code>FLUSHALL</code>命令把所有数据刷掉了，只要文件没有被重写，我们可以把服务停掉，把最后那条命令删掉，然后重启服务，这样就能把被刷掉的数据恢复回来 </li>
</ol>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li> 在相同的数据集下，AOF文件的大小一般会比RDB文件大 </li>
<li> 在某些fsync策略下，AOF的速度会比RDB慢。通常fsync设置为每秒一次就能获得比较高的性能，而在禁止fsync的情况下速度可以达到RDB的水平 </li>
<li> 在过去曾经发现一些很罕见的BUG导致使用AOF重建的数据跟原数据不一致的问题 </li>
</ol>
<h3 id="启用AOF"><a href="#启用AOF" class="headerlink" title="启用AOF"></a>启用AOF</h3><p> 把配置项<code>appendonly</code>设为<code>yes</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">设置开启aof</span><br>appendonly yes<br></code></pre></td></tr></table></figure>



<h3 id="文件路径和名称-1"><a href="#文件路径和名称-1" class="headerlink" title="文件路径和名称"></a>文件路径和名称</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 文件存放目录，与RDB共用。默认为当前工作目录。</span><br>dir ./<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 默认文件名为appendonly.aof</span><br>appendfilename &quot;appendonly.aof&quot;<br></code></pre></td></tr></table></figure>



<h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p> 你可以配置Redis调用fsync的频率，有三个选项： </p>
<ol>
<li>每当有新命令追加到AOF的时候调用fsync。速度最慢，但是最安全</li>
<li> 每秒fsync一次。速度快（2.4版本跟快照方式速度差不多），安全性不错（最多丢失1秒的数据） </li>
<li> 从不fsync，交由系统去处理。这个方式速度最快，但是安全性一般 </li>
</ol>
<p> 推荐使用每秒fsync一次的方式（默认的方式），因为它速度快，安全性也不错。相关配置如下： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> appendfsync always</span><br>appendfsync everysec<br><span class="hljs-meta">#</span><span class="bash"> appendfsync no</span><br></code></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="日志重写"><a href="#日志重写" class="headerlink" title="日志重写"></a>日志重写</h3><p>​       随着写操作的不断增加，AOF文件会越来越大。例如你递增一个计数器100次，那么最终结果就是数据集里的计数器的值为最终的递增结果，但是AOF文件里却会把这100次操作完整的记录下来。而事实上要恢复这个记录，只需要1个命令就行了，也就是说AOF文件里那100条命令其实可以精简为1条。所以Redis支持这样一个功能：在不中断服务的情况下在后台重建AOF文件 </p>
<p> <strong>工作原理如下 :</strong></p>
<ol>
<li> Redis调用fork()，产生一个子进程 </li>
<li> 子进程把新的AOF写到一个临时文件里 </li>
<li> 主进程持续把新的变动写到内存里的buffer，同时也会把这些新的变动写到旧的AOF里，这样即使重写失败也能保证数据的安全 </li>
<li> 当子进程完成文件的重写后，主进程会获得一个信号，然后把内存里的buffer追加到子进程生成的那个新AOF里 </li>
</ol>
<p><strong>我们可以通过配置设置日志重写的条件：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Redis会记住自从上一次重写后AOF文件的大小（如果自Redis启动后还没重写过，则记住启动时使用的AOF文件的大小）。</span><br><span class="hljs-meta">#</span><span class="bash"> 如果当前的文件大小比起记住的那个大小超过指定的百分比，则会触发重写。</span><br><span class="hljs-meta">#</span><span class="bash"> 同时需要设置一个文件大小最小值，只有大于这个值文件才会重写，以防文件很小，但是已经达到百分比的情况。</span><br><br>auto-aof-rewrite-percentage 100<br>auto-aof-rewrite-min-size 64mb<br></code></pre></td></tr></table></figure>



<p> 要禁用自动的日志重写功能，我们可以把百分比设置为0： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">auto-aof-rewrite-percentage 0<br></code></pre></td></tr></table></figure>

<p><strong>Redis 2.4以上才可以自动进行日志重写，之前的版本需要手动运行<a href="http://redis.io/commands/bgrewriteaof">BGREWRITEAOF</a>这个命令。</strong> </p>
<h3 id="数据损坏修复"><a href="#数据损坏修复" class="headerlink" title="数据损坏修复"></a>数据损坏修复</h3><p> 如果因为某些原因（例如服务器崩溃）AOF文件损坏了，导致Redis加载不了，可以通过以下方式进行修复： </p>
<ul>
<li> 备份AOF文件 </li>
<li> 使用<code>redis-check-aof</code>命令修复原始的AOF文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-check-aof --fix   aof文件<br></code></pre></td></tr></table></figure>

<ul>
<li> 可以使用<code>diff -u</code>命令看下两个文件的差异 </li>
<li> 使用修复过的文件重启Redis服务 </li>
</ul>
<h3 id="从RDB切换到AOF"><a href="#从RDB切换到AOF" class="headerlink" title="从RDB切换到AOF"></a>从RDB切换到AOF</h3><p> 这里只说Redis &gt;= 2.2版本的方式： </p>
<ul>
<li><p>备份一个最新的<code>dump.rdb</code>的文件，并把备份文件放在一个安全的地方。</p>
</li>
<li><p>运行以下两条命令：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">$ redis-cli<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span> appendonly <span class="hljs-literal">yes</span><br>$ redis-cli<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span> save <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure></li>
<li><p>确保数据跟切换前一致。</p>
</li>
<li><p>确保数据正确的写到AOF文件里。</p>
</li>
</ul>
<p><strong>第二条命令是用来禁用RDB的持久化方式，但是这不是必须的，因为你可以同时启用两种持久化方式。</strong></p>
<p><strong>记得对配置文件<code>redis.conf</code>进行编辑启用AOF，因为命令行方式修改配置在重启Redis后就会失效。</strong></p>
<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h3 id="建议的备份方法："><a href="#建议的备份方法：" class="headerlink" title="建议的备份方法："></a>建议的备份方法：</h3><ul>
<li>创建一个定时任务，每小时和每天创建一个快照，保存在不同的文件夹里。</li>
<li>定时任务运行时，把太旧的文件进行删除。例如只保留48小时的按小时创建的快照和一到两个月的按天创建的快照。</li>
<li>每天确保一次把快照文件传输到数据中心外的地方进行保存，至少不能保存在Redis服务所在的服务器。</li>
</ul>
<p>参考：</p>
<hr>
<p>​      <a href="https://segmentfault.com/a/1190000002906345">https://segmentfault.com/a/1190000002906345</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的三种特殊类型</title>
    <url>/2021/09/26/Redis%E7%9A%84%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial 地理位置"></a>Geospatial 地理位置</h3><p><strong>朋友的定位，附近的人，打车距离计算？ Redis 的 Geo 在Redis3.2 版本就推出了！ 这个功能可以推算地理位置的信息，两地之间的距离，方圆 几里的人！</strong> </p>
 <span id="more"></span>

<p>官方文档：<a href="https://www.redis.net.cn/order/3685.html">https://www.redis.net.cn/order/3685.html</a></p>
<p>从官网中我们可以看到此数据类型只有<strong>六个命令</strong></p>
<p><img src="/img/work/1632661034050.png"></p>
<p>下面就分别举例来做介绍</p>
<blockquote>
<h4 id="GEOADD"><a href="#GEOADD" class="headerlink" title="GEOADD"></a><strong>GEOADD</strong></h4></blockquote>
<p>官方说明：将指定的地理空间位置（纬度、经度、名称）添加到指定的key中</p>
<p> 该命令以采用标准格式的参数x,y,所以经度必须在纬度之前 ， 规定有如下</p>
<ol>
<li> 有效的经度从-180度到180度 </li>
<li>有效的纬度从-85.05112878度到85.05112878度。</li>
<li> 当坐标位置超出上述指定范围时，该命令将会返回一个错误。 </li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">geo使用举例</span><br><span class="hljs-meta">#</span><span class="bash">通过百度坐标拾取可以获取指定城市坐标 106.680848,26.642216 当前我获取的是自己所在城市的坐标</span><br>127.0.0.1:6379&gt; GEOADD china:city 106.680848 26.642216 guiyang<br>(integer) 1<br><br>127.0.0.1:6379&gt; GEOADD china:city 121.466742 31.231236 shanghai<br>(integer) 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">可以同时添加多个坐标</span><br>127.0.0.1:6379&gt; GEOADD china:city 114.100924 22.675499 shengzhen  106.561887 29.564724 chongqing<br>(integer) 2<br><br></code></pre></td></tr></table></figure>



<blockquote>
<p><strong>GEOPOS</strong>  </p>
</blockquote>
<p> 从<code>key</code>里返回所有给定位置元素的位置（经度和纬度） </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">需要先指定</span><br>127.0.0.1:6379&gt; GEOPOS china:city shanghai shengzhen<br>1) 1) &quot;121.46674007177352905&quot;<br>   2) &quot;31.23123598368359666&quot;<br>2) 1) &quot;114.10092204809188843&quot;<br>   2) &quot;22.6755001616335008&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p> <strong>GEODIST</strong> </p>
</blockquote>
<p>获取两个给定位置之间的距离, 如果两个位置之间的其中一个不存在， 那么命令返回空值 </p>
<p>指定单位的参数 unit 必须是以下单位的其中一个：</p>
<ul>
<li><strong>m</strong> 表示单位为米。</li>
<li><strong>km</strong> 表示单位为千米。</li>
<li><strong>mi</strong> 表示单位为英里。</li>
<li><strong>ft</strong> 表示单位为英尺。</li>
</ul>
<p>如果用户没有显式地指定单位参数， 那么 <code>GEODIST</code> 默认使用米作为单位。</p>
<p><code>GEODIST</code> 命令在计算距离时会假设地球为完美的球形， 在极限情况下， 这一假设最大会造成 0.5% 的误差。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">输入两个城市  并指定计量单位 这里指定的km</span><br>127.0.0.1:6379&gt; GEODIST china:city shanghai chongqing km<br>&quot;1440.7483&quot;<br><br></code></pre></td></tr></table></figure>



<blockquote>
<p><strong>GEORADIUS</strong></p>
</blockquote>
<p>给定的经纬度为中心， 找出某一半径内的元素</p>
<p>范围可以使用以下其中一个单位：</p>
<ul>
<li><strong>m</strong> 表示单位为米。</li>
<li><strong>km</strong> 表示单位为千米。</li>
<li><strong>mi</strong> 表示单位为英里。</li>
<li><strong>ft</strong> 表示单位为英尺。</li>
</ul>
<p>在给定以下可选项时， 命令会返回额外的信息：</p>
<ul>
<li><code>WITHDIST</code>: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</li>
<li><code>WITHCOORD</code>: 将位置元素的经度和维度也一并返回。</li>
<li><code>WITHHASH</code>: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</li>
</ul>
<p>命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式：</p>
<ul>
<li><code>ASC</code>: 根据中心的位置， 按照从近到远的方式返回位置元素。</li>
<li><code>DESC</code>: 根据中心的位置， 按照从远到近的方式返回位置元素。</li>
</ul>
<p>例如：</p>
<p> 我附近的人？ （获得所有附近的人的地址，定位！）通过半径来查询！ 获得指定数量的人</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">以110，30 这个经度为中心寻找方圆一千公里以内的城市</span><br>127.0.0.1:6379&gt; GEORADIUS china:city  110 30 1000 km<br>1) &quot;guiyang&quot;<br>2) &quot;chongqing&quot;<br>3) &quot;shengzhen&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 将具体距离、经纬度信息也一并返回</span><br>127.0.0.1:6379&gt; GEORADIUS china:city  110 30 1000 km WITHCOORD WITHDIST<br>1) 1) &quot;guiyang&quot;<br>   2) &quot;495.0114&quot;<br>   3) 1) &quot;106.68084830045700073&quot;<br>      2) &quot;26.64221710938331711&quot;<br>2) 1) &quot;chongqing&quot;<br>   2) &quot;335.3982&quot;<br>   3) 1) &quot;106.56188696622848511&quot;<br>      2) &quot;29.56472525888953129&quot;<br>3) 1) &quot;shengzhen&quot;<br>   2) &quot;911.2583&quot;<br>   3) 1) &quot;114.10092204809188843&quot;<br>      2) &quot;22.6755001616335008&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>GEORADIUSBYMEMBER</p>
</blockquote>
<p>找出位于指定范围内的元素，中心点是由给定的位置元素决定</p>
<p>这个命令和 <a href="https://www.redis.net.cn/order/3689.html">GEORADIUS</a> 命令一样， 都可以找出位于指定范围内的元素， 但是 <code>GEORADIUSBYMEMBER</code> 的中心点是由给定的位置元素决定的， 而不是像 <a href="https://www.redis.net.cn/order/3689.html">GEORADIUS</a> 那样， 使用输入的经度和纬度来决定中心点 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 找出位于指定元素周围的其他元素！</span><br>127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city chongqing 500 km<br>1) &quot;guiyang&quot;<br>2) &quot;chongqing&quot;<br></code></pre></td></tr></table></figure>

<p> GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; ZRANGE china:city 0 -1 # 查看地图中全部的元素<br>1) &quot;chongqi&quot;<br>2) &quot;xian&quot;<br>3) &quot;shengzhen&quot;<br>4) &quot;hangzhou&quot;<br>5) &quot;shanghai&quot;<br>6) &quot;beijing&quot;<br>127.0.0.1:6379&gt; zrem china:city beijing # 移除指定元素！<br>(integer) 1<br>127.0.0.1:6379&gt; ZRANGE china:city 0 -1<br>1) &quot;chongqi&quot;<br>2) &quot;xian&quot;<br>3) &quot;shengzhen&quot;<br>4) &quot;hangzhou&quot;<br>5) &quot;shanghai&quot;<br></code></pre></td></tr></table></figure>



<h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><blockquote>
<p>什么是基数？</p>
</blockquote>
<p> 比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。 </p>
<blockquote>
<p>简介</p>
</blockquote>
<p>Redis 2.8.9 版本就更新了 Hyperloglog 数据结构！ Redis Hyperloglog 基数统计的算法！</p>
<p>优点：占用的内存是固定，2^64 不同的元素的技术，只需要废 12KB内存！如果要从内存角度来比较的话 Hyperloglog 首选！</p>
<p>网页的 UV （一个人访问一个网站多次，但是还是算作一个人！）</p>
<p>传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 ! 这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id；</p>
<p>0.81% 错误率！ 统计UV任务，可以忽略不计的！</p>
<blockquote>
<p>实例</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> PFADD w3ckey &quot;redis&quot;<br> <br><span class="hljs-number">1</span>) (<span class="hljs-type">integer</span>) <span class="hljs-number">1</span><br> <br>redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> PFADD w3ckey &quot;mongodb&quot;<br> <br><span class="hljs-number">1</span>) (<span class="hljs-type">integer</span>) <span class="hljs-number">1</span><br> <br>redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> PFADD w3ckey &quot;mysql&quot;<br> <br><span class="hljs-number">1</span>) (<span class="hljs-type">integer</span>) <span class="hljs-number">1</span><br> <br>redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> PFCOUNT w3ckey<br> <br>(<span class="hljs-type">integer</span>) <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p>如果允许容错，那么一定可以使用 Hyperloglog</p>
<p>如果不允许容错，就使用 set 或者自己的数据类型即可</p>
<h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><blockquote>
<p>位存储</p>
</blockquote>
<p>统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡，365打卡！ 两个状态的，都可以使用Bitmaps！ Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！ 365 天 = 365 bit 1字节 = 8bit 46 个字节左右！</p>
<blockquote>
<p>测试</p>
</blockquote>
<p>使用bitmap 来记录 周一到周日的打卡！</p>
<p>周一：1 周二：0 周三：0 周四：1 ……</p>
<p><img src="/img/work/1632664931110.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">0</span> <span class="hljs-number">1</span> <br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">1</span> <span class="hljs-number">0</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">2</span> <span class="hljs-number">0</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">3</span> <span class="hljs-number">1</span> <br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">4</span> <span class="hljs-number">1</span> <br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">5</span> <span class="hljs-number">1</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">6</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>查看某一天是否有打卡！</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> getbit sign <span class="hljs-number">3</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> getbit sign <span class="hljs-number">6</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>统计操作，统计 打卡的天数！</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> bitcount sign # 统计这周的打卡记录，就可以看到是否有全勤！<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>



<p>参考：</p>
<p>​       Redis官网：<a href="https://www.redis.net.cn/">https://www.redis.net.cn/</a></p>
<p>​       B站狂神说Java:<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0</a></p>
<p>​      </p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis缓存穿透和雪崩</title>
    <url>/2021/10/11/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="服务的高可用问题"><a href="#服务的高可用问题" class="headerlink" title="服务的高可用问题"></a>服务的高可用问题</h3><p>​       Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一 些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。 另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。  </p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><blockquote>
<p>概念  </p>
</blockquote>
<p>​    缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中,于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中(秒杀!)，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了 缓存穿透。 </p>
<p><img src="/img/work/1633962251731.png"></p>
<blockquote>
<p>解决方案  </p>
</blockquote>
<p><strong>布隆过滤器</strong>  </p>
<p>​     布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则 丢弃，从而避免了对底层存储系统的查询压力； </p>
<p><img src="/img/work/1633962830773.png"></p>
<p><strong>缓存空对象</strong> </p>
<p>​    当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数 据将会从缓存中获取，保护了后端数据源；  </p>
<p>但是这种方法会存在两个问题： </p>
<p>1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多 的空值的键； </p>
<p>2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于 需要保持一致性的业务会有影响。 </p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><blockquote>
<p>概述 </p>
</blockquote>
<p>​      这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中 对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一 个屏障上凿开了一个洞。 </p>
<p>​     当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访 问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。 </p>
<p><strong>解决方案</strong></p>
<blockquote>
<p>设置热点数据永不过期   </p>
</blockquote>
<p>​     从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。  </p>
<p> <strong>加互斥锁</strong></p>
<p>​     分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布 式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考 验很大。  </p>
<p><img src="/img/work/1633963512731.png"></p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p> <strong>概念</strong>  </p>
<p>​      缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机！ </p>
<p>​      产生雪崩的原因之一，比如双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。 </p>
<p><img src="/img/work/1633963929642.png"></p>
<p>​      其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知 的，很有可能瞬间就把数据库压垮。 </p>
<blockquote>
<p>解决方案  </p>
</blockquote>
<p><strong>redis高可用</strong> </p>
<p>​      这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。</p>
<p><strong>限流降级</strong></p>
<p>​      这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 </p>
<p><strong>数据预热</strong> </p>
<p>​     数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数 据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。 </p>
<p>引用:</p>
<hr>
<p>狂神说Java:<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合Flowable工作流(1)</title>
    <url>/2021/09/17/SpringBoot%E6%95%B4%E5%90%88Flowable%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Flowable流程图"><a href="#Flowable流程图" class="headerlink" title="Flowable流程图"></a>Flowable流程图</h1><h3 id="Flowable是什么？"><a href="#Flowable是什么？" class="headerlink" title="Flowable是什么？"></a>Flowable是什么？</h3><p> Flowable是一个使用Java编写的轻量级业务流程引擎。Flowable流程引擎可用于部署BPMN 2.0流程定义（用于定义流程的行业XML标准）， 创建这些流程定义的流程实例，进行查询，访问运行中或历史的流程实例与相关数据，等等。</p>
<p> Flowable可以十分灵活地加入你的应用/服务/构架。可以将JAR形式发布的Flowable库加入应用或服务，来<em>嵌入</em>引擎。 以JAR形式发布使Flowable可以轻易加入任何Java环境：Java SE；Tomcat、Jetty或Spring之类的servlet容器；JBoss或WebSphere之类的Java EE服务器，等等。 另外，也可以使用Flowable REST API进行HTTP调用。也有许多Flowable应用（Flowable Modeler, Flowable Admin, Flowable IDM 与 Flowable Task），提供了直接可用的UI示例，可以使用流程与任务。 </p>
 <span id="more"></span>

<p>Flowable流程需要先画流程图，然后再根据流程图引用自项目中，所以以下先画好流程图，然后再进行集成Spring boot生成</p>
<blockquote>
<p>部署FlowableUi</p>
</blockquote>
<ol>
<li><p>官方网址下载FlowableUI：<a href="https://flowable.com/open-source/downloads/">https://flowable.com/open-source/downloads/</a></p>
</li>
<li><p>将下载好之后的压缩包进行解压进入文件夹之后会看到一个war包文件下，打开文件夹将会有一个（flowable-ui.war）文件</p>
</li>
<li><p>安装部署Tomcat，安装部署就略过了百度都有，将上面的war包放入tomcat的webapps目录下，并在当前目录下执行以下命令</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>flowable-ui.war<br></code></pre></td></tr></table></figure></li>
<li><p>启动之后，有一行日志：Tomcat started on port(s): 8080 (http) with context path ‘/flowable-ui’，从以上可以看出端口默认为8080，路径为：/flowable-ui 。即访问：<a href="http://localhost:8080/flowable-ui%EF%BC%8C">http://localhost:8080/flowable-ui，</a></p>
<p>  账号：admin 密码：test </p>
</li>
</ol>
<blockquote>
<p>画流程图</p>
</blockquote>
<p><strong>登录之后</strong> </p>
<p>![](/img/work/ <a href="https://res.cloudinary.com/dlzf16hlo/image/upload/v1632027508/blog/1632027486_1_qqpru0.png">https://res.cloudinary.com/dlzf16hlo/image/upload/v1632027508/blog/1632027486_1_qqpru0.png</a> )</p>
<p><strong>选择建模器应用程序</strong></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis三种集群模式之Cluster模式</title>
    <url>/2021/10/07/redis-cluster%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1、redis-cluter设计"><a href="#1、redis-cluter设计" class="headerlink" title="1、redis-cluter设计"></a>1、redis-cluter设计</h2><p> Redis集群搭建的方式有多种，开始使用主从模式做集群，若master宕机需要手动配置slave转为master；后来为了高可用提出来(redis-sentinel)<strong>哨兵</strong>模式，该模式下有一个哨兵监视master和slave，若master宕机可自动将slave转为master，但它也有一个问题，就是不能动态扩充；从redis 3.0之后版本支持redis-cluster集群. </p>
<p> Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。其redis-cluster架构图如下： </p>
<p><img src="/img/work/1633829297415.png"></p>
<p> 其结构特点： </p>
<ol>
<li> 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。 </li>
<li> 节点的fail是通过集群中超过半数的节点检测失效时才生效。 </li>
<li> 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。 </li>
<li> redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配）,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value。 </li>
<li> Redis集群预分好16384个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。 </li>
</ol>
<h2 id="2、redis-cluster节点分配"><a href="#2、redis-cluster节点分配" class="headerlink" title="2、redis cluster节点分配"></a>2、redis cluster节点分配</h2><p>现在我们是三个节点分别是：A,B,C 三个节点，它们可以是一台机器上的三个端口，也可以是三台不同服务器。那么，采用哈希槽（hash solt）的方式来分配16384个solt的话，他们三个节点分别承担的solt区间是：</p>
<ul>
<li><p>节点A覆盖0－5460; </p>
</li>
<li><p>节点B覆盖5461－10922; </p>
</li>
<li><p>节点C覆盖10923－16383；</p>
</li>
</ul>
<p> 获取数据： </p>
<p>​     如果存入一个值，按照redis-cluster哈希槽的算法：CRC16(‘key’)%16384 = 6782。那么就会把这个key的存储分配到 B 上。同样，当我连接（A，B，C）任何一个节点，想获取’key’这个key时，也会这样的算法，然后内部跳转到B节点上获取数据新增一个主节点：</p>
<p> 新增一个节点D，redis cluster的这种做法是从各个节点的前面各拿取一部分slot到D上，我会在接下来的实践中实验。大致就会变成这样： </p>
<ul>
<li>节点A覆盖1365-5460</li>
<li> 节点B覆盖6827-10922</li>
<li> 节点C覆盖12288-16383</li>
<li> 节点D覆盖0-1364,5461-6826,10923-12287 </li>
</ul>
<h2 id="3、-Redis-Cluster主从模式"><a href="#3、-Redis-Cluster主从模式" class="headerlink" title="3、 Redis Cluster主从模式"></a>3、 <strong>Redis Cluster主从模式</strong></h2><p>​        redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。</p>
<p>​       上面那个例子里, 集群有ABC三个主节点, 如果这3个节点都没有加入从节点，如果B挂掉了，我们就无法访问整个集群了。A和C的slot也无法访问。所以我们在集群建立的时候，一定要为每个主节点都添加了从节点, 比如像这样, 集群包含主节点A、B、C, 以及从节点A1、B1、C1, 那么即使B挂掉系统也可以继续正确工作。B1节点替代了B节点，所以Redis集群将会选择B1节点作为新的主节点，集群将会继续正确地提供服务。 当B重新开启后，它就会变成B1的从节点。不过需要注意，如果节点B和B1同时挂了，Redis集群就无法继续正确地提供服务了。</p>
<h2 id="4、redis6-2-5-集群部署"><a href="#4、redis6-2-5-集群部署" class="headerlink" title="4、redis6.2.5 集群部署"></a><strong>4、redis6.2.5 集群部署</strong></h2><p><strong>集群中至少应该有奇数个节点，所以至少有三个节点，每个节点至少有一个备份节点，所以下面使用6节点（主节点、备份节点由redis-cluster集群确定）。</strong></p>
<h3 id="4-1-准备工作"><a href="#4-1-准备工作" class="headerlink" title="4.1 准备工作"></a><strong>4.1 准备工作</strong></h3><p>   本文使用两台centOS7主机，一台机器3个节点，创建出3 master、3 salve 环境，master（192.168.1.8） salve(192.168.1.10) </p>
<h3 id="4-2-创建Redis节点"><a href="#4-2-创建Redis节点" class="headerlink" title="4.2 创建Redis节点"></a>4.2 创建Redis节点</h3><p>首先在指定目录下创建  redis_cluster </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mkdir /software01/redis_cluster<br></code></pre></td></tr></table></figure>

<p> 在 redis_cluster 目录下，创建名为 6379、6380、6381的目录，并将 redis.conf 拷贝到这六个目录中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> mkdir 6379 6380 6381、6382、6383、6384</span><br><span class="hljs-meta">#</span><span class="bash"> cp redis.conf redis_cluster/6379</span><br><span class="hljs-meta">#</span><span class="bash"> cp redis.conf redis_cluster/6380</span> <br><span class="hljs-meta">#</span><span class="bash"> cp redis.conf redis_cluster/6381</span><br></code></pre></td></tr></table></figure>

<p> 分别修改这三个配置文件，修改如下内容 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">port 6379　　　　　　#端口6379 6380 6381、6382、6383、6384 <br>bind 本机ip 　　　　 #默认ip为127.0.0.1 需要改为其他节点机器可访问的ip 否则创建集群时无法访问对应的端口，无法创建集群 <br>daemonize yes 　　  #redis后台运行 <br>pidfile /var/run/redis_6379.pid 　　#pidfile文件对应6379,6380,6381 <br>cluster-enabled yes 　　　　　　　　　#开启集群 <br>cluster-config-file nodes_6379.conf #集群的配置 配置文件首次启动自动生成 6379,6380,6381 <br>cluster-node-timeout 15000 　　　　　　#请求超时 默认15秒，可自行设置  <br>appendonly yes 　　　　　　　　　　　　#aof日志开启 有需要就开启，它会每次写操作都记录一条日志<br></code></pre></td></tr></table></figure>



<p>接着在另外一台机器上（192.168.1.10），的操作重复以上三步，只是把目录改为6382、6383、6384，对应的配置文件也按照这个规则修改即可. </p>
<h3 id="4-3-启动各节点"><a href="#4-3-启动各节点" class="headerlink" title="4.3 启动各节点"></a>4.3 启动各节点</h3><p> 第一台机器上执行: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# redis-server /root/software01/redis_cluster/6379/redis.conf <br>[root@centos7 bin]# redis-server /root/software01/redis_cluster/6380/redis.conf <br>[root@centos7 bin]# redis-server /root/software01/redis_cluster/6381/redis.conf <br></code></pre></td></tr></table></figure>

<p> 另外一台机器上执行: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# redis-server /root/software01/redis_cluster/6382/redis.conf <br>[root@centos7 bin]# redis-server /root/software01/redis_cluster/6383/redis.conf <br>[root@centos7 bin]# redis-server /root/software01/redis_cluster/6384/redis.conf <br></code></pre></td></tr></table></figure>



<h3 id="4-4-检查-redis-启动情况"><a href="#4-4-检查-redis-启动情况" class="headerlink" title="4.4 检查 redis 启动情况"></a>4.4 检查 redis 启动情况</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> ps -ef | grep redis //查看redis启动情况</span><br></code></pre></td></tr></table></figure>

<p><img src="/img/work/1633850372740.png"></p>
<p><img src="/img/work/1633850438157.png"></p>
<h3 id="4-5-创建集群"><a href="#4-5-创建集群" class="headerlink" title="4.5 创建集群"></a>4.5 创建集群</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# ./redis-cli --cluster create 192.168.1.10:6379 192.168.1.10:6380 192.168.1.10:6381 192.168.1.8:6382 192.168.1.8:6383 192.168.1.8:6384 --cluster-replicas 1<br></code></pre></td></tr></table></figure>

<p> <strong>注意：Redis Cluster最低要求是3个主节点，如果需要集群需要认证，则在最后加入 -a xx 即可。</strong> </p>
<p>以上命令执行完成后</p>
<p><img src="/img/work/1633868265946.png"></p>
<p>输入yes之后将会出现以下信息</p>
<p><img src="/img/work/1633868317543.png"></p>
<h3 id="4-6-测试"><a href="#4-6-测试" class="headerlink" title="4.6 测试"></a>4.6 测试</h3><p> 在第一台机器上连接集群的6379端口的节点，在另外一台连接6382节点，连接方式为  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli -h 192.168.1.10 -c -p 6379  #-h 连接主机的ip <br>                                      #-c连接集群结点时使用，此选项可防止moved和ask异常 <br>                                      #-p 端口   <br>                                      #-a 如果设置密码 可加上-a进行密码验证登录 <br></code></pre></td></tr></table></figure>

<p>在6379节点设置key值，然后在6382获取key的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">在节点6379上设置值</span><br>192.168.1.10:6379&gt; set k1 v1<br><span class="hljs-meta">-&gt;</span><span class="bash"> Redirected to slot [12706] located at 192.168.1.10:6380</span><br>OK<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">在6382也可以获取值</span><br>192.168.1.8:6382&gt; get k1<br><span class="hljs-meta">-&gt;</span><span class="bash"> Redirected to slot [12706] located at 192.168.1.10:6380</span><br>&quot;v1&quot;<br></code></pre></td></tr></table></figure>

<p>结果分别如下：</p>
<p><img src="/img/work/1633869331466.png"></p>
<p><img src="/img/work/1633869348246.png"></p>
<h2 id="5-Cluster模式的优缺点"><a href="#5-Cluster模式的优缺点" class="headerlink" title="5. Cluster模式的优缺点"></a>5. Cluster模式的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li>无中心架构，数据按照slot分布在多个节点。</li>
<li>集群中的每个节点都是平等的关系，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</li>
<li>可线性扩展到1000多个节点，节点可动态添加或删除</li>
<li>能够实现自动故障转移，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色转换</li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li>客户端实现复杂，驱动要求实现Smart Client，缓存slots mapping信息并及时更新，提高了开发难度。目前仅JedisCluster相对成熟，异常处理还不完善，比如常见的“max redirect exception”</li>
<li>节点会因为某些原因发生阻塞（阻塞时间大于 cluster-node-timeout）被判断下线，这种failover是没有必要的</li>
<li>数据通过异步复制，不保证数据的强一致性</li>
<li>slave充当“冷备”，不能缓解读压力</li>
<li>批量操作限制，目前只支持具有相同slot值的key执行批量操作，对mset、mget、sunion等操作支持不友好</li>
<li>key事务操作支持有线，只支持多key在同一节点的事务操作，多key分布不同节点时无法使用事务功能</li>
<li>不支持多数据库空间，单机redis可以支持16个db，集群模式下只能使用一个，即db 0</li>
</ol>
<p> <strong>Redis Cluster模式不建议使用pipeline和multi-keys操作，减少max redirect产生的场景。</strong> </p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>Redis集群方案的三种模式，其中主从复制模式能实现读写分离，但是不能自动故障转移；哨兵模式基于主从复制模式，能实现自动故障转移，达到高可用，但与主从复制模式一样，不能在线扩容，容量受限于单机的配置；Cluster模式通过无中心化架构，实现分布式存储，可进行线性扩展，也能高可用，但对于像批量操作、事务操作等的支持性不够好。三种模式各有优缺点，可根据实际场景进行选择。</p>
<h2 id="附：Redis集群各种参数设置"><a href="#附：Redis集群各种参数设置" class="headerlink" title="附：Redis集群各种参数设置"></a>附：Redis集群各种参数设置</h2><h3 id="1-创建集群主节点"><a href="#1-创建集群主节点" class="headerlink" title="1. 创建集群主节点"></a>1. 创建集群主节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster create 192.168.1.10:6379 192.168.1.10:6380 192.168.1.10:6381<br></code></pre></td></tr></table></figure>

<h3 id="2-创建集群主从节点"><a href="#2-创建集群主从节点" class="headerlink" title="2. 创建集群主从节点"></a>2. 创建集群主从节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">/redis-cli --cluster create 192.168.1.10:6379 192.168.1.10:6380 192.168.1.10:6381 192.168.1.8:6382 192.168.1.8:6383 192.168.1.8:6384 --cluster-replicas 1<br></code></pre></td></tr></table></figure>

<p> <strong>说明：–cluster-replicas 参数为数字，1表示每个主节点需要1个从节点。</strong> </p>
<p>通过该方式创建的带有从节点的机器不能够自己手动指定主节点，所以如果需要指定的话，需要自己手动指定，先使用1或3创建好主节点后，再通过4来处理。 </p>
<h3 id="3-添加集群主节点"><a href="#3-添加集群主节点" class="headerlink" title="3. 添加集群主节点"></a>3. 添加集群主节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster add-node 192.168.1.8:6382 192.168.1.10:6379 <br></code></pre></td></tr></table></figure>

<p>说明：为一个指定集群添加节点，需要先连到该集群的任意一个节点IP（192.168.1.10:6379），再把新节点加入。该2个参数的顺序有要求：新加入的节点放前 </p>
<h3 id="4-添加集群从节点"><a href="#4-添加集群从节点" class="headerlink" title="4. 添加集群从节点"></a>4. 添加集群从节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster add-node 192.168.1.8:6382 192.168.1.10:6379 --cluster-slave --cluster-master-id 117457eab5071954faab5e81c3170600d5192270<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">说明：把6382节点加入到6379节点的集群中，并且当做node_id:17ea90fd81280b5ee7999cbf0313f89206688242的从节点。如果不指定 --cluster-master-id 会随机分配到任意一个主节点。</span><br></code></pre></td></tr></table></figure>

<h3 id="5-删除节点"><a href="#5-删除节点" class="headerlink" title="5. 删除节点"></a>5. 删除节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster del-node 192.168.1.8:6384 f6a6957421b80409106cb36be3c7ba41f3b603ff<br></code></pre></td></tr></table></figure>

<p>说明：指定IP、端口和node_id 来删除一个节点，从节点可以直接删除，有slot分配的主节点不能直接删除。</p>
<p>注意：当被删除掉的节点重新起来之后不能自动加入集群，但其和主的复制还是正常的，也可以通过该节点看到集群信息（通过其他正常节点已经看不到该被del-node节点的信息）。</p>
<p>如果想要再次加入集群，则需要先在该节点执行cluster reset，再用add-node进行添加，进行增量同步复制。</p>
<h3 id="6-检查集群"><a href="#6-检查集群" class="headerlink" title="6. 检查集群"></a>6. 检查集群</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster check 192.168.1.8:6384 --cluster-search-multiple-owners<br></code></pre></td></tr></table></figure>

<p> 说明：任意连接一个集群节点，进行集群状态检查 </p>
<h3 id="7-集群信息查看"><a href="#7-集群信息查看" class="headerlink" title="7. 集群信息查看"></a>7. 集群信息查看</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster info 192.168.1.8:6384<br></code></pre></td></tr></table></figure>

<p> 说明：检查key、slots、从节点个数的分配情况 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# redis-cli --cluster info 192.168.1.8:6384<br>192.168.1.10:6379 (17ea90fd...) -&gt; 1 keys | 5461 slots | 1 slaves.<br>192.168.1.8:6382 (4a8b3637...) -&gt; 0 keys | 5462 slots | 1 slaves.<br>192.168.1.10:6380 (4c4710e3...) -&gt; 1 keys | 5461 slots | 1 slaves.<br>[OK] 2 keys in 3 masters.<br>0.00 keys per slot on average.<br></code></pre></td></tr></table></figure>

<h3 id="8-修复集群"><a href="#8-修复集群" class="headerlink" title="8. 修复集群"></a>8. 修复集群</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster fix 192.168.1.8:6384 --cluster-search-multiple-owners<br></code></pre></td></tr></table></figure>

<p> 说明：修复集群和槽的重复分配问题 </p>
<h3 id="9-设置集群的超时时间"><a href="#9-设置集群的超时时间" class="headerlink" title="9. 设置集群的超时时间"></a>9. 设置集群的超时时间</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster set-timeout 192.168.1.8:6382 10000<br></code></pre></td></tr></table></figure>

<p> 说明：连接到集群的任意一节点来设置集群的超时时间参数cluster-node-timeout </p>
<h3 id="10-集群中执行相关命令"><a href="#10-集群中执行相关命令" class="headerlink" title="10. 集群中执行相关命令"></a>10. 集群中执行相关命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster call 192.168.1.10:6381 config set requirepass cc<br>redis-cli -a cc --cluster call 192.168.1.10:6381 config set masterauth cc<br>redis-cli -a cc --cluster call 192.168.1.10 config rewrite<br></code></pre></td></tr></table></figure>

<p> 说明：连接到集群的任意一节点来对整个集群的所有节点进行设置。 </p>
<p>到此，相关集群的基本操作已经介绍完，现在说明集群迁移的相关操作。</p>
<p>Redis 6.0 新增了几个命令：</p>
<p>1，fix 的子命令：–cluster-fix-with-unreachable-masters</p>
<p>2，call的子命令：–cluster-only-masters、–cluster-only-replicas</p>
<p>3，集群节点备份：backup</p>
<h2 id="迁移相关"><a href="#迁移相关" class="headerlink" title="迁移相关"></a>迁移相关</h2><h3 id="在线迁移slot-："><a href="#在线迁移slot-：" class="headerlink" title="在线迁移slot ："></a><strong>在线迁移slot</strong> ：</h3><p>​       在线把集群的一些slot从集群原来slot节点迁移到新的节点，即可以完成集群的在线横向扩容和缩容。有2种方式进行迁移</p>
<p>一、是根据提示来进行操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">直接连接到集群的任意一节点</span><br>redis-cli -a cc --cluster reshard 192.168.1.10:6379<br></code></pre></td></tr></table></figure>

<p>​       二、是根据参数进行操作： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli -a cc --cluster reshard 192.168.1.10:6379 --cluster-from 117457eab5071954faab5e81c3170600d5192270 --cluster-to 815da8448f5d5a304df0353ca10d8f9b77016b28 --cluster-slots 10 --cluster-yes --cluster-timeout 5000 --cluster-pipeline 10 --cluster-replace<br></code></pre></td></tr></table></figure>

<p>​       说明：连接到集群的任意一节点来对指定节点指定数量的slot进行迁移到指定的节点。  </p>
<h3 id="平衡（rebalance）slot-："><a href="#平衡（rebalance）slot-：" class="headerlink" title="平衡（rebalance）slot ："></a>平衡（rebalance）<strong>slot</strong> ：</h3><p>1）  平衡集群中各个节点的slot数量 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli -a cc --cluster rebalance 192.168.163.132:6379<br></code></pre></td></tr></table></figure>

<p>2）根据集群中各个节点设置的权重等平衡slot数量（不执行，只模拟） </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli -a cc --cluster rebalance --cluster-weight 117457eab5071954faab5e81c3170600d5192270=5 815da8448f5d5a304df0353ca10d8f9b77016b28=4 56005b9413cbf225783906307a2631109e753f8f=3 --cluster-simulate 192.168.1.10:6379<br></code></pre></td></tr></table></figure>

<ol start="3">
<li> 导入集群 </li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster import 192.168.1.10:6379 --cluster-from 192.168.1.10:9021 --cluster-replace<br></code></pre></td></tr></table></figure>

<p> 说明：外部Redis实例（9021）导入到集群中的任意一节点。 </p>
<p> 注意：测试下来发现参数–cluster-replace没有用，如果集群中已经包含了某个key，在导入的时候会失败，不会覆盖，只有清空集群key才能导入。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">*** Importing 97847 keys from DB 0<br>Migrating 9223372011174675807 to 192.168.1.10:6381: Source 192.168.1.10:9021 replied with error:<br>ERR Target instance replied with error: BUSYKEY Target key name already exists<br></code></pre></td></tr></table></figure>

<p> 并且发现如果集群设置了密码，也会导入失败，需要设置集群密码为空才能进行导入（call）。通过monitor（9021）的时候发现，在migrate的时候需要密码进行auth认证 </p>
<p><strong>Redis Cluster 通过redis-cli –cluster来创建和管理集群的方式和 redis-trib.rb脚本绝大部分都是一样的，所以对于比较熟悉 redis-trib.rb 脚本的，使用–cluster也非常顺手。</strong> </p>
<p>参考：</p>
<hr>
<p><a href="https://www.cnblogs.com/zhoujinyi/p/11606935.html">https://www.cnblogs.com/zhoujinyi/p/11606935.html</a></p>
<p><a href="https://www.cnblogs.com/saneri/p/12409173.html">https://www.cnblogs.com/saneri/p/12409173.html</a></p>
<p>半路雨歌链接：<a href="https://juejin.cn/post/6844904097116585991">https://juejin.cn/post/6844904097116585991</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis.conf详解</title>
    <url>/2021/09/29/redis-conf%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>以下将从配置文件中顺序往下讲解</strong>,<strong>涉及主从复制，持久化将会另起讲解</strong></p>
<h4 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h4><p><img src="/img/work/1632924192904.png"></p>
<p>1.配置文件unit单位大小写不敏感</p>
<h4 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h4><p><img src="/img/work/1632924269484.png"></p>
<p>类似我们nginx中的include中的包含文件</p>
 <span id="more"></span>

<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">bind 127.0.0.1 # 绑定的ip<br>protected-mode yes # 保护模式<br>port 6379 #端口设置<br></code></pre></td></tr></table></figure>



<h4 id="通用-GENERAL"><a href="#通用-GENERAL" class="headerlink" title="通用 GENERAL"></a>通用 GENERAL</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"> daemonize yes #以守护进程的方式运行，默认是no，当我们需要后台启动时需要我们手动设置为yes<br> <br> pidfile /var/run/redis_6379.pid  #如果我们以后台方式运行，我们就需要指定一个pid文件<br> <br><span class="hljs-meta"> </span><br><span class="hljs-meta">#</span><span class="bash">日志</span> <br><span class="hljs-meta">#</span><span class="bash"> Specify the server verbosity level.</span><br><span class="hljs-meta">#</span><span class="bash">ze yes This can be one of:</span><br><span class="hljs-meta">#</span><span class="bash"> debug (a lot of information, useful <span class="hljs-keyword">for</span> development/testing)</span><br><span class="hljs-meta">#</span><span class="bash"> verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="hljs-meta">#</span><span class="bash"> notice (moderately verbose, what you want <span class="hljs-keyword">in</span> production probably) 生产环境</span><br><span class="hljs-meta">#</span><span class="bash"> warning (only very important / critical messages are logged)</span><br>loglevel notice<br><br>logfile &quot;&quot; #日志的文件位置名<br><br>databases 16  #数据库的数量，默认是16个数据库<br><br>always-show-logo no #是否总是显示日志<br><br> <br></code></pre></td></tr></table></figure>



<h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p><strong>持久化，在规定的时间内，执行了多少次操作，则会持久化到文件.rdb.aof</strong>, <strong>redis是内存数据库,如果没有持久化，那么数据断电即丢失</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">如果3600s内，如果至少有一个key进行了修改，即进行持久化操作</span><br>save 3600 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">如果300S内，如果至少300S内，至少有10个可以进行了修改，即进行持久化操作</span><br>save 300 10<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">如果60S内，如果至少10000个进行了修改，即进行持久化操作</span><br>save 60 10000<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">后续持久化配置需要用到这里</span><br><br>stop-writes-on-bgsave-error yes #持久化如果出错，是否继续持久化<br><br>rdbcompression yes #是否压缩rdb文件,会消耗一些CPU资源<br><br>rdbchecksum yes  #保存rdb文件的时候，进行错误的核查校验！<br><br>dbfilename dump.rdb # 指定本地数据库文件名，一般采用默认的 dump.rdb<br><br>dir ./  #指定本地数据库存放目录，一般也用默认配置<br><br><br><br><br><br></code></pre></td></tr></table></figure>



<h4 id="SECURITY-安全"><a href="#SECURITY-安全" class="headerlink" title="SECURITY 安全"></a>SECURITY 安全</h4><p><img src="/img/work/1632927510924.png"></p>
<p> <strong>可以在这里设置redis的密码，默认是没有密码！</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">               <br>requirepass 123456  #设置密码，设置后需要重启服务才有效,这里设置的是123456<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">当我们登录之后，执行命令将会出现以下提示需要认证</span><br>(error) NOAUTH Authentication required.<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">认证即可正常操作</span><br>127.0.0.1:6379&gt; auth 123456<br>OK<br><br>127.0.0.1:6379&gt; set k1 v1<br>OK<br>127.0.0.1:6379&gt; get k1<br>&quot;v1&quot;<br><br></code></pre></td></tr></table></figure>



<h4 id="限制-CLIENTS"><a href="#限制-CLIENTS" class="headerlink" title="限制 CLIENTS"></a>限制 CLIENTS</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><br>maxclients 10000  #设置能连接上redis的最大客户端的数量<br><br>maxmemory &lt;bytes&gt; #redis配置最大的内存容量<br><br><br><br>maxmemory-policy noeviction # 内存达到上限后的处理策略<br><span class="hljs-meta">#</span><span class="bash"> volatile-lru -&gt; Evict using approximated LRU, only keys with an expire <span class="hljs-built_in">set</span>.</span><br><span class="hljs-meta">#</span><span class="bash"> allkeys-lru -&gt; Evict any key using approximated LRU.</span><br><span class="hljs-meta">#</span><span class="bash"> volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire <span class="hljs-built_in">set</span>.</span><br><span class="hljs-meta">#</span><span class="bash"> allkeys-lfu -&gt; Evict any key using approximated LFU.</span><br><span class="hljs-meta">#</span><span class="bash"> volatile-random -&gt; Remove a random key having an expire <span class="hljs-built_in">set</span>.</span><br><span class="hljs-meta">#</span><span class="bash"> allkeys-random -&gt; Remove a random key, any key.</span><br><span class="hljs-meta">#</span><span class="bash"> volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span><br><span class="hljs-meta">#</span><span class="bash"> noeviction -&gt; Don<span class="hljs-string">&#x27;t evict anything, just return an error on write operations.</span></span><br>        1. volatile-lru: 只对设置了过期时间的key进行LRU(默认值)<br>        2. allkeys-lru： 删除lru算法的key<br>        3. volatile-random：随机删除即将过期key<br>        4. allkeys-random：随机删除<br>        5. volatile-ttl： 删除即将过期的<br>        6. noeviction ： 永不过期，返回错误<br>        7. volatile-lfu：使用近似 LFU 驱逐，只有设置过期的键<br><br></code></pre></td></tr></table></figure>



<h4 id="APPEND-ONLY-模式-aof配置"><a href="#APPEND-ONLY-模式-aof配置" class="headerlink" title="APPEND ONLY 模式 aof配置"></a>APPEND ONLY 模式 aof配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">appendonly no #默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！<br>appendfilename &quot;appendonly.aof&quot; #持久化名称<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> appendfsync always   <span class="hljs-comment">#每次修改都会sync。消耗性能</span></span><br>appendfsync everysec   #每秒执行一次sync，可能会丢失这1S的数据<br><span class="hljs-meta">#</span><span class="bash"> appendfsync no       <span class="hljs-comment">#不执行 sync，这个时候操作系统自己同步数据，速度最快！</span></span><br></code></pre></td></tr></table></figure>



<p>参考：</p>
<p>​       B站狂神说Java:<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0</a></p>
<p>​      Redis.Conf配置文件</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis三种集群模式之主从复制</title>
    <url>/2021/10/06/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader),后者称为从节点(slave/flollower);<strong>数据的复制是单向的，只能由主节点到从节点，Master以写为主，Slave以读为主</strong>。</p>
<h3 id="1-1主从复制的作用主要包括："><a href="#1-1主从复制的作用主要包括：" class="headerlink" title="1.1主从复制的作用主要包括："></a>1.1主从复制的作用主要包括：</h3><ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 （即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写 少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
<li>高可用(集群)基石： 除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复 制是Redis高可用的基础 </li>
</ol>
<p><strong>注意：如redis运用于工程项目中，不能使用单机redis，原因如下：</strong></p>
<ol>
<li> 从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大。</li>
<li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存为256G，也不能将所有内存作用于Redis存储内存，一般单台Redis最大使用内存不应该超过20G。</li>
</ol>
<p>一般结构架构如下：</p>
<p><img src="/img/work/1633523383473.png"></p>
<h2 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2.基本原理"></a>2.基本原理</h2><p> 主从复制模式中包含一个主数据库实例(master)与一个或多个从数据库实例(slave)，客户端可对主数据库进行读写操作，对从数据库进行读操作，主数据库写入的数据会实时自动同步给从数据库 </p>
<h3 id="2-1复制原理图"><a href="#2-1复制原理图" class="headerlink" title="2.1复制原理图"></a>2.1复制原理图</h3><p><img src="/img/work/1633524169754.png"></p>
<h3 id="2-3具体步骤"><a href="#2-3具体步骤" class="headerlink" title="2.3具体步骤"></a>2.3具体步骤</h3><ol>
<li> 从服务器连接主服务器，发送SYNC命令 ；</li>
<li> 主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；</li>
<li> 主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；  </li>
<li>  从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； </li>
<li> 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； </li>
<li>  从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令； </li>
</ol>
<h2 id="3-部署示例"><a href="#3-部署示例" class="headerlink" title="3.部署示例"></a>3.部署示例</h2><p>只配置从库，不用配置主库，主库具体配置，可以参考前面文章《Redis.Conf详解》及《Redis持久化》,我这里配置的是<strong>一主两从</strong></p>
<h3 id="3-1-查看主库信息"><a href="#3-1-查看主库信息" class="headerlink" title="3.1 查看主库信息"></a>3.1 查看主库信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看当前库的信息</span><br>127.0.0.1:6379&gt;info replication<br><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:master  #角色<br>connected_slaves:0  #从机信息<br>master_failover_state:no-failover<br>master_replid:e3d0ce67427f5c928650af42bc66dd0c294f5dbe<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:0<br>second_repl_offset:-1<br>repl_backlog_active:0<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:0<br>repl_backlog_histlen:0<br><br></code></pre></td></tr></table></figure>



<h3 id="2-2-配置文件"><a href="#2-2-配置文件" class="headerlink" title="2.2 配置文件"></a>2.2 配置文件</h3><ol>
<li><p>复制三个redis.conf文件，然后修改对应信息，例如slave1.conf,slave2.conf</p>
</li>
<li><p>分别修改端口信息</p>
</li>
<li><p>分别修改配置文件中pid名称</p>
</li>
<li><p>分别修改log文件名称</p>
</li>
<li><p>分别修改dump.rdb名称</p>
</li>
</ol>
<h3 id="3-3-启动服务"><a href="#3-3-启动服务" class="headerlink" title="3.3 启动服务"></a>3.3 启动服务</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# redis-server etc/slave1.conf #启动从库1<br>[root@centos7 bin]# redis-server etc/slave2.conf #启动从库2<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查看redis服务信息</span><br>[root@centos7 bin]# ps -ef | grep redis<br>root       2766      1  0 05:33 ?        00:00:02 redis-server 127.0.0.1:6379 <br>root       3250      1  0 06:05 ?        00:00:00 redis-server 127.0.0.1:6380<br>root       3263      1  0 06:05 ?        00:00:00 redis-server 127.0.0.1:6381<br>root       3293   2715  0 06:09 pts/1    00:00:00 grep --color=auto redis<br><br></code></pre></td></tr></table></figure>



<h3 id="3-4-一主两从命令方式设置"><a href="#3-4-一主两从命令方式设置" class="headerlink" title="3.4 一主两从命令方式设置"></a>3.4 一主两从命令方式设置</h3><p> 默认情况下，每台Redis服务器都是主节点 ，一般我们配置从机即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">分别登录从服务器</span><br>[root@centos7 bin]# redis-cli -p 6380<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">设置主master,也就找那一台当主节点</span><br>127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379  #寻找主节点，找谁当老大<br>OK<br><br>127.0.0.1:6380&gt; INFO replication<br><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:slave  # 当前角色是从机<br>master_host:127.0.0.1 # 可以的看到主机的信息<br>master_port:6379  #主机端口<br>master_link_status:down<br>master_last_io_seconds_ago:-1<br>master_sync_in_progress:0<br>slave_repl_offset:1<br>master_link_down_since_seconds:-1<br>slave_priority:100<br>slave_read_only:1<br>replica_announced:1<br>connected_slaves:0<br>master_failover_state:no-failover<br>master_replid:449ba98d5fcd3c32154dfd049716ce5ca3ee4d4b<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:0<br>second_repl_offset:-1<br>repl_backlog_active:0<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:0<br>repl_backlog_histlen:0<br></code></pre></td></tr></table></figure>

<p>回到6379中查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:master<br>connected_slaves:1 #一个从节点<br>slave0:ip=127.0.0.1,port=6380,state=online,offset=28,lag=0  #从节点信息<br>master_failover_state:no-failover<br>master_replid:b717806873adac0ac99646e873b92a744d2406df<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:28<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:28<br></code></pre></td></tr></table></figure>

<p>第二个从节点根据上面配置即可</p>
<p><strong>注意：使用命令方式配置只是暂时的，重启服务即失效，推荐在配置文件中配置</strong></p>
<h3 id="3-5-一主两从配置文件方式设置（推荐）"><a href="#3-5-一主两从配置文件方式设置（推荐）" class="headerlink" title="3.5 一主两从配置文件方式设置（推荐）"></a>3.5 一主两从配置文件方式设置（推荐）</h3><p>在从数据配置文件中添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">replicaof 127.0.0.1 6379 # master的ip，port<br>masterauth 123456 # master的密码<br>replica-serve-stale-data no # 如果slave无法与master同步，设置成slave不可读，方便监控脚本发现问题<br></code></pre></td></tr></table></figure>



<p>分别启动两个从服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# redis-server etc/slave1.conf <br>[root@centos7 bin]# redis-server etc/slave2.conf <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">然后再在主服务器输入以下信息即可查看到两个从服务器信息</span><br>127.0.0.1:6379&gt; INFO replication<br><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:master<br>connected_slaves:2  #两个从数据库<br>slave0:ip=127.0.0.1,port=6380,state=online,offset=1008,lag=1<br>slave1:ip=127.0.0.1,port=6381,state=online,offset=1008,lag=1<br>master_failover_state:no-failover<br>master_replid:b717806873adac0ac99646e873b92a744d2406df<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:1008<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:1008<br></code></pre></td></tr></table></figure>



<blockquote>
<p>数据测试</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">主数据库写</span><br>127.0.0.1:6379&gt; set k1 v1<br>OK<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">从数据读</span><br>127.0.0.1:6380&gt; get k1<br>&quot;v1&quot;<br></code></pre></td></tr></table></figure>





<blockquote>
<p>细节</p>
</blockquote>
<p> 主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动被从机保存！ </p>
<p>主机写：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set k1 v1<br>OK<br></code></pre></td></tr></table></figure>

<p>从机写：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6380&gt; set k1 v1<br>(error) READONLY You can&#x27;t write against a read only replica. #不能写入<br><br></code></pre></td></tr></table></figure>



<h2 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4.优缺点"></a>4.优缺点</h2><h3 id="4-1优点"><a href="#4-1优点" class="headerlink" title="4.1优点"></a>4.1优点</h3><ul>
<li>master能自动将数据同步到slave，可以进行读写分离，分担master的读压力</li>
<li>master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求</li>
</ul>
<h3 id="4-2缺点"><a href="#4-2缺点" class="headerlink" title="4.2缺点"></a>4.2缺点</h3><ul>
<li>不具备自动容错与恢复功能，master或slave的宕机都可能导致客户端请求失败，需要等待机器重启或手动切换客户端IP才能恢复</li>
<li>master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题</li>
<li>难以支持在线扩容，Redis的容量受限于单机配置</li>
</ul>
<p>参考：</p>
<hr>
<p>狂神说Java：<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0</a></p>
<p>半路雨歌：<a href="https://juejin.cn/post/6844904097116585991#heading-1">https://juejin.cn/post/6844904097116585991#heading-1</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis三种集群模式之哨兵模式</title>
    <url>/2021/10/06/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p> 主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工 干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑 哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题 。</p>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独 立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例</strong> </p>
<p><img src="/img/work/1633534256141.png"></p>
<p> 这里的哨兵有两个作用:</p>
<ul>
<li> 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器 </li>
<li> 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服 务器，修改配置文件，让它们切换主机 </li>
</ul>
<p> 然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。 各个哨兵之间还会进行监控，这样就形成了多哨兵模式。 </p>
<p><img src="/img/work/1633534636100.png"> </p>
<h3 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2.工作原理"></a>2.工作原理</h3><ol>
<li>首先主节点的信息是配置在哨兵(Sentinel)的配置文件中</li>
<li>哨兵节点会和配置的主节点建立起两条连接<code>命令连接</code>和<code>订阅连接</code></li>
<li>哨兵会通过<code>命令连接</code>每10s发送一次<code>INFO</code>命令，通过<code>INFO命令</code>，主节点会返回自己的run_id和自己的<code>从节点信息</code></li>
<li>哨兵会对这些从节点也建立两条连接<code>命令连接</code>和<code>订阅连接</code></li>
<li>哨兵通过<code>命令连接</code>向从节点发送<code>INFO</code>命令，获取到他的一些信息<br>a. run_id<br>b. role<br>c. 从服务器的复制偏移量 offset等</li>
<li>因为哨兵对与集群中的其他节点(主从节点)当前都有两条连接，<code>命令连接</code>和<code>订阅连接</code><br> a. 通过<code>命令连接</code>向服务器的<code>_sentinel:hello</code>频道发送一条消息，内容包括自己的ip端口、run_id、配置纪元(后续投票的时候会用到)等<br> b. 通过<code>订阅连接</code>对服务器的<code>_sentinel:hello</code>频道做了监听，所以所有的向该频道发送的哨兵的消息都能被接受到<br> c. 解析监听到的消息，进行分析提取，就可以知道还有那些别的哨兵服务节点也在监听这些主从节点了，更新结构体将这些哨兵节点记录下来<br> d. 向观察到的其他的哨兵节点建立<code>命令连接</code>—-没有<code>订阅连接</code></li>
</ol>
<h3 id="3-哨兵模式下的故障迁移"><a href="#3-哨兵模式下的故障迁移" class="headerlink" title="3.哨兵模式下的故障迁移"></a>3.哨兵模式下的故障迁移</h3><h4 id="3-2主观下线"><a href="#3-2主观下线" class="headerlink" title="3.2主观下线"></a><strong>3.2主观下线</strong></h4><p>哨兵(Sentinel)节点会每秒一次的频率向建立了命令连接的实例发送PING命令，如果在<code>down-after-milliseconds</code>毫秒内没有做出有效响应包括(PONG/LOADING/MASTERDOWN)以外的响应，哨兵就会将该实例在本结构体中的状态标记为<code>SRI_S_DOWN</code>主观下线</p>
<h4 id="3-3客观下线"><a href="#3-3客观下线" class="headerlink" title="3.3客观下线"></a><strong>3.3客观下线</strong></h4><p>当一个哨兵节点发现主节点处于主观下线状态是，会向其他的哨兵节点发出询问，该节点是不是已经主观下线了。如果超过配置参数<code>quorum</code>个节点认为是主观下线时，该哨兵节点就会将自己维护的结构体中该主节点标记为<code>SRI_O_DOWN</code>客观下线<br> 询问命令<code>SENTINEL is-master-down-by-addr    </code></p>
<p><img src="/img/work/1633535070130.png"></p>
<h4 id="3-4-leader选举"><a href="#3-4-leader选举" class="headerlink" title="3.4 leader选举"></a>3.4 <strong>leader选举</strong></h4><p>在认为主节点<code>客观下线</code>的情况下,哨兵节点间会发起一次选举，命令还是上面的命令<code>SENTINEL is-master-down-by-addr    </code>,只是<code>run_id</code>这次会将<code>自己的run_id</code>带进去，希望接受者将自己设置为主节点。如果超过半数以上的节点返回将该节点标记为leader的情况下，会有该leader对故障进行迁移</p>
<h4 id="3-5故障迁移"><a href="#3-5故障迁移" class="headerlink" title="3.5故障迁移"></a><strong>3.5故障迁移</strong></h4><ol>
<li>在从节点中挑选出新的主节点<br> a. 通讯正常<br> b. 优先级排序<br> c. 优先级相同是选择offset最大的</li>
<li>将该节点设置成新的主节点 <code>SLAVEOF no one</code>,并确保在后续的INGO命令时，该节点返回状态为master</li>
<li>将其他的从节点设置成从新的主节点复制, <code>SLAVEOF命令</code> </li>
<li>将旧的主节点变成新的主节点的从节点</li>
</ol>
<h3 id="4-部署示例"><a href="#4-部署示例" class="headerlink" title="4.部署示例"></a>4.部署示例</h3><p> 哨兵模式基于前文的主从复制模式。当前示例为一主二从模式</p>
<p>4.1首先在reids解压后的文件中将sentinel.conf文件复制到redis.conf文件的目录下</p>
<p><img src="/img/work/1633536145531.png"></p>
<p>4.2在配置文件中进行如下配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> mymaster定义一个master数据库的名称，后面是master的ip， port，1表示至少需要一个Sentinel进程同意才能将master判断为失效，如果不满足这个条件，则自动故障转移（failover）不会执行</span><br>sentinel monitor mymaster 127.0.0.1 6379 1 <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> master的密码</span><br>sentinel auth-pass mymaster 123456 <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 5s未回复PING，则认为master主观下线，默认为30s</span><br>sentinel down-after-milliseconds mymaster 5000 <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 指定在执行故障转移时，最多可以有多少个slave实例在同步新的master实例，在slave实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长</span><br>sentinel parallel-syncs mymaster 2  <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 如果在该时间（ms）内未能完成故障转移操作，则认为故障转移失败，生产环境需要根据数据量设置该值</span><br>sentinel failover-timeout mymaster 300000 <br></code></pre></td></tr></table></figure>



<p> <strong>一个哨兵可以监控多个master数据库，只需按上述配置添加多套</strong> </p>
<p>4.3 分别以26379,36379,46379端口启动三个sentinel </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# redis-sentinel etc/sentinel1.conf <br>[root@centos7 bin]# redis-sentinel etc/sentinel2.conf <br>[root@centos7 bin]# redis-sentinel etc/sentinel3.conf <br></code></pre></td></tr></table></figure>



<p>4.4测试Master挂掉场景</p>
<p><img src="/img/work/1633537126366.png"></p>
<p> 执行 <code>kill -9 4965</code> 将master进程干掉，进入slave中执行 <code>info replication</code>查看 </p>
<p><strong>哨兵服务输出信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">12292:X 07 Oct 2021 18:56:28.858 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.<br>12292:X 07 Oct 2021 18:56:28.858 # Sentinel ID is 0d12a3731fac0690b3cf55d7a424b8a5c0bb2889<br>12292:X 07 Oct 2021 18:56:28.858 # +monitor master mymaster 127.0.0.1 6380 quorum 1<br>12292:X 07 Oct 2021 18:56:38.924 * +convert-to-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 18:59:29.468 * +fix-slave-config slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.021 # +sdown master mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.021 # +odown master mymaster 127.0.0.1 6380 #quorum 1/1<br>12292:X 07 Oct 2021 19:01:59.021 # +new-epoch 2<br>12292:X 07 Oct 2021 19:01:59.021 # +try-failover master mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.023 # +vote-for-leader 0d12a3731fac0690b3cf55d7a424b8a5c0bb2889 2<br>12292:X 07 Oct 2021 19:01:59.023 # +elected-leader master mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.023 # +failover-state-select-slave master mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.078 # +selected-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.078 * +failover-state-send-slaveof-noone slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.140 * +failover-state-wait-promotion slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:00.090 # +promoted-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:00.090 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:00.157 * +slave-reconf-sent slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:01.134 * +slave-reconf-inprog slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:01.134 * +slave-reconf-done slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:01.220 # +failover-end master mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:01.220 # +switch-master mymaster 127.0.0.1 6380 127.0.0.1 6379<br>12292:X 07 Oct 2021 19:02:01.221 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379<br>12292:X 07 Oct 2021 19:02:01.221 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379<br>12292:X 07 Oct 2021 19:02:06.230 # +sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379<br></code></pre></td></tr></table></figure>

<p>从以上信息，可以看出6380的master已经被移除，选举出了6379为master。</p>
<p><strong>如果当我们再次启动6380服务，已经变为从节点</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6380&gt; info replication<br><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:slave #从节点角色<br>master_host:127.0.0.1<br>master_port:6379<br></code></pre></td></tr></table></figure>



<h3 id="5-优缺点"><a href="#5-优缺点" class="headerlink" title="5.优缺点"></a>5.优缺点</h3><h4 id="5-1优点"><a href="#5-1优点" class="headerlink" title="5.1优点"></a>5.1优点</h4><ol>
<li> 哨兵集群，基于主从复制模式，所有的主从配置优点，它全有 </li>
<li> 主从可以切换，故障可以转移，系统的可用性就会更好 </li>
<li> 哨兵模式就是主从模式的升级，手动到自动，更加健壮！ </li>
</ol>
<h4 id="5-2缺点"><a href="#5-2缺点" class="headerlink" title="5.2缺点"></a>5.2缺点</h4><ol>
<li>同样也继承了主从模式难以在线扩容的缺点，Redis的容量受限于单机配置</li>
<li>需要额外的资源来启动sentinel进程，实现相对复杂一点，同时slave节点作为备份节点不提供服务</li>
</ol>
<h3 id="6-哨兵模式全部配置"><a href="#6-哨兵模式全部配置" class="headerlink" title="6.哨兵模式全部配置"></a>6.哨兵模式全部配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Example sentinel.conf</span><br><span class="hljs-meta">#</span><span class="bash"> 哨兵sentinel实例运行的端口 默认26379</span><br>port 26379<br><span class="hljs-meta">#</span><span class="bash"> 哨兵sentinel的工作目录</span><br>dir /tmp<br><span class="hljs-meta">#</span><span class="bash"> 哨兵sentinel监控的redis主节点的 ip port</span><br><span class="hljs-meta">#</span><span class="bash"> master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符<span class="hljs-string">&quot;.-_&quot;</span>组成。</span><br><span class="hljs-meta">#</span><span class="bash"> quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br>sentinel monitor mymaster 127.0.0.1 6379 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span><br><span class="hljs-meta">#</span><span class="bash"> 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br>sentinel auth-pass mymaster MySUPER--secret-0123passw0rd<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br>sentinel down-after-milliseconds mymaster 30000<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br>sentinel parallel-syncs mymaster 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span><br><span class="hljs-meta">#</span><span class="bash">1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span><br><span class="hljs-meta">#</span><span class="bash">2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span><br><span class="hljs-meta">#</span><span class="bash">3.当想要取消一个正在进行的failover所需要的时间。</span><br><span class="hljs-meta">#</span><span class="bash">4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><br><span class="hljs-meta">#</span><span class="bash"> 默认三分钟</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br>sentinel failover-timeout mymaster 180000<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> SCRIPTS EXECUTION</span><br><span class="hljs-meta">#</span><span class="bash">配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span><br><span class="hljs-meta">#</span><span class="bash">对于脚本的运行结果有以下规则：</span><br><span class="hljs-meta">#</span><span class="bash">若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><br><span class="hljs-meta">#</span><span class="bash">若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><br><span class="hljs-meta">#</span><span class="bash">如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><br><span class="hljs-meta">#</span><span class="bash">一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span><br><span class="hljs-meta">#</span><span class="bash">通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><br><span class="hljs-meta">#</span><span class="bash">通知脚本</span><br><span class="hljs-meta">#</span><span class="bash"> shell编程</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span><br>sentinel notification-script mymaster /var/redis/notify.sh<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 客户端重新配置主节点参数脚本</span><br><span class="hljs-meta">#</span><span class="bash"> 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><br><span class="hljs-meta">#</span><span class="bash"> 以下参数将会在调用脚本时传给脚本:</span><br><span class="hljs-meta">#</span><span class="bash"> &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><span class="hljs-meta">#</span><span class="bash"> 目前&lt;state&gt;总是“failover”,</span><br><span class="hljs-meta">#</span><span class="bash"> &lt;role&gt;是“leader”或者“observer”中的一个。</span><br><span class="hljs-meta">#</span><span class="bash"> 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span><br><span class="hljs-meta">#</span><span class="bash"> 这个脚本应该是通用的，能被多次调用，不是针对性的。</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span><br>sentinel client-reconfig-script mymaster /var/redis/reconfig.sh # 一般都是由运维来配置！<br></code></pre></td></tr></table></figure>



<p>参考：</p>
<hr>
<p>狂神说Java：<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0</a></p>
<p>半路雨歌：<a href="https://juejin.cn/post/6844904097116585991#heading-1">https://juejin.cn/post/6844904097116585991#heading-1</a></p>
<p><a href="https://www.jianshu.com/p/d6d2325a5ec7">https://www.jianshu.com/p/d6d2325a5ec7</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础</title>
    <url>/2021/09/25/redis%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Redis是什么？</p>
</blockquote>
<p> Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由<a href="https://baike.baidu.com/item/Pivotal">Pivotal</a>赞助。 </p>
<p> 免费和开源！是当下最热门的 NoSQL 技术之一！也被人们称之为结构化数据库！ </p>
 <span id="more"></span>

<blockquote>
<p>Redis作用于那些</p>
</blockquote>
<ol>
<li> 内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof） </li>
<li> 效率高，可以用于高速缓存 </li>
<li> 发布订阅系统 </li>
<li> 地图信息分析  </li>
<li> 计时器、计数器（浏览量！）  </li>
<li>…</li>
</ol>
<blockquote>
<p>主要特性</p>
</blockquote>
<ol>
<li> 多样的数据类型 </li>
</ol>
<p>   2、持久化</p>
<p>   3、集群 </p>
<p>   4、事务 </p>
<h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><blockquote>
<p>Linux安装</p>
</blockquote>
<p>Redis官网地址: <a href="https://redis.io/">https://redis.io/</a></p>
<p><img src="/img/work/1632572684797.png"></p>
<p>1.下载后,可获得一个tar压缩，我这里放到了 /opt目录下</p>
<p><img src="/img/work/1632573739375.png"></p>
<p>2.解压Redis安装包 解压命令: tar zxvf redis-6.2.5.tar.gz</p>
<p><img src="/img/work/1632574069385.png"></p>
<p>3.解压之后可以看到一个redis目录,进入Redis目录可以看到redis.conf的一个文件</p>
<p><img src="/img/work/1632574182949.png"></p>
<p>4.在redis下我们首先进行基本安装及编译安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">基础环境安装</span><br>yum install gcc-c++<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">编译</span><br>make<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">安装 redis安装之后默认安装在 /usr/<span class="hljs-built_in">local</span>/bin 下</span><br>make install<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">make PREFIX=/data/redis install  指定目录安装</span><br><br></code></pre></td></tr></table></figure>

<p><img src="/img/work/1632575400027.png"></p>
<p>5.在安装目录下复制redis.conf文件复制到安装目录下即：/usr/local/bin</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cp redis.conf /usr/local/bin/<br></code></pre></td></tr></table></figure>



<p>6.修改redis启动方式，因为redis默认启动方式不是后台启动，因此我们需要进入redis.conf中修改为yes</p>
<p><img src="/img/work/1632575702117.png"></p>
<p>7.启动redis服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">启动redis服务</span><br>redis-server etc/redis.conf   #在bin目录下创建了etc目录  redis启动需要将配置文件一同操作<br><br></code></pre></td></tr></table></figure>



<p>8.连接测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">连接客户端命令 -p 指定端口</span><br>redis-cli -p 6379<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">可以看到连接并ping通</span><br>127.0.0.1:6379&gt; ping<br>PONG<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">连接之后如何正常退出？</span><br>127.0.0.1:6379&gt; shutdown #先关闭，防止有数据被中断<br>not connected&gt; exit  #退出<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">此时通过查看进程是否存在</span><br>ps -ef | grep redis<br><br></code></pre></td></tr></table></figure>

<p>9.查看redis进程</p>
<p><img src="/img/work/1632576417517.png"></p>
<p>当客户端连接退出后，任务进程将会不存在</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="redis默认数据库"><a href="#redis默认数据库" class="headerlink" title="redis默认数据库"></a>redis默认数据库</h3><p>通过查看配置文件</p>
<p><strong>redis默认有16个数据库，默认使用第0个数据库</strong> </p>
<p><img src="/img/work/1632576644195.png"></p>
<p>我们可以对数据库进行选择</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">数据使用选择，redis默认界面，我们可以使用table键进行命令补全</span><br>127.0.0.1:6379&gt; SELECT 2<br>OK<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查看库大小</span><br>127.0.0.1:6379[2]&gt; DBSIZE<br>(integer) 0<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查看所有key</span><br>127.0.0.1:6379[2]&gt; KEYS *<br></code></pre></td></tr></table></figure>

<p><strong>清除当前数据库 flushdb</strong></p>
<p><strong>清除全部数据库的内容 FLUSHALL</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; KEYS * <br>1) &quot;name&quot;<br>127.0.0.1:6379&gt; FLUSHDB<br>OK<br>127.0.0.1:6379&gt; KEYS * <br>(empty array)<br>127.0.0.1:6379&gt; <br><br></code></pre></td></tr></table></figure>



<blockquote>
<p>Redis是单线程</p>
</blockquote>
<p> 大家应该知道Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据 机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了！所有就使用了单线程了！</p>
<p> Redis 是C 语言写的，官方提供的数据为 100000+ 的QPS，完全不比同样是使用 key-vale的 Memecache差！ </p>
<h3 id="Redis单线程为什么还这么快？"><a href="#Redis单线程为什么还这么快？" class="headerlink" title="Redis单线程为什么还这么快？"></a>Redis单线程为什么还这么快？</h3><p>了解计算机原理的应该知道   CPU &gt;  内存 &gt; 磁盘</p>
<p><strong>核心：redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程 （CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高 的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！</strong></p>
<h2 id="五大类型"><a href="#五大类型" class="headerlink" title="五大类型"></a>五大类型</h2><blockquote>
<p>官方文档说明</p>
</blockquote>
<p> Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="http://www.redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a href="http://www.redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a href="http://www.redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）。 </p>
<blockquote>
<p>下面命令需要我们记住，现在我们一般使用的spring boot，Jedis方法基本都是这些命令</p>
</blockquote>
<h3 id="Redis基本操作"><a href="#Redis基本操作" class="headerlink" title="Redis基本操作"></a>Redis基本操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查询所有key</span><br>127.0.0.1:6379&gt; KEYS * <br>(empty array)<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">set</span> key</span><br>127.0.0.1:6379&gt; SET name pudewu<br>OK<br><br><br>127.0.0.1:6379&gt; KEYS * <br>1) &quot;name&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">判断key值是不是存在</span><br>127.0.0.1:6379&gt; EXISTS name<br>(integer) 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 移除当前的key</span><br>127.0.0.1:6379&gt; MOVE name 1<br>(integer) 1<br><br><br>127.0.0.1:6379&gt; KEYS *<br>(empty array)<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取key</span><br>127.0.0.1:6379&gt; get name<br>&quot;pudewu&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 设置key的过期时间，单位是秒</span><br>127.0.0.1:6379&gt; EXPIRE name 20<br>(integer) 1<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 查看当前key的剩余时间</span><br>127.0.0.1:6379&gt; TTL name<br>(integer) 17<br>127.0.0.1:6379&gt; TTL name<br>(integer) 13<br>127.0.0.1:6379&gt; TTL name<br>(integer) 12<br>127.0.0.1:6379&gt; TTL name<br>(integer) 11<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查看key的类型</span><br>127.0.0.1:6379&gt; type name<br>string<br></code></pre></td></tr></table></figure>

<p><strong>如果对有些命令不会的可以在官网查看帮助命令</strong></p>
<h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>相信这个命令是我们经常使用到的</p>
<blockquote>
<p>添加Key，获取Key</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; SET k2 v2<br>OK<br>127.0.0.1:6379&gt; GET k2<br>&quot;v2&quot;<br>127.0.0.1:6379&gt; EXISTS k2<br>(integer) 1<br>127.0.0.1:6379&gt; APPEND k2 &quot;hello&quot;<br>(integer) 7<br>127.0.0.1:6379&gt; get k2<br>&quot;v2hello&quot;<br>127.0.0.1:6379&gt; STRLEN k2<br>(integer) 7<br>127.0.0.1:6379&gt; APPEND k2 &quot;redis学习&quot;<br>(integer) 18<br>127.0.0.1:6379&gt; STRLEN k2<br>(integer) 18<br>127.0.0.1:6379&gt; GET k2<br>&quot;v2helloredis\xe5\xad\xa6\xe4\xb9\xa0&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>String自增自减</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">设置默认值为0</span><br>127.0.0.1:6379&gt; set number 0<br>OK<br>127.0.0.1:6379&gt; get number<br>&quot;0&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">自增1</span><br>127.0.0.1:6379&gt; INCR number <br>(integer) 1<br>127.0.0.1:6379&gt; INCR number <br>(integer) 2<br>127.0.0.1:6379&gt; INCR number <br>(integer) 3<br>127.0.0.1:6379&gt; INCR number <br>(integer) 4<br>127.0.0.1:6379&gt; get number<br>&quot;4&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">自减1</span><br>127.0.0.1:6379&gt; DECR number <br>(integer) 3<br>127.0.0.1:6379&gt; DECR number <br>(integer) 2<br>127.0.0.1:6379&gt; DECR number <br>(integer) 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">自定义 增加值</span><br>127.0.0.1:6379&gt; INCRBY number 10<br>(integer) 11<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">自定义 减值</span><br>127.0.0.1:6379&gt; DECRBY number 5<br>(integer) 6<br></code></pre></td></tr></table></figure>



<blockquote>
<p>字符串范围</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 设置 key的值</span><br>127.0.0.1:6379&gt; set key &quot;hello redis&quot;<br>OK<br>127.0.0.1:6379&gt; get key1<br>(nil)<br>127.0.0.1:6379&gt; get key<br>&quot;hello redis&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 截取字符串 [0,3]</span><br>127.0.0.1:6379&gt; GETRANGE key 0 3<br>&quot;hell&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 获取全部的字符串 和 get key是一样的</span><br>127.0.0.1:6379&gt; GETRANGE key 0 -1<br>&quot;hello redis&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 替换！</span><br>127.0.0.1:6379&gt; set key2 &quot;redis fast&quot;<br>OK<br>127.0.0.1:6379&gt; get key2<br>&quot;redis fast&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 替换指定位置开始的字符串！</span><br>127.0.0.1:6379&gt; SETRANGE key2 1 realy<br>(integer) 10<br>127.0.0.1:6379&gt; get key2<br>&quot;rrealyfast&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p> 设置过期时间 </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> setex (<span class="hljs-built_in">set</span> with expire) <span class="hljs-comment"># 设置过期时间</span></span><br><span class="hljs-meta">#</span><span class="bash"> setnx (<span class="hljs-built_in">set</span> <span class="hljs-keyword">if</span> not exist) <span class="hljs-comment"># 不存在在设置 （在分布式锁中会常常使用！）</span></span><br>127.0.0.1:6379&gt; setex key3 30 &quot;hello&quot; # 设置key3 的值为 hello,30秒后过期<br>OK<br>127.0.0.1:6379&gt; ttl key3<br>(integer) 26<br>127.0.0.1:6379&gt; get key3<br>&quot;hello&quot;<br>127.0.0.1:6379&gt; setnx mykey &quot;redis&quot; # 如果mykey 不存在，创建mykey<br>(integer) 1<br>127.0.0.1:6379&gt; keys *<br>1) &quot;key2&quot;<br>2) &quot;mykey&quot;<br>3) &quot;key1&quot;<br>127.0.0.1:6379&gt; ttl key3<br>(integer) -2<br>127.0.0.1:6379&gt; setnx mykey &quot;MongoDB&quot; # 如果mykey存在，创建失败！<br>(integer) 0<br>127.0.0.1:6379&gt; get mykey<br>&quot;redis&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>mset mget</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 # 同时设置多个值<br>OK<br>127.0.0.1:6379&gt; keys *<br>1) &quot;k1&quot;<br>2) &quot;k2&quot;<br>3) &quot;k3&quot;<br>127.0.0.1:6379&gt; mget k1 k2 k3 # 同时获取多个值<br>1) &quot;v1&quot;<br>2) &quot;v2&quot;<br>3) &quot;v3&quot;<br>127.0.0.1:6379&gt; msetnx k1 v1 k4 v4 # msetnx 是一个原子性的操作，要么一起成功，要么一起<br>失败！<br>(integer) 0<br>127.0.0.1:6379&gt; get k4<br>(nil)<br><span class="hljs-meta">#</span><span class="bash"> 对象</span><br>set user:1 &#123;name:zhangsan,age:3&#125; # 设置一个user:1 对象 值为 json字符来保存一个对象！<br><span class="hljs-meta">#</span><span class="bash"> 这里的key是一个巧妙的设计： user:&#123;id&#125;:&#123;filed&#125; , 如此设计在Redis中是完全OK了！</span><br>127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2<br>OK<br>127.0.0.1:6379&gt; mget user:1:name user:1:age<br>1) &quot;zhangsan&quot;<br>2) &quot;2&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p><strong>getset</strong> </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; getset db redis # 如果不存在值，则返回 nil<br>(nil)<br>127.0.0.1:6379&gt; get db<br>&quot;redis<br>127.0.0.1:6379&gt; getset db mongodb # 如果存在值，获取原来的值，并设置新的值<br>&quot;redis&quot;<br>127.0.0.1:6379&gt; get db<br>&quot;mongodb&quot;<br></code></pre></td></tr></table></figure>



<h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h3><p> 在redis里面，我们可以把list玩成 ，栈、队列、阻塞队列！ 所有的list命令都是用l开头的，Redis不区分大小命令  </p>
<blockquote>
<p>lrange list 0 -1 查询list中所有 </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 将一个值或者多个值，插入到列表头部 （左）</span><br>127.0.0.1:6379&gt; lpush list one<br><br>127.0.0.1:6379&gt; lpush list two<br><br>127.0.0.1:6379&gt; lpush list three<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 0 -1 表示查询当前key下所有值</span><br>127.0.0.1:6379&gt; lrange list 0 -1<br><br>1) &quot;three&quot;<br>2) &quot;two&quot;<br>3) &quot;one&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p> RPush将一个值或多个值，插入到列表位部(右) </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; Rpush list righr<br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>1) &quot;three&quot;<br>2) &quot;two&quot;<br>3) &quot;one&quot;<br>4) &quot;righr&quot;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>Lpop左移除列表</strong>  <strong>Rpop右移除列表</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 移除第一个元素</span><br>127.0.0.1:6379&gt; Lpop list<br>&quot;three&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">移除最后一个元素</span><br>127.0.0.1:6379&gt; Rpop list<br>&quot;righr&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查询list中所有数据</span><br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>1) &quot;two&quot;<br>2) &quot;one&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<h3 id="Lindex"><a href="#Lindex" class="headerlink" title="Lindex"></a>Lindex</h3></blockquote>
<p>通过下表获得list中的某一个值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; lindex list 1<br>&quot;one&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p> Llen获取列表长度 </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; llen list<br>(integer) 4<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">指定移除列</span>   <br>127.0.0.1:6379&gt; lrem list 1 one<br></code></pre></td></tr></table></figure>





<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li>他实际上是一个链表，before Node after ， left，right 都可以插入值</li>
<li>如果key 不存在，创建新的链表</li>
<li>如果key存在，新增内容</li>
<li>如果移除了所有值，空链表，也代表不存在！</li>
<li>在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~</li>
</ul>
<p><strong>在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~</strong></p>
<h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h3><p> set中的值不能重复,无序 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># set集合中添加元素  SADD</span></span><br>127.0.0.1:6379&gt; sadd myset &quot;hello set&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查询<span class="hljs-built_in">set</span>中所有元素 SMEMBERS</span> <br>127.0.0.1:6379&gt; Smembers myset<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> SISMEMBER 查询<span class="hljs-built_in">set</span>中某个值是否存在</span><br>127.0.0.1:6379&gt; SISMEMBER myset hello<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取Set中集合元素个数</span><br>127.0.0.1:6379&gt; scard myset<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">rem 移除<span class="hljs-built_in">set</span>中元素</span><br>127.0.0.1:6379&gt; srem myset yes<br>(integer) 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> SRANDMEMBER 随机抽取<span class="hljs-built_in">set</span>集合中数据</span><br>127.0.0.1:6379&gt; SRANDMEMBER myset<br><br><br>==============================================================================<br>删除指定Set数据、随机删除Set数据<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">SMOVE  将一个指定的值，移动到另一个<span class="hljs-built_in">set</span>值中</span><br>127.0.0.1:6379&gt; smove myset myset2 &quot;dewu1&quot;    <br><br><br>==============================================================================<br>数字集合类：<br>- 差集 SDIFF<br>- 交集<br>- 并集<br><br>127.0.0.1:6379&gt; SDIFF key1 key2  # 差集<br><br>127.0.0.1:6379&gt; SINTER key1 key2 # 交集 共同好友就可以这样实现<br><br>127.0.0.1:6379&gt; SUNION key1 key2 # 并集<br></code></pre></td></tr></table></figure>





<h3 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash(哈希)"></a>Hash(哈希)</h3><p> <strong>Map集合，key-map! 时候这个值是一个map集合！ 本质和String类型没有太大区别，还是一个简单的 key-vlaue！</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 添加hash值  hset</span></span><br>127.0.0.1:6379&gt; hset myhash field kuangshen<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 获取<span class="hljs-built_in">hash</span>值  hget</span><br>127.0.0.1:6379&gt; hget myhash field<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">set</span>多个 key-vlaue</span><br>127.0.0.1:6379&gt; hmset myhash field1 hello field2 world<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取多个<span class="hljs-built_in">hash</span>值</span><br>127.0.0.1:6379&gt; hmget myhash field1 field2<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取所有<span class="hljs-built_in">hash</span>中的值</span><br>127.0.0.1:6379&gt;  hgetall myhash<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">删除<span class="hljs-built_in">hash</span>操作  hdel</span><br>127.0.0.1:6379&gt; hdel myhash field1<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 只获得所有field</span><br><span class="hljs-meta">#</span><span class="bash"> 只获得所有value</span><br>127.0.0.1:6379&gt; hkeys myhash # 只获得所有field<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">只获得所有value</span><br>127.0.0.1:6379&gt; hvals myhash<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">incr decr</span><br>127.0.0.1:6379&gt; hset myhash field3 5 #指定增量！<br>127.0.0.1:6379&gt; HINCRby myhash field3 1<br>127.0.0.1:6379&gt; hincrby myhash field3 -1<br><br>127.0.0.1:6379&gt; hsetnx myhash field4 hello # 如果不存在则可以设置<br>127.0.0.1:6379&gt; hsetnx myhash field4 world # 如果存在则不能设置<br></code></pre></td></tr></table></figure>



<p> <strong>hash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！ hash 更适合于对象的 存储，String更加适合字符串存储！</strong> </p>
<h3 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset(有序集合)"></a>Zset(有序集合)</h3><p> <strong>在set基础上增加了一个值，set k1 v1   zset k1 score1  v1</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">添加有序集合</span><br>127.0.0.1:6379&gt; zadd dewu 1 redis<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">多个添加</span><br>127.0.0.1:6379&gt; zadd dewu 2 two 3 three<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查询集合元素</span><br>127.0.0.1:6379&gt; zrange dewu 0 -1<br><br><br>=====================================================<br>排序如何实现<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">添加三个用户</span><br>127.0.0.1:6379&gt; zadd salary 2500 xiaoming <br>(integer) 1<br>127.0.0.1:6379&gt; zadd salary 3000 xiaohong <br>(integer) 1<br>127.0.0.1:6379&gt; zadd salary 3500 zhangsan<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> ZRANGEBYSCORE key min max</span><br>127.0.0.1:6379&gt;  ZRANGEBYSCORE salary -inf +inf<br>1) &quot;xiaoming&quot;<br>2) &quot;xiaohong&quot;<br>3) &quot;zhangsan&quot;  # 显示全部的用户 从小到大！<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">从大到小排序</span><br>127.0.0.1:6379&gt; zrevrange salary 0 -1<br>1) &quot;zhangsan&quot;<br>2) &quot;xiaohong&quot;<br>3) &quot;xiaoming&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">显示全部用户并且附带成绩</span><br>127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores<br>1) &quot;xiaoming&quot;<br>2) &quot;2500&quot;<br>3) &quot;xiaohong&quot;<br>4) &quot;3000&quot;<br>5) &quot;zhangsan&quot;<br>6) &quot;3500&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">显示工资小于2500的员工升序排序</span><br>127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 withscores<br>1) &quot;xiaoming&quot;<br>2) &quot;2500&quot;<br><br><br>=================================================================<br><span class="hljs-meta">#</span><span class="bash"> 移除rem中的元素</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">移除集合中指定元素</span><br>127.0.0.1:6379&gt; zrem salary xiaoming<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取有序集合中的个数</span><br>127.0.0.1:6379&gt; zcard salary<br><br>==================================================================<br><br>127.0.0.1:6379&gt; zadd xiaolong 1 hello<br>127.0.0.1:6379&gt; zadd xiaolong 2 world 3 kuangsheng<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取指定区间的成员数量！</span><br>127.0.0.1:6379&gt; zcount xiaolong 1 3<br> <br></code></pre></td></tr></table></figure>



<p>参考：<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=8440565446323209776&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=8440565446323209776&amp;spm_id_from=333.337.0.0</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-容器之List</title>
    <url>/2021/11/24/Java-%E5%AE%B9%E5%99%A8%E4%B9%8BList/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-List-简介"><a href="#1-List-简介" class="headerlink" title="1. List 简介"></a>1. List 简介</h2><p><img src="/img/work/image-20211124142643473.png" alt="ArrayList关系图"></p>
<p><code>List</code> 是一个接口，它继承于 <code>Collection</code> 的接口。它代表着有序的队列。</p>
<p><code>AbstractList</code> 是一个抽象类，它继承于 <code>AbstractCollection</code>。<code>AbstractList</code> 实现了 <code>List</code> 接口中除 <code>size()</code>、<code>get(int location)</code> 之外的函数。</p>
<p><code>AbstractSequentialList</code> 是一个抽象类，它继承于 <code>AbstractList</code>。<code>AbstractSequentialList</code> 实现了“链表中，根据 index 索引值操作链表的全部函数”。</p>
<h3 id="1-1-ArrayList-和-LinkedList"><a href="#1-1-ArrayList-和-LinkedList" class="headerlink" title="1.1. ArrayList 和 LinkedList"></a>1.1. ArrayList 和 LinkedList</h3><p><strong><code>ArrayList</code>、<code>LinkedList</code> 是 <code>List</code> 最常用的实现。</strong></p>
<ul>
<li><code>ArrayList</code> 基于动态数组实现，存在容量限制，当元素数超过最大容量时，会自动扩容；<code>LinkedList</code> 基于双向链表实现，不存在容量限制。</li>
<li><code>ArrayList</code> 随机访问速度较快，随机插入、删除速度较慢；<code>LinkedList</code> 随机插入、删除速度较快，随机访问速度较慢。</li>
<li><code>ArrayList</code> 和 <code>LinkedList</code> 都不是线程安全的。</li>
</ul>
<h3 id="1-2-Vector-和-Stack"><a href="#1-2-Vector-和-Stack" class="headerlink" title="1.2. Vector 和 Stack"></a>1.2. Vector 和 Stack</h3><p><img src="/img/work/image-20211124143305652.png" alt="Stack关系图"></p>
<p><code>Vector</code> 和 <code>Stack</code> 的设计目标是作为线程安全的 <code>List</code> 实现，替代 <code>ArrayList</code>。</p>
<ul>
<li><code>Vector</code> - <code>Vector</code> 和 <code>ArrayList</code> 类似，也实现了 <code>List</code> 接口。但是， <code>Vector</code> 中的主要方法都是 <code>synchronized</code> 方法，即通过互斥同步方式保证操作的线程安全。</li>
<li><code>Stack</code> - <code>Stack</code> 也是一个同步容器，它的方法也用 <code>synchronized</code> 进行了同步，它实际上是继承于 <code>Vector</code> 类。</li>
</ul>
<h2 id="2-ArrayList"><a href="#2-ArrayList" class="headerlink" title="2. ArrayList"></a>2. ArrayList</h2><blockquote>
<p>ArrayList 从数据结构角度来看，可以视为支持动态扩容的线性表。ArrayList可以存放空元素 arrayList.add(null);且可以存放多个空值，底层是用数组实现的，线程不安全，效率高。</p>
</blockquote>
<h3 id="2-1-ArrayList-要点"><a href="#2-1-ArrayList-要点" class="headerlink" title="2.1. ArrayList 要点"></a>2.1. ArrayList 要点</h3><p><code>ArrayList</code> 是一个数组队列，相当于<strong>动态数组</strong>。**<code>ArrayList</code> 默认初始容量大小为 <code>10</code> ，添加元素时，如果发现容量已满，会自动扩容为原始大小的 1.5 倍**。因此，应该尽量在初始化 <code>ArrayList</code> 时，为其指定合适的初始化容量大小，减少扩容操作产生的性能开销。</p>
<p><code>ArrayList</code> 定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>从 ArrayList 的定义，不难看出 ArrayList 的一些基本特性：</p>
<ul>
<li><code>ArrayList</code> 实现了 <code>List</code> 接口，并继承了 <code>AbstractList</code>，它支持所有 <code>List</code> 的操作。</li>
<li><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，<strong>支持随机访问</strong>。<code>RandomAccess</code> 是一个标志接口，它意味着“只要实现该接口的 <code>List</code> 类，都支持快速随机访问”。在 <code>ArrayList</code> 中，我们即可以<strong>通过元素的序号快速获取元素对象</strong>；这就是快速随机访问。</li>
<li><code>ArrayList</code> 实现了 <code>Cloneable</code> 接口，默认为<strong>浅拷贝</strong>。</li>
<li><code>ArrayList</code> 实现了 <code>Serializable</code> 接口，<strong>支持序列化</strong>，能通过序列化方式传输。</li>
<li><code>ArrayList</code> 是<strong>非线程安全</strong>的。</li>
</ul>
<h3 id="2-2-ArrayList-原理"><a href="#2-2-ArrayList-原理" class="headerlink" title="2.2. ArrayList 原理"></a>2.2. ArrayList 原理</h3><p><strong>ArrayList 的数据结构</strong></p>
<p>ArrayList 包含了两个重要的元素：<code>elementData</code> 和 <code>size</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认初始化容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 对象数组</span><br><span class="hljs-keyword">transient</span> Object[] elementData;<br><span class="hljs-comment">// 数组长度</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>size</code> - 是动态数组的实际大小。</li>
<li><code>elementData</code> - 是一个 <code>Object</code> 数组，用于保存添加到 <code>ArrayList</code> 中的元素。</li>
</ul>
<p> <strong>ArrayList 的序列化</strong></p>
<p><code>ArrayList</code> 具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。为此，<code>ArrayList</code> 定制了其序列化方式。具体做法是：</p>
<ul>
<li>存储元素的 <code>Object</code> 数组（即 <code>elementData</code>）使用 <code>transient</code> 修饰，使得它可以被 Java 序列化所忽略。</li>
<li><code>ArrayList</code> 重写了 <code>writeObject()</code> 和 <code>readObject()</code> 来控制序列化数组中有元素填充那部分内容。</li>
</ul>
<p><strong>ArrayList 构造方法</strong></p>
<p>ArrayList 类实现了三个构造函数：</p>
<ul>
<li>第一个是默认构造方法，ArrayList 会创建一个空数组；</li>
<li>第二个是创建 ArrayList 对象时，传入一个初始化值；</li>
<li>第三个是传入一个集合类型进行初始化。</li>
</ul>
<p>当 ArrayList 新增元素时，如果所存储的元素已经超过其当前容量，它会计算容量后再进行动态扩容。数组的动态扩容会导致整个数组进行一次内存复制。因此，<strong>初始化 ArrayList 时，指定数组初始大小，有助于减少数组的扩容次数，从而提高系统性能</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个空数组</span><br>	<span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 根据初始化值创建数组大小</span><br>		<span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 初始化值为 0 时，创建一个空数组</span><br>		<span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>										   initialCapacity);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>ArrayList 访问元素</strong></p>
<p><code>ArrayList</code> 访问元素的实现主要基于以下关键性源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取第 index 个元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    rangeCheck(index);<br>    <span class="hljs-keyword">return</span> elementData(index);<br>&#125;<br><br><span class="hljs-function">E <span class="hljs-title">elementData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (E) elementData[index];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现非常简单，其实就是**通过数组下标访问数组元素，其时间复杂度为 O(1)**，所以很快。</p>
<p><strong>ArrayList 添加元素</strong></p>
<p><code>ArrayList</code> 添加元素有两种方法：一种是添加元素到数组末尾，另外一种是添加元素到任意位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加元素到数组末尾</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 添加元素到任意位置</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>	rangeCheckForAdd(index);<br><br>	ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>	System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,<br>					 size - index);<br>	elementData[index] = element;<br>	size++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>两种添加元素方法的<strong>不同点</strong>是：</p>
<ul>
<li>添加元素到任意位置，会导致在<strong>该位置后的所有元素都需要重新排列</strong>；</li>
<li>而添加元素到数组末尾，在没有发生扩容的前提下，是不会有元素复制排序过程的。</li>
</ul>
<p>两种添加元素方法的<strong>共同点</strong>是：添加元素时，会先检查容量大小，<strong>如果发现容量不足，会自动扩容为原始大小的 1.5 倍</strong>。</p>
<p><code>ArrayList</code> 添加元素的实现主要基于以下关键性源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br><br>    ensureExplicitCapacity(minCapacity);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    modCount++;<br><br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;<br>    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>ArrayList</code> 执行添加元素动作（<code>add</code> 方法）时，调用 <code>ensureCapacityInternal</code> 方法来保证容量足够。</p>
<ul>
<li>如果容量足够时，将数据作为数组中 <code>size+1</code> 位置上的元素写入，并将 <code>size</code> 自增 1。</li>
<li>如果容量不够时，需要使用 <code>grow</code> 方法进行扩容数组，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。扩容操作实际上是<strong>调用 <code>Arrays.copyOf()</code> 把原数组拷贝为一个新数组</strong>，因此最好在创建 <code>ArrayList</code> 对象时就指定大概的容量大小，减少扩容操作的次数。</li>
</ul>
<p><strong>ArrayList 删除元素</strong></p>
<p><code>ArrayList</code> 的删除方法和添加元素到任意位置方法有些相似。</p>
<p><code>ArrayList</code> 在每一次有效的删除操作后，都要进行数组的重组，并且删除的元素位置越靠前，数组重组的开销就越大。具体来说，<code>ArrayList</code> 会调用 <code>System.arraycopy()</code> 将 <code>index+1</code> 后面的元素都复制到 <code>index</code> 位置上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    rangeCheck(index);<br><br>    modCount++;<br>    E oldValue = elementData(index);<br><br>    <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index, numMoved);<br>    elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br><br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>ArrayList 的 Fail-Fast</strong></p>
<p><code>ArrayList</code> 使用 <code>modCount</code> 来记录结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 <code>modCount</code> 是否改变，如果发生改变，<code>ArrayList</code> 会抛出 <code>ConcurrentModificationException</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> java.io.IOException</span>&#123;<br>    <span class="hljs-comment">// Write out element count, and any hidden stuff</span><br>    <span class="hljs-keyword">int</span> expectedModCount = modCount;<br>    s.defaultWriteObject();<br><br>    <span class="hljs-comment">// Write out size as capacity for behavioural compatibility with clone()</span><br>    s.writeInt(size);<br><br>    <span class="hljs-comment">// Write out all elements in the proper order.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++) &#123;<br>        s.writeObject(elementData[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-3-vector底层结构和源码剖析"><a href="#2-3-vector底层结构和源码剖析" class="headerlink" title="2.3 vector底层结构和源码剖析"></a>2.3 vector底层结构和源码剖析</h3><p><img src="/%5Cimg%5Cwork%5CSnipaste_2021-11-24_21-56-07.png" alt="Vector与ArrayList对比图"></p>
<p> 可以看到，如果是无参构造，那么默认初始容量是10 </p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vector_</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//无参构造器</span><br>        <span class="hljs-comment">//有参数的构造</span><br>        Vector vector = <span class="hljs-keyword">new</span> Vector(<span class="hljs-number">8</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            vector.add(i);<br>        &#125;<br>        vector.add(<span class="hljs-number">100</span>);<br>        System.out.println(<span class="hljs-string">&quot;vector=&quot;</span> + vector);<br>      <br>        <span class="hljs-comment">//1. new Vector() 底层</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            public Vector() &#123;</span><br><span class="hljs-comment">                this(10);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">         补充：如果是  Vector vector = new Vector(8);</span><br><span class="hljs-comment">            走的方法:</span><br><span class="hljs-comment">            public Vector(int initialCapacity) &#123;</span><br><span class="hljs-comment">                this(initialCapacity, 0);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">         2. vector.add(i)</span><br><span class="hljs-comment">         2.1  //下面这个方法就添加数据到vector集合</span><br><span class="hljs-comment">            public synchronized boolean add(E e) &#123;</span><br><span class="hljs-comment">                modCount++;</span><br><span class="hljs-comment">                ensureCapacityHelper(elementCount + 1);</span><br><span class="hljs-comment">                elementData[elementCount++] = e;</span><br><span class="hljs-comment">                return true;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">          2.2  //确定是否需要扩容 条件 ： minCapacity - elementData.length&gt;0</span><br><span class="hljs-comment">            private void ensureCapacityHelper(int minCapacity) &#123;</span><br><span class="hljs-comment">                // overflow-conscious code</span><br><span class="hljs-comment">                if (minCapacity - elementData.length &gt; 0)</span><br><span class="hljs-comment">                    grow(minCapacity);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">          2.3 //如果 需要的数组大小 不够用，就扩容 , 扩容的算法</span><br><span class="hljs-comment">              //newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="hljs-comment">              //                             capacityIncrement : oldCapacity);</span><br><span class="hljs-comment">              //就是扩容两倍.</span><br><span class="hljs-comment">            private void grow(int minCapacity) &#123;</span><br><span class="hljs-comment">                // overflow-conscious code</span><br><span class="hljs-comment">                int oldCapacity = elementData.length;</span><br><span class="hljs-comment">                int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="hljs-comment">                                                 capacityIncrement : oldCapacity);</span><br><span class="hljs-comment">                if (newCapacity - minCapacity &lt; 0)</span><br><span class="hljs-comment">                    newCapacity = minCapacity;</span><br><span class="hljs-comment">                if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="hljs-comment">                    newCapacity = hugeCapacity(minCapacity);</span><br><span class="hljs-comment">                elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">         */</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>







<h2 id="3-LinkedList"><a href="#3-LinkedList" class="headerlink" title="3. LinkedList"></a>3. LinkedList</h2><blockquote>
<p>LinkedList 从数据结构角度来看，可以视为双链表。</p>
</blockquote>
<h3 id="3-1-LinkedList-要点"><a href="#3-1-LinkedList-要点" class="headerlink" title="3.1. LinkedList 要点"></a>3.1. LinkedList 要点</h3><p><code>LinkedList</code> 基于双链表结构实现。由于是双链表，所以<strong>顺序访问会非常高效，而随机访问效率比较低。</strong></p>
<p><code>LinkedList</code> 定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt; </span><br><span class="hljs-class">                           <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>从 <code>LinkedList</code> 的定义，可以得出 <code>LinkedList</code> 的一些基本特性：</p>
<ul>
<li><code>LinkedList</code> 实现了 <code>List</code> 接口，并继承了 <code>AbstractSequentialList</code> ，它支持所有 <code>List</code> 的操作。</li>
<li><code>LinkedList</code> 实现了 <code>Deque</code> 接口，也可以被当作队列（<code>Queue</code>）或双端队列（<code>Deque</code>）进行操作，此外，也可以用来实现栈。</li>
<li><code>LinkedList</code> 实现了 <code>Cloneable</code> 接口，默认为<strong>浅拷贝</strong>。</li>
<li><code>LinkedList</code> 实现了 <code>Serializable</code> 接口，<strong>支持序列化</strong>。</li>
<li><code>LinkedList</code> 是<strong>非线程安全</strong>的。</li>
</ul>
<h3 id="3-2-LinkedList-原理"><a href="#3-2-LinkedList-原理" class="headerlink" title="3.2. LinkedList 原理"></a>3.2. LinkedList 原理</h3><h4 id="LinkedList-的数据结构"><a href="#LinkedList-的数据结构" class="headerlink" title="LinkedList 的数据结构"></a>LinkedList 的数据结构</h4><p><strong><code>LinkedList</code> 内部维护了一个双链表</strong></p>
<p><code>LinkedList</code> 通过 <code>Node</code> 类型的头尾指针（<code>first</code> 和 <code>last</code>）来访问数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 链表长度</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 链表头节点</span><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br><span class="hljs-comment">// 链表尾节点</span><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>size</code> - <strong>表示双链表中节点的个数，初始为 0</strong>。</li>
<li><code>first</code> 和 <code>last</code> - <strong>分别是双链表的头节点和尾节点</strong>。</li>
</ul>
<p> <code>Node</code> 是 <code>LinkedList</code> 的内部类，它表示链表中的元素实例。Node 中包含三个元素： </p>
<ul>
<li><code>prev</code> 是该节点的上一个节点；</li>
<li><code>next</code> 是该节点的下一个节点；</li>
<li><code>item</code> 是该节点所包含的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>        E item;<br>        Node&lt;E&gt; next;<br>        Node&lt;E&gt; prev;<br><br>        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>            <span class="hljs-keyword">this</span>.item = element;<br>            <span class="hljs-keyword">this</span>.next = next;<br>            <span class="hljs-keyword">this</span>.prev = prev;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h4 id="LinkedList-的序列化"><a href="#LinkedList-的序列化" class="headerlink" title="LinkedList 的序列化"></a>LinkedList 的序列化</h4><p> <code>LinkedList</code> 与 <code>ArrayList</code> 一样也定制了自身的序列化方式。具体做法是： </p>
<ul>
<li>将 <code>size</code> （双链表容量大小）、<code>first</code> 和<code>last</code> （双链表的头尾节点）修饰为 <code>transient</code>，使得它们可以被 Java 序列化所忽略。</li>
<li>重写了 <code>writeObject()</code> 和 <code>readObject()</code> 来控制序列化时，只处理双链表中能被头节点链式引用的节点元素。</li>
</ul>
<h4 id="LinkedList-访问元素"><a href="#LinkedList-访问元素" class="headerlink" title="LinkedList 访问元素"></a>LinkedList 访问元素</h4><p> <code>LinkedList</code> 访问元素的实现主要基于以下关键性源码： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>	checkElementIndex(index);<br>	<span class="hljs-keyword">return</span> node(index).item;<br>&#125;<br><br><span class="hljs-function">Node&lt;E&gt; <span class="hljs-title">node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">// assert isElementIndex(index);</span><br><br>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>            x = x.next;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 获取 <code>LinkedList</code> 第 index 个元素的算法是： </p>
<ul>
<li>判断 index 在链表前半部分，还是后半部分。</li>
<li>如果是前半部分，从头节点开始查找；如果是后半部分，从尾结点开始查找。</li>
</ul>
<p> <code>LinkedList</code> 这种访问元素的性能是 <code>O(N)</code> 级别的（极端情况下，扫描 N/2 个元素）；相比于 <code>ArrayList</code> 的 <code>O(1)</code>，显然要慢不少。</p>
<p> <strong>推荐使用迭代器遍历 <code>LinkedList</code> ，不要使用传统的 <code>for</code> 循环</strong>。注：foreach 语法会被编译器转换成迭代器遍历，但是它的遍历过程中不允许修改 <code>List</code> 长度，即不能进行增删操作。  </p>
<h4 id="LinkedList-添加元素"><a href="#LinkedList-添加元素" class="headerlink" title="LinkedList 添加元素"></a>LinkedList 添加元素</h4><p> <code>LinkedList</code> 有多种添加元素方法： </p>
<ul>
<li><code>add(E e)</code>：默认添加元素方法（插入尾部）</li>
<li><code>add(int index, E element)</code>：添加元素到任意位置</li>
<li><code>addFirst(E e)</code>：在头部添加元素</li>
<li><code>addLast(E e)</code>：在尾部添加元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>	linkLast(e);<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>	checkPositionIndex(index);<br><br>	<span class="hljs-keyword">if</span> (index == size)<br>		linkLast(element);<br>	<span class="hljs-keyword">else</span><br>		linkBefore(element, node(index));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(E e)</span> </span>&#123;<br>	linkFirst(e);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>	linkLast(e);<br>&#125;<br></code></pre></td></tr></table></figure>

<p> <code>LinkedList</code> 添加元素的实现主要基于以下关键性源码： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">linkFirst</span><span class="hljs-params">(E e)</span> </span>&#123;<br>	<span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>	<span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(<span class="hljs-keyword">null</span>, e, f);<br>	first = newNode;<br>	<span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)<br>		last = newNode;<br>	<span class="hljs-keyword">else</span><br>		f.prev = newNode;<br>	size++;<br>	modCount++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;<br>	<span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>	<span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(l, e, <span class="hljs-keyword">null</span>);<br>	last = newNode;<br>	<span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)<br>		first = newNode;<br>	<span class="hljs-keyword">else</span><br>		l.next = newNode;<br>	size++;<br>	modCount++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkBefore</span><span class="hljs-params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;<br>	<span class="hljs-comment">// assert succ != null;</span><br>	<span class="hljs-keyword">final</span> Node&lt;E&gt; pred = succ.prev;<br>	<span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(pred, e, succ);<br>	succ.prev = newNode;<br>	<span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)<br>		first = newNode;<br>	<span class="hljs-keyword">else</span><br>		pred.next = newNode;<br>	size++;<br>	modCount++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 算法如下： </p>
<ul>
<li>将新添加的数据包装为 <code>Node</code>；</li>
<li>如果往头部添加元素，将头指针 <code>first</code> 指向新的 <code>Node</code>，之前的 <code>first</code> 对象的 <code>prev</code> 指向新的 <code>Node</code>。</li>
<li>如果是向尾部添加元素，则将尾指针 <code>last</code> 指向新的 <code>Node</code>，之前的 <code>last</code> 对象的 <code>next</code> 指向新的 <code>Node</code>。</li>
</ul>
<h4 id="LinkedList-删除元素"><a href="#LinkedList-删除元素" class="headerlink" title="LinkedList 删除元素"></a>LinkedList 删除元素</h4><p> <code>LinkedList</code> 删除元素的实现主要基于以下关键性源码： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 遍历找到要删除的元素节点</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 遍历找到要删除的元素节点</span><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><br><span class="hljs-function">E <span class="hljs-title">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> </span>&#123;<br>    <span class="hljs-comment">// assert x != null;</span><br>    <span class="hljs-keyword">final</span> E element = x.item;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;<br><br>    <span class="hljs-keyword">if</span> (prev == <span class="hljs-keyword">null</span>) &#123;<br>        first = next;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        prev.next = next;<br>        x.prev = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>) &#123;<br>        last = prev;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        next.prev = prev;<br>        x.next = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    x.item = <span class="hljs-keyword">null</span>;<br>    size--;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 算法说明： </p>
<ul>
<li>遍历找到要删除的元素节点，然后调用 <code>unlink</code> 方法删除节点；</li>
<li> <code>unlink</code> 删除节点的方法： </li>
<li>如果当前节点有前驱节点，则让前驱节点指向当前节点的下一个节点；否则，让双链表头指针指向下一个节点。</li>
<li>如果当前节点有后继节点，则让后继节点指向当前节点的前一个节点；否则，让双链表尾指针指向上一个节点。</li>
</ul>
<h2 id="4-List-常见问题"><a href="#4-List-常见问题" class="headerlink" title="4. List 常见问题"></a>4. List 常见问题</h2><h3 id="4-1-Arrays-asList-问题点"><a href="#4-1-Arrays-asList-问题点" class="headerlink" title="4.1. Arrays.asList 问题点"></a>4.1. Arrays.asList 问题点</h3><p> 在业务开发中，我们常常会把原始的数组转换为 <code>List</code> 类数据结构，来继续展开各种 <code>Stream</code> 操作。通常，我们会使用 <code>Arrays.asList</code> 方法可以把数组一键转换为 <code>List</code>。 </p>
<p> 【示例】Arrays.asList 转换基本类型数组 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>List list = Arrays.asList(arr);<br>log.info(<span class="hljs-string">&quot;list:&#123;&#125; size:&#123;&#125; class:&#123;&#125;&quot;</span>, list, list.size(), list.get(<span class="hljs-number">0</span>).getClass());<br></code></pre></td></tr></table></figure>

<p> 【输出】 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">list:[[I@ae45eb6] size:1 class:class [I<br></code></pre></td></tr></table></figure>

<p> 数组元素个数为 3，但转换后的列表个数为 1。 </p>
<p> 由此可知， <code>Arrays.asList</code> 第一个问题点：<strong>不能直接使用 <code>Arrays.asList</code> 来转换基本类型数组</strong>。 </p>
<p> 其原因是：<code>Arrays.asList</code> 方法传入的是一个泛型 T 类型可变参数，最终 <code>int</code> 数组整体作为了一个对象成为了泛型类型 T： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">asList</span><span class="hljs-params">(T... a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(a);<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 直接遍历这样的 <code>List</code> 必然会出现 Bug，修复方式有两种，如果使用 Java8 以上版本可以使用 <code>Arrays.stream</code> 方法来转换，否则可以把 <code>int</code> 数组声明为包装类型 <code>Integer</code> 数组： </p>
<p> 【示例】转换整型数组为 List 的正确方式 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr1 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>List list1 = Arrays.stream(arr1).boxed().collect(Collectors.toList());<br><br>Integer[] arr2 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>List list2 = Arrays.asList(arr2);<br></code></pre></td></tr></table></figure>

<p> 【示例】Arrays.asList 转换引用类型数组 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String[] arr = &#123; <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span> &#125;;<br>List list = Arrays.asList(arr);<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;4&quot;</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    list.add(<span class="hljs-string">&quot;5&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>    ex.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 抛出 <code>java.lang.UnsupportedOperationException</code>。 </p>
<p> 抛出异常的原因在于 <code>Arrays.asList</code> 第二个问题点：**<code>Arrays.asList</code> 返回的 <code>List</code> 不支持增删操作**。 </p>
<p> <code>Arrays.asList</code> 返回的 List 并不是我们期望的 <code>java.util.ArrayList</code>，而是 <code>Arrays</code> 的内部类 <code>ArrayList</code>。 </p>
<p> 查看源码，我们可以发现 <code>Arrays.asList</code> 返回的 <code>ArrayList</code> 继承了 <code>AbstractList</code>，但是并没有覆写 <code>add</code> 和 <code>remove</code> 方法。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">2764017481108945198L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E[] a;<br><br>    ArrayList(E[] array) &#123;<br>        a = Objects.requireNonNull(array);<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>        E oldValue = a[index];<br>        a[index] = element;<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCollection</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> <code>Arrays.asList</code> 第三个问题点：**对原始数组的修改会影响到我们获得的那个 <code>List</code>**。<code>ArrayList</code> 其实是直接使用了原始的数组。 </p>
<p> 解决方法很简单，重新 <code>new</code> 一个 <code>ArrayList</code> 初始化 <code>Arrays.asList</code> 返回的 <code>List</code> 即可： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String[] arr = &#123; <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span> &#125;;<br>List list = <span class="hljs-keyword">new</span> ArrayList(Arrays.asList(arr));<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;4&quot;</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    list.add(<span class="hljs-string">&quot;5&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>    ex.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-2-List-subList-问题点"><a href="#4-2-List-subList-问题点" class="headerlink" title="4.2. List.subList 问题点"></a>4.2. List.subList 问题点</h3><p> List.subList 直接引用了原始的 List，也可以认为是共享“存储”，而且对原始 List 直接进行结构性修改会导致 SubList 出现异常。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">oom</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        List&lt;Integer&gt; rawList = IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">100000</span>).boxed().collect(Collectors.toList());<br>        data.add(rawList.subList(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 出现 OOM 的原因是，循环中的 1000 个具有 10 万个元素的 List 始终得不到回收，因为它始终被 subList 方法返回的 List 强引用。 </p>
<p> 解决方法是： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">oomfix</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        List&lt;Integer&gt; rawList = IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">100000</span>).boxed().collect(Collectors.toList());<br>        data.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(rawList.subList(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 【示例】子 List 强引用原始的 List </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wrong</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Integer&gt; list = IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>).boxed().collect(Collectors.toList());<br>    List&lt;Integer&gt; subList = list.subList(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);<br>    System.out.println(subList);<br>    subList.remove(<span class="hljs-number">1</span>);<br>    System.out.println(list);<br>    list.add(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        subList.forEach(System.out::println);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        ex.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 抛出 <code>java.util.ConcurrentModificationException</code>。 </p>
<p> 解决方法： </p>
<p> 一种是，不直接使用 subList 方法返回的 SubList，而是重新使用 new ArrayList，在构造方法传入 SubList，来构建一个独立的 ArrayList； </p>
<p>另一种是，对于 Java 8 使用 Stream 的 skip 和 limit API 来跳过流中的元素，以及限制流中元素的个数，同样可以达到 SubList 切片的目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方式一：</span><br>List&lt;Integer&gt; subList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(list.subList(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>));<br><span class="hljs-comment">//方式二：</span><br>List&lt;Integer&gt; subList = list.stream().skip(<span class="hljs-number">1</span>).limit(<span class="hljs-number">3</span>).collect(Collectors.toList());<br></code></pre></td></tr></table></figure>



<h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h2><p> <a href="https://item.jd.com/10058164.html">Java 编程思想（第 4 版）</a> </p>
<p><a href="https://dunwu.github.io/javacore/container/java-container-list.html#_1-list-%E7%AE%80%E4%BB%8B">java-容器之List</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java-容器</category>
      </categories>
      <tags>
        <tag>Java容器</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSPI机制</title>
    <url>/2022/07/20/JavaSPI%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-什么是SPI机制"><a href="#1-什么是SPI机制" class="headerlink" title="1. 什么是SPI机制"></a>1. 什么是SPI机制</h2><p>SPI（Service Provider Interface），是JDK内置的一种服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是<strong>解耦</strong>。</p>
<p>SPI整体机制图如下： </p>
<p><img src="/img/work/1658099262304.png"></p>
<p>当服务的提供者提供了一种接口的实现之后，需要在classpath下的<code>META-INF/services/</code>目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的<code>META-INF/services/</code>中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：<code>java.util.ServiceLoader</code>。</p>
<h2 id="2-SPI机制的简单示例"><a href="#2-SPI机制的简单示例" class="headerlink" title="2. SPI机制的简单示例"></a>2. SPI机制的简单示例</h2><p>我们现在需要使用一个内容搜索接口，搜索的实现可能是基于文件系统的搜索，也可能是基于数据库的搜索。</p>
<ul>
<li>先定义好接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Search</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">searchDoc</span><span class="hljs-params">(String keyword)</span></span>;   <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>文件搜索实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSearch</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Search</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">searchDoc</span><span class="hljs-params">(String keyword)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;文件搜索 &quot;</span>+keyword);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>数据库搜索实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DatabaseSearch</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Search</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">searchDoc</span><span class="hljs-params">(String keyword)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;数据搜索 &quot;</span>+keyword);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>resources 接下来可以在resources下新建META-INF/services/,然后新建接口全限定名的文件：<code>com.dewu.spi.Search</code>，里面加上我们需要用到的实现类 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">com.dewu.spi.FileSearch<br></code></pre></td></tr></table></figure>

<ul>
<li>测试方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSPI</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ServiceLoader&lt;Search&gt; s = ServiceLoader.load(Search.class);<br>        Iterator&lt;Search&gt; iterator = s.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>           Search search =  iterator.next();<br>           search.searchDoc(<span class="hljs-string">&quot;Java SPI&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">文件搜索 Java SPI<br></code></pre></td></tr></table></figure>

<p>结构如下:</p>
<p>类结构:</p>
<p><img src="/img/work/image-20220718160733901.png"></p>
<p>文件结构:</p>
<p><img src="/img/work/image-20220718160926311.png"></p>
<p>如果在<code>com.dewu.spi.Search</code>文件里写上两个实现类，那最后的输出结果就是两行了。</p>
<p>这就是因为<code>ServiceLoader.load(Search.class)</code>在加载某接口时，会去<code>META-INF/services</code>下找接口的全限定名文件，再根据里面的内容加载相应的实现类。</p>
<p>这就是spi的思想，接口的实现由provider实现，provider只用在提交的jar包里的<code>META-INF/services</code>下根据平台定义的接口新建文件，并添加进相应的实现类内容就好。</p>
<h2 id="3-SPI机制的广泛应用"><a href="#3-SPI机制的广泛应用" class="headerlink" title="3. SPI机制的广泛应用"></a>3. SPI机制的广泛应用</h2><h3 id="3-1-SPI机制-JDBC-DriverManager"><a href="#3-1-SPI机制-JDBC-DriverManager" class="headerlink" title="3.1 SPI机制 - JDBC DriverManager"></a>3.1 SPI机制 - JDBC DriverManager</h3><blockquote>
<p>在JDBC4.0之前，我们开发有连接数据库的时候，通常会用Class.forName(“com.mysql.jdbc.Driver”)这句先加载数据库相关的驱动，然后再进行获取连接等的操作。<strong>而JDBC4.0之后不需要用Class.forName(“com.mysql.jdbc.Driver”)来加载驱动，直接获取连接就可以了，现在这种方式就是使用了Java的SPI扩展机制来实现</strong>。</p>
</blockquote>
<p><strong>JDBC接口定义</strong></p>
<p>首先在java中定义了接口<code>java.sql.Driver</code>，并没有具体的实现，具体的实现都是由不同厂商来提供的。</p>
<p><strong>MySQL实现</strong></p>
<p>在mysql的jar包<code>mysql-connector-java-6.0.6.jar</code>中，可以找到<code>META-INF/services</code>目录，该目录下会有一个名字为<code>java.sql.Driver</code>的文件，文件内容是<code>com.mysql.cj.jdbc.Driver</code>，这里面的内容就是针对Java中定义的接口的实现。</p>
<p><strong>postgresql实现</strong></p>
<p>同样在postgresql的jar包<code>postgresql-42.0.0.jar</code>中，也可以找到同样的配置文件，文件内容是<code>org.postgresql.Driver</code>，这是postgresql对Java的<code>java.sql.Driver</code>的实现。</p>
<p><strong>使用方法</strong></p>
<p>上面说了，现在使用SPI扩展来加载具体的驱动，我们在Java中写连接数据库的代码的时候，不需要再使用<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>来加载驱动了，而是直接使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String url = <span class="hljs-string">&quot;jdbc:xxxx://xxxx:xxxx/xxxx&quot;</span>;<br>Connection conn = DriverManager.getConnection(url,username,password);<br>.....<br></code></pre></td></tr></table></figure>

<p>这里并没有涉及到spi的使用，接着看下面的解析。</p>
<p><strong>源码实现</strong></p>
<p>上面的使用方法，就是我们普通的连接数据库的代码，并没有涉及到SPI的东西，但是有一点我们可以确定的是，我们没有写有关具体驱动的硬编码<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>！</p>
<p>上面的代码可以直接获取数据库连接进行操作，但是跟SPI有啥关系呢？上面代码没有了加载驱动的代码，我们怎么去确定使用哪个数据库连接的驱动呢？这里就涉及到使用Java的SPI扩展机制来查找相关驱动的东西了，关于驱动的查找其实都在<code>DriverManager</code>中，<code>DriverManager</code>是Java中的实现，用来获取数据库连接，在<code>DriverManager</code>中有一个静态代码块如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    loadInitialDrivers();<br>    println(<span class="hljs-string">&quot;JDBC DriverManager initialized&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到是加载实例化驱动的，接着看loadInitialDrivers方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadInitialDrivers</span><span class="hljs-params">()</span> </span>&#123;<br>  String drivers;<br>  <span class="hljs-keyword">try</span> &#123;<br>    drivers = AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> System.getProperty(<span class="hljs-string">&quot;jdbc.drivers&quot;</span>);<br>      &#125;<br>    &#125;);<br>  &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>    drivers = <span class="hljs-keyword">null</span>;<br>  &#125;<br><br>  AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//使用SPI的ServiceLoader来加载接口的实现</span><br>      ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);<br>      Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br>      <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>          driversIterator.next();<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;<br>        <span class="hljs-comment">// Do nothing</span><br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>  &#125;);<br><br>  println(<span class="hljs-string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);<br><br>  <span class="hljs-keyword">if</span> (drivers == <span class="hljs-keyword">null</span> || drivers.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  String[] driversList = drivers.split(<span class="hljs-string">&quot;:&quot;</span>);<br>  println(<span class="hljs-string">&quot;number of Drivers:&quot;</span> + driversList.length);<br>  <span class="hljs-keyword">for</span> (String aDriver : driversList) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      println(<span class="hljs-string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);<br>      Class.forName(aDriver, <span class="hljs-keyword">true</span>,<br>                    ClassLoader.getSystemClassLoader());<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>      println(<span class="hljs-string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码主要步骤是：</p>
<ul>
<li>从系统变量中获取有关驱动的定义。</li>
<li>使用SPI来获取驱动的实现。</li>
<li>遍历使用SPI获取到的具体实现，实例化各个实现类。</li>
<li>根据第一步获取到的驱动列表来实例化具体实现类。</li>
</ul>
<p>我们主要关注2,3步，这两步是SPI的用法，首先看第二步，使用SPI来获取驱动的实现，对应的代码是： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);<br></code></pre></td></tr></table></figure>

<p>这里没有去<code>META-INF/services</code>目录下查找配置文件，也没有加载具体实现类，做的事情就是封装了我们的接口类型和类加载器，并初始化了一个迭代器。 </p>
<p>接着看第三步，遍历使用SPI获取到的具体实现，实例化各个实现类，对应的代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取迭代器</span><br>Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br><span class="hljs-comment">//遍历所有的驱动实现</span><br><span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>    driversIterator.next();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在遍历的时候，首先调用<code>driversIterator.hasNext()</code>方法，这里会搜索classpath下以及jar包中所有的<code>META-INF/services</code>目录下的<code>java.sql.Driver</code>文件，并找到文件中的实现类的名字，此时并没有实例化具体的实现类（ServiceLoader具体的源码实现在下面）。</p>
<p>然后是调用<code>driversIterator.next();</code>方法，此时就会根据驱动名字具体实例化各个实现类了。现在驱动就被找到并实例化了。 </p>
<p>可以看下截图，我在测试项目中添加了两个jar包，<code>mysql-connector-java-6.0.6.jar</code>和<code>postgresql-42.0.0.0.jar</code>，跟踪到DriverManager中之后： </p>
<p><img src="/img/work/1658156582561.png"></p>
<p>可以看到此时迭代器中有两个驱动，mysql和postgresql的都被加载了。 </p>
<h3 id="3-2-SPI机制-Common-Logging"><a href="#3-2-SPI机制-Common-Logging" class="headerlink" title="3.2 SPI机制 - Common-Logging"></a>3.2 SPI机制 - Common-Logging</h3><blockquote>
<p> common-logging（也称Jakarta Commons Logging，缩写 JCL）是常用的日志库门面。</p>
</blockquote>
<p>首先，日志实例是通过LogFactory的getLog(String)方法创建的： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">getLog</span><span class="hljs-params">(Class clazz)</span> <span class="hljs-keyword">throws</span> LogConfigurationException </span>&#123;<br>    <span class="hljs-keyword">return</span> getFactory().getInstance(clazz);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>LogFatory是一个抽象类，它负责加载具体的日志实现，分析其Factory getFactory()方法： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> org.apache.commons.logging.<span class="hljs-function">LogFactory <span class="hljs-title">getFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LogConfigurationException </span>&#123;<br>    <span class="hljs-comment">// Identify the class loader we will be using</span><br>    ClassLoader contextClassLoader = getContextClassLoaderInternal();<br><br>    <span class="hljs-keyword">if</span> (contextClassLoader == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// This is an odd enough situation to report about. This</span><br>        <span class="hljs-comment">// output will be a nuisance on JDK1.1, as the system</span><br>        <span class="hljs-comment">// classloader is null in that environment.</span><br>        <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) &#123;<br>            logDiagnostic(<span class="hljs-string">&quot;Context classloader is null.&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Return any previously registered factory for this class loader</span><br>    org.apache.commons.logging.LogFactory factory = getCachedFactory(contextClassLoader);<br>    <span class="hljs-keyword">if</span> (factory != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> factory;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) &#123;<br>        logDiagnostic(<br>            <span class="hljs-string">&quot;[LOOKUP] LogFactory implementation requested for the first time for context classloader &quot;</span> +<br>            objectId(contextClassLoader));<br>        logHierarchy(<span class="hljs-string">&quot;[LOOKUP] &quot;</span>, contextClassLoader);<br>    &#125;<br><br>    <span class="hljs-comment">// Load properties file.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// If the properties file exists, then its contents are used as</span><br>    <span class="hljs-comment">// &quot;attributes&quot; on the LogFactory implementation class. One particular</span><br>    <span class="hljs-comment">// property may also control which LogFactory concrete subclass is</span><br>    <span class="hljs-comment">// used, but only if other discovery mechanisms fail..</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// As the properties file (if it exists) will be used one way or</span><br>    <span class="hljs-comment">// another in the end we may as well look for it first.</span><br>    <span class="hljs-comment">// classpath根目录下寻找commons-logging.properties</span><br>    Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES);<br><br>    <span class="hljs-comment">// Determine whether we will be using the thread context class loader to</span><br>    <span class="hljs-comment">// load logging classes or not by checking the loaded properties file (if any).</span><br>    <span class="hljs-comment">// classpath根目录下commons-logging.properties是否配置use_tccl</span><br>    ClassLoader baseClassLoader = contextClassLoader;<br>    <span class="hljs-keyword">if</span> (props != <span class="hljs-keyword">null</span>) &#123;<br>        String useTCCLStr = props.getProperty(TCCL_KEY);<br>        <span class="hljs-keyword">if</span> (useTCCLStr != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// The Boolean.valueOf(useTCCLStr).booleanValue() formulation</span><br>            <span class="hljs-comment">// is required for Java 1.2 compatibility.</span><br>            <span class="hljs-keyword">if</span> (Boolean.valueOf(useTCCLStr).booleanValue() == <span class="hljs-keyword">false</span>) &#123;<br>                <span class="hljs-comment">// Don&#x27;t use current context classloader when locating any</span><br>                <span class="hljs-comment">// LogFactory or Log classes, just use the class that loaded</span><br>                <span class="hljs-comment">// this abstract class. When this class is deployed in a shared</span><br>                <span class="hljs-comment">// classpath of a container, it means webapps cannot deploy their</span><br>                <span class="hljs-comment">// own logging implementations. It also means that it is up to the</span><br>                <span class="hljs-comment">// implementation whether to load library-specific config files</span><br>                <span class="hljs-comment">// from the TCCL or not.</span><br>                baseClassLoader = thisClassLoader;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 这里真正开始决定使用哪个factory</span><br>    <span class="hljs-comment">// 首先，尝试查找vm系统属性org.apache.commons.logging.LogFactory，其是否指定factory</span><br>    <span class="hljs-comment">// Determine which concrete LogFactory subclass to use.</span><br>    <span class="hljs-comment">// First, try a global system property</span><br>    <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) &#123;<br>        logDiagnostic(<span class="hljs-string">&quot;[LOOKUP] Looking for system property [&quot;</span> + FACTORY_PROPERTY +<br>                      <span class="hljs-string">&quot;] to define the LogFactory subclass to use...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        String factoryClass = getSystemProperty(FACTORY_PROPERTY, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">if</span> (factoryClass != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) &#123;<br>                logDiagnostic(<span class="hljs-string">&quot;[LOOKUP] Creating an instance of LogFactory class &#x27;&quot;</span> + factoryClass +<br>                              <span class="hljs-string">&quot;&#x27; as specified by system property &quot;</span> + FACTORY_PROPERTY);<br>            &#125;<br>            factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) &#123;<br>                logDiagnostic(<span class="hljs-string">&quot;[LOOKUP] No system property [&quot;</span> + FACTORY_PROPERTY + <span class="hljs-string">&quot;] defined.&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123;<br>        <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) &#123;<br>            logDiagnostic(<span class="hljs-string">&quot;[LOOKUP] A security exception occurred while trying to create an&quot;</span> +<br>                          <span class="hljs-string">&quot; instance of the custom factory class&quot;</span> + <span class="hljs-string">&quot;: [&quot;</span> + trim(e.getMessage()) +<br>                          <span class="hljs-string">&quot;]. Trying alternative implementations...&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// ignore</span><br>    &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>        <span class="hljs-comment">// This is not consistent with the behaviour when a bad LogFactory class is</span><br>        <span class="hljs-comment">// specified in a services file.</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// One possible exception that can occur here is a ClassCastException when</span><br>        <span class="hljs-comment">// the specified class wasn&#x27;t castable to this LogFactory type.</span><br>        <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) &#123;<br>            logDiagnostic(<span class="hljs-string">&quot;[LOOKUP] An exception occurred while trying to create an&quot;</span> +<br>                          <span class="hljs-string">&quot; instance of the custom factory class&quot;</span> + <span class="hljs-string">&quot;: [&quot;</span> +<br>                          trim(e.getMessage()) +<br>                          <span class="hljs-string">&quot;] as specified by a system property.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br><br>    <span class="hljs-comment">// 第二，尝试使用java spi服务发现机制，载META-INF/services下寻找org.apache.commons.logging.LogFactory实现</span><br>    <span class="hljs-comment">// Second, try to find a service by using the JDK1.3 class</span><br>    <span class="hljs-comment">// discovery mechanism, which involves putting a file with the name</span><br>    <span class="hljs-comment">// of an interface class in the META-INF/services directory, where the</span><br>    <span class="hljs-comment">// contents of the file is a single line specifying a concrete class</span><br>    <span class="hljs-comment">// that implements the desired interface.</span><br><br>    <span class="hljs-keyword">if</span> (factory == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) &#123;<br>            logDiagnostic(<span class="hljs-string">&quot;[LOOKUP] Looking for a resource file of name [&quot;</span> + SERVICE_ID +<br>                          <span class="hljs-string">&quot;] to define the LogFactory subclass to use...&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// META-INF/services/org.apache.commons.logging.LogFactory, SERVICE_ID</span><br>            <span class="hljs-keyword">final</span> InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID);<br><br>            <span class="hljs-keyword">if</span> (is != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// This code is needed by EBCDIC and other strange systems.</span><br>                <span class="hljs-comment">// It&#x27;s a fix for bugs reported in xerces</span><br>                BufferedReader rd;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    rd = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(is, <span class="hljs-string">&quot;UTF-8&quot;</span>));<br>                &#125; <span class="hljs-keyword">catch</span> (java.io.UnsupportedEncodingException e) &#123;<br>                    rd = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(is));<br>                &#125;<br><br>                String factoryClassName = rd.readLine();<br>                rd.close();<br><br>                <span class="hljs-keyword">if</span> (factoryClassName != <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-string">&quot;&quot;</span>.equals(factoryClassName)) &#123;<br>                    <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) &#123;<br>                        logDiagnostic(<span class="hljs-string">&quot;[LOOKUP]  Creating an instance of LogFactory class &quot;</span> +<br>                                      factoryClassName +<br>                                      <span class="hljs-string">&quot; as specified by file &#x27;&quot;</span> + SERVICE_ID +<br>                                      <span class="hljs-string">&quot;&#x27; which was present in the path of the context classloader.&quot;</span>);<br>                    &#125;<br>                    factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// is == null</span><br>                <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) &#123;<br>                    logDiagnostic(<span class="hljs-string">&quot;[LOOKUP] No resource file with name &#x27;&quot;</span> + SERVICE_ID + <span class="hljs-string">&quot;&#x27; found.&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            <span class="hljs-comment">// note: if the specified LogFactory class wasn&#x27;t compatible with LogFactory</span><br>            <span class="hljs-comment">// for some reason, a ClassCastException will be caught here, and attempts will</span><br>            <span class="hljs-comment">// continue to find a compatible class.</span><br>            <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) &#123;<br>                logDiagnostic(<br>                    <span class="hljs-string">&quot;[LOOKUP] A security exception occurred while trying to create an&quot;</span> +<br>                    <span class="hljs-string">&quot; instance of the custom factory class&quot;</span> +<br>                    <span class="hljs-string">&quot;: [&quot;</span> + trim(ex.getMessage()) +<br>                    <span class="hljs-string">&quot;]. Trying alternative implementations...&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// ignore</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 第三，尝试从classpath根目录下的commons-logging.properties中查找org.apache.commons.logging.LogFactory属性指定的factory</span><br>    <span class="hljs-comment">// Third try looking into the properties file read earlier (if found)</span><br><br>    <span class="hljs-keyword">if</span> (factory == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (props != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) &#123;<br>                logDiagnostic(<br>                    <span class="hljs-string">&quot;[LOOKUP] Looking in properties file for entry with key &#x27;&quot;</span> + FACTORY_PROPERTY +<br>                    <span class="hljs-string">&quot;&#x27; to define the LogFactory subclass to use...&quot;</span>);<br>            &#125;<br>            String factoryClass = props.getProperty(FACTORY_PROPERTY);<br>            <span class="hljs-keyword">if</span> (factoryClass != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) &#123;<br>                    logDiagnostic(<br>                        <span class="hljs-string">&quot;[LOOKUP] Properties file specifies LogFactory subclass &#x27;&quot;</span> + factoryClass + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                &#125;<br>                factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);<br><br>                <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> think about whether we need to handle exceptions from newFactory</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) &#123;<br>                    logDiagnostic(<span class="hljs-string">&quot;[LOOKUP] Properties file has no entry specifying LogFactory subclass.&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) &#123;<br>                logDiagnostic(<span class="hljs-string">&quot;[LOOKUP] No properties file available to determine&quot;</span> + <span class="hljs-string">&quot; LogFactory subclass from..&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 最后，使用后备factory实现，org.apache.commons.logging.impl.LogFactoryImpl</span><br>    <span class="hljs-comment">// Fourth, try the fallback implementation class</span><br><br>    <span class="hljs-keyword">if</span> (factory == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (isDiagnosticsEnabled()) &#123;<br>            logDiagnostic(<br>                <span class="hljs-string">&quot;[LOOKUP] Loading the default LogFactory implementation &#x27;&quot;</span> + FACTORY_DEFAULT +<br>                <span class="hljs-string">&quot;&#x27; via the same classloader that loaded this LogFactory&quot;</span> +<br>                <span class="hljs-string">&quot; class (ie not looking in the context classloader).&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Note: unlike the above code which can try to load custom LogFactory</span><br>        <span class="hljs-comment">// implementations via the TCCL, we don&#x27;t try to load the default LogFactory</span><br>        <span class="hljs-comment">// implementation via the context classloader because:</span><br>        <span class="hljs-comment">// * that can cause problems (see comments in newFactory method)</span><br>        <span class="hljs-comment">// * no-one should be customising the code of the default class</span><br>        <span class="hljs-comment">// Yes, we do give up the ability for the child to ship a newer</span><br>        <span class="hljs-comment">// version of the LogFactoryImpl class and have it used dynamically</span><br>        <span class="hljs-comment">// by an old LogFactory class in the parent, but that isn&#x27;t</span><br>        <span class="hljs-comment">// necessarily a good idea anyway.</span><br>        factory = newFactory(FACTORY_DEFAULT, thisClassLoader, contextClassLoader);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (factory != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">            * Always cache using context class loader.</span><br><span class="hljs-comment">            */</span><br>        cacheFactory(contextClassLoader, factory);<br><br>        <span class="hljs-keyword">if</span> (props != <span class="hljs-keyword">null</span>) &#123;<br>            Enumeration names = props.propertyNames();<br>            <span class="hljs-keyword">while</span> (names.hasMoreElements()) &#123;<br>                String name = (String) names.nextElement();<br>                String value = props.getProperty(name);<br>                factory.setAttribute(name, value);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> factory;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>可以看出，抽象类LogFactory加载具体实现的步骤如下： </p>
<ul>
<li>从vm系统属性org.apache.commons.logging.LogFactory</li>
<li>使用SPI服务发现机制，发现org.apache.commons.logging.LogFactory的实现</li>
<li>查找classpath根目录commons-logging.properties的org.apache.commons.logging.LogFactory属性是否指定factory实现</li>
<li>使用默认factory实现，org.apache.commons.logging.impl.LogFactoryImpl</li>
</ul>
<blockquote>
<p>LogFactory的getLog()方法返回类型是org.apache.commons.logging.Log接口，提供了从trace到fatal方法。可以确定，如果日志实现提供者只要实现该接口，并且使用继承自org.apache.commons.logging.LogFactory的子类创建Log，必然可以构建一个松耦合的日志系统。</p>
</blockquote>
<h3 id="3-3-SPI机制-插件体系"><a href="#3-3-SPI机制-插件体系" class="headerlink" title="3.3 SPI机制 - 插件体系"></a>3.3 SPI机制 - 插件体系</h3><blockquote>
<p>其实最具spi思想的应该属于插件开发，我们项目中也用到的这种思想，后面再说，这里具体说一下eclipse的插件思想。 </p>
</blockquote>
<p>Eclipse使用OSGi作为插件系统的基础，动态添加新插件和停止现有插件，以动态的方式管理组件生命周期。 </p>
<p>一般来说，插件的文件结构必须在指定目录下包含以下三个文件： </p>
<ul>
<li><code>META-INF/MANIFEST.MF</code>: 项目基本配置信息，版本、名称、启动器等</li>
<li><code>build.properties</code>: 项目的编译配置信息，包括，源代码路径、输出路径</li>
<li><code>plugin.xml</code>：插件的操作配置信息，包含弹出菜单及点击菜单后对应的操作执行类等</li>
</ul>
<p>当eclipse启动时，会遍历plugins文件夹中的目录，扫描每个插件的清单文件<code>MANIFEST.MF</code>，并建立一个内部模型来记录它所找到的每个插件的信息，就实现了动态添加新的插件。 </p>
<p>这也意味着是eclipse制定了一系列的规则，像是文件结构、类型、参数等。插件开发者遵循这些规则去开发自己的插件，eclipse并不需要知道插件具体是怎样开发的，只需要在启动的时候根据配置文件解析、加载到系统里就好了，是spi思想的一种体现。</p>
<h3 id="3-4-SPI机制-Spring中SPI机制"><a href="#3-4-SPI机制-Spring中SPI机制" class="headerlink" title="3.4 SPI机制 - Spring中SPI机制"></a>3.4 SPI机制 - Spring中SPI机制</h3><p>在springboot的自动装配过程中，最终会加载<code>META-INF/spring.factories</code>文件，而加载的过程是由<code>SpringFactoriesLoader</code>加载的。从CLASSPATH下的每个Jar包中搜寻所有<code>META-INF/spring.factories</code>配置文件，然后将解析properties文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅是会去ClassPath路径下查找，会扫描所有路径下的Jar包，只不过这个文件只会在Classpath下的jar包中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>;<br><span class="hljs-comment">// spring.factories文件的格式为：key=value1,value2,value3</span><br><span class="hljs-comment">// 从所有的jar包中找到META-INF/spring.factories文件</span><br><span class="hljs-comment">// 然后从文件中解析出key=factoryClass类名称的所有value值</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;<br>    String factoryClassName = factoryClass.getName();<br>    <span class="hljs-comment">// 取得资源文件的URL</span><br>    Enumeration&lt;URL&gt; urls = (classLoader != <span class="hljs-keyword">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));<br>    List&lt;String&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    <span class="hljs-comment">// 遍历所有的URL</span><br>    <span class="hljs-keyword">while</span> (urls.hasMoreElements()) &#123;<br>        URL url = urls.nextElement();<br>        <span class="hljs-comment">// 根据资源文件URL解析properties文件，得到对应的一组@Configuration类</span><br>        Properties properties = PropertiesLoaderUtils.loadProperties(<span class="hljs-keyword">new</span> UrlResource(url));<br>        String factoryClassNames = properties.getProperty(factoryClassName);<br>        <span class="hljs-comment">// 组装数据，并返回</span><br>        result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-SPI机制深入理解"><a href="#4-SPI机制深入理解" class="headerlink" title="4. SPI机制深入理解"></a>4. SPI机制深入理解</h2><h3 id="4-1-SPI机制通常怎么使用"><a href="#4-1-SPI机制通常怎么使用" class="headerlink" title="4.1 SPI机制通常怎么使用"></a>4.1 SPI机制通常怎么使用</h3><p>看完上面的几个例子解析，应该都能知道大概的流程了： </p>
<ul>
<li>有关组织或者公司定义标准。</li>
<li>具体厂商或者框架开发者实现。</li>
<li>程序猿使用。</li>
</ul>
<p><strong>定义标准</strong></p>
<p>定义标准，就是定义接口。比如接口<code>java.sql.Driver</code> </p>
<p><strong>具体厂商或者框架开发者实现</strong></p>
<p>厂商或者框架开发者开发具体的实现： </p>
<p>在<code>META-INF/services</code>目录下定义一个名字为接口全限定名的文件，比如<code>java.sql.Driver</code>文件，文件内容是具体的实现名字，比如<code>me.cxis.sql.MyDriver</code>。 </p>
<p>写具体的实现<code>me.cxis.sql.MyDriver</code>，都是对接口Driver的实现。 </p>
<p><strong>程序猿使用</strong></p>
<p>我们会引用具体厂商的jar包来实现我们的功能： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);<br><span class="hljs-comment">//获取迭代器</span><br>Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br><span class="hljs-comment">//遍历</span><br><span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>    driversIterator.next();<br>    <span class="hljs-comment">//可以做具体的业务逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>使用规范</strong></p>
<p>最后总结一下jdk spi需要遵循的规范 </p>
<p><img src="/img/work/1658158319501.png"></p>
<h3 id="4-2-SPI和API的区别是什么"><a href="#4-2-SPI和API的区别是什么" class="headerlink" title="4.2 SPI和API的区别是什么"></a>4.2 SPI和API的区别是什么</h3><blockquote>
<p>这里实际包含两个问题，第一个SPI和API的区别？第二个什么时候用API，什么时候用SPI？</p>
</blockquote>
<p>SPI - “接口”位于“调用方”所在的“包”中</p>
<ul>
<li>概念上更依赖调用方。</li>
<li>组织上位于调用方所在的包中。</li>
<li>实现位于独立的包中。</li>
<li>常见的例子是：插件模式的插件。</li>
</ul>
<blockquote>
<p>API - “接口”位于“实现方”所在的“包”中</p>
</blockquote>
<ul>
<li>概念上更接近实现方。</li>
<li>组织上位于实现方所在的包中。</li>
<li>实现和接口在一个包中。</li>
</ul>
<h3 id="4-3-原理解析"><a href="#4-3-原理解析" class="headerlink" title="4.3 原理解析"></a>4.3 原理解析</h3><p>首先看ServiceLoader类的签名类的成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceLoader</span>&lt;<span class="hljs-title">S</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">S</span>&gt;</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX = <span class="hljs-string">&quot;META-INF/services/&quot;</span>;<br><br>    <span class="hljs-comment">// 代表被加载的类或者接口</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;S&gt; service;<br><br>    <span class="hljs-comment">// 用于定位，加载和实例化providers的类加载器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader loader;<br><br>    <span class="hljs-comment">// 创建ServiceLoader时采用的访问控制上下文</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AccessControlContext acc;<br><br>    <span class="hljs-comment">// 缓存providers，按实例化的顺序排列</span><br>    <span class="hljs-keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br><br>    <span class="hljs-comment">// 懒查找迭代器</span><br>    <span class="hljs-keyword">private</span> LazyIterator lookupIterator;<br>  <br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<p>参考具体ServiceLoader具体源码，代码量不多，加上注释一共587行，梳理了一下，实现的流程如下： </p>
<p>1 应用程序调用ServiceLoader.load方法</p>
<p>ServiceLoader.load方法内先创建一个新的ServiceLoader，并实例化该类中的成员变量，包括： </p>
<ul>
<li>loader(ClassLoader类型，类加载器)</li>
<li>acc(AccessControlContext类型，访问控制器)</li>
<li>providers(LinkedHashMap&lt;String,S&gt;类型，用于缓存加载成功的类)</li>
<li>lookupIterator(实现迭代器功能)</li>
</ul>
<p>2 应用程序通过迭代器接口获取对象实例 </p>
<p>ServiceLoader先判断成员变量providers对象中(LinkedHashMap&lt;String,S&gt;类型)是否有缓存实例对象，如果有缓存，直接返回。</p>
<p>如果没有缓存，执行类的装载，实现如下： </p>
<ul>
<li>读取META-INF/services/下的配置文件，获得所有能被实例化的类的名称，值得注意的是，ServiceLoader<strong>可以跨越jar包获取META-INF下的配置文件</strong>，具体加载配置的实现代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    String fullName = PREFIX + service.getName();<br>    <span class="hljs-keyword">if</span> (loader == <span class="hljs-keyword">null</span>)<br>        configs = ClassLoader.getSystemResources(fullName);<br>    <span class="hljs-keyword">else</span><br>        configs = loader.getResources(fullName);<br>&#125; <span class="hljs-keyword">catch</span> (IOException x) &#123;<br>    fail(service, <span class="hljs-string">&quot;Error locating configuration files&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>通过反射方法Class.forName()加载类对象，并用instance()方法将类实例化。</p>
</li>
<li><p>把实例化后的类缓存到providers对象中，(LinkedHashMap&lt;String,S&gt;类型）然后返回实例对象。  </p>
</li>
</ul>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><h3 id="5-1-SPI的优势"><a href="#5-1-SPI的优势" class="headerlink" title="5.1 SPI的优势"></a>5.1 SPI的优势</h3><p>使用Java SPI机制的优势是实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，而不是耦合在一起。应用程序可以根据实际业务情况启用框架扩展或替换框架组件。  </p>
<p>相比使用提供接口jar包，供第三方服务模块实现接口的方式，SPI的方式使得源框架，不必关心接口的实现类的路径，可以不用通过下面的方式获取接口实现类： </p>
<ul>
<li>代码硬编码import 导入实现类</li>
<li>指定类全路径反射获取：例如在JDBC4.0之前，JDBC中获取数据库驱动类需要通过**Class.forName(“com.mysql.jdbc.Driver”)**，类似语句先动态加载数据库相关的驱动，然后再进行获取连接等的操作</li>
<li>第三方服务模块把接口实现类实例注册到指定地方，源框架从该处访问实例</li>
</ul>
<p>通过SPI的方式，第三方服务模块实现接口后，在第三方的项目代码的META-INF/services目录下的配置文件指定实现类的全路径名，源码框架即可找到实现类 </p>
<h3 id="5-2-SPI机制的缺陷"><a href="#5-2-SPI机制的缺陷" class="headerlink" title="5.2 SPI机制的缺陷"></a>5.2 SPI机制的缺陷</h3><p>通过上面的解析，可以发现，我们使用SPI机制的缺陷： </p>
<ul>
<li>不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</li>
<li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</li>
<li>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</li>
</ul>
<h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><ul>
<li><a href="https://www.pdai.tech/md/java/advanced/java-advanced-spi.html#spi%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">基于pdai的SPI详解修改</a></li>
<li><a href="https://www.jianshu.com/p/46b42f7f593c">https://www.jianshu.com/p/46b42f7f593c</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/2022/06/20/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-物理内存模型"><a href="#1-物理内存模型" class="headerlink" title="1. 物理内存模型"></a>1. 物理内存模型</h2><p>物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。 </p>
<h3 id="1-1-硬件处理效率"><a href="#1-1-硬件处理效率" class="headerlink" title="1.1 硬件处理效率"></a>1.1 硬件处理效率</h3><p>物理内存的第一个问题是：硬件处理效率。 </p>
<ul>
<li>绝大多数的运算任务都不可能只靠处理器“计算”就能完成，处理器至少需要与<strong>内存交互</strong>，如读取运算数据、存储运算结果，这个I/O操作是很难消除的(无法仅靠寄存器完成所有运算任务)。</li>
<li> <strong>由于计算机的存储设备与处理器的运算速度有几个数量级的差距</strong>，这种速度上的矛盾，会降低硬件的处理效率。所以，现代计算机都不得不 <strong>加入高速缓存（Cache） 来作为内存和处理器之间的缓冲</strong>。将需要用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步到内存中，这样处理器就无需等待缓慢的内存读写了。 </li>
</ul>
<h3 id="1-2-缓存一致性"><a href="#1-2-缓存一致性" class="headerlink" title="1.2. 缓存一致性"></a>1.2. 缓存一致性</h3><p>高速缓存解决了 <strong>硬件效率问题</strong>，但是引入了一个新的问题：<strong>缓存一致性（Cache Coherence）</strong>。 </p>
<p>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。 </p>
<p>为了解决缓存一致性问题，<strong>需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作</strong>。 </p>
<p> <img src="/img/work/20210102230327.png"> </p>
<h3 id="1-3-代码乱序执行优化"><a href="#1-3-代码乱序执行优化" class="headerlink" title="1.3. 代码乱序执行优化"></a>1.3. 代码乱序执行优化</h3><p><strong>除了高速缓存以外，为了使得处理器内部的运算单元尽量被充分利用</strong>，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化。处理器会在计算之后将乱序执行的结果重组，<strong>保证该结果与顺序执行的结果是一致的</strong>，但不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。 </p>
<p> <img src="/img/work/20210102223609.png"> </p>
<p>乱序执行技术是处理器为提高运算速度而做出违背代码原有顺序的优化。 </p>
<ul>
<li><strong>单核</strong>环境下，处理器保证做出的优化不会导致执行结果远离预期目标，但在多核环境下却并非如此。</li>
<li><strong>多核</strong>环境下， 如果存在一个核的计算任务依赖另一个核的计算任务的中间结果，而且对相关数据读写没做任何防护措施，那么其顺序性并不能靠代码的先后顺序来保证。</li>
</ul>
<p> <img src="/img/work/20210102224144.png"> </p>
<h2 id="2-Java-内存模型"><a href="#2-Java-内存模型" class="headerlink" title="2. Java 内存模型"></a>2. Java 内存模型</h2><p><strong><code>内存模型</code></strong> 这个概念。我们可以理解为：<strong>在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象</strong>。不同架构的物理计算机可以有不一样的内存模型，JVM 也有自己的内存模型。 </p>
<p>JVM 中试图定义一种 Java 内存模型（Java Memory Model, JMM）来<strong>屏蔽各种硬件和操作系统的内存访问差异</strong>，以实现让 Java 程序<strong>在各种平台下都能达到一致的内存访问效果</strong>。 </p>
<p>在并发环境下，并发安全需要满足<strong>可见性、有序性、原子性</strong>。其中，导致可见性的原因是缓存，导致有序性的原因是编译优化。那解决可见性、有序性最直接的办法就是<strong>禁用缓存和编译优化</strong> 。但这么做，性能就堪忧了。</p>
<p>合理的方案应该是<strong>按需禁用缓存以及编译优化</strong>。那么，如何做到呢？，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 <strong>volatile</strong>、<strong>synchronized</strong> 和 <strong>final</strong> 三个关键字，以及 <strong>Happens-Before 规则</strong>。</p>
<h3 id="2-1-主内存和工作内存"><a href="#2-1-主内存和工作内存" class="headerlink" title="2.1. 主内存和工作内存"></a>2.1. 主内存和工作内存</h3><p>JMM 的主要目标是<strong>定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节</strong>。此处的变量（Variables）与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数值对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，JMM 并没有限制执行引擎使用处理器的特定寄存器或缓存来和主存进行交互，也没有限制即使编译器进行调整代码执行顺序这类优化措施。</p>
<p>JMM 规定了<strong>所有的变量都存储在主内存（Main Memory）中</strong>。</p>
<p>每条线程还有自己的工作内存（Working Memory），<strong>工作内存中保留了该线程使用到的变量的主内存的副本</strong>。工作内存是 JMM 的一个抽象概念，并不真实存在，它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p>
<p><img src="/img/work/20210102225839.png"></p>
<p>线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程间也无法直接访问对方工作内存中的变量，<strong>线程间变量值的传递均需要通过主内存来完成</strong>。</p>
<p><img src="/img/work/20210102225657.png"></p>
<blockquote>
<p>说明：</p>
<p>这里说的主内存、工作内存与 Java 内存区域中的堆、栈、方法区等不是同一个层次的内存划分。</p>
</blockquote>
<h3 id="2-2-JMM-内存操作的问题"><a href="#2-2-JMM-内存操作的问题" class="headerlink" title="2.2. JMM 内存操作的问题"></a>2.2. JMM 内存操作的问题</h3><p>类似于物理内存模型面临的问题，JMM 存在以下两个问题：</p>
<ul>
<li><strong>工作内存数据一致性</strong> -各个线程操作数据时会保存使用到的主内存中的共享变量副本，当多个线程的运算任务都涉及同一个共享变量时，将导致各自的的共享变量副本不一致。如果真的发生这种情况，数据同步回主内存以谁的副本数据为准？ Java 内存模型主要通过一系列的数据同步协议、规则来保证数据的一致性。</li>
<li><strong>指令重排序优化</strong> - Java 中重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：<strong>编译期重排序和运行期重排序</strong>，分别对应编译时和运行时环境。 同样的，指令重排序不是随意重排序，它需要满足以下两个条件：<ul>
<li>在单线程环境下不能改变程序运行的结果。即时编译器（和处理器）需要保证程序能够遵守 <code>as-if-serial</code> 属性。通俗地说，就是在单线程情况下，要给程序一个顺序执行的假象。即经过重排序的执行结果要与顺序执行的结果保持一致。存在数据依赖关系的不允许重排序。</li>
<li>多线程环境下，如果线程处理逻辑之间存在依赖关系，有可能因为指令重排序导致运行结果与预期不同。</li>
</ul>
</li>
</ul>
<h3 id="2-3-内存间交互操作"><a href="#2-3-内存间交互操作" class="headerlink" title="2.3. 内存间交互操作"></a>2.3. 内存间交互操作</h3><p>JMM 定义了 8 个操作来完成主内存和工作内存之间的交互操作。JVM 实现时必须保证下面介绍的每种操作都是 <strong>原子的</strong>（对于 double 和 long 型的变量来说，load、store、read、和 write 操作在某些平台上允许有例外 ）。</p>
<ul>
<li><p><code>lock</code> (锁定) - 作用于<strong>主内存</strong>的变量，它把一个变量标识为一条线程独占的状态。</p>
</li>
<li><p><code>unlock</code> (解锁) - 作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>
</li>
<li><p><code>read</code> (读取) - 作用于<strong>主内存</strong>的变量，它把一个变量的值从主内存<strong>传输</strong>到线程的工作内存中，以便随后的 <code>load</code> 动作使用。</p>
</li>
<li><p><code>write</code> (写入) - 作用于<strong>主内存</strong>的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</p>
</li>
<li><p><code>load</code> (载入) - 作用于<strong>工作内存</strong>的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</p>
</li>
<li><p><code>use</code> (使用) - 作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令时就会执行这个操作。</p>
</li>
<li><p><code>assign</code> (赋值) - 作用于<strong>工作内存</strong>的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p>
</li>
<li><p><code>store</code> (存储) - 作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传送到主内存中，以便随后 <code>write</code> 操作使用。</p>
</li>
</ul>
<p>如果要把一个变量从主内存中复制到工作内存，就<strong>需要按序执行 <code>read</code> 和 <code>load</code> 操作</strong>；如果把变量从工作内存中同步回主内存中，就<strong>需要按序执行 <code>store</code> 和 <code>write</code> 操作</strong>。但 Java 内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</p>
<p>JMM 还规定了上述 8 种基本操作，需要满足以下规则：</p>
<ul>
<li><p><strong>read 和 load 必须成对出现</strong>；<strong>store 和 write 必须成对出现</strong>。即不允许一个变量从主内存读取了但工作内存不接受，或从工作内存发起回写了但主内存不接受的情况出现。</p>
</li>
<li><p><strong>不允许一个线程丢弃它的最近 assign 的操作</strong>，即变量在工作内存中改变了之后必须把变化同步到主内存中。</p>
</li>
<li><p><strong>不允许一个线程无原因的（没有发生过任何 assign 操作）把数据从工作内存同步回主内存中</strong>。</p>
</li>
<li><p>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign ）的变量。换句话说，就是对一个变量实施 use 和 store 操作之前，必须先执行过了 load 或 assign 操作。</p>
</li>
<li><p>一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。所以 <strong>lock 和 unlock 必须成对出现</strong>。</p>
</li>
<li><p>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</p>
</li>
<li><p>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量。</p>
</li>
<li><p>对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）</p>
</li>
</ul>
<p><img src="/img/work/20210102230708.png"></p>
<h3 id="2-4-并发安全特性"><a href="#2-4-并发安全特性" class="headerlink" title="2.4. 并发安全特性"></a>2.4. 并发安全特性</h3><p>上文介绍了 Java 内存交互的 8 种基本操作，它们遵循 Java 内存三大特性：原子性、可见性、有序性。</p>
<p>而这三大特性，归根结底，是为了实现多线程的 <strong>数据一致性</strong>，使得程序在多线程并发，指令重排序优化的环境中能如预期运行。</p>
<h4 id="2-4-1-原子性"><a href="#2-4-1-原子性" class="headerlink" title="2.4.1 原子性"></a>2.4.1 <strong>原子性</strong></h4><p><strong>原子性即一个操作或者多个操作，要么全部执行（执行的过程不会被任何因素打断），要么就都不执行</strong>。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。</p>
<p>在 Java 中，为了保证原子性，提供了两个高级的字节码指令 <code>monitorenter</code> 和 <code>monitorexit</code>。这两个字节码，在 Java 中对应的关键字就是 <code>synchronized</code>。</p>
<p>因此，在 Java 中可以使用 <code>synchronized</code> 来保证方法和代码块内的操作是原子性的。</p>
<h4 id="2-4-2-可见性"><a href="#2-4-2-可见性" class="headerlink" title="2.4.2 可见性"></a>2.4.2 可见性</h4><p><strong>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</strong>。</p>
<p>JMM 是通过 <strong>变量修改后将新值同步回主内存</strong>， <strong>变量读取前从主内存刷新变量值</strong>这种依赖主内存作为传递媒介的方式来实现的。</p>
<p>Java 实现多线程可见性的方式有：</p>
<ul>
<li><code>volatile</code></li>
<li><code>synchronized</code></li>
<li><code>final</code></li>
</ul>
<h4 id="2-4-3-有序性"><a href="#2-4-3-有序性" class="headerlink" title="2.4.3 有序性"></a>2.4.3 有序性</h4><p>有序性规则表现在以下两种场景: 线程内和线程间</p>
<ul>
<li>线程内 - 从某个线程的角度看方法的执行，指令会按照一种叫“串行”（<code>as-if-serial</code>）的方式执行，此种方式已经应用于顺序编程语言。</li>
<li>线程间 - 这个线程“观察”到其他线程并发地执行非同步的代码时，由于指令重排序优化，任何代码都有可能交叉执行。唯一起作用的约束是：对于同步方法，同步块（<code>synchronized</code> 关键字修饰）以及 <code>volatile</code> 字段的操作仍维持相对有序。</li>
</ul>
<p>在 Java 中，可以使用 <code>synchronized</code> 和 <code>volatile</code> 来保证多线程之间操作的有序性。实现方式有所区别：</p>
<ul>
<li><p><code>volatile</code> 关键字会禁止指令重排序。</p>
</li>
<li><p><code>synchronized</code> 关键字通过互斥保证同一时刻只允许一条线程操作。</p>
</li>
</ul>
<h2 id="3-Happens-Before"><a href="#3-Happens-Before" class="headerlink" title="3. Happens-Before"></a>3. Happens-Before</h2><p>JMM 为程序中所有的操作定义了一个偏序关系，称之为 **<code>先行发生原则（Happens-Before）</code>**。</p>
<p><strong>Happens-Before</strong> 是指 <strong>前面一个操作的结果对后续操作是可见的</strong>。</p>
<p><strong>Happens-Before</strong> 非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作间是否可能存在冲突的所有问题。</p>
<ul>
<li><strong>程序次序规则</strong> - 一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。</li>
<li><strong>锁定规则</strong> - 一个 <code>unLock</code> 操作先行发生于后面对同一个锁的 <code>lock</code> 操作。</li>
<li><strong>volatile 变量规则</strong> - 对一个 <code>volatile</code> 变量的写操作先行发生于后面对这个变量的读操作。</li>
<li><strong>线程启动规则</strong> - <code>Thread</code> 对象的 <code>start()</code> 方法先行发生于此线程的每个一个动作。</li>
<li><strong>线程终止规则</strong> - 线程中所有的操作都先行发生于线程的终止检测，我们可以通过 <code>Thread.join()</code> 方法结束、<code>Thread.isAlive()</code> 的返回值手段检测到线程已经终止执行。</li>
<li><strong>线程中断规则</strong> - 对线程 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 <code>Thread.interrupted()</code> 方法检测到是否有中断发生。</li>
<li><strong>对象终结规则</strong> - 一个对象的初始化完成先行发生于它的 <code>finalize()</code> 方法的开始。</li>
<li><strong>传递性</strong> - 如果操作 A 先行发生于 操作 B，而操作 B 又 先行发生于 操作 C，则可以得出操作 A 先行发生于 操作 C。</li>
</ul>
<h2 id="4-内存屏障"><a href="#4-内存屏障" class="headerlink" title="4. 内存屏障"></a>4. 内存屏障</h2><p>Java 中如何保证底层操作的有序性和可见性？可以通过内存屏障（memory barrier）。 </p>
<p>内存屏障是被插入两个 CPU 指令之间的一种指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障<strong>有序性</strong>的。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，如从而保障<strong>可见性</strong>。 </p>
<p>举个例子： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">Store1;<br>Store2;<br>Load1;<br>StoreLoad;  //内存屏障<br>Store3;<br>Load2;<br>Load3;<br></code></pre></td></tr></table></figure>

<p>对于上面的一组 CPU 指令（Store 表示写入指令，Load 表示读取指令），StoreLoad 屏障之前的 Store 指令无法与 StoreLoad 屏障之后的 Load 指令进行交换位置，即<strong>重排序</strong>。但是 StoreLoad 屏障之前和之后的指令是可以互换位置的，即 Store1 可以和 Store2 互换，Load2 可以和 Load3 互换。 </p>
<p>常见有 4 种屏障 </p>
<ul>
<li><code>LoadLoad</code> 屏障 - 对于这样的语句 <code>Load1; LoadLoad; Load2</code>，在 Load2 及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。</li>
<li><code>StoreStore</code> 屏障 - 对于这样的语句 <code>Store1; StoreStore; Store2</code>，在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其它处理器可见。</li>
<li><code>LoadStore</code> 屏障 - 对于这样的语句 <code>Load1; LoadStore; Store2</code>，在 Store2 及后续写入操作被执行前，保证 Load1 要读取的数据被读取完毕。</li>
<li><code>StoreLoad</code> 屏障 - 对于这样的语句 <code>Store1; StoreLoad; Load2</code>，在 Load2 及后续所有读取操作执行前，保证 Store1 的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li>
</ul>
<p>Java 中对内存屏障的使用在一般的代码中不太容易见到，常见的有 <code>volatile</code> 和 <code>synchronized</code> 关键字修饰的代码块(后面再展开介绍)，还可以通过 <code>Unsafe</code> 这个类来使用内存屏障。 </p>
<h2 id="5-volatile"><a href="#5-volatile" class="headerlink" title="5. volatile"></a>5. volatile</h2><p><code>volatile</code> 是 JVM 提供的 <strong>最轻量级的同步机制</strong>。 </p>
<p><code>volatile</code> 的中文意思是不稳定的，易变的，用 <code>volatile</code> 修饰变量是为了保证变量在多线程中的可见性。 </p>
<h4 id="5-1-volatile-变量的特性"><a href="#5-1-volatile-变量的特性" class="headerlink" title="5.1 volatile 变量的特性"></a>5.1 volatile 变量的特性</h4><p><code>volatile</code> 变量具有两种特性： </p>
<ul>
<li>保证变量对所有线程的可见性。</li>
<li>禁止进行指令重排序</li>
</ul>
<h5 id="5-1-1-保证变量对所有线程的可见性"><a href="#5-1-1-保证变量对所有线程的可见性" class="headerlink" title="5.1.1 保证变量对所有线程的可见性"></a>5.1.1 保证变量对所有线程的可见性</h5><p>这里的可见性是指当一条线程修改了 volatile 变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。 </p>
<p><strong>线程写 volatile 变量的过程：</strong> </p>
<ol>
<li>改变线程工作内存中 volatile 变量副本的值</li>
<li>将改变后的副本的值从工作内存刷新到主内存</li>
</ol>
<p><strong>线程读 volatile 变量的过程:</strong> </p>
<ol>
<li>从主内存中读取 volatile 变量的最新值到线程的工作内存中</li>
<li>从工作内存中读取 volatile 变量的副本</li>
</ol>
<blockquote>
<p>注意：<strong>保证可见性不等同于 volatile 变量保证并发操作的安全性</strong></p>
<p>在不符合以下两点的场景中，仍然要通过枷锁来保证原子性：</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他状态变量共同参与不变约束。</li>
</ul>
</blockquote>
<p>但是如果多个线程同时把更新后的变量值同时刷新回主内存，可能导致得到的值不是预期结果： </p>
<p>举个例子： 定义 <code>volatile int count = 0</code>，2 个线程同时执行 count++ 操作，每个线程都执行 500 次，最终结果小于 1000，原因是每个线程执行 count++ 需要以下 3 个步骤： </p>
<ol>
<li>线程从主内存读取最新的 count 的值</li>
<li>执行引擎把 count 值加 1，并赋值给线程工作内存</li>
<li>线程工作内存把 count 值保存到主内存 有可能某一时刻 2 个线程在步骤 1 读取到的值都是 100，执行完步骤 2 得到的值都是 101，最后刷新了 2 次 101 保存到主内存。</li>
</ol>
<h5 id="5-1-2-禁止进行指令重排序"><a href="#5-1-2-禁止进行指令重排序" class="headerlink" title="5.1.2 禁止进行指令重排序"></a>5.1.2 禁止进行指令重排序</h5><p>具体一点解释，禁止重排序的规则如下： </p>
<ul>
<li>当程序执行到 <code>volatile</code> 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</li>
<li>在进行指令优化时，不能将在对 <code>volatile</code> 变量访问的语句放在其后面执行，也不能把 <code>volatile</code> 变量后面的语句放到其前面执行。</li>
</ul>
<p>普通的变量仅仅会保证该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证赋值操作的顺序与程序代码中的执行顺序一致。 </p>
<p>举个例子： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> initialized = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-comment">// 下面代码线程A中执行</span><br><span class="hljs-comment">// 读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用</span><br>doSomethingReadConfg();<br>initialized = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">// 下面代码线程B中执行</span><br><span class="hljs-comment">// 等待initialized 为true，代表线程A已经把配置信息初始化完成</span><br><span class="hljs-keyword">while</span> (!initialized) &#123;<br>     sleep();<br>&#125;<br><span class="hljs-comment">// 使用线程A初始化好的配置信息</span><br>doSomethingWithConfig();<br></code></pre></td></tr></table></figure>

<p>上面代码中如果定义 initialized 变量时没有使用 volatile 修饰，就有可能会由于指令重排序的优化，导致线程 A 中最后一句代码 “initialized = true” 在 “doSomethingReadConfg()” 之前被执行，这样会导致线程 B 中使用配置信息的代码就可能出现错误，而 volatile 关键字就禁止重排序的语义可以避免此类情况发生。 </p>
<h4 id="5-2-volatile-的原理"><a href="#5-2-volatile-的原理" class="headerlink" title="5.2 volatile 的原理"></a>5.2 volatile 的原理</h4><p>具体实现方式是在编译期生成字节码时，会在指令序列中增加内存屏障来保证，下面是基于保守策略的 JMM 内存屏障插入策略： </p>
<ul>
<li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。 该屏障除了保证了屏障之前的写操作和该屏障之后的写操作不能重排序，还会保证了 volatile 写操作之前，任何的读写操作都会先于 volatile 被提交。</li>
<li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。 该屏障除了使 volatile 写操作不会与之后的读操作重排序外，还会刷新处理器缓存，使 volatile 变量的写更新对其他线程可见。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。 该屏障除了使 volatile 读操作不会与之前的写操作发生重排序外，还会刷新处理器缓存，使 volatile 变量读取的为最新值。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。 该屏障除了禁止了 volatile 读操作与其之后的任何写操作进行重排序，还会刷新处理器缓存，使其他线程 volatile 变量的写更新对 volatile 读操作的线程可见。</li>
</ul>
<h4 id="5-3-volatile-的使用场景"><a href="#5-3-volatile-的使用场景" class="headerlink" title="5.3 volatile 的使用场景"></a>5.3 volatile 的使用场景</h4><p>总结起来，就是“一次写入，到处读取”，某一线程负责更新变量，其他线程只读取变量(不更新变量)，并根据变量的新值执行相应逻辑。例如状态标志位更新，观察者模型变量值发布。 </p>
<h2 id="6-synchronized"><a href="#6-synchronized" class="headerlink" title="6. synchronized"></a>6. synchronized</h2><h3 id="6-1-long-和-double-变量的特殊规则"><a href="#6-1-long-和-double-变量的特殊规则" class="headerlink" title="6.1. long 和 double 变量的特殊规则"></a>6.1. long 和 double 变量的特殊规则</h3><p>JMM 要求 lock、unlock、read、load、assign、use、store、write 这 8 种操作都具有原子性，但是对于 64 位的数据类型（long 和 double），在模型中特别定义相对宽松的规定：允许虚拟机将没有被 <code>volatile</code> 修饰的 64 位数据的读写操作分为 2 次 32 位的操作来进行，即允许虚拟机可选择不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。由于这种非原子性，有可能导致其他线程读到同步未完成的“32 位的半个变量”的值。 </p>
<p>不过实际开发中，Java 内存模型强烈建议虚拟机把 64 位数据的读写实现为具有原子性，目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的 long 和 double 变量专门声明为 volatile。 </p>
<h3 id="6-2-final-型量的特殊规则"><a href="#6-2-final-型量的特殊规则" class="headerlink" title="6.2. final 型量的特殊规则"></a>6.2. final 型量的特殊规则</h3><p>我们知道，final 成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。 final 关键字的可见性是指：被 final 修饰的字段在声明时或者构造器中，一旦初始化完成，那么在其他线程无须同步就能正确看见 final 字段的值。这是因为一旦初始化完成，final 变量的值立刻回写到主内存。 </p>
<h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><p><a href="https://dunwu.github.io/javacore/concurrent/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html#_1-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">文章转载自顿悟的“Java内存模型</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java原子类</title>
    <url>/2022/05/27/Java%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-原子变量类简介"><a href="#1-原子变量类简介" class="headerlink" title="1. 原子变量类简介"></a>1. 原子变量类简介</h2><h3 id="1-1-为何需要原子变量类"><a href="#1-1-为何需要原子变量类" class="headerlink" title="1.1. 为何需要原子变量类"></a>1.1. 为何需要原子变量类</h3><p>保证线程安全是 Java 并发编程必须要解决的重要问题。Java 从原子性、可见性、有序性这三大特性入手，确保多线程的数据一致性。 </p>
<ul>
<li>确保线程安全最常见的做法是利用锁机制（<code>Lock</code>、<code>sychronized</code>）来对共享数据做互斥同步，这样在同一个时刻，只有一个线程可以执行某个方法或者某个代码块，那么操作必然是原子性的，线程安全的。互斥同步最主要的问题是线程阻塞和唤醒所带来的性能问题。</li>
<li><code>volatile</code> 是轻量级的锁（自然比普通锁性能要好），它保证了共享变量在多线程中的可见性，但无法保证原子性。所以，它只能在一些特定场景下使用。</li>
<li>为了兼顾原子性以及锁带来的性能问题，Java 引入了 CAS （主要体现在 <code>Unsafe</code> 类）来实现非阻塞同步（也叫乐观锁）。并基于 CAS ，提供了一套原子工具类。</li>
</ul>
<h3 id="1-2-原子变量类的作用"><a href="#1-2-原子变量类的作用" class="headerlink" title="1.2. 原子变量类的作用"></a>1.2. 原子变量类的作用</h3><p>原子变量类 <strong>比锁的粒度更细，更轻量级</strong>，并且对于在多处理器系统上实现高性能的并发代码来说是非常关键的。原子变量将发生竞争的范围缩小到单个变量上。 </p>
<p>原子变量类相当于一种泛化的 <code>volatile</code> 变量，能够<strong>支持原子的、有条件的读/改/写操</strong>作。 </p>
<p>原子类在内部使用 CAS 指令（基于硬件的支持）来实现同步。这些指令通常比锁更快。 </p>
<p>原子变量类可以分为 4 组： </p>
<ul>
<li>基本类型<ul>
<li><code>AtomicBoolean</code> - 布尔类型原子类</li>
<li> <code>AtomicInteger</code>  -  整型原子类 </li>
<li><code>AtomicLong</code> - 长整型原子类</li>
</ul>
</li>
<li>引用类型<ul>
<li><code>AtomicReference</code> - 引用类型原子类</li>
<li><code>AtomicMarkableReference</code> - 带有标记位的引用类型原子类</li>
<li><code>AtomicStampedReference</code> - 带有版本号的引用类型原子类</li>
</ul>
</li>
<li> 数组类型 </li>
<li><code>AtomicIntegerArray</code> - 整形数组原子类</li>
<li><code>AtomicLongArray</code> - 长整型数组原子类</li>
<li><code>AtomicReferenceArray</code> - 引用类型数组原子类</li>
<li> 属性更新器类型 </li>
<li><code>AtomicIntegerFieldUpdater</code> - 整型字段的原子更新器。</li>
<li><code>AtomicLongFieldUpdater</code> - 长整型字段的原子更新器。</li>
<li><code>AtomicReferenceFieldUpdater</code> - 原子更新引用类型里的字段。</li>
</ul>
<h2 id="2-基本类型"><a href="#2-基本类型" class="headerlink" title="2.基本类型"></a>2.基本类型</h2><p>这一类型的原子类是针对 Java 基本类型进行操作。 </p>
<ul>
<li><code>AtomicBoolean</code> - 布尔类型原子类</li>
<li><code>AtomicInteger</code> - 整型原子类</li>
<li><code>AtomicLong</code> - 长整型原子类</li>
</ul>
<p>以上类都支持 CAS（<a href="https://en.wikipedia.org/wiki/Compare-and-swap">compare-and-swap</a>）技术，此外，<code>AtomicInteger</code>、<code>AtomicLong</code> 还支持算术运算。 </p>
<blockquote>
<p>虽然 Java 只提供了 <code>AtomicBoolean</code> 、<code>AtomicInteger</code>、<code>AtomicLong</code>，但是可以模拟其他基本类型的原子变量。要想模拟其他基本类型的原子变量，可以将 <code>short</code> 或 <code>byte</code> 等类型与 <code>int</code> 类型进行转换，以及使用 <code>Float.floatToIntBits</code> 、<code>Double.doubleToLongBits</code> 来转换浮点数。</p>
<p>由于 <code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code> 实现方式、使用方式都相近，所以本文仅针对 <code>AtomicInteger</code> 进行介绍</p>
</blockquote>
<h3 id="2-1-AtomicInteger-用法"><a href="#2-1-AtomicInteger-用法" class="headerlink" title="2.1. AtomicInteger 用法"></a>2.1. <strong><code>AtomicInteger</code> 用法</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-comment">// 获取当前值</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span> <span class="hljs-comment">// 获取当前值，并设置新值</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span><span class="hljs-comment">// 获取当前值，并自增</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndDecrement</span><span class="hljs-params">()</span> <span class="hljs-comment">// 获取当前值，并自减</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> delta)</span> <span class="hljs-comment">// 获取当前值，并加上预期值</span></span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> <span class="hljs-comment">// 如果输入值（update）等于预期值，将该值设置为输入值</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lazySet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span> <span class="hljs-comment">// 最终设置为 newValue，使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></code></pre></td></tr></table></figure>

<p><code>AtomicInteger</code> 使用示例： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>        AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            executorService.submit((Runnable) () -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; count=&quot;</span> + count.get());<br>                count.incrementAndGet();<br>            &#125;);<br>        &#125;<br><br>        executorService.shutdown();<br>        executorService.awaitTermination(<span class="hljs-number">30</span>, TimeUnit.SECONDS);<br>        System.out.println(<span class="hljs-string">&quot;Final Count is : &quot;</span> + count.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-2-AtomicInteger-实现"><a href="#2-2-AtomicInteger-实现" class="headerlink" title="2.2. AtomicInteger 实现"></a>2.2. <strong><code>AtomicInteger</code> 实现</strong></h3><p>阅读 <code>AtomicInteger</code> 源码，可以看到如下定义： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> valueOffset;<br><br><span class="hljs-keyword">static</span> &#123;<br>	<span class="hljs-keyword">try</span> &#123;<br>		valueOffset = unsafe.objectFieldOffset<br>			(AtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>	&#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(ex); &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> value;<br></code></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li><code>value</code> - value 属性使用 <code>volatile</code> 修饰，使得对 value 的修改在并发环境下对所有线程可见。</li>
<li><code>valueOffset</code> - value 属性的偏移量，通过这个偏移量可以快速定位到 value 字段，这个是实现 AtomicInteger 的关键。</li>
<li><code>unsafe</code> - Unsafe 类型的属性，它为 <code>AtomicInteger</code> 提供了 CAS 操作。</li>
</ul>
<h2 id="3-引用类型"><a href="#3-引用类型" class="headerlink" title="3. 引用类型"></a>3. 引用类型</h2><p>Java 数据类型分为 <strong>基本数据类型</strong> 和 <strong>引用数据类型</strong> 两大类 </p>
<p>上一节中提到了针对基本数据类型的原子类，那么如果想针对引用类型做原子操作怎么办？Java 也提供了相关的原子类： </p>
<ul>
<li><code>AtomicReference</code> - 引用类型原子类</li>
<li><code>AtomicMarkableReference</code> - 带有标记位的引用类型原子类</li>
<li><code>AtomicStampedReference</code> - 带有版本号的引用类型原子类</li>
</ul>
<p><code>AtomicStampedReference</code> 类在引用类型原子类中，彻底地解决了 ABA 问题，其它的 CAS 能力与另外两个类相近，所以最具代表性。因此，本节只针对 <code>AtomicStampedReference</code> 进行说明。 </p>
<p>示例：基于 <code>AtomicReference</code> 实现一个简单的自旋锁 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicReferenceDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        threadSafeDemo();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">threadSafeDemo</span> <span class="hljs-params">()</span> </span>&#123;<br>        SpinLock lock = <span class="hljs-keyword">new</span> SpinLock();<br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            executorService.execute(<span class="hljs-keyword">new</span> MyThread(lock));<br>        &#125;<br>        executorService.shutdown();<br>    &#125;<br><br><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基于 &#123;<span class="hljs-doctag">@link</span> AtomicReference&#125; 实现的简单自旋锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpinLock</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>            Thread thread = Thread.currentThread();<br><br>            <span class="hljs-keyword">while</span> (!atomicReference.compareAndSet(<span class="hljs-keyword">null</span>,thread)) &#123;&#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>            Thread current = Thread.currentThread();<br>            atomicReference.compareAndSet(current,<span class="hljs-keyword">null</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> SpinLock lock;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(SpinLock lock)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.lock = lock;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                lock.lock();<br>                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 卖出了第 &quot;</span> + ticket + <span class="hljs-string">&quot; 张票&quot;</span>);<br>                    ticket --;<br>                &#125;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>原子类的实现基于 CAS 机制，而 CAS 存在 ABA 问题, 正是为了解决 ABA 问题,才有了<code> AtomicMarkableReference</code> 和 <code>AtomicStampedReference</code>。 </p>
<p><code>AtomicMarkableReference</code> 使用一个布尔值作为标记，修改时在 true / false 之间切换。这种策略不能根本上解决 ABA 问题，但是可以降低 ABA 发生的几率。常用于缓存或者状态描述这样的场景。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicMarkableReferenceDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String INIT_TEXT = <span class="hljs-string">&quot;abc&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><br>        <span class="hljs-keyword">final</span> AtomicMarkableReference&lt;String&gt; amr = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(INIT_TEXT, <span class="hljs-keyword">false</span>);<br><br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            executorService.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(Math.abs((<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">100</span>)));<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br><br>                    String name = Thread.currentThread().getName();<br>                    <span class="hljs-keyword">if</span> (amr.compareAndSet(INIT_TEXT, name, amr.isMarked(), !amr.isMarked())) &#123;<br>                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 修改了对象！&quot;</span>);<br>                        System.out.println(<span class="hljs-string">&quot;新的对象为：&quot;</span> + amr.getReference());<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br><br>        executorService.shutdown();<br>        executorService.awaitTermination(<span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-1</span> 修改了对象！<br>新的对象为：pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure>

<p><strong><code>AtomicStampedReference</code> 使用一个整型值做为版本号，每次更新前先比较版本号，如果一致，才进行修改</strong>。通过这种策略，可以根本上解决 ABA 问题。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicStampedReferenceDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String INIT_REF = <span class="hljs-string">&quot;pool-1-thread-3&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; asr = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(INIT_REF,<span class="hljs-number">0</span>);<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;初始对象为：&quot;</span> + asr.getReference());<br><br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            executorService.execute(<span class="hljs-keyword">new</span> MyThread());<br>        &#125;<br><br>        executorService.shutdown();<br>        executorService.awaitTermination(<span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(Math.abs((<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">100</span>)));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> stamp = asr.getStamp();<br><br>            <span class="hljs-keyword">if</span> (asr.compareAndSet(INIT_REF,Thread.currentThread().getName(),stamp,stamp + <span class="hljs-number">1</span>)) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 修改了对象！&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;新的对象为：&quot;</span> + asr.getReference());<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="4-数组类型"><a href="#4-数组类型" class="headerlink" title="4.数组类型"></a>4.数组类型</h2><p>Java 提供了以下针对数组的原子类： </p>
<ul>
<li><code>AtomicIntegerArray</code> - 整形数组原子类</li>
<li><code>AtomicLongArray</code> - 长整型数组原子类</li>
<li><code>AtomicReferenceArray</code> - 引用类型数组原子类</li>
</ul>
<p>已经有了针对基本类型和引用类型的原子类，为什么还要提供针对数组的原子类呢？ </p>
<p>数组类型的原子类为 <strong>数组元素</strong> 提供了 <code>volatile</code> 类型的访问语义，这是普通数组所不具备的特性——**<code>volatile</code> 类型的数组仅在数组引用上具有 <code>volatile</code> 语义**。 </p>
<p>示例：<code>AtomicIntegerArray</code> 使用示例（<code>AtomicLongArray</code> 、<code>AtomicReferenceArray</code> 使用方式也类似） </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerArrayDemo</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicIntegerArray atomicIntegerArray = <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Init Values: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; atomicIntegerArray.length(); i++ ) &#123;<br>            atomicIntegerArray.set(i,i);<br>            System.out.print(atomicIntegerArray.get(i) + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br><br>        System.out.println();<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Increment());<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Compare());<br>        t1.start();<br>        t2.start();<br><br>        t1.join();<br>        t2.join();<br><br>        System.out.println(<span class="hljs-string">&quot;Final Values: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; atomicIntegerArray.length(); i++) &#123;<br>            System.out.print(atomicIntegerArray.get(i) + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Increment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; atomicIntegerArray.length(); i++) &#123;<br>                <span class="hljs-keyword">int</span> value = atomicIntegerArray.incrementAndGet(i);<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;, index = &quot;</span> + i + <span class="hljs-string">&quot;, value = &quot;</span> + value);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compare</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; atomicIntegerArray.length(); i++) &#123;<br>                <span class="hljs-keyword">boolean</span> compareAndSet = atomicIntegerArray.compareAndSet(i, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>                <span class="hljs-keyword">if</span> (compareAndSet) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; swapped, index = &quot;</span> + i + <span class="hljs-string">&quot;, value = 3&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Init Values: <br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <br>Thread-<span class="hljs-number">0</span>, index = <span class="hljs-number">0</span>, value = <span class="hljs-number">1</span><br>Thread-<span class="hljs-number">1</span> swapped, index = <span class="hljs-number">2</span>, value = <span class="hljs-number">3</span><br>Thread-<span class="hljs-number">0</span>, index = <span class="hljs-number">1</span>, value = <span class="hljs-number">2</span><br>Thread-<span class="hljs-number">0</span>, index = <span class="hljs-number">2</span>, value = <span class="hljs-number">4</span><br>Thread-<span class="hljs-number">0</span>, index = <span class="hljs-number">3</span>, value = <span class="hljs-number">4</span><br>Thread-<span class="hljs-number">0</span>, index = <span class="hljs-number">4</span>, value = <span class="hljs-number">5</span><br>Thread-<span class="hljs-number">0</span>, index = <span class="hljs-number">5</span>, value = <span class="hljs-number">6</span><br>Thread-<span class="hljs-number">0</span>, index = <span class="hljs-number">6</span>, value = <span class="hljs-number">7</span><br>Thread-<span class="hljs-number">0</span>, index = <span class="hljs-number">7</span>, value = <span class="hljs-number">8</span><br>Thread-<span class="hljs-number">0</span>, index = <span class="hljs-number">8</span>, value = <span class="hljs-number">9</span><br>Thread-<span class="hljs-number">0</span>, index = <span class="hljs-number">9</span>, value = <span class="hljs-number">10</span><br>Final Values: <br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <br></code></pre></td></tr></table></figure>



<h2 id="5-属性更新器类型"><a href="#5-属性更新器类型" class="headerlink" title="5.属性更新器类型"></a>5.属性更新器类型</h2><p>更新器类支持基于反射机制的更新字段值的原子操作。 </p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code> - 整型字段的原子更新器。</li>
<li><code>AtomicLongFieldUpdater</code> - 长整型字段的原子更新器。</li>
<li><code>AtomicReferenceFieldUpdater</code> - 原子更新引用类型里的字段。</li>
</ul>
<p>这些类的使用有一定限制： </p>
<ul>
<li>因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 <code>newUpdater()</code> 创建一个更新器，并且需要设置想要更新的类和属性。</li>
<li>字段必须是 <code>volatile</code> 类型的；</li>
<li>不能作用于静态变量（<code>static</code>）；</li>
<li>不能作用于常量（<code>final</code>）；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicReferenceFieldUpdaterDemo</span> </span>&#123;<br><br><br>    <span class="hljs-keyword">static</span> User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;begin&quot;</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>            executorService.execute(<span class="hljs-keyword">new</span> MyThread());<br>        &#125;<br>        executorService.shutdown();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> AtomicReferenceFieldUpdater&lt;User,String&gt; updater = AtomicReferenceFieldUpdater.newUpdater(User.class,String.class,<span class="hljs-string">&quot;name&quot;</span>);<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>        <span class="hljs-keyword">volatile</span> String name;<br><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (updater.compareAndSet(user,<span class="hljs-string">&quot;begin&quot;</span>,<span class="hljs-string">&quot;end&quot;</span>)) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.MICROSECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;已修改 name = &quot;</span> + user.getName());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;已被其他线程修改&quot;</span>);<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6-原子化的累加器"><a href="#6-原子化的累加器" class="headerlink" title="6. 原子化的累加器"></a>6. 原子化的累加器</h2><p><code>DoubleAccumulator</code>、<code>DoubleAdder</code>、<code>LongAccumulator</code> 和 <code>LongAdder</code>，这四个类仅仅用来执行累加操作，相比原子化的基本数据类型，速度更快，但是不支持 <code>compareAndSet()</code> 方法。如果你仅仅需要累加操作，使用原子化的累加器性能会更好，代价就是会消耗更多的内存空间。 </p>
<p><code>LongAdder</code> 内部由一个 <code>base</code> 变量和一个 <code>cell[]</code> 数组组成。 </p>
<ul>
<li>当只有一个写线程，没有竞争的情况下，<code>LongAdder</code> 会直接使用 <code>base</code> 变量作为原子操作变量，通过 CAS 操作修改变量；</li>
<li>当有多个写线程竞争的情况下，除了占用 <code>base</code> 变量的一个写线程之外，其它各个线程会将修改的变量写入到自己的槽 <code>cell[]</code> 数组中。</li>
</ul>
<p>我们可以发现，<code>LongAdder</code> 在操作后的返回值只是一个近似准确的数值，但是 <code>LongAdder</code> 最终返回的是一个准确的数值， 所以在一些对实时性要求比较高的场景下，<code>LongAdder</code> 并不能取代 <code>AtomicInteger</code> 或 <code>AtomicLong</code>。 </p>
<h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><p><a href="https://dunwu.github.io/javacore/concurrent/Java%E5%8E%9F%E5%AD%90%E7%B1%BB.html#_1-%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%B1%BB%E7%AE%80%E4%BB%8B">引自JavaCore的原子类并做一些修改</a></p>
<ul>
<li><p><a href="http://tutorials.jenkov.com/java-util-concurrent/atomicinteger.html">http://tutorials.jenkov.com/java-util-concurrent/atomicinteger.html</a></p>
</li>
<li><p><a href="http://tutorials.jenkov.com/java-util-concurrent/atomicintegerarray.html">http://tutorials.jenkov.com/java-util-concurrent/atomicintegerarray.html</a></p>
</li>
<li><p><a href="http://tutorials.jenkov.com/java-util-concurrent/atomicreference.html">http://tutorials.jenkov.com/java-util-concurrent/atomicreference.html</a></p>
</li>
<li><p><a href="http://tutorials.jenkov.com/java-util-concurrent/atomicstampedreference.htm">http://tutorials.jenkov.com/java-util-concurrent/atomicstampedreference.htm</a></p>
</li>
<li><p><a href="https://book.douban.com/subject/10484692/">《Java 并发编程实战》</a></p>
</li>
<li><p><a href="https://book.douban.com/subject/26591326/">《Java 并发编程的艺术》</a></p>
</li>
<li><p><a href="http://www.itsoku.com/article/182">JUC 中的原子类</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-反射机制</title>
    <url>/2021/11/09/Java%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-反射简介"><a href="#1-反射简介" class="headerlink" title="1.反射简介"></a>1.反射简介</h2><h3 id="1-1-什么是反射"><a href="#1-1-什么是反射" class="headerlink" title="1.1 什么是反射"></a>1.1 什么是反射</h3><blockquote>
<p>Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为动态语言的关键。（引自百度百科）</p>
</blockquote>
<p>核心反射机制<code> java.lang.reflect</code>提供对任意类的编程访问,给定一个Class对象，你可以获得<code>Constructor</code>、<code>Method</code> 和 <code>Field</code> 实例分别代表了该 <code>Class</code> 实例所表示的类的构造器、方法和字段。这些对象提供对类 的成员名、字段类型、方法签名等的编程访问。此外，<code>Constructor</code>、<code>Method</code> 和 <code>Field</code> 实例允许你反射性地操作它们的底层对应项：你可以通过调用 <code>Constructor</code>、 <code>Method</code> 和 <code>Field</code> 实例上的方法，可以构造底层类的实例、调用底层类的方法，并访问底层类中的字段。</p>
<h3 id="1-2-反射的应用场景"><a href="#1-2-反射的应用场景" class="headerlink" title="1.2. 反射的应用场景"></a>1.2. 反射的应用场景</h3><p>反射的主要应用场景有：</p>
<ul>
<li><strong>开发通用框架</strong> - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</li>
<li><strong>动态代理</strong> - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。</li>
<li><strong>注解</strong> - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。</li>
<li><strong>可扩展性功能</strong> - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。</li>
</ul>
<h3 id="1-3-反射优点"><a href="#1-3-反射优点" class="headerlink" title="1.3.反射优点"></a>1.3.反射优点</h3><ul>
<li>增加程序的灵活性，避免将程序写死到代码里</li>
<li>代码简洁，提高代码的复用率，外部调用方便</li>
<li>对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法</li>
</ul>
<h3 id="1-4-反射缺点"><a href="#1-4-反射缺点" class="headerlink" title="1.4.反射缺点"></a>1.4.反射缺点</h3><ul>
<li><strong>失去了编译时类型检查的所有好处</strong>，包括异常检查。如果一个程序试图反射性地调用一个不存在的或不可访 问的方法，它将在运行时失败，除非你采取了特殊的预防措施。</li>
<li><strong>执行反射访问所需的代码既笨拙又冗长</strong>。 写起来很乏味，读起来也很困难。</li>
<li><strong>性能降低。</strong>反射方法调用比普通方法调用慢得多。到底慢了多少还很难说，因为有很多因素在起作用。在我的 机器上，调用一个没有输入参数和返回 int 类型的方法时，用反射执行要慢 11 倍。</li>
</ul>
<h2 id="2-反射机制"><a href="#2-反射机制" class="headerlink" title="2.反射机制"></a>2.反射机制</h2><h3 id="2-1-类加载过程"><a href="#2-1-类加载过程" class="headerlink" title="2.1. 类加载过程"></a>2.1. 类加载过程</h3><p><img src="/%5Cimg%5Cwork%5C1636379724292.png"></p>
<p> 类加载的完整过程如下： </p>
<ol>
<li>在编译时，Java 编译器编译好 <code>.java</code> 文件之后，在磁盘中产生 <code>.class</code> 文件。<code>.class</code> 文件是二进制文件，内容是只有 JVM 能够识别的机器码。</li>
<li>JVM 中的类加载器读取字节码文件，取出二进制数据，加载到内存中，解析.class 文件内的信息。类加载器会根据类的全限定名来获取此类的二进制字节流；然后，将字节流所代表的静态存储结构转化为方法区的运行时数据结构；接着，在内存中生成代表这个类的 <code>java.lang.Class</code> 对象。</li>
<li>加载结束后，JVM 开始进行连接阶段（包含验证、准备、初始化）。经过这一系列操作，类的变量会被初始化。</li>
</ol>
<h3 id="2-2-Class-对象"><a href="#2-2-Class-对象" class="headerlink" title="2.2. Class 对象"></a>2.2. Class 对象</h3><p>要想使用反射，首先需要获得待操作的类所对应的 Class 对象。<strong>Java 中，无论生成某个类的多少个对象，这些对象都会对应于同一个 Class 对象。这个 Class 对象是由 JVM 生成的，通过它能够获悉整个类的结构</strong>。所以，<code>java.lang.Class</code> 可以视为所有反射 API 的入口点。</p>
<p><strong>反射的本质就是：在运行时，把 Java 类中的各种成分映射成一个个的 Java 对象。</strong></p>
<p> 举例来说，假如定义了以下代码： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">User user = <span class="hljs-keyword">new</span> User();<br></code></pre></td></tr></table></figure>

<p> 步骤说明： </p>
<ol>
<li>JVM 加载方法的时候，遇到 <code>new User()</code>，JVM 会根据 <code>User</code> 的全限定名去加载 <code>User.class</code> 。</li>
<li>JVM 会去本地磁盘查找 <code>User.class</code> 文件并加载 JVM 内存中。</li>
<li>JVM 通过调用类加载器自动创建这个类对应的 <code>Class</code> 对象，并且存储在 JVM 的方法区。注意：<strong>一个类有且只有一个 <code>Class</code> 对象</strong>。</li>
</ol>
<h3 id="2-3-方法的反射调用"><a href="#2-3-方法的反射调用" class="headerlink" title="2.3. 方法的反射调用"></a>2.3. 方法的反射调用</h3><p>方法的反射调用，也就是 <code>Method.invoke</code> 方法。</p>
<p><code>Method.invoke</code> 方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Method</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Executable</span> </span>&#123;<br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span> <span class="hljs-keyword">throws</span> ... </span>&#123;<br>    ... <span class="hljs-comment">// 权限检查</span><br>    MethodAccessor ma = methodAccessor;<br>    <span class="hljs-keyword">if</span> (ma == <span class="hljs-keyword">null</span>) &#123;<br>      ma = acquireMethodAccessor();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ma.invoke(obj, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Method.invoke</code> 方法实际上委派给 <code>MethodAccessor</code> 接口来处理。它有两个已有的具体实现：</p>
<ul>
<li><code>NativeMethodAccessorImpl</code>：本地方法来实现反射调用</li>
<li><code>DelegatingMethodAccessorImpl</code>：委派模式来实现反射调用</li>
</ul>
<p>每个 <code>Method</code> 实例的第一次反射调用都会生成一个委派实现（<code>DelegatingMethodAccessorImpl</code>），它所委派的具体实现便是一个本地实现（<code>NativeMethodAccessorImpl</code>）。本地实现非常容易理解。当进入了 Java 虚拟机内部之后，我们便拥有了 <code>Method</code> 实例所指向方法的具体地址。这时候，反射调用无非就是将传入的参数准备好，然后调用进入目标方法。</p>
<h3 id="2-4-反射调用的开销"><a href="#2-4-反射调用的开销" class="headerlink" title="2.4. 反射调用的开销"></a>2.4. 反射调用的开销</h3><p>方法的反射调用会带来不少性能开销，原因主要有三个：</p>
<ul>
<li>变长参数方法导致的 Object 数组</li>
<li>基本类型的自动装箱、拆箱</li>
<li>还有最重要的方法内联</li>
</ul>
<p> <code>Class.forName</code> 会调用本地方法，<code>Class.getMethod</code> 则会遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法。可想而知，这两个操作都非常费时。 </p>
<blockquote>
<p> 注意，以 <code>getMethod</code> 为代表的查找方法操作，会返回查找得到结果的一份拷贝。因此，我们应当避免在热点代码中使用返回 <code>Method</code> 数组的 <code>getMethods</code> 或者 <code>getDeclaredMethods</code> 方法，以减少不必要的堆空间消耗。在实践中，我们往往会在应用程序中缓存 <code>Class.forName</code> 和 <code>Class.getMethod</code> 的结果。 </p>
</blockquote>
<p> 下面只关注反射调用本身的性能开销。 </p>
<p>第一，由于 Method.invoke 是一个变长参数方法，在字节码层面它的最后一个参数会是 Object 数组（感兴趣的同学私下可以用 javap 查看）。Java 编译器会在方法调用处生成一个长度为传入参数数量的 Object 数组，并将传入参数一一存储进该数组中。</p>
<p>第二，由于 Object 数组不能存储基本类型，Java 编译器会对传入的基本类型参数进行自动装箱。</p>
<p>这两个操作除了带来性能开销外，还可能占用堆内存，使得 GC 更加频繁。（如果你感兴趣的话，可以用虚拟机参数 -XX:+PrintGC 试试。）那么，如何消除这部分开销呢？</p>
<h2 id="3-使用反射"><a href="#3-使用反射" class="headerlink" title="3. 使用反射"></a>3. 使用反射</h2><h3 id="3-1-java-lang-reflect-包"><a href="#3-1-java-lang-reflect-包" class="headerlink" title="3.1. java.lang.reflect 包"></a>3.1. java.lang.reflect 包</h3><p> Java 中的 <code>java.lang.reflect</code> 包提供了反射功能。<code>java.lang.reflect</code> 包中的类都没有 <code>public</code> 构造方法。 </p>
<p> <code>java.lang.reflect</code> 包的核心接口和类如下： </p>
<ul>
<li><code>Member</code> 接口：反映关于单个成员(字段或方法)或构造函数的标识信息。</li>
<li><code>Field</code> 类：提供一个类的域的信息以及访问类的域的接口。</li>
<li><code>Method</code> 类：提供一个类的方法的信息以及访问类的方法的接口。</li>
<li><code>Constructor</code> 类：提供一个类的构造函数的信息以及访问类的构造函数的接口。</li>
<li><code>Array</code> 类：该类提供动态地生成和访问 JAVA 数组的方法。</li>
<li><code>Modifier</code> 类：提供了 static 方法和常量，对类和成员访问修饰符进行解码。</li>
<li><code>Proxy</code> 类：提供动态地生成代理类和类实例的静态方法。</li>
</ul>
<h3 id="3-2-获取-Class-对象"><a href="#3-2-获取-Class-对象" class="headerlink" title="3.2. 获取 Class 对象"></a>3.2. 获取 Class 对象</h3><p> 获取 <code>Class</code> 对象的三种方法： </p>
<p> （1）**<code>Class.forName</code> 静态方法** </p>
<p> 【示例】使用 <code>Class.forName</code> 静态方法获取 <code>Class</code> 对象 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectClassDemo01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        Class c1 = Class.forName(<span class="hljs-string">&quot;io.github.dunwu.javacore.reflect.ReflectClassDemo01&quot;</span>);<br>        System.out.println(c1.getCanonicalName());<br><br>        Class c2 = Class.forName(<span class="hljs-string">&quot;[D&quot;</span>);<br>        System.out.println(c2.getCanonicalName());<br><br>        Class c3 = Class.forName(<span class="hljs-string">&quot;[[Ljava.lang.String;&quot;</span>);<br>        System.out.println(c3.getCanonicalName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//io.github.dunwu.javacore.reflect.ReflectClassDemo01</span><br><span class="hljs-comment">//double[]</span><br><span class="hljs-comment">//java.lang.String[][]</span><br></code></pre></td></tr></table></figure>

<p> 使用类的完全限定名来反射对象的类。常见的应用场景为：在 JDBC 开发中常用此方法加载数据库驱动。 </p>
<p> （2）<strong>类名 + <code>.class</code></strong> </p>
<p> 【示例】直接用类名 + <code>.class</code> 获取 <code>Class</code> 对象 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectClassDemo02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> b;<br>        <span class="hljs-comment">// Class c = b.getClass(); // 编译错误</span><br>        Class c1 = <span class="hljs-keyword">boolean</span>.class;<br>        System.out.println(c1.getCanonicalName());<br><br>        Class c2 = java.io.PrintStream.class;<br>        System.out.println(c2.getCanonicalName());<br><br>        Class c3 = <span class="hljs-keyword">int</span>[][][].class;<br>        System.out.println(c3.getCanonicalName());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//boolean</span><br><span class="hljs-comment">//java.io.PrintStream</span><br><span class="hljs-comment">//int[][][]</span><br></code></pre></td></tr></table></figure>

<p> （3）**<code>Object</code> 的 <code>getClass</code> 方法** </p>
<p><code>Object</code> 类中有 <code>getClass</code> 方法，因为所有类都继承 <code>Object</code> 类。从而调用 <code>Object</code> 类来获取 <code>Class</code> 对象。</p>
<p>【示例】<code>Object</code> 的 <code>getClass</code> 方法获取 <code>Class</code> 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectClassDemo03</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">E</span> </span>&#123;A, B&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Class c = <span class="hljs-string">&quot;foo&quot;</span>.getClass();<br>        System.out.println(c.getCanonicalName());<br><br>        Class c2 = ReflectClassDemo03.E.A.getClass();<br>        System.out.println(c2.getCanonicalName());<br><br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        Class c3 = bytes.getClass();<br>        System.out.println(c3.getCanonicalName());<br><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        Class c4 = set.getClass();<br>        System.out.println(c4.getCanonicalName());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//java.lang.String</span><br><span class="hljs-comment">//io.github.dunwu.javacore.reflect.ReflectClassDemo.E</span><br><span class="hljs-comment">//byte[]</span><br><span class="hljs-comment">//java.util.HashSet</span><br></code></pre></td></tr></table></figure>





<h3 id="3-3-判断是否为某个类的实例"><a href="#3-3-判断是否为某个类的实例" class="headerlink" title="3.3. 判断是否为某个类的实例"></a>3.3. 判断是否为某个类的实例</h3><p>判断是否为某个类的实例有两种方式：</p>
<ol>
<li><strong>用 <code>instanceof</code> 关键字</strong></li>
<li><strong>用 <code>Class</code> 对象的 <code>isInstance</code> 方法</strong>（它是一个 Native 方法）</li>
</ol>
<p> 【示例】 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceofDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList arrayList = <span class="hljs-keyword">new</span> ArrayList();<br>        <span class="hljs-keyword">if</span> (arrayList <span class="hljs-keyword">instanceof</span> List) &#123;<br>            System.out.println(<span class="hljs-string">&quot;ArrayList is List&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (List.class.isInstance(arrayList)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;ArrayList is List&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//ArrayList is List</span><br><span class="hljs-comment">//ArrayList is List</span><br></code></pre></td></tr></table></figure>



<h3 id="3-4-创建实例"><a href="#3-4-创建实例" class="headerlink" title="3.4. 创建实例"></a>3.4. 创建实例</h3><p> 通过反射来创建实例对象主要有两种方式： </p>
<ul>
<li>用 <code>Class</code> 对象的 <code>newInstance</code> 方法。</li>
<li>用 <code>Constructor</code> 对象的 <code>newInstance</code> 方法。</li>
</ul>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewInstanceDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;<br>        Class&lt;?&gt; c1 = StringBuilder.class;<br>        StringBuilder sb = (StringBuilder) c1.newInstance();<br>        sb.append(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        System.out.println(sb.toString());<br><br>        <span class="hljs-comment">//获取String所对应的Class对象</span><br>        Class&lt;?&gt; c2 = String.class;<br>        <span class="hljs-comment">//获取String类带一个String参数的构造器</span><br>        Constructor constructor = c2.getConstructor(String.class);<br>        <span class="hljs-comment">//根据构造器创建实例</span><br>        String str2 = (String) constructor.newInstance(<span class="hljs-string">&quot;bbb&quot;</span>);<br>        System.out.println(str2);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//aaa</span><br><span class="hljs-comment">//bbb</span><br></code></pre></td></tr></table></figure>

<h3 id="3-5-创建数组实例"><a href="#3-5-创建数组实例" class="headerlink" title="3.5. 创建数组实例"></a>3.5. 创建数组实例</h3><p> 数组在 Java 里是比较特殊的一种类型，它可以赋值给一个对象引用。Java 中，<strong>通过 <code>Array.newInstance</code> 创建数组的实例</strong>。 </p>
<p> 【示例】利用反射创建数组 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectArrayDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        Class&lt;?&gt; cls = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br>        Object array = Array.newInstance(cls, <span class="hljs-number">25</span>);<br>        <span class="hljs-comment">//往数组里添加内容</span><br>        Array.set(array, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Scala&quot;</span>);<br>        Array.set(array, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br>        Array.set(array, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;Groovy&quot;</span>);<br>        Array.set(array, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;Scala&quot;</span>);<br>        Array.set(array, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;Clojure&quot;</span>);<br>        <span class="hljs-comment">//获取某一项的内容</span><br>        System.out.println(Array.get(array, <span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Output:</span><br><span class="hljs-comment">//Scala</span><br></code></pre></td></tr></table></figure>

<p> 其中的 Array 类为 <code>java.lang.reflect.Array</code> 类。我们<code>Array.newInstance</code> 的原型是： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newInstance</span><span class="hljs-params">(Class&lt;?&gt; componentType, <span class="hljs-keyword">int</span> length)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> NegativeArraySizeException </span>&#123;<br>    <span class="hljs-keyword">return</span> newArray(componentType, length);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-6-Field"><a href="#3-6-Field" class="headerlink" title="3.6. Field"></a>3.6. Field</h3><p><code>Class</code> 对象提供以下方法获取对象的成员（<code>Field</code>）：</p>
<ul>
<li><code>getFiled</code> - 根据名称获取公有的（public）类成员。</li>
<li><code>getDeclaredField</code> - 根据名称获取已声明的类成员。但不能得到其父类的类成员。</li>
<li><code>getFields</code> - 获取所有公有的（public）类成员。</li>
<li><code>getDeclaredFields</code> - 获取所有已声明的类成员。</li>
</ul>
<p> 示例如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectFieldDemo</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldSpy</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span>[][] b = &#123; &#123;<span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>&#125;, &#123;<span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>&#125; &#125;;<br>        <span class="hljs-keyword">public</span> String name = <span class="hljs-string">&quot;Alice&quot;</span>;<br>        <span class="hljs-keyword">public</span> List&lt;Integer&gt; list;<br>        <span class="hljs-keyword">public</span> T val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException </span>&#123;<br>        Field f1 = FieldSpy.class.getField(<span class="hljs-string">&quot;b&quot;</span>);<br>        System.out.format(<span class="hljs-string">&quot;Type: %s%n&quot;</span>, f1.getType());<br><br>        Field f2 = FieldSpy.class.getField(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.format(<span class="hljs-string">&quot;Type: %s%n&quot;</span>, f2.getType());<br><br>        Field f3 = FieldSpy.class.getField(<span class="hljs-string">&quot;list&quot;</span>);<br>        System.out.format(<span class="hljs-string">&quot;Type: %s%n&quot;</span>, f3.getType());<br><br>        Field f4 = FieldSpy.class.getField(<span class="hljs-string">&quot;val&quot;</span>);<br>        System.out.format(<span class="hljs-string">&quot;Type: %s%n&quot;</span>, f4.getType());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Output:</span><br><span class="hljs-comment">//Type: class [[Z</span><br><span class="hljs-comment">//Type: class java.lang.String</span><br><span class="hljs-comment">//Type: interface java.util.List</span><br><span class="hljs-comment">//Type: class java.lang.Object</span><br></code></pre></td></tr></table></figure>

<h3 id="3-7-Method"><a href="#3-7-Method" class="headerlink" title="3.7. Method"></a>3.7. Method</h3><p> <code>Class</code> 对象提供以下方法获取对象的方法（<code>Method</code>）： </p>
<ul>
<li><code>getMethod</code> - 返回类或接口的特定方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。</li>
<li><code>getDeclaredMethod</code> - 返回类或接口的特定声明方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。</li>
<li><code>getMethods</code> - 返回类或接口的所有 public 方法，包括其父类的 public 方法。</li>
<li><code>getDeclaredMethods</code> - 返回类或接口声明的所有方法，包括 public、protected、默认（包）访问和 private 方法，但不包括继承的方法。</li>
</ul>
<p>获取一个 <code>Method</code> 对象后，可以用 <code>invoke</code> 方法来调用这个方法。</p>
<p><code>invoke</code> 方法的原型为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><br><span class="hljs-function">           InvocationTargetException</span><br></code></pre></td></tr></table></figure>

<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectMethodDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;<br><br>        <span class="hljs-comment">// 返回所有方法</span><br>        Method[] methods1 = System.class.getDeclaredMethods();<br>        System.out.println(<span class="hljs-string">&quot;System getDeclaredMethods 清单（数量 = &quot;</span> + methods1.length + <span class="hljs-string">&quot;）：&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Method m : methods1) &#123;<br>            System.out.println(m);<br>        &#125;<br><br>        <span class="hljs-comment">// 返回所有 public 方法</span><br>        Method[] methods2 = System.class.getMethods();<br>        System.out.println(<span class="hljs-string">&quot;System getMethods 清单（数量 = &quot;</span> + methods2.length + <span class="hljs-string">&quot;）：&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Method m : methods2) &#123;<br>            System.out.println(m);<br>        &#125;<br><br>        <span class="hljs-comment">// 利用 Method 的 invoke 方法调用 System.currentTimeMillis()</span><br>        Method method = System.class.getMethod(<span class="hljs-string">&quot;currentTimeMillis&quot;</span>);<br>        System.out.println(method);<br>        System.out.println(method.invoke(<span class="hljs-keyword">null</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-8-Constructor"><a href="#3-8-Constructor" class="headerlink" title="3.8. Constructor"></a>3.8. Constructor</h3><p><code>Class</code> 对象提供以下方法获取对象的构造方法（<code>Constructor</code>）：</p>
<ul>
<li><code>getConstructor</code> - 返回类的特定 public 构造方法。参数为方法参数对应 Class 的对象。</li>
<li><code>getDeclaredConstructor</code> - 返回类的特定构造方法。参数为方法参数对应 Class 的对象。</li>
<li><code>getConstructors</code> - 返回类的所有 public 构造方法。</li>
<li><code>getDeclaredConstructors</code> - 返回类的所有构造方法。</li>
</ul>
<p>获取一个 <code>Constructor</code> 对象后，可以用 <code>newInstance</code> 方法来创建类实例。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectMethodConstructorDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;<br>        Constructor&lt;?&gt;[] constructors1 = String.class.getDeclaredConstructors();<br>        System.out.println(<span class="hljs-string">&quot;String getDeclaredConstructors 清单（数量 = &quot;</span> + constructors1.length + <span class="hljs-string">&quot;）：&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Constructor c : constructors1) &#123;<br>            System.out.println(c);<br>        &#125;<br><br>        Constructor&lt;?&gt;[] constructors2 = String.class.getConstructors();<br>        System.out.println(<span class="hljs-string">&quot;String getConstructors 清单（数量 = &quot;</span> + constructors2.length + <span class="hljs-string">&quot;）：&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Constructor c : constructors2) &#123;<br>            System.out.println(c);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;====================&quot;</span>);<br>        Constructor constructor = String.class.getConstructor(String.class);<br>        System.out.println(constructor);<br>        String str = (String) constructor.newInstance(<span class="hljs-string">&quot;bbb&quot;</span>);<br>        System.out.println(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-9-绕开访问限制"><a href="#3-9-绕开访问限制" class="headerlink" title="3.9. 绕开访问限制"></a>3.9. 绕开访问限制</h3><p>有时候，我们需要通过反射访问私有成员、方法。可以使用 <code>Constructor/Field/Method.setAccessible(true)</code> 来绕开 Java 语言的访问限制。</p>
<p>参考</p>
<hr>
<p><a href="/img/work/Effective.Java.pdf">Effective-Java</a></p>
<p>引用</p>
<hr>
<p><a href="https://dunwu.github.io/javacore/basics/java-reflection.html#_1-%E5%8F%8D%E5%B0%84%E7%AE%80%E4%BB%8B">Java反射机制</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-泛型</title>
    <url>/2021/10/24/Java%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。<a href="http://baike.baidu.com/view/229611.htm">Java语言</a>引入泛型的好处是安全简单。</p>
<p>在Java SE 1.5之前，没有泛型的<a href="http://baike.baidu.com/view/780206.htm">情况</a>的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的<a href="http://baike.baidu.com/view/2886403.htm">强制类型转换</a>，而这种转换是要求开发者对<a href="http://baike.baidu.com/view/2245196.htm">实际参数</a>类型可以预知的情况下进行的。对于强制类型转换错误的情况，<a href="http://baike.baidu.com/view/487018.htm">编译器</a>可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。<br> 泛型的好处是在编译的时候检查<a href="http://baike.baidu.com/view/1965709.htm">类型安全</a>，并且所有的<a href="http://baike.baidu.com/view/965170.htm">强制转换</a>都是自动和<a href="http://baike.baidu.com/view/2852863.htm">隐式</a>的，以提高代码的重用率。</p>
</blockquote>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p><strong>Box类定义为一个泛型类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T object;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T object)</span> </span>&#123; <span class="hljs-keyword">this</span>.object = object; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> object; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>创建一个Box对象，不带泛型参数，发现获取对象的时候需要强制转换</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Box box2 = <span class="hljs-keyword">new</span> Box();<br>box2.set(<span class="hljs-keyword">new</span> Apple());<br>Apple apple = (Apple) box2.get();<br></code></pre></td></tr></table></figure>

<p><strong>创建一个Box对象，带泛型参数，获取对象的时候就不需要强制转换</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Box&lt;Apple&gt; box = <span class="hljs-keyword">new</span> Box&lt;Apple&gt;();<br>box.set(<span class="hljs-keyword">new</span> Apple());<br>Apple apple = box.get();<br></code></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>泛型省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上</strong></p>
<blockquote>
<p>泛型的核心概念是<strong>参数化类型</strong>，使用参数指定方法类型，而非硬编码。泛型的出现带给我们很多好处，其中最重要的莫过于对集合类的改进，避免了任意类型都可以丢到同一个集合里的不可靠问题。</p>
</blockquote>
<h3 id="泛型使用简介"><a href="#泛型使用简介" class="headerlink" title="泛型使用简介"></a>泛型使用简介</h3><p>泛型一般有三种使用方式：泛型类、泛型接口和泛型方法。</p>
<p><strong>泛型类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T member;<br>&#125;<br>...<br><span class="hljs-comment">// 初始化时指定泛型类型</span><br>Test&lt;String&gt; instance = <span class="hljs-keyword">new</span> Test&lt;String&gt;();<br></code></pre></td></tr></table></figure>

<p><strong>泛型接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T param)</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 实现类指定泛型类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TestInterface</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String param)</span> </span>&#123;...&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>泛型方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在方法前添加&lt;T&gt;,泛型类型可用于返回值也可用于参数</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">function</span><span class="hljs-params">(T param)</span></span>;<br>...<br>function(<span class="hljs-string">&quot;123&quot;</span>); <span class="hljs-comment">// 编译器自动识别T为String</span><br></code></pre></td></tr></table></figure>



<h3 id="泛型通配符T，E，K，V区别"><a href="#泛型通配符T，E，K，V区别" class="headerlink" title="泛型通配符T，E，K，V区别"></a>泛型通配符T，E，K，V区别</h3><p>T,E,K,V都属于java泛型的通配符,刚开始我看到这么多通配符，一下晕了，这几个其实<strong>没什么区别</strong>，只不过是一个约定好的代码，也就是说</p>
<blockquote>
<p><strong>使用大写字母A,B,C,D……X,Y,Z定义的，就都是泛型，把T换成A也一样，这里T只是名字上的意义而已</strong></p>
<ul>
<li><strong>？</strong> 表示不确定的java类型</li>
<li><strong>T (type)</strong> 表示具体的一个java类型</li>
<li><strong>K V (key value)</strong> 分别代表java键值中的Key Value</li>
<li><strong>E (element)</strong> 代表Element</li>
</ul>
</blockquote>
<p><strong>举例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <br>  <span class="hljs-keyword">public</span> List&lt;T&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;T&gt;();   <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test&lt;String&gt; test = <span class="hljs-keyword">new</span> Test&lt;String&gt;();<br>        test.list.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>        System.out.println(test.list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">A</span>&gt; </span>&#123;    <br>  <span class="hljs-keyword">public</span> List&lt;A&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;A&gt;();   <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test&lt;String&gt; test = <span class="hljs-keyword">new</span> Test&lt;String&gt;();<br>        test.list.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>        System.out.println(test.list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将T换成了A，在执行效果上是没有任何区别的，只不过我们约定好了T代表type，所以还是<strong>按照约定规范来比较好</strong>，增加了代码的可读性。</p>
<p>如果要定义<strong>多个</strong>泛型参数，比如说两个泛型参数</p>
<p>很典型的一个例子是Map的key,value泛型，我们也可以定义一个这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Mymap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MymapImpl</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Mymap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> K key;<br>    <span class="hljs-keyword">private</span> V value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MymapImpl</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.key = key;<br>    <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span>   </span>&#123; <span class="hljs-keyword">return</span> key; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来就可以传入任意类型，创建实例了，不用转化类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Mymap&lt;String, Integer&gt; mp1= <span class="hljs-keyword">new</span> MymapImpl&lt;String, Integer&gt;(<span class="hljs-string">&quot;Even&quot;</span>, <span class="hljs-number">8</span>);<br>Mymap&lt;String, String&gt;  mp2= <span class="hljs-keyword">new</span> MymapImpl&lt;String, String&gt;(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>Mymap&lt;Integer, Integer&gt; mp3= <span class="hljs-keyword">new</span> MymapImpl&lt;Integer, Integer&gt;(<span class="hljs-number">888</span>, <span class="hljs-number">888</span>);<br></code></pre></td></tr></table></figure>

<p>如果要定义<strong>超过两个，三个或三个以上</strong>的泛型参数可以使用<strong>T1, T2, …, Tn</strong>，像这</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T1</span>,<span class="hljs-title">T2</span>,<span class="hljs-title">T3</span>&gt; </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T1 t1,T2 t2,T3 t3)</span></span>&#123;<br>        System.out.println(t1.getClass());<br>        System.out.println(t2.getClass());<br>        System.out.println(t3.getClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="List-lt-T-gt-，List-lt-Object-gt-，List-lt-gt-区别"><a href="#List-lt-T-gt-，List-lt-Object-gt-，List-lt-gt-区别" class="headerlink" title="List&lt;T&gt;，List&lt; Object &gt;，List&lt;?&gt;区别"></a><code>List&lt;T&gt;</code>，List&lt; Object &gt;，List&lt;?&gt;区别</h3><blockquote>
<p><strong><code>ArrayList&lt;T&gt;</code> al=new ArrayList&lt; T&gt;();</strong> 指定集合元素只能是T类型</p>
<p><strong>ArrayList&lt; ?&gt; al=new ArrayList&lt; ?&gt;();</strong> 集合元素可以是任意类型，这种没有意义，一般是方法中，只是为了说明用法</p>
</blockquote>
<p><strong>ArrayList&lt;? extends E&gt; al=new ArrayList&lt;? extends E&gt;();</strong></p>
<p>泛型的限定：</p>
<p><strong>? extends E</strong>:接收E类型或者E的子类型。</p>
<p><strong>? super E</strong>:接收E类型或者E的父类型。</p>
<ul>
<li>Object和T不同点在于，Object是一个实打实的类,并没有泛指谁，而T可以泛指Object，比方<strong>public void printList(List&lt; T&gt; list){}<strong>方法中可以传入</strong>List&lt; Object&gt; list</strong>类型参数，也可以传入<strong>List&lt; String&gt; list</strong>类型参数，但是<strong>public void printList(List&lt; Object&gt; list){}<strong>就只可以传入</strong>List&lt; Object&gt; list</strong>类型参数，因为Object类型并没有泛指谁，是一个确定的类型。</li>
<li>?和T区别是:?是一个不确定类，？和T都表示不确定的类型 ，但如果是T的话，函数里面可以对T进行操作，比方 T car = getCar()，而不能用？ car = getCar()。</li>
</ul>
<p>以下举例比较三种情况:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDifferenceBetweenObjectAndT</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printList1</span><span class="hljs-params">(List&lt;Object&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Object elem : list)<br>            System.out.println(elem + <span class="hljs-string">&quot; &quot;</span>);<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printList2</span><span class="hljs-params">(List&lt;T&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (T elem : list)<br>            System.out.println(elem + <span class="hljs-string">&quot; &quot;</span>);<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">printList3</span><span class="hljs-params">(List&lt;?&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;list.size();i++)<br>            System.out.println(list.get(i) + <span class="hljs-string">&quot; &quot;</span>);<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; test1 = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        List&lt;String&gt;  test2 = Arrays.asList(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>);<br>        List&lt;Object&gt; test3 = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-number">1.23</span>);<br>        List&lt;Fruit&gt; test4 = Arrays.asList(<span class="hljs-keyword">new</span> Apple(), <span class="hljs-keyword">new</span> Banana());<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 下面这句会编译报错，因为参数不能转化成功</span><br><span class="hljs-comment">        * */</span><br>        printList1(test4);<br>        <span class="hljs-comment">/**/</span><br><span class="hljs-comment">        printList1(test3);</span><br><span class="hljs-comment">        printList1(test3);</span><br><span class="hljs-comment">        printList2(test1);</span><br><span class="hljs-comment">        printList2(test2);</span><br><span class="hljs-comment">        printList2(test3);</span><br><span class="hljs-comment">        printList3(test1);</span><br><span class="hljs-comment">        printList3(test2);</span><br><span class="hljs-comment">        printList3(test3);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure>



<h3 id="T，Class-lt-T-gt-，Class-lt-gt-区别"><a href="#T，Class-lt-T-gt-，Class-lt-gt-区别" class="headerlink" title="T，Class&lt;T&gt;，Class&lt;?&gt;区别"></a>T，<code>Class&lt;T&gt;</code>，Class&lt;?&gt;区别</h3><p>T是一种具体的类，例如String,List,Map……等等，这些都是属于具体的类</p>
<p>Class是什么呢，Class也是一个类，但Class是存放上面String,List,Map……类信息的一个类</p>
<p>如何获取到Class类呢，有三种方式：</p>
<p><strong>1.调用Object类的getClass()方法来得到Class对象，这也是最常见的产生Class对象的方法。</strong></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List list = <span class="hljs-keyword">null</span>;<br>Class clazz = list.getClass();<br></code></pre></td></tr></table></figure>



<p><strong>2.使用Class类的中静态forName()方法获得与字符串对应的Class对象。</strong></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Class clazz = Class.forName(<span class="hljs-string">&quot;xx.xx.xx.xx.People&quot;</span>);<br></code></pre></td></tr></table></figure>



<p><strong>3.获取Class类型对象的第三个方法非常简单。如果T是一个Java类型，那么T.class就代表了匹配的类对象。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Class clazz = List.class;<br></code></pre></td></tr></table></figure>

<p><strong>Class类是创建出来了，但是Class&lt; T&gt;和Class&lt;?&gt;适用于什么时候</strong></p>
<p>使用Class&lt; T&gt;和Class&lt; ?&gt;多发生在反射场景下，先看看如果我们不使用泛型，反射创建一个类是什么样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">People people = (People) Class.forName(<span class="hljs-string">&quot;xx.xx.People&quot;</span>).newInstance();<br></code></pre></td></tr></table></figure>

<p>看到了么，需要强转，如果反射的类型不是People类，就会报<strong>java.lang.ClassCastException</strong>错误。</p>
<p>使用Class<T>泛型后，不用强转了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">createInstance</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;<br>        <span class="hljs-keyword">return</span> clazz.newInstance();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException  </span>&#123;<br>            Fruit fruit= createInstance(Fruit .class);<br>            People people= createInstance(People.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那Class&lt; T&gt;和Class&lt; ?&gt;有什么区别呢？</p>
<p><strong>Class&lt; T&gt;在实例化的时候，T要替换成具体类</strong></p>
<p><strong>Class&lt;?&gt;它是个通配泛型，?可以代表任何类型，主要用于声明时的限制情况</strong></p>
<p>例如可以声明一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;?&gt; clazz;<br></code></pre></td></tr></table></figure>

<p>但是你不能声明一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;T&gt; clazz;<br></code></pre></td></tr></table></figure>

<p>因为T需要指定类型<br>所以当，不知道定声明什么类型的Class的时候可以定义一个Class&lt; ?&gt;,Class&lt;?&gt;可以用于参数类型定义，方法返回值定义等。</p>
<h3 id="深入Java泛型"><a href="#深入Java泛型" class="headerlink" title="深入Java泛型"></a>深入Java泛型</h3><h4 id="Java的伪泛型和类型擦除"><a href="#Java的伪泛型和类型擦除" class="headerlink" title="Java的伪泛型和类型擦除"></a>Java的伪泛型和类型擦除</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; strList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;Integer&gt; intList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>System.out.println(strList.getClass() == intList.getClass()); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>

<p>对如上部分代码，相信多数人接触到泛型的第一时刻都认为这是两个不同的类型，反编译其字节码获得代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ArrayList var1 = <span class="hljs-keyword">new</span> ArrayList();<br>ArrayList var2 = <span class="hljs-keyword">new</span> ArrayList();<br>System.out.println(var1.getClass() == var2.getClass());<br></code></pre></td></tr></table></figure>

<p>我们发现两个列表都变成ArrayList类型，如果大家对Jdk1.5之前的版本还有印象就可以看出，这一段反编译的代码就是Java集合最初的使用形式。因此，Java泛型的是通过<strong>编译期将泛型的实际类型擦除为原始类型(通常为Object)实现的伪泛型</strong>。</p>
<p>所谓伪泛型，是相对C++的”真泛型”(异构扩展，可见参考第三条)，在Java中，由于编译后擦除了具体类型，在<strong>泛型代码内部</strong>，无法获得任何有关泛型参数类型的信息，在运行期代码所持有的也只是擦除后的原始类型，也就意味着在运行期可以通过反射的方式为泛型类传入任何原始类型的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; ints = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        GenericTest test = <span class="hljs-keyword">new</span> GenericTest();<br>        List&lt;GenericTest&gt; list = (List&lt;GenericTest&gt;) GenericTest.class.getDeclaredField(<span class="hljs-string">&quot;ints&quot;</span>).get(test);<br>        list.add(<span class="hljs-keyword">new</span> GenericTest());<br>        System.out.println(test.ints.get(<span class="hljs-number">0</span>));   <span class="hljs-comment">// 打印GenericTest变量地址</span><br>        <span class="hljs-keyword">int</span> number = test.ints.get(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 类型转换抛出异常</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 泛型代码内部是指泛型类或泛型方法内部。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">getTClass</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">//无法获取 &#125;</span><br>&#125;<br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Class <span class="hljs-title">getParamClass</span><span class="hljs-params">(T param)</span> </span>&#123; <span class="hljs-comment">//无法获取 &#125;</span><br><br></code></pre></td></tr></table></figure>

<p>在泛型外部可以获取已指定的泛型参数类型，通过<code>javap -v</code>查看<code>Constant Pool</code>，可看到具体类型记录在<code>Signature</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span><br><span class="hljs-class">    <span class="hljs-title">private</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">String</span>&gt; <span class="hljs-title">list</span> </span>= <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-comment">//可以获取list的具体类型</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>事实上在Java推出泛型时，C++的模板泛型已经相当成熟，设计者也并非没有能力实现包含具体类型的泛型，使用类型擦除最重要的原因还是为了保持<strong>兼容性</strong>。假设<code>ArrayList&lt;String&gt;</code>和<code>ArrayList</code>编译后是不同的class，那么为了兼容旧代码正常运行，必须平行的添加一套泛型集合并在后续版本中同时维护，而集合类作为大量使用的基础工具类，开发者不得不为此承担大量代码切换的风险(参考<code>Vector</code>和<code>HashTable</code>的带来的遗留问题)，因此相较于兼容性的取舍，采用类型擦除实现泛型算是折中方案。</p>
<h3 id="Java泛型的上下界"><a href="#Java泛型的上下界" class="headerlink" title="Java泛型的上下界"></a>Java泛型的上下界</h3><p>前面说到泛型会被擦除为原始类型，一般是<code>Object</code>。如果泛型声明为<code>&lt;? extends Number&gt;</code>，就会被擦除为<code>Number</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Number&gt; numbers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;Integer&gt; integers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>numbers = integers;	<span class="hljs-comment">// compile error</span><br></code></pre></td></tr></table></figure>

<p>考虑以上代码，<code>numbers</code>可以增加<code>Integer</code>类型的元素，直觉上<code>integers</code>应该也可以赋值给<code>numbers</code>。由于类型擦除，Java在编译期限定了只有相同类型的泛型实例才可以互相赋值，但这样就违背了Java的多态，为了解决泛型转换的问题，Java引入了上下限<code>&lt;? extends A&gt;</code>和<code>&lt;? super B&gt;</code>两种机制。</p>
<p><strong>1.上界</strong></p>
<p>如果泛型声明为<code>&lt;? extends A&gt;</code>，即声明该泛型的上界也即擦除后的原始类型为<code>A</code>，同时该泛型类的实例可以引用<code>A</code>子类的泛型实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 上界保证取出来的元素一定是Number，但无法约束放入的类型</span><br>List&lt;Integer&gt; integers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;Float&gt; floats = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <br>List&lt;? extends Number&gt; numbers = integers;	<span class="hljs-comment">// numbers = floats; 也可以</span><br>numbers.get(<span class="hljs-number">0</span>);	<span class="hljs-comment">// ok，总能保证取出的一定是Number</span><br>numbers.put(<span class="hljs-number">1</span>);	<span class="hljs-comment">// compile error，无法保证放入的是否符合约束</span><br></code></pre></td></tr></table></figure>

<p><strong>2.下界</strong></p>
<p>如果泛型声明为<code>&lt;? super B&gt;</code>，即声明该泛型的下界为<code>B</code>，原始类型仍为<code>Object</code>，同时该泛型类的实力可以引用<code>B</code>父类的泛型实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设三个继承类 Child -&gt; Father -&gt; GrandFather</span><br><span class="hljs-comment">// 下界保证写入的元素一定是Child，但无法确定取出的类型</span><br>List&lt;Father&gt; fathers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;GrandFather&gt; grandFathers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;? <span class="hljs-keyword">super</span> Child&gt; childs = fathers;	<span class="hljs-comment">// childs = grandFathers; 也可以</span><br>numbers.put(<span class="hljs-keyword">new</span> Child());	<span class="hljs-comment">//ok，总能保证实际容器可接受Child</span><br>Child ele = (Child) numbers.get(<span class="hljs-number">0</span>);	<span class="hljs-comment">// runtime error，无法确定得到的具体类型</span><br></code></pre></td></tr></table></figure>



<p>在Java中，根据里式替换原则，向上转型是默认合法的，向下转型则需要强制转换，如不能转换则报错。在<code>extends</code>的<code>get</code>和<code>super</code>的<code>put</code>场景中，一定可以保证读取/放入的元素是可以向上转型的，而在<code>extends</code>的<code>put</code>和<code>super</code>的<code>get</code>中，则无法确认可转的类型，因此<code>extends</code>只能读取，<code>super</code>只能写入。</p>
<blockquote>
<p>当然如果使用super时，取出的对象以Object存放，也没有问题，因为super擦除后的原始类型为Object。</p>
</blockquote>
<p>参考《Effective Java》中给出的<code>PECS</code>使用建议。</p>
<blockquote>
<p>为了获得最大限度的灵活性，要在表示生产者或消费者的输入参数上使用通配符类型。</p>
<p>如果参数化类型表示一个T生产者，就使用&lt;? extends T&gt;。 producer-extends</p>
<p>如果参数化类型表示一个T消费者，就使用&lt;? super T&gt;。consumer-super</p>
<p>如果某个输入参数即是生产者又是消费者，那么通配符类型对你就没什么好处了。</p>
</blockquote>
<p><strong>个人认为</strong>对这段话的正确理解是以泛型为第一视角切入，即当<strong>泛型类型本身作为生产者提供功能</strong>(被读取)时使用<code>extends</code>，反之(被写入)使用<code>super</code>。而非常规意义上生产者要写入的容器采用<code>extends</code>，消费者读取的容器使用<code>super</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// producer，此时返回值作为生产后的结果提供给消费者</span><br>List&lt;? extends A&gt; writeBuffer(...);<br><span class="hljs-comment">// consumer，此时返回值作为消费后的结果提供给生产者</span><br>List&lt;? <span class="hljs-keyword">super</span> B&gt; readBuffer(...);<br></code></pre></td></tr></table></figure>



<h3 id="Java泛型的多态"><a href="#Java泛型的多态" class="headerlink" title="Java泛型的多态"></a>Java泛型的多态</h3><p>泛型类也可以被继承，泛型类主要有两种继承方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123; <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T param)</span></span>&#123;<br>    <br>  &#125; <br>&#125;<br><span class="hljs-comment">// 泛型继承，Child依然是泛型类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T param)</span></span>&#123;&#125; <br>&#125;<br><span class="hljs-comment">// 指定泛型类型，StringChild为具体类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringChild</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String param)</span></span>&#123;&#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们知道<code>@Override</code>是保持签名不变且重写父类方法，查看<code>Father</code>类字节码，其中test方法被擦除为<code>void test(Object param)</code>；在<code>StringChild</code>中，方法签名为<code>void test(String param)</code>。到此读者可能意识到，这根本不是重写而是重载(<code>Overload</code>)。</p>
<p>查看<code>StringChild</code>的字节码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">...<br>#<span class="hljs-number">3</span> = Methodref<br>...<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(java.lang.String)</span></span>;<br>    ...<br>    invokespecial #<span class="hljs-number">3</span> <span class="hljs-comment">// Method StringChild.test:(Ljava/lang.Object;) V</span><br>    ...<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(java.lang.Object)</span></span>;<br></code></pre></td></tr></table></figure>

<p>可以看到其中实际包含了两个方法，一个参数是<code>String</code>一个是<code>Object</code>，后者才是对父类方法的重写，前者通过invoke转到对后者的调用。这个方法是JVM在编译时自动添加的，也叫做<strong>桥方法</strong>。同时还有一点需要提及，示例中的代码是以泛型参数作为入参，作为返回类型的话会产生<code>Object test()</code>和<code>String test()</code>两个方法，这两个方法在常规的编码中是无法编译通过的，但JVM为泛型多态的实现允许了这个不合规的存在。</p>
<h3 id="Java泛型使用的局限"><a href="#Java泛型使用的局限" class="headerlink" title="Java泛型使用的局限"></a>Java泛型使用的局限</h3><ul>
<li>基本类型无法擦除为原始类型<code>Object</code>，因此范型不支持基本类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;<span class="hljs-keyword">int</span>&gt; intList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <span class="hljs-comment">// 无法编译</span><br></code></pre></td></tr></table></figure>

<ul>
<li>由于类型擦除，泛型代码内部在运行期无法获得具体类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">T instance = <span class="hljs-keyword">new</span> T();   <span class="hljs-comment">// 不能直接使用泛型初始化</span><br><span class="hljs-keyword">if</span> (t instanceOf T);    <span class="hljs-comment">// 不能判断泛型类型</span><br>T[] array = <span class="hljs-keyword">new</span> T[]&#123;&#125;;  <span class="hljs-comment">// 不能创建泛型数组</span><br></code></pre></td></tr></table></figure>

<ul>
<li>由于静态资源加载先于类型实例化，不能在静态代码块引用泛型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Error</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T t;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> t;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>异常类型的派生类不能添加泛型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设继承实现一个泛型异常</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeException</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span>...</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">try</span> </span>&#123;<br>    ...<br>&#125; <span class="hljs-keyword">catch</span>(SomeException&lt;Integer&gt; | SomeException&lt;String&gt; ex) &#123;<br>    <span class="hljs-comment">//由于类型擦除，无法捕获多个泛型异常</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>



<p>参考:</p>
<hr>
<p>程序鱼:<a href="https://www.jianshu.com/p/95f349258afb">https://www.jianshu.com/p/95f349258afb</a><br>拉夫德鲁:<a href="https://juejin.cn/post/6996285441943011341">https://juejin.cn/post/6996285441943011341</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发核心机制-volatile关键字</title>
    <url>/2022/05/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-volatile的作用详解"><a href="#1-volatile的作用详解" class="headerlink" title="1.volatile的作用详解"></a>1.volatile的作用详解</h2><h3 id="1-1-防重排序"><a href="#1-1-防重排序" class="headerlink" title="1.1 防重排序"></a>1.1 防重排序</h3><p>一个最经典的例子来分析重排序问题。大家应该都很熟悉单例模式的实现，而在并发环境下的单例实现方式，我们通常可以采用双重检查加锁(DCL)的方式来实现。其源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数私有，禁止外部实例化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;<br>                    singleton = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在我们分析一下为什么要在变量singleton之间加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：</p>
<ul>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>将内存空间的地址赋值给对应的应用</li>
</ul>
<p>但是由于操作系统<code>可以对指令进行重排序</code>，所以上面的过程也可能会变成如下过程：</p>
<ul>
<li>分配内存空间。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
<li>初始化对象</li>
</ul>
<p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。</p>
<h3 id="1-2-实现可见性"><a href="#1-2-实现可见性" class="headerlink" title="1.2 实现可见性"></a>1.2 实现可见性</h3><p>可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题，我们看下下面的例子,就可以知道其作用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileTest</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">()</span></span>&#123;<br>        a = <span class="hljs-number">3</span>;<br>        b = a;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;b=&quot;</span>+b+<span class="hljs-string">&quot;;a=&quot;</span>+a);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">final</span> VolatileTest test = <span class="hljs-keyword">new</span> VolatileTest();<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">10</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    test.change();<br>                &#125;<br>            &#125;).start();<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">10</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    test.print();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>直观上说，这段代码的结果只可能有两种：b=3;a=3 或 b=2;a=1。不过运行上面的代码(可能时间上要长一点)，你会发现除了上两种结果之外，还出现了第三种结果： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">...... <br>b=<span class="hljs-number">2</span>;a=<span class="hljs-number">1</span><br>b=<span class="hljs-number">2</span>;a=<span class="hljs-number">1</span><br>b=<span class="hljs-number">3</span>;a=<span class="hljs-number">3</span><br>b=<span class="hljs-number">3</span>;a=<span class="hljs-number">3</span><br>b=<span class="hljs-number">3</span>;a=<span class="hljs-number">1</span> <span class="hljs-comment">// 这里</span><br>b=<span class="hljs-number">3</span>;a=<span class="hljs-number">3</span><br>b=<span class="hljs-number">2</span>;a=<span class="hljs-number">1</span><br>b=<span class="hljs-number">3</span>;a=<span class="hljs-number">3</span><br>b=<span class="hljs-number">3</span>;a=<span class="hljs-number">3</span><br>......<br></code></pre></td></tr></table></figure>

<p>为什么会出现b=3;a=1这种结果呢? 正常情况下，如果先执行change方法，再执行print方法，输出结果应该为b=3;a=3。相反，如果先执行的print方法，再执行change方法，结果应该是 b=2;a=1。那b=3;a=1的结果是怎么出来的? 原因就是第一个线程将值a=3修改后，但是对第二个线程是不可见的，所以才出现这一结果。如果将a和b都改成volatile类型的变量再执行，则再也不会出现b=3;a=1的结果了。</p>
<h3 id="1-3-保证原子性-单次读-写"><a href="#1-3-保证原子性-单次读-写" class="headerlink" title="1.3 保证原子性:单次读/写"></a>1.3 保证原子性:单次读/写</h3><p>volatile不能保证完全的原子性，只能保证单次的读/写操作具有原子性。先从如下两个问题来理解:</p>
<p><strong>问题1：i++为什么不能保证原子性？</strong></p>
<p>对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单词读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读，写两次操作。</p>
<p>现在我们就通过下列程序来演示这个问题:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileTest01</span> </span>&#123;<br><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addI</span><span class="hljs-params">()</span> </span>&#123;<br>        i ++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        VolatileTest01 volatileTest01 = <span class="hljs-keyword">new</span> VolatileTest01();<br><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; n &lt; <span class="hljs-number">1000</span>; n++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">10</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                volatileTest01.addI();<br>            &#125;).start();<br><br>        &#125;<br><br>        Thread.sleep(<span class="hljs-number">10000</span>);<br>        System.out.println(volatileTest01.i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>大家可能会误认为对变量i加上关键字volatile后，这段程序就是线程安全的。大家可以尝试运行上面的程序。下面是我本地运行的结果：981 可能每个人运行的结果不相同。不过应该能看出，volatile是无法保证原子性的(否则结果应该是1000)。原因也很简单，i++其实是一个复合操作，包括三步骤：</p>
<ul>
<li>读取i的值。</li>
<li>对i加1。</li>
<li>将i的值写回内存。volatile是无法保证这三个是具有原子性的，我们可以通过 AtomicInteger或者Synchronized来保证+1操作的原子性。   注：上面几段代码中多处执行了Thread.sleep()方法，目的是为了增加并发问题的产生几率，无其他作用。 </li>
</ul>
<p><strong>问题2:共享的long和double变量的为什么要用volatile?</strong></p>
<p>因为long和double两种数据类型的操作可分为高32位和低32位两部分， 因此普通的long或double类型读/写</p>
<p>可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性 </p>
<h2 id="2-volatile-的实现原理"><a href="#2-volatile-的实现原理" class="headerlink" title="2.volatile 的实现原理"></a>2.volatile 的实现原理</h2><h3 id="2-1-volatile-可见性实现"><a href="#2-1-volatile-可见性实现" class="headerlink" title="2.1 volatile 可见性实现"></a>2.1 volatile 可见性实现</h3><blockquote>
<p> volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现: </p>
</blockquote>
<ul>
<li>内存屏障，又称内存栅栏，是一个cpu指令</li>
<li>在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM为了保证在不同的编译器和CPU上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU： 不管什么指令都不能和这条 Memory Barrier 指令重排序。 </li>
</ul>
<p>写一段简单的 Java 代码，声明一个 volatile 变量，并赋值。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        a = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test test = <span class="hljs-keyword">new</span> Test();<br>        test.update();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过 hsdis 和 jitwatch 工具可以得到编译后的汇编代码: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">......<br>  <span class="hljs-number">0x0000000002951563</span>: and    $<span class="hljs-number">0xffffffffffffff87</span>,%rdi<br>  <span class="hljs-number">0x0000000002951567</span>: je     <span class="hljs-number">0x00000000029515f8</span><br>  <span class="hljs-number">0x000000000295156d</span>: test   $<span class="hljs-number">0x7</span>,%rdi<br>  <span class="hljs-number">0x0000000002951574</span>: jne    <span class="hljs-number">0x00000000029515bd</span><br>  <span class="hljs-number">0x0000000002951576</span>: test   $<span class="hljs-number">0x300</span>,%rdi<br>  <span class="hljs-number">0x000000000295157d</span>: jne    <span class="hljs-number">0x000000000295159c</span><br>  <span class="hljs-number">0x000000000295157f</span>: and    $<span class="hljs-number">0x37f</span>,%rax<br>  <span class="hljs-number">0x0000000002951586</span>: mov    %rax,%rdi<br>  <span class="hljs-number">0x0000000002951589</span>: or     %r15,%rdi<br>  <span class="hljs-number">0x000000000295158c</span>: lock cmpxchg %rdi,(%rdx)  <span class="hljs-comment">//在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令</span><br>  <span class="hljs-number">0x0000000002951591</span>: jne    <span class="hljs-number">0x0000000002951a15</span><br>  <span class="hljs-number">0x0000000002951597</span>: jmpq   <span class="hljs-number">0x00000000029515f8</span><br>  <span class="hljs-number">0x000000000295159c</span>: mov    <span class="hljs-number">0x8</span>(%rdx),%edi<br>  <span class="hljs-number">0x000000000295159f</span>: shl    $<span class="hljs-number">0x3</span>,%rdi<br>  <span class="hljs-number">0x00000000029515a3</span>: mov    <span class="hljs-number">0xa8</span>(%rdi),%rdi<br>  <span class="hljs-number">0x00000000029515aa</span>: or     %r15,%rdi<br>......<br></code></pre></td></tr></table></figure>

<p>lock前缀的指令在多核处理下会引发两件事情:</p>
<ul>
<li> 将当前处理器缓存行的数据写回到系统内存 。</li>
<li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li>
</ul>
<p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2 或其他)后再进行操作，但操作完不知道何时会写到内存。 </p>
<p>如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。 </p>
<p>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>
<p>所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。  </p>
<p>volatile变量通过这样的机制就使得每个线程都能获得该变量的最新值。 </p>
<p><strong>lock 指令</strong></p>
<p>在 Pentium 和早期的 IA-32 处理器中，lock 前缀会使处理器执行当前指令时产生一个 LOCK# 信号，会对总线进行锁定，其它 CPU 对内存的读写请求都会被阻塞，直到锁释放。后来的处理器，加锁操作是由高速缓存锁代替总线锁来处理。 因为锁总线的开销比较大，锁总线期间其他 CPU 没法访问内存。 这种场景多缓存的数据一致通过缓存一致性协议(MESI)来保证。    </p>
<p><strong>缓存一致性</strong></p>
<p>缓存是分段(line)的，一个段对应一块存储空间，称之为缓存行，它是 CPU 缓存中可分配的最小存储单元，大小 32 字节、64 字节、128 字节不等，这与 CPU 架构有关，通常来说是 64 字节。LOCK# 因为锁总线效率太低，因此使用了多组缓存。为了使其行为看起来如同一组缓存那样。因而设计了 缓存一致性协议。缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 “ 嗅探(snooping)” 协议。所有内存的传输都发生在一条共享的总线上， 而所有的处理器都能看到这条总线。缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁(同一个指令周期中，只有一个 CPU 缓存可以读写内存)。 CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。 当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。       </p>
<h3 id="2-2-volatile-有序性实现"><a href="#2-2-volatile-有序性实现" class="headerlink" title="2.2 volatile 有序性实现"></a>2.2 volatile 有序性实现</h3><p><strong>volatile 的 happens-before 关系</strong></p>
<p>happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//假设线程A执行writer方法，线程B执行reader方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileExample</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span> </span>&#123;<br>        a = <span class="hljs-number">1</span>;              <span class="hljs-comment">// 1 线程A修改共享变量</span><br>        flag = <span class="hljs-keyword">true</span>;        <span class="hljs-comment">// 2 线程A写volatile变量</span><br>    &#125; <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (flag) &#123;         <span class="hljs-comment">// 3 线程B读同一个volatile变量</span><br>        <span class="hljs-keyword">int</span> i = a;          <span class="hljs-comment">// 4 线程B读共享变量</span><br>        ……<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。 </p>
<ul>
<li>根据程序次序规则：1 happens-before 2 且 3 happens-before 4。</li>
<li>根据 volatile 规则：2 happens-before 3。</li>
<li>根据 happens-before 的传递性规则：1 happens-before 4。</li>
</ul>
<p> <img src="/img/work/java-thread-x-key-volatile-1.png"> </p>
<p> 因为以上规则，当线程 A 将 volatile 变量 flag 更改为 true 后，线程 B 能够迅速感知。 </p>
<p><strong>volatile 禁止重排序</strong></p>
<p>为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。 </p>
<p>Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。 </p>
<p>JMM 会针对编译器制定 volatile 重排序规则表。 </p>
<p><img src="/img/work/1652099036495.png" alt="1652099036495"></p>
<p> “ NO “ 表示禁止重排序。 </p>
<p>为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
<p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。</p>
<ul>
<li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li>
<li> 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障 </li>
<li>在每个 volatile 读操作的前面插入一个 LoadLoad 屏障。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li>
</ul>
<p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。 </p>
<table>
<thead>
<tr>
<th align="center"><strong>内存屏障</strong></th>
<th align="center"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">StoreStore 屏障</td>
<td align="center">禁止上面的普通写和下面的 volatile 写重排序。</td>
</tr>
<tr>
<td align="center">StoreLoad 屏障</td>
<td align="center">防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。</td>
</tr>
<tr>
<td align="center">LoadLoad 屏障</td>
<td align="center">禁止下面所有的普通读操作和上面的 volatile 读重排序。</td>
</tr>
<tr>
<td align="center">LoadStore 屏障</td>
<td align="center">禁止下面所有的普通写操作和上面的 volatile 读重排序。</td>
</tr>
</tbody></table>
<p><img src="/img/work/1652099536430.png"></p>
<h2 id="3-volatile-的应用场景"><a href="#3-volatile-的应用场景" class="headerlink" title="3 volatile 的应用场景"></a>3 volatile 的应用场景</h2><p>使用 volatile 必须具备的条件 </p>
<ul>
<li>对变量的写操作不依赖于当前值。</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
<li>只有在状态真正独立于程序内其他内容时才能使用 volatile。</li>
</ul>
<h3 id="模式1：状态标志"><a href="#模式1：状态标志" class="headerlink" title="模式1：状态标志"></a><strong>模式1：状态标志</strong></h3><p>也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> shutdownRequested;<br>......<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123; shutdownRequested = <span class="hljs-keyword">true</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-keyword">while</span> (!shutdownRequested) &#123; <br>        <span class="hljs-comment">// do stuff</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="模式2：一次性安全发布-one-time-safe-publication"><a href="#模式2：一次性安全发布-one-time-safe-publication" class="headerlink" title="模式2：一次性安全发布(one-time safe publication)"></a><strong>模式2：一次性安全发布(one-time safe publication)</strong></h3><p>缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原始值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值(由另一个线程写入)和该对象状态的旧值同时存在。(这就是造成著名的双重检查锁定(double-checked-locking)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BackgroundFloobleLoader</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> Flooble theFlooble;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initInBackground</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// do lots of stuff</span><br>        theFlooble = <span class="hljs-keyword">new</span> Flooble();  <span class="hljs-comment">// this is the only write to theFlooble</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeOtherClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123; <br>            <span class="hljs-comment">// do some stuff...</span><br>            <span class="hljs-comment">// use the Flooble, but only if it is ready</span><br>            <span class="hljs-keyword">if</span> (floobleLoader.theFlooble != <span class="hljs-keyword">null</span>) <br>                doSomething(floobleLoader.theFlooble);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="模式3：独立观察-independent-observation"><a href="#模式3：独立观察-independent-observation" class="headerlink" title="模式3：独立观察(independent observation)"></a><strong>模式3：独立观察(independent observation)</strong></h3><p>安全使用 volatile 的另一种简单模式是定期 发布 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserManager</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> String lastUser;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">authenticate</span><span class="hljs-params">(String user, String password)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> valid = passwordIsValid(user, password);<br>        <span class="hljs-keyword">if</span> (valid) &#123;<br>            User u = <span class="hljs-keyword">new</span> User();<br>            activeUsers.add(u);<br>            lastUser = user;<br>        &#125;<br>        <span class="hljs-keyword">return</span> valid;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="模式4：volatile-bean-模式"><a href="#模式4：volatile-bean-模式" class="headerlink" title="模式4：volatile bean 模式"></a><strong>模式4：volatile bean 模式</strong></h3><p>在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义)。对于任何 volatile 变量，不变式或约束都不能包含 JavaBean 属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">著作权归https:<span class="hljs-comment">//pdai.tech所有。</span><br>链接：https:<span class="hljs-comment">//www.pdai.tech/md/java/thread/java-thread-x-key-volatile.html</span><br><br><span class="hljs-meta">@ThreadSafe</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> String firstName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> String lastName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> age;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFirstName</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> firstName; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLastName</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> lastName; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> age; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFirstName</span><span class="hljs-params">(String firstName)</span> </span>&#123; <br>        <span class="hljs-keyword">this</span>.firstName = firstName;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLastName</span><span class="hljs-params">(String lastName)</span> </span>&#123; <br>        <span class="hljs-keyword">this</span>.lastName = lastName;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123; <br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="模式5：开销较低的读－写锁策略"><a href="#模式5：开销较低的读－写锁策略" class="headerlink" title="模式5：开销较低的读－写锁策略"></a><strong>模式5：开销较低的读－写锁策略</strong></h3><p>volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作(读、添加、存储)的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。 如果读操作远远超过写操作，可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。 安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ThreadSafe</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheesyCounter</span> </span>&#123;<br>    <span class="hljs-comment">// Employs the cheap read-write lock trick</span><br>    <span class="hljs-comment">// All mutative operations MUST be done with the &#x27;this&#x27; lock held</span><br>    <span class="hljs-meta">@GuardedBy(&quot;this&quot;)</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> value;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="模式6：双重检查-double-checked"><a href="#模式6：双重检查-double-checked" class="headerlink" title="模式6：双重检查(double-checked)"></a><strong>模式6：双重检查(double-checked)</strong></h3><p>单例模式的一种实现方式，但很多人会忽略 volatile 关键字，因为没有该关键字，程序也可以很好的运行，只不过代码的稳定性总不是 100%，说不定在未来的某个时刻，隐藏的 bug 就出来了。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            syschronized(Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a><strong>参考:</strong></h2><ul>
<li><a href="https://blog.csdn.net/devotion987/article/details/68486942">https://blog.csdn.net/devotion987/article/details/68486942</a></li>
<li><a href="https://www.jianshu.com/p/ccfe24b63d87">https://www.jianshu.com/p/ccfe24b63d87</a></li>
<li><a href="https://www.pdai.tech/md/java/thread/java-thread-x-key-volatile.html">https://www.pdai.tech/md/java/thread/java-thread-x-key-volatile.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>并发核心机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发-锁核心AbstractQueuedSynchronizer详解</title>
    <url>/2022/05/20/Java%E5%B9%B6%E5%8F%91-%E9%94%81%E6%A0%B8%E5%BF%83AbstractQueuedSynchronizer%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础。</p>
<p>本文主要从AQS源码分析，分析AbstractQueuedSynchronizer如何实现加锁及解锁。</p>
<h2 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h2><p>先来看看 AQS 有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br><br><span class="hljs-comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br><br><span class="hljs-comment">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span><br><span class="hljs-comment">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;<br><br><span class="hljs-comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span><br><span class="hljs-comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span><br><span class="hljs-comment">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread; <span class="hljs-comment">//继承自AbstractOwnableSynchronizer</span><br></code></pre></td></tr></table></figure>

<p>怎么样，看样子应该是很简单的吧，毕竟也就四个属性啊。 </p>
<p>AbstractQueuedSynchronizer 的等待队列示意如下所示，注意了，之后分析过程中所说的 queue，也就是阻塞队列<strong>不包含 head，不包含 head，不包含 head</strong>。 </p>
<p><img src="/img/work/aqs-0.png"> </p>
<p>等待队列中每个线程被包装成一个 Node 实例，数据结构是链表，一起看看源码吧： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-comment">// 标识节点当前在共享模式下</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();<br>    <span class="hljs-comment">// 标识节点当前在独占模式下</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// ======== 下面的几个int常量是给waitStatus用的 ===========</span><br>    <span class="hljs-comment">/** waitStatus value to indicate thread has cancelled */</span><br>    <span class="hljs-comment">// 代码此线程取消了争抢这个锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span><br>    <span class="hljs-comment">// 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/** waitStatus value to indicate thread is waiting on condition */</span><br>    <span class="hljs-comment">// 本文不分析condition，所以略过吧，下一篇文章会介绍这个</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * waitStatus value to indicate the next acquireShared should</span><br><span class="hljs-comment">     * unconditionally propagate</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 同样的不分析，略过吧</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;<br>    <span class="hljs-comment">// =====================================================</span><br><br><br>    <span class="hljs-comment">// 取值为上面的1、-1、-2、-3，或者0(以后会讲到)</span><br>    <span class="hljs-comment">// 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span><br>    <span class="hljs-comment">//    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;<br>    <span class="hljs-comment">// 前驱节点的引用</span><br>    <span class="hljs-keyword">volatile</span> Node prev;<br>    <span class="hljs-comment">// 后继节点的引用</span><br>    <span class="hljs-keyword">volatile</span> Node next;<br>    <span class="hljs-comment">// 这个就是线程本尊</span><br>    <span class="hljs-keyword">volatile</span> Thread thread;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。 </p>
<p>上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说 ReentrantLock 的公平锁。再次强调，我说的阻塞队列不包含 head 节点。 </p>
<p> <img src="/img/work/aqs-0-1652966483927.png"> </p>
<p>首先，我们先看下 ReentrantLock 的使用方式。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 我用个web开发中的service概念吧</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderService</span> </span>&#123;<br>    <span class="hljs-comment">// 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ReentrantLock reentrantLock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 比如我们同一时间，只允许一个线程创建订单</span><br>        reentrantLock.lock();<br>        <span class="hljs-comment">// 通常，lock 之后紧跟着 try 语句</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 这块代码同一时间只能有一个线程进来(获取到锁的线程)，</span><br>            <span class="hljs-comment">// 其他的线程在lock()方法上阻塞，等待获取到锁，再进来</span><br>            <span class="hljs-comment">// 执行代码...</span><br>            <span class="hljs-comment">// 执行代码...</span><br>            <span class="hljs-comment">// 执行代码...</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 释放锁</span><br>            reentrantLock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ReentrantLock 在内部用了内部类 Sync 来管理锁，所以真正的获取锁和释放锁是由 Sync 的实现类来控制的。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Sync 有两个实现，分别为 NonfairSync（非公平锁）和 FairSync（公平锁），我们看 FairSync 部分。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> FairSync() : <span class="hljs-keyword">new</span> NonfairSync();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="线程抢锁"><a href="#线程抢锁" class="headerlink" title="线程抢锁"></a>线程抢锁</h2><p>下面我们直接进入FairSync分析线程抢锁的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">3000897897090466540L</span>;<br>      <span class="hljs-comment">// 争锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>      <span class="hljs-comment">// 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力</span><br>    <span class="hljs-comment">// 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。</span><br>    <span class="hljs-comment">// 否则，acquireQueued方法会将线程压到队列中</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123; <span class="hljs-comment">// 此时 arg == 1</span><br>        <span class="hljs-comment">// 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试</span><br>        <span class="hljs-comment">// 因为有可能直接就成功了呢，也就不需要进队列排队了，</span><br>        <span class="hljs-comment">// 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)</span><br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            <span class="hljs-comment">// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span><br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;<br>              selfInterrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span><br><span class="hljs-comment">     * recursive call or no waiters or is first.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span><br>    <span class="hljs-comment">// 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-comment">// state == 0 此时此刻没有线程持有锁</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span><br>            <span class="hljs-comment">// 看看有没有别人在队列中等了半天了</span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                <span class="hljs-comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span><br>                <span class="hljs-comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span><br>                <span class="hljs-comment">// 因为刚刚还没人的，我判断过了</span><br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br><br>                <span class="hljs-comment">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span><br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>          <span class="hljs-comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span><br>        <span class="hljs-comment">// 这里不存在并发问题</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-keyword">int</span> nextc = c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span><br>        <span class="hljs-comment">// 回到上面一个外层调用方法继续看:</span><br>        <span class="hljs-comment">// if (!tryAcquire(arg) </span><br>        <span class="hljs-comment">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br>        <span class="hljs-comment">//     selfInterrupt();</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 假设tryAcquire(arg) 返回false，那么代码将执行：</span><br>      <span class="hljs-comment">//        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，</span><br>    <span class="hljs-comment">// 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates and enqueues node for current thread and given mode.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the new node</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 此方法的作用是把线程包装成node，同时进入到队列中</span><br>    <span class="hljs-comment">// 参数mode此时是Node.EXCLUSIVE，代表独占模式</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br>        Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);<br>        <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>        <span class="hljs-comment">// 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后</span><br>        Node pred = tail;<br><br>        <span class="hljs-comment">// tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)</span><br>        <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123; <br>            <span class="hljs-comment">// 将当前的队尾节点，设置为自己的前驱 </span><br>            node.prev = pred; <br>            <span class="hljs-comment">// 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴</span><br>            <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123; <br>                <span class="hljs-comment">// 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，</span><br>                <span class="hljs-comment">// 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了</span><br>                pred.next = node;<br>                <span class="hljs-comment">// 线程入队了，可以返回了</span><br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 仔细看看上面的代码，如果会到这里，</span><br>        <span class="hljs-comment">// 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span><br>        <span class="hljs-comment">// 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的</span><br>        enq(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Inserts node into queue, initializing if necessary. See picture above.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node the node to insert</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> node&#x27;s predecessor</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 采用自旋的方式入队</span><br>    <span class="hljs-comment">// 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，</span><br>    <span class="hljs-comment">// 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            Node t = tail;<br>            <span class="hljs-comment">// 之前说过，队列为空也会进来这里</span><br>            <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>                <span class="hljs-comment">// 初始化head节点</span><br>                <span class="hljs-comment">// 细心的读者会知道原来 head 和 tail 初始化的时候都是 null 的</span><br>                <span class="hljs-comment">// 还是一步CAS，你懂的，现在可能是很多线程同时进来呢</span><br>                <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))<br>                    <span class="hljs-comment">// 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了</span><br><br>                    <span class="hljs-comment">// 这个时候有了head，但是tail还是null，设置一下，</span><br>                    <span class="hljs-comment">// 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了</span><br>                    <span class="hljs-comment">// 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return</span><br>                    <span class="hljs-comment">// 所以，设置完了以后，继续for循环，下次就到下面的else分支了</span><br>                    tail = head;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 下面几行，和上一个方法 addWaiter 是一样的，</span><br>                <span class="hljs-comment">// 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排</span><br>                node.prev = t;<br>                <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                    t.next = node;<br>                    <span class="hljs-keyword">return</span> t;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 现在，又回到这段代码了</span><br>    <span class="hljs-comment">// if (!tryAcquire(arg) </span><br>    <span class="hljs-comment">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br>    <span class="hljs-comment">//     selfInterrupt();</span><br><br>    <span class="hljs-comment">// 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列</span><br>    <span class="hljs-comment">// 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，</span><br>    <span class="hljs-comment">// 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false</span><br>    <span class="hljs-comment">// 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>                <span class="hljs-comment">// p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head</span><br>                <span class="hljs-comment">// 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列</span><br>                <span class="hljs-comment">// 所以当前节点可以去试抢一下锁</span><br>                <span class="hljs-comment">// 这里我们说一下，为什么可以去试试：</span><br>                <span class="hljs-comment">// 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span><br>                <span class="hljs-comment">// enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span><br>                <span class="hljs-comment">// 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span><br>                <span class="hljs-comment">// tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state</span><br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    setHead(node);<br>                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>                <span class="hljs-comment">// 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，</span><br>                <span class="hljs-comment">// 要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 什么时候 failed 会为 true???</span><br>            <span class="hljs-comment">// tryAcquire() 方法抛异常的情况</span><br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Checks and updates status for a node that failed to acquire.</span><br><span class="hljs-comment">     * Returns true if thread should block. This is the main signal</span><br><span class="hljs-comment">     * control in all acquire loops.  Requires that pred == node.prev</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pred node&#x27;s predecessor holding status</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if thread should block</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：&quot;当前线程没有抢到锁，是否需要挂起当前线程？&quot;</span><br>    <span class="hljs-comment">// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ws = pred.waitStatus;<br>        <span class="hljs-comment">// 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span><br>        <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * This node has already set status asking a release</span><br><span class="hljs-comment">             * to signal it, so it can safely park.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span><br>        <span class="hljs-comment">// 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span><br>        <span class="hljs-comment">// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span><br>        <span class="hljs-comment">// 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span><br>        <span class="hljs-comment">// 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的</span><br>        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Predecessor was cancelled. Skip over predecessors and</span><br><span class="hljs-comment">             * indicate retry.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                node.prev = pred = pred.prev;<br>            &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>            pred.next = node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="hljs-comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span><br><span class="hljs-comment">             * retry to make sure it cannot acquire before parking.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-comment">// 仔细想想，如果进入到这个分支意味着什么</span><br>            <span class="hljs-comment">// 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span><br>            <span class="hljs-comment">// 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span><br>            <span class="hljs-comment">// 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span><br>            <span class="hljs-comment">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span><br>            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>        &#125;<br>        <span class="hljs-comment">// 这个方法返回 false，那么会再走一次 for 循序，</span><br>        <span class="hljs-comment">//     然后再次进来此方法，此时会从第一个分支返回 true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)</span><br>    <span class="hljs-comment">// 这个方法结束根据返回值我们简单分析下：</span><br>    <span class="hljs-comment">// 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒</span><br>    <span class="hljs-comment">//        我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span><br>    <span class="hljs-comment">// 如果返回false, 说明当前不需要被挂起，为什么呢？往后看</span><br><br>    <span class="hljs-comment">// 跳回到前面是这个方法</span><br>    <span class="hljs-comment">// if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br>    <span class="hljs-comment">//                parkAndCheckInterrupt())</span><br>    <span class="hljs-comment">//                interrupted = true;</span><br><br>    <span class="hljs-comment">// 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，</span><br>    <span class="hljs-comment">// 那么需要执行parkAndCheckInterrupt():</span><br><br>    <span class="hljs-comment">// 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的</span><br>    <span class="hljs-comment">// 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>        LockSupport.park(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> Thread.interrupted();<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况</span><br><br>   <span class="hljs-comment">// 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。</span><br><br>    <span class="hljs-comment">// 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：</span><br>    <span class="hljs-comment">// =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>说到这里，也就明白了，多看几遍 <code>final boolean acquireQueued(final Node node, int arg)</code> 这个方法吧。 </p>
<h2 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h2><p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被 <code>LockSupport.park(this);</code> 挂起停止，等待被唤醒。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>    sync.release(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-comment">// 往后看吧</span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        Node h = head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 回到ReentrantLock看tryRelease方法</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> c = getState() - releases;<br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>    <span class="hljs-comment">// 是否完全释放锁</span><br>    <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-keyword">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Wakes up node&#x27;s successor, if one exists.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 唤醒后继节点</span><br><span class="hljs-comment">// 从上面调用处知道，参数node是head头结点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="hljs-comment">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="hljs-comment">     * fails or if status is changed by waiting thread.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">int</span> ws = node.waitStatus;<br>    <span class="hljs-comment">// 如果head节点当前waitStatus&lt;0, 将其修改为0</span><br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）</span><br>    <span class="hljs-comment">// 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的</span><br>    Node s = node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况</span><br>        <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-comment">// 唤醒线程</span><br>        LockSupport.unpark(s.thread);<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>    LockSupport.park(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 刚刚线程被挂起在这里了</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br><span class="hljs-comment">// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</span><br></code></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在并发环境下，加锁和解锁需要以下三个部件的协调： </p>
<ul>
<li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li>
<li>线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。</li>
<li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现，感兴趣的读者可以参考这篇文章<a href="http://coderbee.net/index.php/concurrent/20131115/577">关于CLH的介绍</a>，写得简单明了。</li>
</ul>
<h2 id="示例图解析"><a href="#示例图解析" class="headerlink" title="示例图解析"></a>示例图解析</h2><p>首先，第一个线程调用 reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回 true 了，结束。只是设置了 state=1，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，那世界就太太太平了，完全没有交集嘛，那我还要 AQS 干嘛。 </p>
<p>如果线程 1 没有调用 unlock() 之前，线程 2 调用了 lock(), 想想会发生什么？ </p>
<p>线程 2 会初始化 head【new Node()】，同时线程 2 也会插入到阻塞队列并挂起 (注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环) </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Node t = tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))<br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 首先，是线程 2 初始化 head 节点，此时 head==tail, waitStatus==0 </p>
<p> <img src="/img/work/aqs-1.png"> </p>
<p>然后线程 2 入队： </p>
<p> <img src="/img/work/aqs-2.png"> </p>
<p>同时我们也要看此时节点的 waitStatus，我们知道 head 节点是线程 2 初始化的，此时的 waitStatus 没有设置， java 默认会设置为 0，但是到 shouldParkAfterFailedAcquire 这个方法的时候，线程 2 会把前驱节点，也就是 head 的waitStatus设置为 -1。 </p>
<p>那线程 2 节点此时的 waitStatus 是多少呢，由于没有设置，所以是 0； </p>
<p>如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 shouldParkAfterFailedAcquire 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。 </p>
<p> <img src="/img/work/aqs-3.png"> </p>
<p>这里可以简单说下 waitStatus 中 SIGNAL(-1) 状态的意思，Doug Lea 注释的是：代表后继节点需要被唤醒。也就是说这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着 “waitStatus代表后继节点的状态” 这种思路去看一遍源码。 </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://javadoop.com/post/AbstractQueuedSynchronizer">文章引自Javadoop并做了一些修改</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发核心机制-synchronized关键字</title>
    <url>/2022/04/25/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p> Java 对于并发的支持主要汇聚在 <code>java.util.concurrent</code>，即 J.U.C。而 J.U.C 的核心是 <code>AQS</code>。</p>
</blockquote>
<h2 id="1-J-U-C-简介"><a href="#1-J-U-C-简介" class="headerlink" title="1. J.U.C 简介"></a>1. J.U.C 简介</h2><p>Java 的 <code>java.util.concurrent</code> 包（简称 J.U.C）中提供了大量并发工具类，是 Java 并发能力的主要体现（注意，不是全部，有部分并发能力的支持在其他包中）。从功能上，大致可以分为：</p>
<ul>
<li>原子类 - 如：<code>AtomicInteger</code>、<code>AtomicIntegerArray</code>、<code>AtomicReference</code>、<code>AtomicStampedReference</code> 等。</li>
<li>锁 - 如：<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code> 等。</li>
<li>并发容器 - 如：<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code> 等。</li>
<li>阻塞队列 - 如：<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code> 等。</li>
<li>非阻塞队列 - 如： <code>ConcurrentLinkedQueue</code> 、<code>LinkedTransferQueue</code> 等。</li>
<li><code>Executor</code> 框架（线程池）- 如：<code>ThreadPoolExecutor</code>、<code>Executors</code> 等。</li>
</ul>
<p> Java 并发框架可以分为以下层次</p>
<p><img src="/img/work/java-concurrent-basic-mechanism.png" alt="Java并发架构图"></p>
<p>由 Java 并发框架图不难看出，J.U.C 包中的工具类是基于 <code>synchronized</code>、<code>volatile</code>、<code>CAS</code>、<code>ThreadLocal</code> 这样的并发核心机制打造的。所以，要想深入理解 J.U.C 工具类的特性、为什么具有这样那样的特性，就必须先理解这些核心机制。 </p>
<h2 id="2-synchronized关键字"><a href="#2-synchronized关键字" class="headerlink" title="2. synchronized关键字"></a>2. synchronized关键字</h2><p><strong>概念</strong>:</p>
<p><code>synchronized</code> 是 Java 中的关键字，是 <strong>利用锁的机制来实现互斥同步的</strong>。<code>synchronized</code> 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块。如果不需要 <code>Lock</code> 、<code>ReadWriteLock</code> 所提供的高级同步特性，应该优先考虑使用 <code>synchronized</code> ，理由如下：  </p>
<ul>
<li>Java 1.6 以后，<code>synchronized</code> 做了大量的优化，其性能已经与 <code>Lock</code> 、<code>ReadWriteLock</code> 基本上持平。从趋势来看，Java 未来仍将继续优化 <code>synchronized</code> ，而不是 <code>ReentrantLock</code> 。</li>
<li><code>ReentrantLock</code> 是 Oracle JDK 的 API，在其他版本的 JDK 中不一定支持；而 <code>synchronized</code> 是 JVM 的内置特性，所有 JDK 版本都提供支持。</li>
</ul>
<h3 id="2-1-synchronized-的应用"><a href="#2-1-synchronized-的应用" class="headerlink" title="2.1. synchronized 的应用"></a>2.1. synchronized 的应用</h3><p>在应用Sychronized关键字时需要把握如下注意点： </p>
<ul>
<li>一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；</li>
<li>每个实例都对应有自己的一把锁(this),不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁</li>
<li>synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁</li>
</ul>
<h4 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h4><p>包括方法锁(默认锁对象为this,当前实例对象)和同步代码块锁(自己指定锁对象) </p>
<p><strong>代码块形式：手动指定锁定对象，也可是this,也可以是自定义的锁</strong></p>
<p>示例1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock1 instance = <span class="hljs-keyword">new</span> SynchronizedObjectLock1();<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//同步代码块形式——锁为this，两个线程使用的锁是一样的，线程1必须要等到线程0释放了该锁后，才能执行。</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是线程 &quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instance);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instance);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 输出结果： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">我是线程Thread-<span class="hljs-number">0</span><br>Thread-<span class="hljs-number">0</span>结束<br>我是线程Thread-<span class="hljs-number">1</span><br>Thread-<span class="hljs-number">1</span>结束<br></code></pre></td></tr></table></figure>



<p>示例2:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock1 instance = <span class="hljs-keyword">new</span> SynchronizedObjectLock1();<br>    <span class="hljs-comment">//创建2把锁</span><br>    Object block1 = <span class="hljs-keyword">new</span> Object();<br>    Object block2 = <span class="hljs-keyword">new</span> Object();<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-comment">//这个代码块使用的是第一把锁，当它释放后，他后面的代码块由于使用的是第二把锁，因此可以马上执行</span><br>        <span class="hljs-keyword">synchronized</span> (block1) &#123;<br>            System.out.println(<span class="hljs-string">&quot;block1锁，我是线程&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;block1锁,&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (block2) &#123;<br>            System.out.println(<span class="hljs-string">&quot;block2锁,我是线程&quot;</span> + Thread.currentThread().getName());<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;block2锁,&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instance);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instance);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 输出结果： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">block1锁,我是线程Thread-<span class="hljs-number">0</span><br>block1锁,Thread-<span class="hljs-number">0</span>结束<br>block2锁,我是线程Thread-<span class="hljs-number">0</span>　　<span class="hljs-comment">// 可以看到当第一个线程在执行完第一段同步代码块之后，第二个同步代码块可以马上得到执行，因为他们使用的锁不是同一把</span><br>block1锁,我是线程Thread-<span class="hljs-number">1</span><br>block2锁,Thread-<span class="hljs-number">0</span>结束<br>block1锁,Thread-<span class="hljs-number">1</span>结束<br>block2锁,我是线程Thread-<span class="hljs-number">1</span><br>block2锁,Thread-<span class="hljs-number">1</span>结束<br></code></pre></td></tr></table></figure>

<p><strong>方法锁形式：synchronized修饰普通方法，锁对象默认为this</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLockDemo1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-keyword">static</span> SynchronizedObjectLockDemo1 instance = <span class="hljs-keyword">new</span> SynchronizedObjectLockDemo1();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        method();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是线程 &quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br><br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instance);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instance);<br>        t1.start();<br>        t2.start();<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">我是线程Thread-<span class="hljs-number">0</span><br>Thread-<span class="hljs-number">0</span>结束<br>我是线程Thread-<span class="hljs-number">1</span><br>Thread-<span class="hljs-number">1</span>结束<br></code></pre></td></tr></table></figure>

<h4 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h4><p>指synchronize修饰静态的方法或指定锁对象为Class对象</p>
<p><strong>synchronize修饰静态方法</strong></p>
<p>示例1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence1 = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence2 = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.method();<br>    &#125;<br><br>    <span class="hljs-comment">//synchronized用在普通方法上，默认的锁就是this，当前实例</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span> <span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// t1和t2对应的this是两个不同的实例，所以代码不会串行</span><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instence1);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instence2);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">我是线程Thread-<span class="hljs-number">0</span><br>我是线程Thread-<span class="hljs-number">1</span><br>Thread-<span class="hljs-number">1</span>结束<br>Thread-<span class="hljs-number">0</span>结束<br></code></pre></td></tr></table></figure>

<p>示例2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence1 = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence2 = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        method();<br>    &#125;<br><br>    <span class="hljs-comment">// synchronized用在静态方法上，默认的锁就是当前所在的Class类，所以无论是哪个线程访问它，需要的锁都只有一把</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instence1);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instence2);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">我是线程Thread-<span class="hljs-number">0</span><br>Thread-<span class="hljs-number">0</span>结束<br>我是线程Thread-<span class="hljs-number">1</span><br>Thread-<span class="hljs-number">1</span>结束<br></code></pre></td></tr></table></figure>

<h4 id="synchronized指定锁对象为Class对象"><a href="#synchronized指定锁对象为Class对象" class="headerlink" title="synchronized指定锁对象为Class对象"></a>synchronized指定锁对象为Class对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock1 instence1 = <span class="hljs-keyword">new</span> SynchronizedObjectLock1();<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock1 instence2 = <span class="hljs-keyword">new</span> SynchronizedObjectLock1();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">synchronized</span> (SynchronizedObjectLock1.class) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// t1和t2对应的this是两个不同的实例，所以代码不会串行</span><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instence1);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instence2);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">我是线程Thread-<span class="hljs-number">0</span><br>Thread-<span class="hljs-number">0</span>结束<br>我是线程Thread-<span class="hljs-number">1</span><br>Thread-<span class="hljs-number">1</span>结束<br></code></pre></td></tr></table></figure>



<h3 id="2-2-Synchronized原理分析"><a href="#2-2-Synchronized原理分析" class="headerlink" title="2.2 Synchronized原理分析"></a>2.2 Synchronized原理分析</h3><h4 id="加锁和释放锁的原理"><a href="#加锁和释放锁的原理" class="headerlink" title="加锁和释放锁的原理"></a>加锁和释放锁的原理</h4><p>深入JVM看字节码，创建如下的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedDemo2</span> </span>&#123;<br><br>    Object object = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (object) &#123;<br><br>        &#125;<br>        method2();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用javac命令进行编译生成.class文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">javac SynchronizedDemo2.java<br></code></pre></td></tr></table></figure>

<p>使用javap命令反编译查看.class文件的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">javap -verbose SynchronizedDemo2.class<br></code></pre></td></tr></table></figure>

<p>得到如下的信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>;<br>   descriptor: ()V<br>   flags: ACC_PUBLIC<br>   Code:<br>     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>        <span class="hljs-number">0</span>: aload_0<br>        <span class="hljs-number">1</span>: getfield      #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field object:Ljava/lang/Object;</span><br>        <span class="hljs-number">4</span>: dup<br>        <span class="hljs-number">5</span>: astore_1<br>        <span class="hljs-number">6</span>: monitorenter <br>        <span class="hljs-number">7</span>: aload_1<br>        <span class="hljs-number">8</span>: monitorexit<br>        <span class="hljs-number">9</span>: goto          <span class="hljs-number">17</span><br>       <span class="hljs-number">12</span>: astore_2<br>       <span class="hljs-number">13</span>: aload_1<br>       <span class="hljs-number">14</span>: monitorexit<br>       <span class="hljs-number">15</span>: aload_2<br>       <span class="hljs-number">16</span>: athrow<br>       <span class="hljs-number">17</span>: invokestatic  #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method method2:()V</span><br>       <span class="hljs-number">20</span>: <span class="hljs-keyword">return</span><br>     Exception table:<br>        from    to  target type<br>            <span class="hljs-number">7</span>     <span class="hljs-number">9</span>    <span class="hljs-number">12</span>   any<br>           <span class="hljs-number">12</span>    <span class="hljs-number">15</span>    <span class="hljs-number">12</span>   any<br>     LineNumberTable:<br>       line <span class="hljs-number">15</span>: <span class="hljs-number">0</span><br>       line <span class="hljs-number">17</span>: <span class="hljs-number">7</span><br>       line <span class="hljs-number">19</span>: <span class="hljs-number">17</span><br>       line <span class="hljs-number">20</span>: <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure>

<p>关注<code>monitorenter</code>和<code>monitorexit</code>即可。</p>
<p><code>Monitorenter</code>和<code>Monitorexit</code>指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一：</p>
<ul>
<li>monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待</li>
<li>如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加</li>
<li>这把锁已经被别的线程获取了，等待锁释放</li>
</ul>
<p><code>monitorexit指令</code>：释放对于monitor的所有权，释放过程很简单，就是将monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。</p>
<p>下图表现了对象，对象监视器，同步队列以及执行线程状态之间的关系：</p>
<p><img src="/img/work/image-20220420155917083.png"></p>
<p>该图可以看出，任意线程对Object的访问，首先要获得Object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。</p>
<h4 id="可重入原理：加锁次数计数器"><a href="#可重入原理：加锁次数计数器" class="headerlink" title="可重入原理：加锁次数计数器"></a>可重入原理：加锁次数计数器</h4><p>上面的demo中在执行完同步代码块之后紧接着再会去执行一个静态同步方法，而这个方法锁的对象依然就这个类对象，那么这个正在执行的线程还需要获取该锁吗? 答案是不必的，从上图中就可以看出来，执行静态同步方法的时候就只有一条monitorexit指令，并没有monitorenter获取锁的指令。这就是锁的重入性，即在同一锁程中，线程不需要再次获取同一把锁。</p>
<p>Synchronized先天具有重入性。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一。</p>
<h4 id="保证可见性的原理：内存模型和happens-before规则"><a href="#保证可见性的原理：内存模型和happens-before规则" class="headerlink" title="保证可见性的原理：内存模型和happens-before规则"></a>保证可见性的原理：内存模型和happens-before规则</h4><p>Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。继续来看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonitorDemo</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-comment">// 1</span><br>        a++;                                <span class="hljs-comment">// 2</span><br>    &#125;                                       <span class="hljs-comment">// 3</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 4</span><br>        <span class="hljs-keyword">int</span> i = a;                         <span class="hljs-comment">// 5</span><br>    &#125;                                      <span class="hljs-comment">// 6</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>该代码的happens-before关系如图所示：</p>
<p><img src="/img/work/image-20220420161225673.png"></p>
<p>在图中每一个箭头连接的两个节点就代表之间的happens-before关系，黑色的是通过程序顺序规则推导出来，红色的为监视器锁规则推导而出：线程A释放锁happens-before线程B加锁，蓝色的则是通过程序顺序规则和监视器锁规则推测出来happens-befor关系，通过传递性规则进一步推导的happens-before关系。现在我们来重点关注2 happens-before 5，通过这个关系我们可以得出什么?</p>
<p>根据happens-before的定义中的一条:如果A happens-before B，则A的执行结果对B可见，并且A的执行顺序先于B。线程A先对共享变量A进行加一，由2 happens-before 5关系可知线程A的执行结果对线程B可见即线程B所读取到的a的值为1。</p>
<h3 id="2-3-JVM中锁的优化"><a href="#2-3-JVM中锁的优化" class="headerlink" title="2.3 JVM中锁的优化"></a>2.3 JVM中锁的优化</h3><p>简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能。<strong>不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销</strong>。</p>
<ul>
<li><p><code>锁粗化(Lock Coarsening)</code>：也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。</p>
</li>
<li><p><code>锁消除(Lock Elimination)</code>：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本的Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。</p>
</li>
<li><p><code>轻量级锁(Lightweight Locking)</code>: 这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒(具体处理步骤下面详细讨论)。</p>
</li>
<li><p><code>偏向锁(Biased Locking)</code>：是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本的延迟。</p>
</li>
<li><p><code>适应性自旋(Adaptive Spinning)</code>：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。</p>
</li>
</ul>
<h4 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h4><p>在Java SE 1.6里Synchronied同步锁，一共有四种状态：<code>无锁</code>、<code>偏向锁</code>、<code>轻量级所</code>、<code>重量级锁</code>，它会随着竞争情况逐渐升级。锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。</p>
<blockquote>
<p>锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)</p>
</blockquote>
<h4 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h4><p><strong>自旋锁</strong></p>
<blockquote>
<p>引入背景：大家都知道，在没有加入锁优化时，Synchronized是一个非常“胖大”的家伙。在多线程竞争锁时，当一个线程获取锁时，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。在挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。同时HotSpot团队注意到在很多情况下，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和回复阻塞线程并不值得。在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会(自旋)，但不放弃CPU的执行时间。等待持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。</p>
</blockquote>
<p>自旋锁早在JDK1.4 中就引入了，只是当时默认时关闭的。在JDK 1.6后默认为开启状态。自旋锁本质上与阻塞并不相同，先不考虑其对多处理器的要求，如果锁占用的时间非常的短，那么自旋锁的性能会非常的好，相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用CPU的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉CPU资源)。因此自旋等待的时间必须要有一定的限度，如果自选超过了限定的次数仍然没有成功获取到锁，就应该使用传统的方式去挂起线程了，在JDK定义中，自旋锁默认的自旋次数为10次，用户可以使用参数<code>-XX:PreBlockSpin</code>来更改。</p>
<p>可是现在又出现了一个问题：如果线程锁在线程自旋刚结束就释放掉了锁，那么是不是有点得不偿失。所以这时候我们需要更加聪明的锁来实现更加灵活的自旋。来提高并发的性能。(这里则需要自适应自旋锁！)</p>
<p><strong>自适应自旋锁</strong></p>
<p>在JDK 1.6中引入了自适应自旋锁。这就意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋 时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到100此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM对程序的锁的状态预测会越来越准确，JVM也会越来越聪明。</p>
<p><strong>锁消除</strong></p>
<p>锁消除是指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。意思就是：JVM会判断在一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据时线程独有的，不需要加同步。此时就会进行锁消除。</p>
<p>当然在实际开发中，我们很清楚的知道哪些是线程独有的，不需要加同步锁，但是在Java API中有很多方法都是加了同步的，那么此时JVM会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁消除。比如如下操作：在操作String类型数据时，由于String是一个不可变类，对字符串的连接操作总是通过生成的新的String对象来进行的。因此Javac编译器会对String连接做自动优化。在JDK 1.5之前会使用StringBuffer对象的连续append()操作，在JDK 1.5及以后的版本中，会转化为StringBuidler对象的连续append()操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">test03</span><span class="hljs-params">(String s1, String s2, String s3)</span> </span>&#123;<br>    String s = s1 + s2 + s3;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码使用javap 编译结果</p>
<p><img src="/img/work/image-20220421112257342.png"></p>
<p>众所周知，StringBuilder不是安全同步的，但是在上述代码中，JVM判断该段代码并不会逃逸，则将该代码带默认为线程独有的资源，并不需要同步，所以执行了锁消除操作。(还有Vector中的各种操作也可实现锁消除。在没有逃逸出数据安全防卫内)</p>
<h4 id="锁粗话"><a href="#锁粗话" class="headerlink" title="锁粗话"></a>锁粗话</h4><p>原则上,我们都知道在同步加锁的时，尽可能的将同步块的作用范围限制到尽量小的范围(只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。</p>
<p>大部分上述情况是完美正确的，但是如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作。</p>
<p>根据上述Javap 编译的情况编写的实例java类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">test04</span><span class="hljs-params">(String s1, String s2, String s3)</span> </span>&#123;<br>    StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>    sb.append(s1);<br>    sb.append(s2);<br>    sb.append(s3);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述的连续append()操作中就属于这类情况。JVM会检测到这样一连串的操作都是对同一个对象加锁，那么JVM会将加锁同步的范围扩展(粗化)到整个一系列操作的 外部，使整个一连串的append()操作只需要加锁一次就可以了。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>在JDK 1.6之后引入的轻量级锁，需要注意的是轻量级锁并不是替代重量级锁的，而是对在大多数情况下同步块并不会有竞争出现提出的一种优化。它可以减少重量级锁对线程的阻塞带来的线程开销。从而提高并发性能。</p>
<p>如果要理解轻量级锁，那么必须先要了解HotSpot虚拟机中对象头的内存布局。在对象头中(<code>Object Header</code>)存在两部分。第一部分用于存储对象自身的运行时数据，<code>HashCode</code>、<code>GC Age</code>、<code>锁标记位</code>、<code>是否为偏向锁</code>。等。一般为32位或者64位(视操作系统位数定)。官方称之为<code>Mark Word</code>，它是实现轻量级锁和偏向锁的关键。 另外一部分存储的是指向方法区对象类型数据的指针(<code>Klass Point</code>)，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。</p>
<p><strong>轻量级锁加锁</strong></p>
<p>在线程执行同步块之前,JVM会先在当前线程的栈帧中创建一个名为锁记录(<code>Lock Record</code>)的空间，用于存储锁对象目前的<code>Mark Word</code>的拷贝(JVM会将对象头中的<code>Mark Word</code>拷贝到锁记录中，官方称为<code>Displaced Mark Ward</code>)这个时候线程堆栈与对象头的状态如图：</p>
<p><img src="/img/work/image-20220424172439521.png"></p>
<p>如上图所示：如果当前对象没有被锁定，那么锁标志位位01状态，JVM在执行当前线程时，首先会在当前线程栈帧中创建锁记录<code>Lock Record</code>的空间用于存储锁对象目前的<code>Mark Word</code>的拷贝。</p>
<p> 然后，虚拟机使用CAS操作将标记字段Mark Word拷贝到锁记录中，并且将<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。如果更新成功了，那么这个线程就有用了该对象的锁，并且对象Mark Word的锁标志位更新为(<code>Mark Word</code>中最后的2bit)00，即表示此对象处于轻量级锁定状态，如图：</p>
<p><img src="/img/work/image-20220424172837543.png"></p>
<p>如果这个更新操作失败,JVM会检查当前的<code>Mark Word</code>中是否存在指向当前线程的栈帧的指针,如果有，说明该锁已经被获取,可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀位重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为<code>10.Mark World</code>中存储的时指向重量级锁的指针。</p>
<p>轻量级解锁时，会使用原子的CAS操作将<code>Displaced Mark Word</code>替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。两个线程同时争夺锁，导致锁膨胀的流程图如下：</p>
<p><img src="/img/work/20200604105248.png"></p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><blockquote>
<p>引入背景：在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争，那么这样看上去，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。</p>
</blockquote>
<p>为了解决这一问题，HotSpot的作者在Java SE 1.6 中对Synchronized进行了优化，引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。只需要简单的测试一下对象头的<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。</p>
<p><img src="/img/work/image-20220425100801853.png"></p>
<p><strong>偏向锁的撤销</strong></p>
<p>偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，让你后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。</p>
<p><img src="/img/work/20200604105151.png"></p>
<h4 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h4><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块的场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了响应速度</td>
<td>如线程成始终得不到锁竞争的线程，使用自旋会消耗CPU性能</td>
<td>追求响应时间，同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不适用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td>
<td>追求吞吐量，同步块执行速度较长</td>
</tr>
</tbody></table>
<h3 id="2-4-Synchronized与Lock"><a href="#2-4-Synchronized与Lock" class="headerlink" title="2.4  Synchronized与Lock"></a>2.4  Synchronized与Lock</h3><h4 id="synchronized的缺陷"><a href="#synchronized的缺陷" class="headerlink" title="synchronized的缺陷"></a>synchronized的缺陷</h4><ul>
<li><code>效率低</code>：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock可以中断和设置超时</li>
<li><code>不够灵活</code>：加锁和释放的时机单一，每个锁仅有一个单一的条件(某个对象)，相对而言，读写锁更加灵活</li>
<li><code>无法知道是否成功获得锁</code>，相对而言，Lock可以拿到状态，如果成功获取锁，….，如果获取失败，…..</li>
</ul>
<p><strong>Lock解决相应问题</strong></p>
<p>Lock类这里不做过多解释，主要看里面的4个方法:</p>
<ul>
<li><code>lock()</code>: 加锁</li>
<li><code>unlock()</code>: 解锁</li>
<li><code>tryLock()</code>: 尝试获取锁，返回一个boolean值</li>
<li><code>tryLock(long,TimeUtil)</code>: 尝试获取锁，可以设置超时</li>
</ul>
<p>Synchronized只有锁只与一个条件(是否获取锁)相关联，不灵活，后来<code>Condition与Lock的结合</code>解决了这个问题。</p>
<p>多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。ReentrantLock的lockInterruptibly()方法可以优先考虑响应中断。 一个线程等待时间过长，它可以中断自己，然后ReentrantLock响应这个中断，不再让这个线程继续等待。有了这个机制，使用ReentrantLock时就不会像synchronized那样产生死锁了。</p>
<p>synchronized是通过软件(JVM)实现的，简单易用，即使在JDK5之后有了Lock，仍然被广泛的使用。</p>
<ul>
<li><strong>使用Synchronized有哪些要注意的？</strong><ul>
<li>锁对象不能为空，因为锁的信息都保存在对象头里</li>
<li>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</li>
<li>避免死锁</li>
<li>在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错</li>
</ul>
</li>
<li><strong>synchronized是公平锁吗？</strong></li>
</ul>
<p>synchronized实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，这样有利于提高性能，但是也可能会导致饥饿现象。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p><a href="https://juejin.im/post/5ae6dc04f265da0ba351d3ff">https://juejin.im/post/5ae6dc04f265da0ba351d3ff</a></p>
<p><a href="https://www.cnblogs.com/javaminer/p/3889023.html">https://www.cnblogs.com/javaminer/p/3889023.html</a></p>
<p><a href="https://www.jianshu.com/p/dab7745c0954">https://www.jianshu.com/p/dab7745c0954</a></p>
<p><a href="https://www.cnblogs.com/wuchaodzxx/p/6867546.html">https://www.cnblogs.com/wuchaodzxx/p/6867546.html</a></p>
<p><a href="https://www.cnblogs.com/xyabk/p/10901291.html">https://www.cnblogs.com/xyabk/p/10901291.html</a></p>
<p><a href="https://www.jianshu.com/p/64240319ed60">https://www.jianshu.com/p/64240319ed60</a></p>
<p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html">https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html</a></p>
<p><a href="https://dunwu.github.io/javacore/concurrent/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6.html#_1-j-u-c-%E7%AE%80%E4%BB%8B">https://dunwu.github.io/javacore/concurrent/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6.html#_1-j-u-c-%E7%AE%80%E4%BB%8B</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>并发核心机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发简介</title>
    <url>/2022/03/22/Java%E5%B9%B6%E5%8F%91%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>引自: <a href="https://dunwu.github.io/javacore/concurrent/">JAVACORE</a>的多线程并发简介 </p>
</blockquote>
<blockquote>
<p><strong>关键词</strong>：<code>进程</code>、<code>线程</code>、<code>安全性</code>、<code>活跃性</code>、<code>性能</code>、<code>死锁</code>、<code>饥饿</code>、<code>上下文切换</code></p>
<p><strong>摘要</strong>：并发编程并非 Java 语言所独有，而是一种成熟的编程范式，Java 只是用自己的方式实现了并发工作模型。学习 Java 并发编程，应该先熟悉并发的基本概念，然后进一步了解并发的特性以及其特性所面临的问题。掌握了这些，当学习 Java 并发工具时，才会明白它们各自是为了解决什么问题，为什么要这样设计。通过这样由点到面的学习方式，更容易融会贯通，将并发知识形成体系化。</p>
</blockquote>
<h1 id="1-并发概念"><a href="#1-并发概念" class="headerlink" title="1. 并发概念"></a>1. 并发概念</h1><p>并发编程中有很多术语概念相近，容易让人混淆。本节内容通过对比分析，力求让读者清晰理解其概念以及差异。</p>
<h2 id="1-1-并发和并行"><a href="#1-1-并发和并行" class="headerlink" title="1.1 并发和并行"></a>1.1 并发和并行</h2><p>并发和并行是最容易让新手费解的概念，那么如何理解二者呢？其最关键的差异在于：是否是<strong>同时</strong>发生：</p>
<ul>
<li><strong>并发</strong>：是指具备处理多个任务的能力，但不一定要同时。</li>
<li><strong>并行</strong>：是指具备同时处理多个任务的能力。</li>
</ul>
<p>下面是我见过最生动的说明，摘自 <a href="https://www.zhihu.com/question/33515481/answer/58849148">并发与并行的区别是什么？——知乎的高票答案 (opens new window)</a>：</p>
<ul>
<li>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。</li>
<li>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。</li>
<li>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</li>
</ul>
<h2 id="1-2-同步和异步"><a href="#1-2-同步和异步" class="headerlink" title="1.2. 同步和异步"></a>1.2. 同步和异步</h2><ul>
<li><strong>同步</strong>：是指在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。</li>
<li><strong>异步</strong>：则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。</li>
</ul>
<p>举例来说明：</p>
<ul>
<li>同步就像是打电话：不挂电话，通话不会结束。</li>
<li>异步就像是发短信：发完短信后，就可以做其他事；当收到回复短信时，手机会通过铃声或振动来提醒。</li>
</ul>
<h2 id="1-3-阻塞和非阻塞"><a href="#1-3-阻塞和非阻塞" class="headerlink" title="1.3 阻塞和非阻塞"></a>1.3 阻塞和非阻塞</h2><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态：</p>
<ul>
<li><strong>阻塞</strong>：是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</li>
<li><strong>非阻塞</strong>：是指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li>
</ul>
<p>举例来说明：</p>
<ul>
<li>阻塞调用就像是打电话，通话不结束，不能放下。</li>
<li>非阻塞调用就像是发短信，发完短信后，就可以做其他事，短信来了，手机会提醒。</li>
</ul>
<h2 id="1-4-进程和线程"><a href="#1-4-进程和线程" class="headerlink" title="1.4. 进程和线程"></a>1.4. 进程和线程</h2><ul>
<li><p>**进程:**进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。进程是操作系统进行资源分配的基本单位。进程可视为一个正在运行的程序。</p>
</li>
<li><p>**线程:**线程是操作系统进行调度的基本单位。</p>
</li>
</ul>
<p>进程和线程的差异：</p>
<ul>
<li><p>一个程序至少有一个进程，一个进程至少有一个线程。</p>
</li>
<li><p>线程比进程划分更细，所以执行开销更小，并发性更高</p>
</li>
<li><p>进程是一个实体，拥有独立的资源；而同一个进程中的多个线程共享进程的资源。</p>
</li>
</ul>
<p><img src="/img/work/processes-vs-threads.jpg"></p>
<p>JVM 在单个进程中运行，JVM 中的线程共享属于该进程的堆。这就是为什么几个线程可以访问同一个对象。线程共享堆并拥有自己的堆栈空间。这是一个线程如何调用一个方法以及它的局部变量是如何保持线程安全的。但是堆不是线程安全的并且为了线程安全必须进行同步。</p>
<h2 id="1-5-竞态条件和临界区"><a href="#1-5-竞态条件和临界区" class="headerlink" title="1.5. 竞态条件和临界区"></a>1.5. 竞态条件和临界区</h2><ul>
<li><strong>竞态条件（Race Condition）</strong>：当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。</li>
<li><strong>临界区（Critical Sections）</strong>：导致竞态条件发生的代码区称作临界区。</li>
</ul>
<h2 id="1-6-管程"><a href="#1-6-管程" class="headerlink" title="1.6. 管程"></a>1.6. 管程</h2><p>管程（Monitor），是指管理共享变量以及对共享变量的操作过程，让他们支持并发。</p>
<p>Java 采用的是管程技术，synchronized 关键字及 wait()、notify()、notifyAll() 这三个方法都是管程的组成部分。而<strong>管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程</strong>。</p>
<h1 id="2-并发特点"><a href="#2-并发特点" class="headerlink" title="2.并发特点"></a>2.并发特点</h1><p>技术在进步，CPU、内存、I/O 设备的性能也在不断提高。但是，始终存在一个核心矛盾：<strong>CPU、内存、I/O 设备存在速度差异</strong>。CPU 远快于内存，内存远快于 I/O 设备。</p>
<p>木桶短板理论告诉我们：一只木桶能装多少水，取决于最短的那块木板。同理，程序整体性能取决于最慢的操作（即 I/O 操作），所以单方面提高 CPU、内存的性能是无效的。</p>
<p><img src="/img/work/20201225170052.jpg"></p>
<p>为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：</p>
<ul>
<li><strong>CPU 增加了缓存</strong>，以均衡与内存的速度差异；</li>
<li><strong>操作系统增加了进程、线程</strong>，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；</li>
<li><strong>编译程序优化指令执行次序</strong>，使得缓存能够得到更加合理地利用。</li>
</ul>
<p>其中，进程、线程使得计算机、程序有了并发处理任务的能力。</p>
<p>并发的优点在于：</p>
<ul>
<li>提升资源利用率</li>
<li>程序响应更快</li>
</ul>
<h2 id="2-1-提升资源利用率"><a href="#2-1-提升资源利用率" class="headerlink" title="2.1 提升资源利用率"></a>2.1 提升资源利用率</h2><p>想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要 5 秒，处理一个文件需要 2 秒。处理两个文件则需要：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc">5秒读取文件A<br>2秒处理文件A<br>5秒读取文件B<br><span class="hljs-section">2秒处理文件B</span><br><span class="hljs-section">---------------------</span><br>总共需要14秒<br></code></pre></td></tr></table></figure>

<p>从磁盘中读取文件的时候，大部分的 CPU 时间用于等待磁盘去读取数据。在这段时间里，CPU 非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用 CPU 资源。看下面的顺序：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc">5秒读取文件A<br>5秒读取文件B + 2秒处理文件A<br><span class="hljs-section">2秒处理文件B</span><br><span class="hljs-section">---------------------</span><br>总共需要12秒<br></code></pre></td></tr></table></figure>

<p>CPU 等待第一个文件被读取完。然后开始读取第二个文件。当第二文件在被读取的时候，CPU 会去处理第一个文件。记住，在等待磁盘读取文件的时候，CPU 大 部分时间是空闲的。</p>
<p>总的说来，CPU 能够在等待 IO 的时候做一些其他的事情。这个不一定就是磁盘 IO。它也可以是网络的 IO，或者用户输入。通常情况下，网络和磁盘的 IO 比 CPU 和内存的 IO 慢的多。  </p>
<h2 id="2-2-程序响应更快"><a href="#2-2-程序响应更快" class="headerlink" title="2.2 程序响应更快"></a>2.2 程序响应更快</h2><p>将一个单线程应用程序变成多线程应用程序的另一个常见的目的是实现一个响应更快的应用程序。  设想一个服务器应用，它在某一个端口监听进来的请求。当一个请求到来时，它去处理这个请求，然后再返回去监听。 </p>
<p> 服务器的流程如下所述： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span>(server is active) &#123;<br>    listen <span class="hljs-keyword">for</span> request<br>    process request<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果一个请求需要占用大量的时间来处理，在这段时间内新的客户端就无法发送请求给服务端。只有服务器在监听的时候，请求才能被接收。另一种设计是，监听线程把请求传递给工作者线程(worker thread)，然后立刻返回去监听。而工作者线程则能够处理这个请求并发送一个回复给客户端。这种设计如下所述： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(server is active) &#123;<br>    listen <span class="hljs-keyword">for</span> request<br>    hand request to worker thread<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种方式，服务端线程迅速地返回去监听。因此，更多的客户端能够发送请求给服务端。这个服务也变得响应更快。 </p>
<p>桌面应用也是同样如此。如果你点击一个按钮开始运行一个耗时的任务，这个线程既要执行任务又要更新窗口和按钮，那么在任务执行的过程中，这个应用程序看起来好像没有反应一样。相反，任务可以传递给工作者线程（worker thread)。当工作者线程在繁忙地处理任务的时候，窗口线程可以自由地响应其他用户的请求。当工作者线程完成任务的时候，它发送信号给窗口线程。窗口线程便可以更新应用程序窗口，并显示任务的结果。对用户而言，这种具有工作者线程设计的程序显得响应速度更快。 </p>
<h2 id="2-3-并发的问题"><a href="#2-3-并发的问题" class="headerlink" title="2.3. 并发的问题"></a>2.3. 并发的问题</h2><p> 任何事物都有利弊，并发也不例外。 </p>
<p> 我们知道了并发带来的好处：提升资源利用率、程序响应更快，同时也要认识到并发带来的问题，主要有： </p>
<ul>
<li>安全性问题</li>
<li>活跃性问题</li>
<li>性能问题</li>
</ul>
<h1 id="3-安全性问题"><a href="#3-安全性问题" class="headerlink" title="3.安全性问题"></a>3.安全性问题</h1><p>并发最重要的问题是并发安全问题。 </p>
<p><strong>并发安全</strong>：是指保证程序的正确性，使得并发处理结果符合预期。 </p>
<p>并发安全需要保证几个基本特性： </p>
<ul>
<li><p><strong>可见性:</strong> 是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，<code>volatile</code> 就是负责保证可见性的。 </p>
</li>
<li><p><strong>原子性:</strong> 简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制（加锁：<code>sychronized</code>、<code>Lock</code>）实现。 </p>
</li>
<li><p><strong>有序性:</strong> 是保证线程内串行语义，避免指令重排等。 </p>
</li>
</ul>
<h2 id="3-1-缓存导致的可见性问题"><a href="#3-1-缓存导致的可见性问题" class="headerlink" title="3.1.缓存导致的可见性问题"></a>3.1.缓存导致的可见性问题</h2><blockquote>
<p> 一个线程对共享变量的修改，另外一个线程能够立刻看到，称为 <strong>可见性</strong>。 </p>
</blockquote>
<p>在单核时代，所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。例如在下面的图中，线程 A 和线程 B 都是操作同一个 CPU 里面的缓存，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的最新值（线程 A 写过的值）。 </p>
<p> <img src="/img/work/20200701110313.png"> </p>
<p>多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。比如下图中，线程 A 操作的是 CPU-1 上的缓存，而线程 B 操作的是 CPU-2 上的缓存，很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。 </p>
<p>【示例】线程不安全的示例 </p>
<p>下面我们再用一段代码来验证一下多核场景下的可见性问题。下面的代码，每执行一次 add10K() 方法，都会循环 10000 次 count+=1 操作。在 calc() 方法中我们创建了两个线程，每个线程调用一次 add10K() 方法，我们来想一想执行 calc() 方法得到的结果应该是多少呢？ </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add10K</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(idx++ &lt; <span class="hljs-number">10000</span>) &#123;<br>      count += <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">calc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Test test = <span class="hljs-keyword">new</span> Test();<br>    <span class="hljs-comment">// 创建两个线程，执行 add() 操作</span><br>    Thread th1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>      test.add10K();<br>    &#125;);<br>    Thread th2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>      test.add10K();<br>    &#125;);<br>    <span class="hljs-comment">// 启动两个线程</span><br>    th1.start();<br>    th2.start();<br>    <span class="hljs-comment">// 等待两个线程执行结束</span><br>    th1.join();<br>    th2.join();<br>    <span class="hljs-keyword">return</span> count;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>直觉告诉我们应该是 20000，因为在单线程里调用两次 add10K() 方法，count 的值就是 20000，但实际上 calc() 的执行结果是个 10000 到 20000 之间的随机数。为什么呢？</p>
<p>我们假设线程 A 和线程 B 同时开始执行，那么第一次都会将 count=0 读到各自的 CPU 缓存里，执行完 count+=1 之后，各自 CPU 缓存里的值都是 1，同时写入内存后，我们会发现内存中是 1，而不是我们期望的 2。之后由于各自的 CPU 缓存里都有了 count 的值，两个线程都是基于 CPU 缓存里的 count 值来计算，所以导致最终 count 的值都是小于 20000 的。这就是缓存的可见性问题。</p>
<p>循环 10000 次 count+=1 操作如果改为循环 1 亿次，你会发现效果更明显，最终 count 的值接近 1 亿，而不是 2 亿。如果循环 10000 次，count 的值接近 20000，原因是两个线程不是同时启动的，有一个时差。</p>
<p> <img src="/img/work/20200701110615.png"> </p>
<h2 id="3-2-线程切换带来的原子性问题"><a href="#3-2-线程切换带来的原子性问题" class="headerlink" title="3.2. 线程切换带来的原子性问题"></a>3.2. 线程切换带来的原子性问题</h2><p>由于 IO 太慢，早期的操作系统就发明了多进程，操作系统允许某个进程执行一小段时间（称为 <strong>时间片</strong>）。 </p>
<p>在一个时间片内，如果一个进程进行一个 IO 操作，例如读个文件，这个时候该进程可以把自己标记为“休眠状态”并出让 CPU 的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得 CPU 的使用权了。 </p>
<p>这里的进程在等待 IO 时之所以会释放 CPU 使用权，是为了让 CPU 在这段等待时间里可以做别的事情，这样一来 CPU 的使用率就上来了；此外，如果这时有另外一个进程也读文件，读文件的操作就会排队，磁盘驱动在完成一个进程的读操作后，发现有排队的任务，就会立即启动下一个读操作，这样 IO 的使用率也上来了。 </p>
<p>早期的操作系统基于进程来调度 CPU，不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换成本就很低了。现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。 </p>
<p>Java 并发程序都是基于多线程的，自然也会涉及到任务切换，也许你想不到，任务切换竟然也是并发编程里诡异 Bug 的源头之一。任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的 <code>count += 1</code>，至少需要三条 CPU 指令。 </p>
<ul>
<li>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；</li>
<li>指令 2：之后，在寄存器中执行 +1 操作；</li>
<li>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</li>
</ul>
<p>操作系统做任务切换，可以发生在任何一条<strong>CPU 指令</strong>执行完，是的，是 CPU 指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count=0，如果线程 A 在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。 </p>
<p> <img src="/img/work/20200701110946.png"> </p>
<p>我们潜意识里面觉得 count+=1 这个操作是一个不可分割的整体，就像一个原子一样，线程的切换可以发生在 count+=1 之前，也可以发生在 count+=1 之后，但就是不会发生在中间。<strong>我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性</strong>。CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符，这是违背我们直觉的地方。因此，很多时候我们需要在高级语言层面保证操作的原子性。 </p>
<h2 id="3-3-编译优化带来的有序性问题"><a href="#3-3-编译优化带来的有序性问题" class="headerlink" title="3.3 编译优化带来的有序性问题"></a>3.3 编译优化带来的有序性问题</h2><p>那并发编程里还有没有其他有违直觉容易导致诡异 Bug 的技术呢？有的，就是有序性。顾名思义，有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。不过有时候编译器及解释器的优化可能导致意想不到的 Bug。 </p>
<p>在 Java 领域一个经典的案例就是利用双重检查创建单例对象，例如下面的代码：在获取实例 getInstance() 的方法中，我们首先判断 instance 是否为空，如果为空，则锁定 Singleton.class 并再次检查 instance 是否为空，如果还为空则创建 Singleton 的一个实例。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> Singleton instance;<br>  <span class="hljs-function"><span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)<br>          instance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 <code>instance == null</code> ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 <code>instance == null</code> 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。 </p>
<p>这看上去一切都很完美，无懈可击，但实际上这个 getInstance() 方法并不完美。问题出在哪里呢？出在 new 操作上，我们以为的 new 操作应该是： </p>
<ol>
<li>分配一块内存 M；</li>
<li>在内存 M 上初始化 Singleton 对象；</li>
<li>然后 M 的地址赋值给 instance 变量。</li>
</ol>
<p> 但是实际上优化后的执行路径却是这样的： </p>
<ol>
<li>分配一块内存 M；</li>
<li>将 M 的地址赋值给 instance 变量；</li>
<li>最后在内存 M 上初始化 Singleton 对象。</li>
</ol>
<p>优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 <code>instance != null</code> ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。 </p>
<p> <img src="/img/work/20200701111050.png"> </p>
<h2 id="3-4-保证并发安全的思路"><a href="#3-4-保证并发安全的思路" class="headerlink" title="3.4 保证并发安全的思路"></a>3.4 保证并发安全的思路</h2><p><strong>互斥同步(阻塞同步)</strong></p>
<p>互斥同步是最常见的并发正确性保障手段。 </p>
<p><strong>同步是指在多线程并发访问共享数据时,保证共享数据在同一时刻只能被一个线程访问</strong></p>
<p>互拆是实现同步的一种手段。临界区( Critical Sections )、互斥量( Mutex )和信号量( Semaphore )都是主要的互斥实现方式。</p>
<p>最典型的案例是使用  <code>synchronized</code> 或 <code>Lock</code> 。 </p>
<p><strong>互斥同步最主要的问题是线程阻塞和唤醒所带来的性能问题</strong>，互斥同步属于是一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁( 这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁 )、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<p><strong>非阻塞同步</strong></p>
<p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略，先进行操作，如果没有其它线程争用共享数据，那就操作成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种操作称为非同步阻塞同步。</p>
<p>为什么说乐观锁需要<strong>硬件指令集的发展</strong>才能进行？ 因为需要操作和冲突检测这两个步骤具备原子性。而这点是由硬件来完成，如果再使用互斥同步来保证就失去意义了。 </p>
<p>这类乐观锁指令常见的有： </p>
<ul>
<li>测试并设置（Test-and-Set）</li>
<li>获取并增加（Fetch-and-Increment）</li>
<li>交换（Swap）</li>
<li>比较并交换（CAS）</li>
<li>加载链接、条件存储（Load-linked / Store-Conditional）</li>
</ul>
<p> Java 典型应用场景：J.U.C 包中的原子类（基于 <code>Unsafe</code> 类的 CAS 操作） </p>
<p><strong>无同步</strong></p>
<p>要保证线程安全，不一定非要进行同步。同步只是保证共享数据争用时的正确性，如果一个方法本来就不涉及共享数据，那么自然无须同步。 </p>
<p> Java 中的 <strong>无同步方案</strong> 有 ：</p>
<ul>
<li><strong>可重入代码</strong> - 也叫纯代码。如果一个方法，它的 <strong>返回结果是可以预测的</strong>，即只要输入了相同的数据，就能返回相同的结果，那它就满足可重入性，当然也是线程安全的。</li>
<li><strong>线程本地存储</strong> - 使用 <strong><code>ThreadLocal</code> 为共享变量在每个线程中都创建了一个本地副本</strong>，这个副本只能被当前线程访问，其他线程无法访问，那么自然是线程安全的。</li>
</ul>
<h1 id="4-活跃性问题"><a href="#4-活跃性问题" class="headerlink" title="4.活跃性问题"></a>4.活跃性问题</h1><h2 id="4-1-死锁（Deadlock）"><a href="#4-1-死锁（Deadlock）" class="headerlink" title="4.1 死锁（Deadlock）"></a>4.1 死锁（Deadlock）</h2><p><strong>什么是死锁</strong></p>
<p>多个线程互相等待对象释放锁</p>
<p>死锁是当线程进行无限等待状态时发生的情况，因为所请求的锁被另一个线程持有，而另一个线程又等待第一个线程持有另一个锁。</p>
<p> <img src="/img/work/deadlock.png"> </p>
<p><strong>避免死锁</strong></p>
<p> （1）按序加锁 </p>
<p> 当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。  如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。  按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(译者注：并对这些锁做适当的排序)，但总有些时候是无法预知的。 </p>
<p> （2）超时释放锁 </p>
<p>另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(译者注：加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。 </p>
<p> （3）死锁检测 </p>
<p> 死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。  每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph 等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。 </p>
<p>当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。 </p>
<p> 如果检测出死锁，有两种处理手段： </p>
<ul>
<li>释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争） </li>
<li> 一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级 .</li>
</ul>
<h2 id="4-2活锁（Livelock）"><a href="#4-2活锁（Livelock）" class="headerlink" title="4.2活锁（Livelock）"></a>4.2活锁（Livelock）</h2><p><strong>什么是活锁</strong></p>
<p>活锁是一个递归的情况，两个或更多的线程会不断的重复一个特定的代码逻辑。预期的逻辑通常为其他线程提供机会继续支持‘this‘线程。</p>
<p>想象这样一个例子：两个人在狭窄的走廊相遇，二者都很礼貌，试图移到旁边让对方先通过。但是他们最终在没有取得任务进展的情况下左右摇摆，因为他们都在同一时间向相同的方向移动。</p>
<p> <img src="/img/work/livelock.png">  </p>
<p> 如图所示：两个线程想要通过一个 Worker 对象访问共享公共资源的情况，但是当他们看到另一个 Worker（在另一个线程上调用）也是“活动的”时，它们会尝试将该资源交给其他工作者并等待为它完成。如果最初我们让两名工作人员都活跃起来，他们将会面临活锁问题 。</p>
<p><strong>避免活锁</strong></p>
<p>解决“<strong>活锁</strong>”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。由于等待的时间是随机的，所以同时相撞后再次相撞的概率就很低了。“等待一个随机时间”的方案虽然很简单，却非常有效，Raft 这样知名的分布式一致性算法中也用到了它。</p>
<h2 id="4-3-饥饿（Starvation）"><a href="#4-3-饥饿（Starvation）" class="headerlink" title="4.3. 饥饿（Starvation）"></a>4.3. 饥饿（Starvation）</h2><p><strong>什么是饥饿</strong></p>
<ul>
<li><p>高优先级线程吞噬所有的低优先级线程的 CPU 时间。</p>
</li>
<li><p>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</p>
</li>
<li><p>线程在等待一个本身(在其上调用 wait())也处于永久等待完成的对象，因为其他线程总是被持续地获得唤醒。</p>
<p> <img src="/img/work/starvation-and-fairness.png"> </p>
</li>
</ul>
<p>饥饿问题最经典的例子就是哲学家问题。如图所示：有五个哲学家用餐，每个人要获得两把叉子才可以就餐。当 2、4 就餐时，1、3、5 永远无法就餐，只能看着盘中的美食饥饿的等待着。 </p>
<p><strong>解决饥饿</strong></p>
<p>Java 不可能实现 100% 的公平性，我们依然可以通过同步结构在线程间实现公平性的提高。 </p>
<p>有三种方案： </p>
<ul>
<li>保证资源充足</li>
<li>公平地分配资源</li>
<li>避免持有锁的线程长时间执行</li>
</ul>
<p>这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。倒是方案二的适用场景相对来说更多一些。 </p>
<p>那如何公平地分配资源呢？在并发编程里，主要是使用<strong>公平锁</strong>。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。 </p>
<h1 id="5-性能问题"><a href="#5-性能问题" class="headerlink" title="5. 性能问题"></a>5. 性能问题</h1><p>并发执行一定比串行执行快吗？线程越多执行越快吗？</p>
<p>答案是：<strong>并发不一定比串行快</strong>。因为有创建线程和线程上下文切换的开销</p>
<h2 id="5-1-上下文切换"><a href="#5-1-上下文切换" class="headerlink" title="5.1. 上下文切换"></a>5.1. 上下文切换</h2><p><strong>什么是上下文切换</strong>？</p>
<p>当 CPU 从执行一个线程切换到执行另一个线程时，CPU 需要保存当前线程的本地数据，程序指针等状态，并加载下一个要执行的线程的本地数据，程序指针等。这个开关被称为“上下文切换”。 </p>
<p><strong>减少上下文切换的方法</strong></p>
<ul>
<li>无锁并发编程 - 多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的 ID 按照 Hash 算法取模分段，不同的线程处理不同段的数据。</li>
<li>CAS 算法 - Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁。</li>
<li>使用最少线程 - 避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。</li>
<li>使用协程 - 在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li>
</ul>
<h2 id="5-2-资源限制"><a href="#5-2-资源限制" class="headerlink" title="5.2. 资源限制"></a>5.2. 资源限制</h2><p><strong>什么是资源限制</strong></p>
<p>资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。 </p>
<p><strong>资源限制引发的问题</strong></p>
<p>在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。 </p>
<p><strong>如何解决资源限制的问题</strong></p>
<p> 在资源限制情况下进行并发编程，根据不同的资源限制调整程序的并发度。 </p>
<ul>
<li>对于硬件资源限制，可以考虑使用集群并行执行程序。</li>
<li>对于软件资源限制，可以考虑使用资源池将资源复用。</li>
</ul>
<h1 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h1><p>并发编程可以总结为三个核心问题：分工、同步、互斥。</p>
<ul>
<li><strong>分工</strong>：是指如何高效地拆解任务并分配给线程。</li>
<li><strong>同步</strong>：是指线程之间如何协作。</li>
<li><strong>互斥</strong>：是指保证同一时刻只允许一个线程访问共享资源。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-注解机制</title>
    <url>/2021/11/05/Java%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="1-1-注解："><a href="#1-1-注解：" class="headerlink" title="1.1 注解："></a>1.1 <strong>注解：</strong></h3><blockquote>
<p>从本质上来说，<strong>注解是一种标签，其实质上可以视为一种特殊的注释，如果没有解析它的代码，它并不比普通注释强。</strong>。</p>
</blockquote>
<p>解析一个注解往往有两种形式：</p>
<ul>
<li><strong>编译期直接的扫描</strong> - 编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。这种情况只适用于 JDK 内置的注解类。</li>
<li><strong>运行期的反射</strong> - 如果要自定义注解，Java 编译器无法识别并处理这个注解，它只能根据该注解的作用范围来选择是否编译进字节码文件。如果要处理注解，必须利用反射技术，识别该注解以及它所携带的信息，然后做相应的处理。</li>
</ul>
<h3 id="1-2注解优点"><a href="#1-2注解优点" class="headerlink" title="1.2注解优点"></a>1.2<strong>注解优点</strong></h3><ul>
<li><p>注解的出现可以替代一些现有的系统，例如 XDoclet，它是一种独立的文档化工具，专门设计用来生成注解风格的文档。与之相比，注解是真正语言层级的概念，以前构造出来就享有编译器的类型检查保护。</p>
</li>
<li><p>注解在源代码级别保存所有信息而不是通过注释文字，这使得代码更加整洁和便于维护。通过使用拓展的 annotation API 或稍后在本章节可以看到的外部的字节码工具类库，你会拥有对源代码及字节码强大的检查与操作能力。</p>
</li>
</ul>
<h3 id="1-3注解缺点"><a href="#1-3注解缺点" class="headerlink" title="1.3注解缺点:"></a>1.3<strong>注解缺点:</strong></h3><ul>
<li><p>它是一种侵入式编程，增加程序耦合度。</p>
</li>
<li><p>自定义注解的处理需要在运行时，通过反射技术来获取属性。如果注解所修饰的元素是类的非 public 成员，也可以通过反射获取。这就违背了面向对象的封装性。</p>
</li>
<li><p>注解所产生的问题，相对而言，更难以 debug 或定位。</p>
</li>
</ul>
<h3 id="1-4-注解应用范围"><a href="#1-4-注解应用范围" class="headerlink" title="1.4 注解应用范围"></a><strong>1.4 注解应用范围</strong></h3><p>注解可以应用于类、字段、方法和其他程序元素的声明</p>
<p>JDK8 开始，注解的应用范围进一步扩大，以下是新的应用范围：</p>
<p>类实例初始化表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-meta">@Interned</span> MyObject();<br></code></pre></td></tr></table></figure>

<p>类型转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">myString = (<span class="hljs-meta">@NonNull</span> String) str;<br></code></pre></td></tr></table></figure>

<p>实现接口的声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnmodifiableList</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span></span><br><span class="hljs-class">    @<span class="hljs-title">Readonly</span> <span class="hljs-title">List</span>&lt;@<span class="hljs-title">Readonly</span> <span class="hljs-title">T</span>&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>抛出异常声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">monitorTemperature</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> @Critical TemperatureException </span>&#123;&#125;<br></code></pre></td></tr></table></figure>



<h2 id="2-内置注解及元注解"><a href="#2-内置注解及元注解" class="headerlink" title="2.内置注解及元注解"></a>2.内置注解及元注解</h2><h3 id="2-2-内置注解"><a href="#2-2-内置注解" class="headerlink" title="2.2 内置注解"></a>2.2 内置注解</h3><p>JDK 中内置了以下注解：</p>
<ul>
<li><code>@Override</code></li>
<li><code>@Deprecated</code></li>
<li><code>@SuppressWarnnings</code></li>
<li><code>@SafeVarargs</code>（JDK7 引入）</li>
<li><code>@FunctionalInterface</code>（JDK8 引入）</li>
</ul>
<h4 id="2-2-1-Override"><a href="#2-2-1-Override" class="headerlink" title="2.2.1  @Override"></a><strong>2.2.1  @Override</strong></h4><p><strong>@Override用于表明被修饰方法覆写了父类的方法。</strong></p>
<p>如果试图使用 <code>@Override</code> 标记一个实际上并没有覆写父类的方法时，java 编译器会告警。</p>
<p><code>@Override</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OverrideAnnotationDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;getName&quot;</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;override getName&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  放开下面的注释，编译时会告警</span><br><span class="hljs-comment">         */</span><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">        @Override</span><br><span class="hljs-comment">        public String getName2() &#123;</span><br><span class="hljs-comment">            return &quot;override getName2&quot;;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-2-2-Deprecated"><a href="#2-2-2-Deprecated" class="headerlink" title="2.2.2@Deprecated"></a><strong>2.2.2@Deprecated</strong></h4><p><strong><code>@Deprecated</code> 用于标明被修饰的类或类成员、类方法已经废弃、过时，不建议使用。</strong></p>
<p><code>@Deprecated</code> 有一定的<strong>延续性</strong>：如果我们在代码中通过继承或者覆盖的方式使用了过时的类或类成员，即使子类或子方法没有标记为 <code>@Deprecated</code>，但编译器仍然会告警。</p>
<blockquote>
<p> 🔔 注意： <code>@Deprecated</code> 这个注解类型和 javadoc 中的 <code>@deprecated</code> 这个 tag 是有区别的：前者是 java 编译器识别的；而后者是被 javadoc 工具所识别用来生成文档（包含程序成员为什么已经过时、它应当如何被禁止或者替代的描述）。</p>
</blockquote>
<h4 id="2-2-3-SuppressWarnnings"><a href="#2-2-3-SuppressWarnnings" class="headerlink" title="2.2.3 @SuppressWarnnings"></a><strong>2.2.3 @SuppressWarnnings</strong></h4><p><strong><code>@SuppressWarnings</code>用于关闭对类、方法、成员编译时产生的特定警告。</strong></p>
<p><code>@SuppressWarning</code> 不是一个标记注解。它有一个类型为 <code>String[]</code> 的数组成员，这个数组中存储的是要关闭的告警类型。对于 javac 编译器来讲，对 <code>-Xlint</code> 选项有效的警告名也同样对 <code>@SuppressWarings</code> 有效，同时编译器会忽略掉无法识别的警告名。</p>
<p><code>@SuppressWarning</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuppressWarningsAnnotationDemo</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuppressDemo</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">private</span> T value;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">var</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;deprecation&quot;&#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SuppressDemo d = <span class="hljs-keyword">new</span> SuppressDemo();<br>        d.setValue(<span class="hljs-string">&quot;南京&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;地名：&quot;</span> + d.getValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>@SuppressWarnings</code> 注解的常见参数值的简单说明：</p>
<ul>
<li><code>deprecation</code> - 使用了不赞成使用的类或方法时的警告；</li>
<li><code>unchecked</code> - 执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型;</li>
<li><code>fallthrough</code> - 当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;</li>
<li><code>path</code> - 在类路径、源文件路径等中有不存在的路径时的警告;</li>
<li><code>serial</code> - 当在可序列化的类上缺少 serialVersionUID 定义时的警告;</li>
<li><code>finally</code> - 任何 finally 子句不能正常完成时的警告;</li>
<li><code>all</code> - 所有的警告。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&#123;&quot;uncheck&quot;, &quot;deprecation&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InternalAnnotationDemo</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@SuppressWarnings</span> 标记消除当前类的告警信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;deprecation&quot;&#125;)</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;call method1&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@Deprecated</span> 标记当前方法为废弃方法，不建议使用</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Deprecated</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;call method2&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Deprecated</span> 标记当前类为废弃类，不建议使用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Deprecated</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@Override</span> 标记显示指明当前方法覆写了父类或接口的方法</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        A obj = <span class="hljs-keyword">new</span> B();<br>        obj.method1();<br>        obj.method2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-2-4-SafeVarargs"><a href="#2-2-4-SafeVarargs" class="headerlink" title="2.2.4 @SafeVarargs"></a><strong>2.2.4 @SafeVarargs</strong></h4><p><code>@SafeVarargs</code> 在 JDK7 中引入。</p>
<p><strong><code>@SafeVarargs</code>的作用是：告诉编译器，在可变长参数中的泛型是类型安全的。可变长参数是使用数组存储的，而数组和泛型不能很好的混合使用。</strong></p>
<p>简单的说，数组元素的数据类型在编译和运行时都是确定的，而泛型的数据类型只有在运行时才能确定下来。因此，当把一个泛型存储到数组中时，编译器在编译阶段无法确认数据类型是否匹配，因此会给出警告信息；即如果泛型的真实数据类型无法和参数数组的类型匹配，会导致 <code>ClassCastException</code> 异常。</p>
<p><code>@SafeVarargs</code> 注解使用范围：</p>
<ul>
<li><code>@SafeVarargs</code> 注解可以用于构造方法。</li>
<li><code>@SafeVarargs</code> 注解可以用于 <code>static</code> 或 <code>final</code> 方法。</li>
</ul>
<p><code>@SafeVarargs</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SafeVarargsAnnotationDemo</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 此方法实际上并不安全，不使用此注解，编译时会告警</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SafeVarargs</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wrongMethod</span><span class="hljs-params">(List&lt;String&gt;... stringLists)</span> </span>&#123;<br>        Object[] array = stringLists;<br>        List&lt;Integer&gt; tmpList = Arrays.asList(<span class="hljs-number">42</span>);<br>        array[<span class="hljs-number">0</span>] = tmpList; <span class="hljs-comment">// 语法错误，但是编译不告警</span><br>        String s = stringLists[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>); <span class="hljs-comment">// 运行时报 ClassCastException</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;A&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;B&quot;</span>);<br><br>        List&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;2&quot;</span>);<br><br>        wrongMethod(list, list2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上代码，如果不使用 <code>@SafeVarargs</code> ，编译时会告警</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">[WARNING] SafeVarargsAnnotationDemo.java: 某些输入文件使用了未经检查或不安全的操作。<br>[WARNING] SafeVarargsAnnotationDemo.java: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。<br></code></pre></td></tr></table></figure>

<h4 id="2-2-5-FunctionalInterface"><a href="#2-2-5-FunctionalInterface" class="headerlink" title="2.2.5 @FunctionalInterface"></a><strong>2.2.5 @FunctionalInterface</strong></h4><p><code>@FunctionalInterface</code> 在 JDK8 引入。</p>
<p><strong><code>@FunctionalInterface</code>用于指示被修饰的接口是函数式接口。</strong></p>
<p>需要注意的是，如果一个接口符合”函数式接口”定义，不加 <code>@FunctionalInterface</code> 也没关系；但如果编写的不是函数式接口，却使用 <code>@FunctionInterface</code>，那么编译器会报错。</p>
<p>什么是函数式接口？</p>
<p><strong>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口</strong>。函数式接口可以被隐式转换为 lambda 表达式。</p>
<p>函数式接口的特点：</p>
<ul>
<li>接口有且只能有个一个抽象方法（抽象方法只有方法定义，没有方法体）。</li>
<li>不能在接口中覆写 Object 类中的 public 方法（写了编译器也会报错）。</li>
<li>允许有 default 实现方法。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionalInterfaceAnnotationDemo</span> </span>&#123;<br><br>    <span class="hljs-meta">@FunctionalInterface</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Func1</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">(T message)</span></span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@FunctionalInterface</span> 修饰的接口中定义两个抽象方法，编译时会报错</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">/*@FunctionalInterface</span><br><span class="hljs-comment">    public interface Func2&lt;T&gt; &#123;</span><br><span class="hljs-comment">        void printMessage(T message);</span><br><span class="hljs-comment">        void printMessage2(T message);</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Func1 func1 = message -&gt; System.out.println(message);<br>        func1.printMessage(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        func1.printMessage(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-3-元注解"><a href="#2-3-元注解" class="headerlink" title="2.3 元注解"></a>2.3 元注解</h3><p>Java 语言中目前有 5 种标准注解（前面介绍过），以及 5 种元注解。元注解用于注解其他的注解</p>
<p><strong>@Target</strong></p>
<p><strong><code>@Target</code> 指定注解可以修饰的元素类型。</strong></p>
<p>**<code>@Target</code> **源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Target &#123;<br>    ElementType[] value();<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>ElementType</code> 是一个枚举类型，它定义了被 <code>@Target</code> 修饰的注解可以应用的范围：</p>
<ul>
<li><code>ElementType.ANNOTATION_TYPE</code> - 标记的注解可以应用于注解类型。</li>
<li><code>ElementType.CONSTRUCTOR</code> - 标记的注解可以应用于构造函数。</li>
<li><code>ElementType.FIELD</code> - 标记的注解可以应用于字段或属性。</li>
<li><code>ElementType.LOCAL_VARIABLE</code> - 标记的注解可以应用于局部变量。</li>
<li><code>ElementType.METHOD</code> - 标记的注解可以应用于方法。</li>
<li><code>ElementType.PACKAGE</code> - 标记的注解可以应用于包声明。</li>
<li><code>ElementType.PARAMETER</code> - 标记的注解可以应用于方法的参数。</li>
<li><code>ElementType.TYPE</code> - 标记的注解可以应用于类的任何元素。</li>
</ul>
<p><code>@Target</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Table &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数据表名称注解，默认值为类名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">tableName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;className&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NoDBColumn &#123;&#125;<br></code></pre></td></tr></table></figure>

<p><strong>@Retention</strong></p>
<p><code>@Retention</code><strong>指明了注解的保留级别</strong></p>
<p><code>@Retention</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Retention &#123;<br>    <span class="hljs-function">RetentionPolicy <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>RetentionPolicy</code> 是一个枚举类型，它定义了被 <code>@Retention</code> 修饰的注解所支持的保留级别：</p>
<ul>
<li><code>RetentionPolicy.SOURCE</code> - 标记的注解仅在源文件中有效，编译器会忽略。</li>
<li><code>RetentionPolicy.CLASS</code> - 标记的注解在 class 文件中有效，JVM 会忽略。</li>
<li><code>RetentionPolicy.RUNTIME</code> - 标记的注解在运行时有效。</li>
</ul>
<p><code>@Retention</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Column &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;fieldName&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">setFuncName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;setField&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFuncName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;getField&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">defaultDBValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>@Documented</strong></p>
<p><code>@Documented</code>表示无论何时使用指定的注解，都应使用 Javadoc（默认情况下，注释不包含在 Javadoc 中）</p>
<p><code>@Documented</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Column &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;fieldName&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">setFuncName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;setField&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFuncName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;getField&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">defaultDBValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>@Interited</strong></p>
<p><strong><code>@Inherited</code> 表示注解类型可以被继承（默认情况下不是这样）</strong>。</p>
<p>表示自动继承注解类型。 如果注解类型声明中存在 <code>@Inherited</code> 元注解，则注解所修饰类的所有子类都将会继承此注解。</p>
<blockquote>
<p>🔔 注意：<code>@Inherited</code> 注解类型是被标注过的类的子类所继承。类并不从它所实现的接口继承注解，方法并不从它所覆写的方法继承注解。</p>
<p>此外，当 <code>@Inherited</code> 类型标注的注解的 <code>@Retention</code> 是 <code>RetentionPolicy.RUNTIME</code>，则反射 API 增强了这种继承性。如果我们使用 <code>java.lang.reflect</code> 去查询一个 <code>@Inherited</code> 类型的注解时，反射代码检查将展开工作：检查类和其父类，直到发现指定的注解类型被发现，或者到达类继承结构的顶层。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Greeting &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FontColor</span></span>&#123; BULE,RED,GREEN&#125;;<br>    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">FontColor <span class="hljs-title">fontColor</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> FontColor.GREEN</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>@Repeatable</strong></p>
<p><strong><code>@Repeatable</code> 表示注解可以重复使用（Java 8新特性）。</strong></p>
<p>以 Spring <code>@Scheduled</code> 为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Schedules &#123;<br>	Scheduled[] value();<br>&#125;<br><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Repeatable(Schedules.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Scheduled &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>应用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskRunner</span> </span>&#123;<br><br>    <span class="hljs-meta">@Scheduled(&quot;0 0/15 * * * ?&quot;)</span><br>    <span class="hljs-meta">@Scheduled(&quot;0 0 12 * ?&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">task1</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="3.基本语法"></a>3.基本语法</h2><p>在下面举例中，使用@Test对<code>testExcute</code>进行注解。该注解本身不做任何操作，但是编译器要保证类路径上有<code>@Test</code>注解的定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestTable</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Executing ... &quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testExecute</span><span class="hljs-params">()</span> </span>&#123;<br>        execute();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>被注解标注的方法和其他的方法没有任何区别,注解 <code>@Test</code>可以和任何修饰符共同用于方法，诸如 <strong>public</strong>、<strong>static</strong> 或 <strong>void</strong>。从语法的角度上看，注解的使用方式和修饰符的使用方式一致。</p>
<h3 id="3-1-定义注解"><a href="#3-1-定义注解" class="headerlink" title="3.1 定义注解"></a>3.1 定义注解</h3><p>如下是一个注解的定义。注解的定义看起来很像接口的定义。事实上，它们和其他 Java 接口一样，也会被编译成 class 文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;&#125;<br></code></pre></td></tr></table></figure>

<p>除了 @ 符号之外， <code>@Test</code> 的定义看起来更像一个空接口。注解的定义也需要一些元注解（meta-annoation），比如 <code>@Target</code> 和 <code>@Retention</code>。<code>@Target</code> 定义你的注解可以应用在哪里（例如是方法还是字段）。<code>@Retention</code> 定义了注解在哪里可用，在源代码中(SOURCE)，class 文件(CLASS)中或者是在运行时(RUNTIME)。</p>
<blockquote>
<p> 标记注解</p>
</blockquote>
<p>不包含任何元素的注解称为标记注解（marker annotation），例如上例中的 <code>@Test</code> 就是标记注解。</p>
<h3 id="3-2-注解使用"><a href="#3-2-注解使用" class="headerlink" title="3.2 注解使用"></a>3.2 注解使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> UseCase &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">String <span class="hljs-title">description</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;no description&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意 <strong>id</strong> 和 <strong>description</strong> 与方法定义类似。由于编译器会对 <strong>id</strong> 进行类型检查，因此将跟踪数据库与用例文档和源代码相关联是可靠的方式。<strong>description</strong> 元素拥有一个 <strong>default</strong> 值，如果在注解某个方法时没有给出 <strong>description</strong> 的值。则该注解的处理器会使用此元素的默认值。</p>
<p>以下例子中，将有三个方法被注解为用例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PasswordUtils</span> </span>&#123;<br><br>    <span class="hljs-meta">@UseCase(id = 2,description = &quot;Passwords must contain at least one numeric&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validatePassword</span><span class="hljs-params">(String password)</span> </span>&#123;<br><br>        <span class="hljs-keyword">return</span> (password.matches(<span class="hljs-string">&quot;\\w*\\d\\w*&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-meta">@UseCase(id = 3)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encryptPassword</span><span class="hljs-params">(String passwd)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StringBuilder(passwd)<br>                .reverse().toString();<br>    &#125;<br><br>    <span class="hljs-meta">@UseCase(id = 4,description = &quot;New passwords can&#x27;t equal previously used ones&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkForNewPassword</span><span class="hljs-params">(List&lt;String&gt; prevPasswords, String passwd)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !prevPasswords.contains(passwd);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注解的元素在使用时表现为 名-值 对的形式，并且需要放置在 <code>@UseCase</code> 声明之后的括号内。在 <code>encryptPassword()</code> 方法的注解中，并没有给出 <strong>description</strong> 的默认值，所以在 <strong>@interface UseCase</strong> 的注解处理器分析处理这个类的时候会使用该元素的默认值。</p>
<h3 id="3-3-注解处理器"><a href="#3-3-注解处理器" class="headerlink" title="3.3 注解处理器"></a>3.3 注解处理器</h3><blockquote>
<p>如果没有用于读取注解的工具，那么注解不会比注释更有用。使用注解中一个很重要的部分就是，创建与使用注解处理器。Java 拓展了反射机制的 API 用于帮助你创造这类工具。同时他还提供了 javac 编译器钩子在编译时使用注解。</p>
</blockquote>
<p>下面是一个非常简单的注解处理器，我们用它来读取被注解的 <strong>PasswordUtils</strong> 类，并且使用反射机制来寻找 <strong>@UseCase</strong> 标记。给定一组 <strong>id</strong> 值，然后列出在 <strong>PasswordUtils</strong> 中找到的用例，以及缺失的用例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UseCaseTracker</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trackUseCases</span><span class="hljs-params">(List&lt;Integer&gt; useCases,Class&lt;?&gt; cl)</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span> (Method method : cl.getDeclaredMethods()) &#123;<br>            UseCase useCase = method.getAnnotation(UseCase.class);<br><br>            <span class="hljs-keyword">if</span> (useCase != <span class="hljs-keyword">null</span> ) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Found Use Case&quot;</span> + useCase.id() + <span class="hljs-string">&quot;\n&quot;</span> + useCase.description());<br>                useCases.remove(Integer.valueOf(useCase.id()));<br>            &#125;<br>        &#125;<br><br>        useCases.forEach(e -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Missing use case &quot;</span> + e);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; useCases = IntStream.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>).boxed().collect(Collectors.toList());<br><br>        trackUseCases(useCases,PasswordUtils.class);<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<p>这个程序用了两个反射的方法：<code>getDeclaredMethods()</code> 和 <code>getAnnotation()</code>，它们都属于 <strong>AnnotatedElement</strong> 接口（<strong>Class</strong>，<strong>Method</strong> 与 <strong>Field</strong> 类都实现了该接口）。<code>getAnnotation()</code> 方法返回指定类型的注解对象，在本例中就是 “<strong>UseCase</strong>”。如果被注解的方法上没有该类型的注解，返回值就为 <strong>null</strong>。我们通过调用 <code>id()</code> 和 <code>description()</code> 方法来提取元素值。注意 <code>encryptPassword()</code> 方法在注解的时候没有指定 <strong>description</strong> 的值，因此处理器在处理它对应的注解时，通过 <code>description()</code> 取得的是默认值 “no description”。</p>
<h3 id="3-4-注解元素"><a href="#3-4-注解元素" class="headerlink" title="3.4 注解元素"></a>3.4 注解元素</h3><p>在 <strong>UseCase.java</strong> 中定义的 <strong>@UseCase</strong> 的标签包含 int 元素 <strong>id</strong> 和 String 元素 <strong>description</strong>。注解元素可用的类型如下所示：</p>
<ul>
<li>所有基本类型（int、float、boolean 等）</li>
<li>String</li>
<li>Class</li>
<li>enum</li>
<li>Annotation</li>
<li>以上类型的数组</li>
</ul>
<p>如果你使用了其他类型，编译器就会报错。注意，也不允许使用任何包装类型，但是由于自动装箱的存在，这不算是什么限制。注解也可以作为元素的类型。稍后你会看到，注解嵌套是一个非常有用的技巧。</p>
<h3 id="3-5-默认值限制"><a href="#3-5-默认值限制" class="headerlink" title="3.5 默认值限制"></a>3.5 默认值限制</h3><p>编译器对于元素的默认值有些过于挑剔。首先，元素不能有不确定的值。也就是说，元素要么有默认值，要么就在使用注解时提供元素的值。</p>
<p>这里有另外一个限制：任何非基本类型的元素， 无论是在源代码声明时还是在注解接口中定义默认值时，都不能使用 null 作为其值。这个限制使得处理器很难表现一个元素的存在或者缺失的状态，因为在每个注解的声明中，所有的元素都存在，并且具有相应的值。为了绕开这个约束，可以自定义一些特殊的值，比如空字符串或者负数用于表达某个元素不存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// annotations/SimulatingNull.java</span><br><span class="hljs-keyword">import</span> java.lang.annotation.*;<br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SimulatingNull &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -1</span>;<br>    <span class="hljs-function">String <span class="hljs-title">description</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是一个在定义注解的习惯用法。</p>
<h2 id="4-注解使用示例"><a href="#4-注解使用示例" class="headerlink" title="4. 注解使用示例"></a>4. 注解使用示例</h2><p>知道以上语法及基本使用后，下面引用(《Tinking in Java》)例子来示例利用运行时注解来组装数据库SQL的构建语句的过程</p>
<blockquote>
<p>表注解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><span class="hljs-comment">//只能应用于类上</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-comment">//保存到运行时</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> DBTable &#123;<br>    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>注解String类型的字段</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SQLString &#123;<br><br>    <span class="hljs-comment">//对应数据库表的列名</span><br>    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    <span class="hljs-comment">//列类型分配的长度，如varchar(30)的30</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;<br><br>    <span class="hljs-function">Constraints <span class="hljs-title">constraint</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> @Constraints</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>注解SQLInteger类型</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SQLInteger &#123;<br><br>    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    <span class="hljs-function">Constraints <span class="hljs-title">constraints</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> @Constraints</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>约束注解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><span class="hljs-comment">//只能应用在字段上</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Constraints &#123;<br>    <span class="hljs-comment">//判断是否作为主键约束</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">primaryKey</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br>    <span class="hljs-comment">//判断是否允许为null</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">allowNull</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br>    <span class="hljs-comment">//判断是否唯一</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">unique</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>数据库表Member对应实例类bean</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DBTable(name = &quot;MEMBER&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Member</span> </span>&#123;<br>    <span class="hljs-meta">@SQlString(30)</span><br>    String firstName;<br><br>    <span class="hljs-meta">@SQlString(50)</span><br>    String lastName;<br><br>    <span class="hljs-meta">@SQLInteger</span><br>    Integer age;<br><br>    <span class="hljs-meta">@SQlString(value = 30,constraints = @Constraints(primaryKey = true))</span><br>    String reference;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> memberCount;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFirstName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> firstName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLastName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> lastName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getReference</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> reference;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> reference; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>上述定义4个注解，分别是@DBTable(用于类上)、@Constraints(用于字段上)、 @SQLString(用于字段上)、@SQLString(用于字段上)并在Member类中使用这些注解，这些注解的作用的是用于帮助注解处理器生成创建数据库表MEMBER的构建语句，在这里有点需要注意的是，我们使用了嵌套注解@Constraints，该注解主要用于判断字段是否为null或者字段是否唯一。必须清楚认识到上述提供的注解生命周期必须为@Retention(RetentionPolicy.RUNTIME)，即运行时，这样才可以使用反射机制获取其信息。有了上述注解和使用，剩余的就是编写上述的注解处理器了，前面我们聊了很多注解，其处理器要么是Java自身已提供、要么是框架已提供的，我们自己都没有涉及到注解处理器的编写，但上述定义处理SQL的注解，其处理器必须由我们自己编写了，如下:</p>
<h3 id="实现处理器"><a href="#实现处理器" class="headerlink" title="实现处理器"></a>实现处理器</h3><p>处理器将读取一个类文件，检查上面的数据库注解，并生成用于创建数据库的 SQL 命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TableCreator</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createTableSql</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        <span class="hljs-keyword">if</span> (args.length &lt; <span class="hljs-number">0</span>) &#123;<br>            System.out.println(<br>                    <span class="hljs-string">&quot;arguments: annotated classes&quot;</span>);<br>            System.exit(<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (String className : args) &#123;<br>            Class&lt;?&gt; cl = Class.forName(className);<br><br>            DBTable dbTable = cl.getAnnotation(DBTable.class);<br><br>            <span class="hljs-keyword">if</span> (dbTable == <span class="hljs-keyword">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;No DBTable annotations in class &quot;</span> + className);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            String tableName = dbTable.name();<br><br>            <span class="hljs-keyword">if</span> (tableName.length() &lt; <span class="hljs-number">1</span>)<br>                tableName = cl.getName().toUpperCase();<br><br>            List&lt;String&gt; columnDefs = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>            <span class="hljs-keyword">for</span> (Field field : cl.getDeclaredFields()) &#123;<br>                String columnName = <span class="hljs-keyword">null</span>;<br>                Annotation[] annotations = field.getDeclaredAnnotations();<br>                <span class="hljs-keyword">if</span> (annotations.length &lt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (annotations[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> SQLInteger) &#123;<br>                    SQLInteger sqlInteger = (SQLInteger) annotations[<span class="hljs-number">0</span>];<br><br>                    <span class="hljs-keyword">if</span> (sqlInteger.name().length() &lt; <span class="hljs-number">1</span> ) &#123;<br>                        columnName = field.getName().toUpperCase();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        columnName = sqlInteger.name();<br>                    &#125;<br><br>                    columnDefs.add(columnName + <span class="hljs-string">&quot; INT &quot;</span> + getConstraints(sqlInteger.constraints()));<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (annotations[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> SQlString) &#123;<br>                    SQlString sQlString = (SQlString) annotations[<span class="hljs-number">0</span>];<br>                    <span class="hljs-keyword">if</span> (sQlString.name().length() &lt; <span class="hljs-number">1</span>) &#123;<br>                        columnName = field.getName().toUpperCase();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        columnName = sQlString.name();<br>                    &#125;<br><br>                    columnDefs.add(columnName + <span class="hljs-string">&quot; VARCHAR(&quot;</span> + sQlString.value() + <span class="hljs-string">&quot;)&quot;</span>  + getConstraints(sQlString.constraints()));<br>                &#125;<br><br>            &#125;<br><br>            StringBuilder createCommand = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;CREATE TABLE &quot;</span> + tableName + <span class="hljs-string">&quot;(&quot;</span>);<br><br>            <span class="hljs-keyword">for</span> (String columnDef : columnDefs) &#123;<br>                createCommand.append(<span class="hljs-string">&quot;\n&quot;</span> + columnDef + <span class="hljs-string">&quot;,&quot;</span>);<br><br>            &#125;<br><br>            String tableCreate = createCommand.substring(<br>                    <span class="hljs-number">0</span>, createCommand.length() - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;);&quot;</span>;<br>            System.out.println(<span class="hljs-string">&quot;Table Creation SQL for &quot;</span> +<br>                    className + <span class="hljs-string">&quot; is:\n&quot;</span> + tableCreate);<br><br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getConstraints</span><span class="hljs-params">(Constraints con)</span> </span>&#123;<br>        String constraints = <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-keyword">if</span> (!con.allowNull())<br>            constraints += <span class="hljs-string">&quot; NOT NULL&quot;</span>;<br>        <span class="hljs-keyword">if</span> (con.primaryKey())<br>            constraints += <span class="hljs-string">&quot; PRIMARY KEY&quot;</span>;<br><br>        <span class="hljs-keyword">if</span> (con.unique())<br>            constraints += <span class="hljs-string">&quot; UNIQUE&quot;</span>;<br>        <span class="hljs-keyword">return</span> constraints;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String[] arg = &#123;<span class="hljs-string">&quot;com.example.basic.annotation.example.Member&quot;</span>&#125;;<br>        createTableSql(arg);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>最终输出结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs txt">Table Creation SQL for com.example.basic.annotation.example.Member is:<br>CREATE TABLE MEMBER(<br>FIRSTNAME VARCHAR(30),<br>LASTNAME VARCHAR(50),<br>AGE INT ,<br>REFERENCE VARCHAR(30) PRIMARY KEY);<br></code></pre></td></tr></table></figure>



<p>通过处理器可以看出是基于反射来进行处理，我们通过传递Member的全路径后通过Class.forName()方法获取到Member的class对象，然后利用Class对象中的方法获取所有成员字段Field，最后利用field.getDeclaredAnnotations()遍历每个Field上的注解再通过注解的类型判断来构建建表的SQL语句。这便是利用注解结合反射来构建SQL语句的简单的处理器模型。</p>
<p>参考:</p>
<p>《Thinking in Java》</p>
<p><a href="https://dunwu.github.io/javacore/basics/java-annotation.html#_4-1-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9A%E4%B9%89">https://dunwu.github.io/javacore/basics/java-annotation.html#_4-1-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9A%E4%B9%89</a></p>
<p><a href="https://blog.csdn.net/javazejian/article/details/71860633">https://blog.csdn.net/javazejian/article/details/71860633</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java网络编程</title>
    <url>/2022/02/28/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p><img src="/img/work/EXHSGAJSLGFI27485SHFJK0098S.png" alt="邮件发送方式"></p>
<p><strong>计算机网络：</strong></p>
<p>​        计算机网络是指将<code>地理位置不同</code>的具有独立功能的<code>多台计算机及其外部设备</code>  ，通过通信线路<code>连接起来</code>，  在网络操作系统，网络管理软件及<code>网络通信协议</code>的管理和协调下， 实现<code>资源共享</code>和<code>信息传递</code>的计算机系统。  </p>
<p><strong>网络编程的目的：</strong></p>
<p>​         传播交流信息，数据交换，通信 </p>
<p><strong>达到效果需要什么：</strong> </p>
<ol>
<li>如何准确的定位网络上的主机 <code>ip</code> <code>端口</code></li>
<li>找到了主机，如何<code>传输数据</code></li>
<li>网络编程！= 网站编程</li>
</ol>
<h2 id="2-网络分层"><a href="#2-网络分层" class="headerlink" title="2.网络分层"></a>2.网络分层</h2><p> <strong>通信双方的地址</strong> </p>
<ul>
<li>ip（局域网，公网）</li>
<li>端口号</li>
</ul>
<p> <strong>规则：网络通信的协议 OSI参考模型 TCP五层模型</strong> </p>
<ul>
<li>http https ftp（应用层）</li>
<li>tcp ip （传输层）</li>
</ul>
<h3 id="2-1-OSI参考模型"><a href="#2-1-OSI参考模型" class="headerlink" title="2.1 OSI参考模型"></a>2.1 OSI参考模型</h3><p> <strong>OSI模型把网络通信的工作分为7层:</strong>   分别是 <code> 物理层</code>、<code>数据链路层</code>、<code>网络层</code>、<code>传输层</code>、<code>会话层</code>、<code>表示层</code>和<code>应用层</code>。 </p>
<p><img src="/img/work/osi.png" alt="osi参考模型"></p>
<h3 id="2-2-TCP-IP参考模型"><a href="#2-2-TCP-IP参考模型" class="headerlink" title="2.2 TCP/IP参考模型:"></a>2.2 TCP/IP参考模型:</h3><p>​          &ensp; TCP/IP，即Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，是Internet最基本的协议，Internet国际互联网络的基础。 </p>
<p>​           &ensp; TCP/IP协议是一个开放的网络协议簇，它的名字主要取自最重要的网络层IP协议和传输层TCP协议。TCP/IP协议定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。TCP/IP参考模型采用4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求，这4个层次分别是：<code>网络接口层</code>、<code>网络层（IP层</code>）、<code>传输层（TCP层）</code>、<code>应用层</code>。 </p>
<p>![osi tcp](/img/work/osi tcp.png) </p>
<ul>
<li><p>网络接口层</p>
<p>  &ensp; TCP/IP协议对网络接口层没有给出具体的描述，网络接口层对应着OSI参考模型的物理层和数据链路层 </p>
</li>
<li><p>网络层（IP层）</p>
</li>
</ul>
<p>​          &ensp; 网络层是整个TCP/IP协议栈的核心。它的功能是把分组发往目标网络或主机。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。网络层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，互联网层还需要完成拥塞控制的功能。 </p>
<ul>
<li>传输层（TCP层）</li>
</ul>
<p>​           &ensp; TCP层负责在应用进程之间建立端到端的连接和可靠通信，它只存在与端节点中。TCP层涉及两个协议，TCP和UDP。其中，TCP协议提供面向连接的服务，提供按字节流的有序、可靠传输，可以实现连接管理、差错控制、流量控制、拥塞控制等。UDP协议提供无连接的服务，用于不需要或无法实现面向连接的网络应用中。 </p>
<ul>
<li>应用层</li>
</ul>
<p>​           &ensp; 应用层为Internet中的各种网络应用提供服务。 </p>
<p>总结:</p>
<ol>
<li> 如何准确的定位到网络上的一台或者多台主机，找到后如何通信 </li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">C:\Users\A&gt;ping www.baidu.com<br><br>正在 Ping www.a.shifen.com [183.232.231.172] 具有 32 字节的数据:<br>来自 183.232.231.172 的回复: 字节=32 时间=26ms TTL=56<br>来自 183.232.231.172 的回复: 字节=32 时间=26ms TTL=56<br><br>183.232.231.172 的 Ping 统计信息:<br>    数据包: 已发送 = 2，已接收 = 2，丢失 = 0 (0% 丢失)，<br>往返行程的估计时间(以毫秒为单位):<br>    最短 = 26ms，最长 = 26ms，平均 = 26ms<br>C:\Users\A&gt;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>ip + 端口号 + 网络通信协议</li>
</ol>
<h2 id="3-网络协议"><a href="#3-网络协议" class="headerlink" title="3.网络协议"></a>3.网络协议</h2><p><strong>网络通信协议：</strong> 如同人与人之间相互交流是需要遵循一定的规则（如语言）一样，计算机之间能够进行相互通信是因为它们都共同遵守一定的规则，即网络协议。  </p>
<p>OSI参考模型和TCP/IP模型在不同的层次中有许多不同的网络协议，如图所示： </p>
<p> <img src="/img/work/1217276-20190503164338008-348345936.png" alt="不同层次网络协议"> </p>
<p>网络协议之间的关系图如下： </p>
<p> <img src="/img/work/1217276-20190503165942538-1220277464.png"> </p>
<h3 id="3-1-IP协议（Internet-protocol）"><a href="#3-1-IP协议（Internet-protocol）" class="headerlink" title="3.1 IP协议（Internet protocol）"></a>3.1 IP协议（Internet protocol）</h3><p>​       &ensp; IP协议的作用在于把各种数据包准备无误的传递给对方，其中两个重要的条件是IP地址和MAC地址。由于IP地址是稀有资源，不可能每个人都拥有一个IP地址，所以我们通常的IP地址是路由器给我们生成的IP地址，路由器里面会记录我们的MAC地址。而MAC地址是全球唯一的。举例，IP地址就如同是我们居住小区的地址，而MAC地址就是我们住的那栋楼那个房间那个人。IP地址采用的IPv4格式，目前正在向IPv6过渡。 </p>
<h3 id="3-2-TCP协议（Transmission-Control-Protocol）"><a href="#3-2-TCP协议（Transmission-Control-Protocol）" class="headerlink" title="3.2 TCP协议（Transmission Control Protocol）"></a>3.2 TCP协议（Transmission Control Protocol）</h3><p>​        &ensp;  TCP（传输控制协议）是面向连接的传输层协议。TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。TCP协议采用字节流传输数据。 </p>
<h4 id="3-2-1-三次握手与四次挥手"><a href="#3-2-1-三次握手与四次挥手" class="headerlink" title="3.2.1 三次握手与四次挥手"></a>3.2.1 三次握手与四次挥手</h4><p>​          &ensp; TCP是面向连接的协议，因此每个<code>TCP连接</code>都有3个阶段：连接建立、数据传送和连接释放。连接建立经历三个步骤，通常称为“三次握手”。 </p>
<p> <strong>TCP三次握手过程</strong>如下： </p>
<p> <img src="/img/work/1217276-20190503210424740-1764008697.jpg" alt="三次握手"> </p>
<ol>
<li> 第一次握手（客户端发送请求） </li>
</ol>
<p>​            &ensp; 客户机发送连接请求报文段到服务器，并进入SYN_SENT状态，等待服务器确认。发送连接请求报文段内容：SYN=1，seq=x；SYN=1意思是一个TCP的SYN标志位置为1的包，指明客户端打算连接的服务器的端口；seq=x表示客户端初始序号x，保存在包头的序列号（Sequence Number）字段里。 </p>
<ol start="2">
<li> 第二次握手（服务端回传确认） </li>
</ol>
<p>​           &ensp;  服务器收到客户端连接请求报文，如果同意建立连接，向客户机发回确认报文段（ACK）应答，并为该TCP连接分配TCP缓存和变量。服务器发回确认报文段内容：SYN=1，ACK=1，seq=y，ack=x+1；SYN标志位和ACK标志位均为1，同时将确认序号（Acknowledgement Number）设置为客户的ISN加1，即x+1；seq=y为服务端初始序号y。 </p>
<ol start="3">
<li>  第三次握手（客户端回传确认） </li>
</ol>
<p>​           &ensp;  客户机收到服务器的确认报文段后，向服务器给出确认报文段（ACK），并且也要给该连接分配缓存和变量。此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。客户端发回确认报文段内容：ACK=1，seq=x+1，ack=y+1；ACK=1为确认报文段；seq=x+1为客户端序号加1；ack=y+1,为服务器发来的ACK的初始序号字段+1。 </p>
<p> <strong>注意：</strong>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。 </p>
<p><strong>TCP四次挥手过程</strong>如下： </p>
<p> <img src="/img/work/1217276-20190503231436105-1355677452.png" alt="TCP四次挥手"> </p>
<p>​          &ensp;   由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 </p>
<ol>
<li><p> TCP客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态。发送报文段内容：FIN=1，seq=u；FIN=1表示请求切断连接；seq=u为客户端请求初始序号。 </p>
</li>
<li><p> 服务端收到这个FIN，它发回一个ACK给客户端，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号；服务端进入CLOSE_WAIT状态。发送报文段内容：ACK=1，seq=v，ack=u+1；ACK=1为确认报文；seq=v为服务器确认初始序号；ack=u+1为客户端初始序号加1。 </p>
</li>
<li><p>  服务器关闭客户端的连接后，发送一个FIN给客户端，服务端进入LAST_ACK状态。发送报文段内容：FIN=1，ACK=1，seq=w，ack=u+1；FIN=1为请求切断连接，ACK=1为确认报文，seq=w为服务端请求切断初始序号。 </p>
</li>
<li><p>客户端收到FIN后，客户端进入TIME_WAIT状态，接着发回一个ACK报文给服务端确认，并将确认序号设置为收到序号加1，服务端进入CLOSED状态，完成四次挥手。发送报文内容：ACK=1，seq=u+1，ack=w+1；ACK=1为确认报文，seq=u+1为客户端初始序号加1，ack=w+1为服务器初始序号加1。  </p>
</li>
</ol>
<p><strong>注意：为什么连接的时候是三次握手，关闭的时候却是四次挥手？</strong> </p>
<p>​        &ensp;  因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，<strong>很可能并不会立即关闭socket</strong>，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文，我收到了”。只有等到服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四步挥手。 </p>
<h3 id="3-3-UDP协议（User-Datagram-Protocol）"><a href="#3-3-UDP协议（User-Datagram-Protocol）" class="headerlink" title="3.3 UDP协议（User Datagram Protocol）"></a>3.3 UDP协议（User Datagram Protocol）</h3><p> UDP，用户数据报协议，它是TCP/IP协议簇中无连接的运输层协议。 </p>
<ol>
<li>UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</li>
<li>由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务器可同时向多个客户端传输相同的消息。</li>
<li>UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。</li>
<li>吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。</li>
<li>UDP使用尽量最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表。</li>
<li>UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部受就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。</li>
</ol>
<h3 id="3-4-TCP与UDP的区别"><a href="#3-4-TCP与UDP的区别" class="headerlink" title="3.4 TCP与UDP的区别"></a>3.4 TCP与UDP的区别</h3><ul>
<li>TCP基于连接，UDP是无连接的；</li>
<li>对系统资源的要求，TCP较多，UDP较少；</li>
<li>UDP程序结构较简单；</li>
<li>TCP是流模式，而UDP是数据报模式；</li>
<li>TCP保证数据正确性，而UDP可能丢包；TCP保证数据顺序，而UDP不保证；</li>
</ul>
<h3 id="3-5-HTTP协议（Hypertext-Transfer-Protocol）"><a href="#3-5-HTTP协议（Hypertext-Transfer-Protocol）" class="headerlink" title="3.5 HTTP协议（Hypertext Transfer Protocol）"></a>3.5 HTTP协议（Hypertext Transfer Protocol）</h3><p>​         &ensp;  HTTP，超文本传输协议，它是互联网上应用最为广泛的一种网络协议。HTTP是一种应用层协议，它是基于TCP协议之上的请求/响应式的协议。HTTP协议是Web浏览器和Web服务器之间通信的标准协议。HTTP指定客户端与服务器如何建立连接、客户端如何从服务器请求数据，服务器如何响应请求，以及最后如何关闭连接。HTTP连接使用TCP/IP来传输数据。 </p>
<p>对于从客户端到服务器的每一个请求，都有4个步骤：</p>
<ol>
<li>默认情况下，客户端在端口80打开与服务器的一个TCP连接，URL中还可以指定其他端口。</li>
<li>客户端向服务器发送消息，请求指定路径上的资源。这个资源包括一个首部，可选地（取决于请求的性质）还可以有一个空行，后面是这个请求的数据。</li>
<li>服务器向客户端发送响应。响应以响应码开头，后面是包含数据的首部、一个空行以及所请求的文档或错误消息。</li>
<li>服务器关闭连接。</li>
</ol>
<p>​       &ensp;   现在使用的HTTP协议是HTTP/1.1版本，1997年之前采用的是HTTP1.0版本。HTTP连接在1.0版本中采用非持续连接工作方式，1.1版本采用的是持续连接工作方式，持续连接是指服务器在发送响应后仍然在一段时间内保持这条由TCP运输层协议建立起来的连接，使客户端和服务器可以继续在这条连接上传输HTTP报文。 </p>
<p>​     &ensp;     是否采用持续连接工作方式，1.0中默认是关闭的，需要在HTTP头加入“Connection:Keep-Alive”，才能启用Keep-Alive。HTTP1.1中默认启用Keep-Alive，如果加入“Connection:close”，才关闭。目前大部分浏览器都是用HTTP1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。 </p>
<h4 id="3-5-1-HTTP和TCP-IP协议的关系"><a href="#3-5-1-HTTP和TCP-IP协议的关系" class="headerlink" title="3.5.1 HTTP和TCP/IP协议的关系"></a>3.5.1 HTTP和TCP/IP协议的关系</h4><p> 网络中有一段比较容易理解的介绍： </p>
<p>​         &ensp;  “我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也 可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。” </p>
<h2 id="4-Java-Socket网络编程"><a href="#4-Java-Socket网络编程" class="headerlink" title="4. Java Socket网络编程"></a>4. Java Socket网络编程</h2><h3 id="4-1-Socket概述"><a href="#4-1-Socket概述" class="headerlink" title="4.1 Socket概述"></a>4.1 Socket概述</h3><p>​       &ensp;   Java的网络编程主要涉及到的内容是Socket编程。Socket，套接字，就是两台主机之间逻辑连接的端点。   TCP/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。 Socket是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。 它是网络通信过程中端点的抽象表示，  包含进行网络通信必须的五种信息：  连接使用的协议、  本地主机的IP地址、 本地进程的协议端口、 远程主机的IP地址、远程进程的协议端口。  </p>
<p>​      &ensp;    应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。  多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。  为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP/IP协议交互提供了套接字（Socket）接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p>
<p>​        &ensp;     Socket，实际上是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API）， 通过Socket，我们才能使用TCP/IP协议。实际上，Socket跟TCP/IP协议没有必然的关系，Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以说，Socket的出现，只是使得程序员更方便地使用TCP/IP协议栈而已， 是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、listen、accept、send、read和write等等。网络有一段关于socket和TCP/IP协议关系的说法比较容易理解： </p>
<p>​          &ensp;    &ensp;  “TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。”  </p>
<p>​      &ensp;      &ensp;   实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。socket是对端口通信开发的工具,它要更底层一些。 </p>
<h3 id="4-2-Socket整体流程"><a href="#4-2-Socket整体流程" class="headerlink" title="4.2 Socket整体流程"></a>4.2 Socket整体流程</h3><p>​       &ensp;      Socket编程主要涉及到客户端和服务端两个方面， 首先是在服务器端创建一个服务器套接字（ServerSocket）  ，并把它附加到一个端口上，服务器从这个端口监听连接。  端口号的范围是0到65536，但是0到1024是为特权服务保留的端口号，我们可以选择任意一个当前没有被其他进程使用的端口。 </p>
<p>​    &ensp;          客户端请求与服务器进行连接的时候，根据服务器的域名或者IP地址，加上端口号，打开一个套接字。当服务器接受连接后，服务器和客户端之间的通信就像输入输出流一样进行操作。 </p>
<p> <img src="/img/work/1217276-20190505145914692-1580218673.png" alt="Socket通信模型"> </p>
<h3 id="4-3-Socket类"><a href="#4-3-Socket类" class="headerlink" title="4.3 Socket类"></a>4.3 Socket类</h3><p> Socket 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。 </p>
<p> <strong>构造方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Socket</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-comment">//举例：</span></span><br><span class="hljs-function">Socket client </span>= <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>);<br></code></pre></td></tr></table></figure>

<p> <strong>成员方法</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//返回此套接字的输入流。</span><br><span class="hljs-comment">//如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。关闭生成的InputStream也将关闭相关的Socket。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> InputStream <span class="hljs-title">getInputStream</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//返回此套接字的输出流。</span></span><br><span class="hljs-function"><span class="hljs-comment">//如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</span></span><br><span class="hljs-function"><span class="hljs-comment">//关闭生成的OutputStream也将关闭相关的Socket。</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> OutputStream <span class="hljs-title">getOutputStream</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//关闭此套接字。</span></span><br><span class="hljs-function"><span class="hljs-comment">//一旦一个socket被关闭，它不可再使用。</span></span><br><span class="hljs-function"><span class="hljs-comment">//关闭此socket也将关闭相关的InputStream和OutputStream 。</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//禁用此套接字的输出流。</span></span><br><span class="hljs-function"><span class="hljs-comment">//任何先前写出的数据将被发送，随后终止输出流。</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdownOutput</span><span class="hljs-params">()</span>  </span><br></code></pre></td></tr></table></figure>



<h3 id="4-4-ServerSocket类"><a href="#4-4-ServerSocket类" class="headerlink" title="4.4 ServerSocket类"></a><strong>4.4 ServerSocket类</strong></h3><p> ServerSocket类：这个类实现了服务器套接字，该对象等待通过网络的请求。 </p>
<p>构造方法</p>
<p>public ServerSocket(int port) ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</p>
<p>举例：ServerSocket server = new ServerSocket(6666);</p>
<p>成员方法</p>
<p>public Socket accept() ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。</p>
<h3 id="4-5-TCP通信"><a href="#4-5-TCP通信" class="headerlink" title="4.5 TCP通信"></a><strong>4.5 TCP</strong>通信</h3><p> <strong>TCP通信分析步骤</strong> </p>
<ol>
<li>【服务端】启动,创建ServerSocket对象，等待连接。</li>
<li>【客户端】启动,创建Socket对象，请求连接。</li>
<li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li>
<li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li>
<li> 【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。 </li>
</ol>
<p> 到此，客户端想服务端发送数据成功。并且服务端向客户端回写数据。 </p>
<ol start="6">
<li><p>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</p>
</li>
<li><p>【客户端】Scoket对象，获取InputStream，解析回写数据。</p>
</li>
<li><p>【客户端】释放资源，断开连接。</p>
</li>
</ol>
<blockquote>
<p> 实例一 </p>
</blockquote>
<p> &ensp; 下面是一个客户端和服务器端进行数据交互的简单例子，客户端输入正方形的边长，服务器端接收到后计算面积并返回给客户端，通过这个例子可以初步对Socket编程有个把握。 </p>
<ul>
<li><strong>服务器端</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketServer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">7000</span>;<br><br>        <span class="hljs-comment">// 在端口上创建一个服务器套接字</span><br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(port);<br><br>        <span class="hljs-comment">//监听来自客户端的连接</span><br>        Socket socket = serverSocket.accept();<br><br>        DataInputStream dataInputStream = <span class="hljs-keyword">new</span> DataInputStream(socket.getInputStream());<br><br>        DataOutputStream dataOutputStream = <span class="hljs-keyword">new</span> DataOutputStream(socket.getOutputStream());<br><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">double</span> length = dataInputStream.readDouble();<br>            System.out.println(<span class="hljs-string">&quot;服务端收到的边长数据为:&quot;</span> + length);<br><br>            <span class="hljs-keyword">double</span> result = length * length;<br>            dataOutputStream.writeDouble(result);<br>            dataOutputStream.flush();<br><br><br><br>        &#125; <span class="hljs-keyword">while</span> (dataInputStream.readInt() != <span class="hljs-number">0</span> );<br><br>        socket.close();<br>        serverSocket.close();<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>客户端</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketClient</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">7000</span>;<br>        String host = <span class="hljs-string">&quot;localhost&quot;</span>;<br>        <span class="hljs-comment">//创建一个套接字并将其连接指定端口号</span><br>        Socket socket = <span class="hljs-keyword">new</span> Socket(host, port);<br><br>        DataInputStream dataInputStream = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> BufferedInputStream(socket.getInputStream()));<br><br>        DataOutputStream dataOutputStream = <span class="hljs-keyword">new</span> DataOutputStream(<span class="hljs-keyword">new</span> BufferedOutputStream(socket.getOutputStream()));<br><br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br><br>        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">while</span> (!flag) &#123;<br>            System.out.println(<span class="hljs-string">&quot;请输入正方形的边长：&quot;</span>);<br><br>            <span class="hljs-keyword">double</span> length = scanner.nextDouble();<br><br>            dataOutputStream.writeDouble(length);<br>            dataOutputStream.flush();<br><br><br>            <span class="hljs-keyword">double</span> readDouble = dataInputStream.readDouble();<br><br>            System.out.println(<span class="hljs-string">&quot;服务器返回的计算机面积为:&quot;</span> + readDouble);<br><br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;继续计算吗？(Y/N)&quot;</span>);<br><br>                String str = scanner.next();<br><br>                <span class="hljs-keyword">if</span> (str.equalsIgnoreCase(<span class="hljs-string">&quot;N&quot;</span>)) &#123;<br>                    dataOutputStream.writeInt(<span class="hljs-number">0</span>);<br>                    dataOutputStream.flush();<br>                    flag = <span class="hljs-keyword">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str.equalsIgnoreCase(<span class="hljs-string">&quot;Y&quot;</span>)) &#123;<br>                    dataOutputStream.writeInt(<span class="hljs-number">1</span>);<br>                    dataOutputStream.flush();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br><br>        &#125;<br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>实例二 </p>
</blockquote>
<p> &ensp; 可以看到上面的服务器端程序和客户端程序是一对一的关系，为了能让一个服务器端程序能同时为多个客户提供服务，可以使用多线程机制，每个客户端的请求都由一个独立的线程进行处理。下面是改写后的服务器端程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketServerM</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        <span class="hljs-keyword">int</span> port =  <span class="hljs-number">7000</span>;<br><br>        <span class="hljs-keyword">int</span> clientNo = <span class="hljs-number">1</span>;<br><br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(port);<br><br>        ExecutorService pool = Executors.newCachedThreadPool();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                Socket socket = serverSocket.accept();<br><br>                pool.execute(<span class="hljs-keyword">new</span> SingleServer(socket, clientNo) );<br><br>                clientNo ++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            serverSocket.close();<br>        &#125;<br>    &#125;<br><br><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> clientNo;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SingleServer</span><span class="hljs-params">(Socket socket, <span class="hljs-keyword">int</span> clientNo)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.socket = socket;<br>        <span class="hljs-keyword">this</span>.clientNo = clientNo;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            DataInputStream dis = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> BufferedInputStream(socket.getInputStream()));<br><br>            DataOutputStream dos = <span class="hljs-keyword">new</span> DataOutputStream(<span class="hljs-keyword">new</span> BufferedOutputStream(socket.getOutputStream()));<br><br><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">double</span> length = dis.readDouble();<br>                System.out.println(<span class="hljs-string">&quot;从客户端&quot;</span> + clientNo + <span class="hljs-string">&quot;接收到的边长数据为:&quot;</span> + length);<br><br>                <span class="hljs-keyword">double</span> result = length * length;<br><br>                dos.writeDouble(result);<br>                dos.flush();<br><br>            &#125; <span class="hljs-keyword">while</span> (dis.readInt() != <span class="hljs-number">0</span>) ;<br><br><br><br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;与客户端&quot;</span> + clientNo + <span class="hljs-string">&quot;通信结束&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                socket.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> &ensp; 上面改进后的服务器端代码可以支持不断地并发响应网络中的客户请求。关键的地方在于多线程机制的运用，同时利用线程池可以改善服务器程序的性能。 </p>
<h4 id="4-5-1-总结"><a href="#4-5-1-总结" class="headerlink" title="4.5.1 总结"></a>4.5.1 <strong>总结</strong></h4><p><strong>TCP程序交互的流程</strong> </p>
<p><strong>客户端：</strong></p>
<p>1,创建客户端的Socket对象</p>
<p>2,获取Socket的输出流对象</p>
<p>3,写数据给服务器</p>
<p>4,获取Socket的输入流对象</p>
<p>5，使用输入流，读反馈信息</p>
<p>6,关闭流资源</p>
<p><strong>服务器端：</strong></p>
<p>1，创建服务器端ServerSocket对象，指定服务器端端口号</p>
<p>2，开启服务器，等待着客户端Socket对象的连接，如有客户端连接，返回客户端的Socket对象</p>
<p>3,通过客户端的Socket对象，获取客户端的输入流，为了实现获取客户端发来的数据</p>
<p>4,通过客户端的输入流，获取流中的数据</p>
<p>5,通过客户端的Socket对象，获取客户端的输出流，为了实现给客户端反馈信息</p>
<p>6,通过客户端的输出流，写数据到流中</p>
<p>7,关闭流资源</p>
<h3 id="4-6-UDP通信"><a href="#4-6-UDP通信" class="headerlink" title="4.6 UDP通信"></a>4.6 UDP通信</h3><h4 id="4-6-1-DatagramSocket-和-DatagramPacket"><a href="#4-6-1-DatagramSocket-和-DatagramPacket" class="headerlink" title="4.6.1 DatagramSocket 和 DatagramPacket"></a>4.6.1 DatagramSocket 和 DatagramPacket</h4><p> Java 通过 <code>DatagramSocket</code> 和 <code>DatagramPacket</code> 实现对 UDP 协议的支持。 </p>
<ul>
<li><code>DatagramPacket</code>：数据包类</li>
<li><code>DatagramSocket</code>：通信类</li>
</ul>
<p><strong>DatagramSocket</strong><br>这个类用来表示发送和接收<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE&spm=1001.2101.3001.7020">数据</a>包的套接字。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造方法，创建数据报套接字并将其绑定到本地主机上的指定端口</span><br>DatagramSocket socket = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">0</span>);	<br></code></pre></td></tr></table></figure>

<p><strong>DatagramPacket</strong> </p>
<p> &ensp; 表示数据报包，用来实现无连接的包的投递服务。这些数据包选择不同的路由，经过计算机的存储转发，最终到达目的计算机。所以到达的数据包和发送时的顺序不一定会相同。 </p>
<p> <strong>Sever端程序</strong> </p>
<ol>
<li>调用DatagramSocket(int port)创建一个数据报<a href="https://so.csdn.net/so/search?q=%E5%A5%97%E6%8E%A5%E5%AD%97&spm=1001.2101.3001.7020">套接字</a>，绑定在指定端口上；</li>
<li>调用DatagramPacket(byte[] buf,int length),建立一个字节数组来接收<a href="https://so.csdn.net/so/search?q=UDP&spm=1001.2101.3001.7020">UDP</a>包；</li>
<li>调用DatagramSocket.receive()；</li>
<li>最后关闭数据报套接字。 </li>
</ol>
<p><strong>Client端程序</strong></p>
<ol>
<li>调用DatagramSocket()创建一个数据报套接字；</li>
<li>调用DatagramPacket(byte[] buf,int offset,InetAddress address,int port),建立要发送的UDP包</li>
<li>调用DatagramSocket类的send方法发送数据包；</li>
<li>关闭数据报套接字。</li>
</ol>
<p>数据报套接字发送成功后，相当于建立了一个虚连接，双方可以发送数据。</p>
<p> UDP 服务端示例： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UDPServer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; <span class="hljs-comment">// 所有异常抛出</span><br>        String str = <span class="hljs-string">&quot;hello World!!!&quot;</span>;<br>        DatagramSocket ds = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">3000</span>); <span class="hljs-comment">// 服务端在3000端口上等待服务器发送信息</span><br>        DatagramPacket dp =<br>            <span class="hljs-keyword">new</span> DatagramPacket(str.getBytes(), str.length(), InetAddress.getByName(<span class="hljs-string">&quot;localhost&quot;</span>), <span class="hljs-number">9000</span>); <span class="hljs-comment">// 所有的信息使用buf保存</span><br>        System.out.println(<span class="hljs-string">&quot;发送信息。&quot;</span>);<br>        ds.send(dp); <span class="hljs-comment">// 发送信息出去</span><br>        ds.close();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p> UDP 客户端示例： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UDPClient</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; <span class="hljs-comment">// 所有异常抛出</span><br>        <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>]; <span class="hljs-comment">// 开辟空间，以接收数据</span><br>        DatagramSocket ds = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">9000</span>); <span class="hljs-comment">// 客户端在9000端口上等待服务器发送信息</span><br>        DatagramPacket dp = <span class="hljs-keyword">new</span> DatagramPacket(buf, <span class="hljs-number">1024</span>); <span class="hljs-comment">// 所有的信息使用buf保存</span><br>        ds.receive(dp); <span class="hljs-comment">// 接收数据</span><br>        String str = <span class="hljs-keyword">new</span> String(dp.getData(), <span class="hljs-number">0</span>, dp.getLength()) + <span class="hljs-string">&quot;from &quot;</span> + dp.getAddress().getHostAddress() + <span class="hljs-string">&quot;：&quot;</span><br>            + dp.getPort();<br>        System.out.println(str); <span class="hljs-comment">// 输出内容</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>









<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><p><a href="https://zjwmxy.top/2021/09/15/java-wang-luo-bian-cheng/">Java网络编程</a></p>
<p><a href="https://blog.csdn.net/sarracode/article/details/120009805">JavaSocket网络编程</a></p>
<p><a href="https://www.cnblogs.com/swordfall/p/10781281.html">Java—网络编程总结（整理版） </a></p>
<p><a href="https://dunwu.github.io/javacore/io/java-net.html#%E4%B8%80%E3%80%81socket-%E5%92%8C-serversocket">Java网络编程</a></p>
<p><a href="https://blog.csdn.net/weixin_42882887/article/details/86598410">Java实现UDP通信过程</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式-代理模式</title>
    <url>/2022/06/07/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="代理模式概念"><a href="#代理模式概念" class="headerlink" title="代理模式概念"></a><strong>代理模式概念</strong></h3><p>代理模式的定义很简单：<strong>给某一对象提供一个代理对象，并由代理对象控制对原对象的引用</strong>。</p>
<blockquote>
<p>代理模式是常用的 java 设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。</p>
</blockquote>
<h3 id="代理模式的结构"><a href="#代理模式的结构" class="headerlink" title="代理模式的结构"></a><strong>代理模式的结构</strong></h3><p>有些情况下，一个客户不想或者不能够直接引用一个对象，可以通过代理对象在客户端和目标对象之间起到中介作用。</p>
<p>在代理模式中的角色：</p>
<ol>
<li><strong>抽象对象角色：</strong>声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。</li>
<li><strong>目标对象角色：</strong>定义了代理对象所代表的目标对象。</li>
<li><strong>代理对象角色：</strong>代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。</li>
</ol>
<p><img src="/img/work/7980749234585f364651f522f7e45c73.png" alt="UML 示意图"></p>
<p>需要注意的有下面几点：</p>
<ol>
<li>用户只关心接口功能，而不在乎谁提供了功能。上图中接口是 <code>Subject</code>。</li>
<li>接口真正实现者是上图的 <code>RealSubject</code>，但是它不与用户直接接触，而是通过代理。</li>
<li>代理就是上图中的 <code>Proxy</code>，由于它实现了 <code>Subject</code> 接口，所以它能够直接与用户接触。</li>
<li>用户调用 <code>Proxy</code> 的时候，<code>Proxy</code> 内部调用了 <code>RealSubject</code>。所以，<code>Proxy</code> 是中介者，它可以增强 <code>RealSubject</code> 操作。</li>
</ol>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>电影是电影公司委托给影院进行播放的，但是影院可以在播放电影的时候，产生一些自己的经济收益，比如提供按摩椅，娃娃机。</p>
<p>我们平常去电影院看电影的时候，在电影开始的阶段是不是经常会放广告呢？然后在影片开始结束时播放一些广告。</p>
<p>下面我们通过代码来模拟下电影院这一系列的赚钱操作。</p>
<p>首先得有一个接口，通用的接口是代理模式实现的基础。这个接口我们命名为 <code>Movie</code>，代表电影播放的能力。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Move</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 播放功能</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>接下来我们要创建一个真正的实现这个 <code>Movie</code> 接口的类，和一个实现该接口的代理类。</li>
</ul>
<p>真正的类<code>《功夫》</code>电影：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KungFuMovie</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Move</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;普通影厅正在播放的电影是《功夫》&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MovieStaticProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Move</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> Move move;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MovieStaticProxy</span><span class="hljs-params">(Move move)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.move = move;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;<br>        playStart();<br>        move.play();<br>        playEnd();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">playStart</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;电影开始前播放广告&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">playEnd</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;电影结束，继续播放广告&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticProxyTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        KungFuMovie kungFuMovie = <span class="hljs-keyword">new</span> KungFuMovie();<br><br>        MovieStaticProxy staticProxy = <span class="hljs-keyword">new</span> MovieStaticProxy(kungFuMovie);<br>        staticProxy.play();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs txt">电影开始前播放广告<br>普通影厅正在播放的电影是《功夫》<br>电影结束，继续播放广告<br></code></pre></td></tr></table></figure>

<p>可以看到，<strong>代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类</strong>。这个就是是静态代理的内容，为什么叫做静态呢？因为它的类型是事先预定好的，比如上面代码中的 <code>MovieStaticProxy</code> 这个类。</p>
<h3 id="静态代理优缺点"><a href="#静态代理优缺点" class="headerlink" title="静态代理优缺点"></a>静态代理优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</li>
<li>代理对象可以扩展目标对象的功能</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护。</li>
</ul>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="jdk-动态代理"><a href="#jdk-动态代理" class="headerlink" title="jdk 动态代理"></a>jdk 动态代理</h4><p>与静态代理类对照的是动态代理类，动态代理类的字节码在程序运行时由 Java 反射机制动态生成，无需程序员手工编写它的源代码。动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为 Java 反射机制可以生成任意类型的动态代理类。<code>java.lang.reflect</code> 包中的 Proxy 类和<code>InvocationHandler</code> 接口提供了生成动态代理类的能力。 </p>
<p><strong>动态代理示例</strong></p>
<p>创建一个 VIPMovie 电影接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">VIPMovie</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * vip播放</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vipPlay</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>紧接着创建一个 VIP 影厅的播放实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IronManVIPMovie</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">VIPMovie</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vipPlay</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;VI影厅正在播放的电影是《熊出没》&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果按照静态代理我们是不是又要创建一个 VIP 影厅播放的代理实现类，这种方式我们就不演示了。下面我们来看看通过动态代理怎么来实现吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Object object;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyInvocationHandler</span><span class="hljs-params">(Object object)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.object = object;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><br>        playStart();<br>        Object invoke = method.invoke(object, args);<br>        playEnd();<br>        <span class="hljs-keyword">return</span> invoke;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">playStart</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;电影正在播放广告&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">playEnd</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;电影结束了，连续播放广告&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>MyInvocationHandler</code>实现了 <code>InvocationHandler</code> 这个类，这个类是什么意思呢？下文将会讲解。然后，我们就可以在 VIP 影厅看电影了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicProxyTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        IronManVIPMovie ironManVIPMovie = <span class="hljs-keyword">new</span> IronManVIPMovie();<br><br>        MyInvocationHandler invocationHandler = <span class="hljs-keyword">new</span> MyInvocationHandler(ironManVIPMovie);<br><br>        VIPMovie proxyInstance = (VIPMovie) Proxy.newProxyInstance(IronManVIPMovie.class.getClassLoader(), IronManVIPMovie.class.getInterfaces(), invocationHandler);<br><br>        proxyInstance.vipPlay();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs txt">电影正在播放广告<br>VI影厅正在播放的电影是《熊出没》<br>电影结束了，连续播放广告<br></code></pre></td></tr></table></figure>

<p>看到没有，我们并没有像静态代理那样为 <code>VIPMovie</code>接口实现一个代理类，但最终它仍然实现了相同的功能，这其中的差别，就是之前讨论的动态代理所谓“动态”的原因。</p>
<p><strong>我们通过 <code>Proxy.newProxyInstance()</code> 方法，却产生了 <code>Movie</code>和 <code>VIPMovie</code>两种接口的实现类代理，这就是动态代理的魔力。</strong></p>
<p><strong>JDK 动态代理到底是怎么实现的呢</strong></p>
<p>动态代码涉及了一个非常重要的类 <code>Proxy</code>。正是通过 <code>Proxy</code> 的静态方法 <code>newProxyInstance</code> 才会动态创建代理。具体怎么去创建代理类就不分析了,感兴趣的可以去看下源码。我们直接看下生成的代理类。</p>
<p>如何查看生成的代理类？</p>
<p>在生成代理类之前加上以下代码(我用的 jdk1.8)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//新版本 jdk产生代理类 </span><br>System.getProperties().put(<span class="hljs-string">&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br><br><br><span class="hljs-comment">//如果上述代码加上不生效可以考虑加下下面的代码：</span><br><span class="hljs-comment">// 老版本jdk</span><br>System.getProperties().put(<span class="hljs-string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br><span class="hljs-comment">//  该设置用于输出cglib动态代理产生的类</span><br>System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="hljs-string">&quot;C:\\class&quot;</span>);    <br></code></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicProxyTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        System.getProperties().put(<span class="hljs-string">&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;</span>,<span class="hljs-keyword">true</span>);<br>        IronManVIPMovie ironManVIPMovie = <span class="hljs-keyword">new</span> IronManVIPMovie();<br><br>        InvocationHandler invocationHandler = <span class="hljs-keyword">new</span> MyInvocationHandler(ironManVIPMovie);<br><br>        VIPMovie proxyInstance = (VIPMovie) Proxy.newProxyInstance(IronManVIPMovie.class.getClassLoader(), IronManVIPMovie.class.getInterfaces(), invocationHandler);<br><br>        proxyInstance.vipPlay();<br><br>        KungFuMovie kungFuMovie = <span class="hljs-keyword">new</span> KungFuMovie();<br>        InvocationHandler handler = <span class="hljs-keyword">new</span> MyInvocationHandler(kungFuMovie);<br>        Move dynamicProxy = (Move) Proxy.newProxyInstance(KungFuMovie.class.getClassLoader(), KungFuMovie.class.getInterfaces(), handler);<br>        dynamicProxy.play();<br><br>        System.out.println(<span class="hljs-string">&quot;VIP 影厅《熊出没》代理类：&quot;</span>+proxyInstance.getClass());<br>        System.out.println(<span class="hljs-string">&quot;普通影厅《功夫》：&quot;</span>+dynamicProxy.getClass());<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs txt">电影正在播放广告<br>VI影厅正在播放的电影是《熊出没》<br>电影结束了，连续播放广告<br>电影正在播放广告<br>普通影厅正在播放的电影是《功夫》<br>电影结束了，连续播放广告<br>VIP 影厅《熊出没》代理类：class com.sun.proxy.$Proxy0<br>普通影厅《功夫》：class com.sun.proxy.$Proxy1<br></code></pre></td></tr></table></figure>

<p>产生了两个代理类分别是<code>$Proxy0</code>和<code>$Proxy1</code>。</p>
<p>下面们来看下代理类<code>$Proxy0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">Proxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">VIPMovie</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m0;<br><br>    <span class="hljs-keyword">public</span> $Proxy0(InvocationHandler var1) <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-keyword">super</span>(var1);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object var1)</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Boolean)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m1, <span class="hljs-keyword">new</span> Object[]&#123;var1&#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var3) &#123;<br>            <span class="hljs-keyword">throw</span> var3;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var4) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var4);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vipPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m3, (Object[])<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (String)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m2, (Object[])<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Integer)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m0, (Object[])<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>));<br>            m3 = Class.forName(<span class="hljs-string">&quot;com.dewu.design.proxy.dynamicproxy&quot;</span>).getMethod(<span class="hljs-string">&quot;vipPlay&quot;</span>);<br>            m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>);<br>            m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException var2) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodError(var2.getMessage());<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoClassDefFoundError(var3.getMessage());<br>        &#125;<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure>

<p>通过上述代码我们可以看到 <code>$Proxy0 extends Proxy implements VIPMovie</code>继承了<code>Proxy</code> 且实现了<code>VIPMovie</code>接口，这也就是为什么 jdk 动态代理必须基于接口,java 是单继承的。</p>
<p>然后再看下代理类实现的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vipPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m3, (Object[])<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个<code>supper.h.invoke Proxy</code>中的 h 的 invoke 方法，即<code>InvocationHandler.invoke</code>也就是上面 <code>MyInvocationHandler.invok</code>e 方法，至此整个流程就清晰了。这就是 jdk 的动态代理。</p>
<h4 id="cglib-动态代理"><a href="#cglib-动态代理" class="headerlink" title="cglib 动态代理"></a>cglib 动态代理</h4><p>上面说 jdk 动态代理只能基于接口，那么如果是类要动态代理怎么办呢？cglib 动态代理就可解决关于类的动态代理。</p>
<p>下面我们来创建一个“《美国队长 2》”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CaptainAmerica2MovieImpl</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;正在播放的电影是《美国队长》&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>引入 cglib pom 依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;!-- https:<span class="hljs-comment">//mvnrepository.com/artifact/cglib/cglib --&gt;</span><br>&lt;dependency&gt;<br>    &lt;groupId&gt;cglib&lt;/groupId&gt;<br>    &lt;artifactId&gt;cglib&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">3.3</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>

<p>创建一个自定义 MethodInterceptor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibProxyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        playStart();<br>        Object invokeSuper = methodProxy.invokeSuper(o, objects);<br>        playEnd();<br>        <span class="hljs-keyword">return</span> invokeSuper;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">playStart</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;电影开始前正在播放广告&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">playEnd</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;电影结束了，接续播放广告&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibProxyTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// //在指定目录下生成动态代理类</span><br>        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="hljs-string">&quot;/software02&quot;</span>);<br>        <span class="hljs-comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span><br>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>        <span class="hljs-comment">//设置目标类的字节码文件</span><br>        enhancer.setSuperclass(CaptainAmerica2MovieImpl.class);<br>        <span class="hljs-comment">//设置回调函数</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> CglibProxyInterceptor());<br>        <span class="hljs-comment">//这里的create方法就是正式创建代理类</span><br>        CaptainAmerica2MovieImpl captainAmerica2Movie = (CaptainAmerica2MovieImpl) enhancer.create();<br>        <span class="hljs-comment">//调用代理类的play方法</span><br>        captainAmerica2Movie.play();<br>        <span class="hljs-comment">//调用代理类的play方法</span><br>        System.out.println(<span class="hljs-string">&quot;cglib动态代理《美国队长2》：&quot;</span> + captainAmerica2Movie.getClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">电影开始前正在播放广告<br>正在播放的电影是《美国队长》<br>电影结束了，接续播放广告<br>cglib动态代理《美国队长<span class="hljs-number">2</span>》：<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">dewu</span>.<span class="hljs-title">design</span>.<span class="hljs-title">proxy</span>.<span class="hljs-title">cglib</span>.<span class="hljs-title">CaptainAmerica2MovieImpl</span>$$<span class="hljs-title">EnhancerByCGLIB</span>$$<span class="hljs-title">b9ec98c5</span></span><br></code></pre></td></tr></table></figure>

<p>我们看下最终创建的代理类生成的<code>play</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CaptainAmerica2MovieImpl</span>$$<span class="hljs-title">EnhancerByCGLIB</span>$$5<span class="hljs-title">c3ddcfe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CaptainAmerica2MovieImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;<br><br>        MethodInterceptor var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;<br><br>        <span class="hljs-keyword">if</span> (var10000 == <span class="hljs-keyword">null</span>) &#123;<br><br>            CGLIB$BIND_CALLBACKS(<span class="hljs-keyword">this</span>);<br><br>            var10000 = <span class="hljs-keyword">this</span>.CGLIB$CALLBACK_0;<br><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (var10000 != <span class="hljs-keyword">null</span>) &#123;<br><br>            var10000.intercept(<span class="hljs-keyword">this</span>, CGLIB$play$<span class="hljs-number">0</span>$Method, CGLIB$emptyArgs, CGLIB$play$<span class="hljs-number">0</span>$Proxy);<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><br>            <span class="hljs-keyword">super</span>.play();<br><br>        &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>从代理对象反编译源码可以知道，代理对象继承于<code>CaptainAmerica2MovieImpl</code> ，拦截器调用<code>intercept</code>()方法，</p>
<p><code>intercept</code>()方法由自定义<code>CglibProxyInterceptor</code>实现，所以，最后调用<code>CglibProxyInterceptor</code>中的<code>intercept</code>()方法，从而完成了由代理对象访问到目标对象的动态代理实现。</p>
<ul>
<li>CGlib 是一个强大的,高性能,高质量的 Code 生成类库。它可以在运行期扩展 Java 类与实现 Java 接口。</li>
<li>用 CGlib 生成代理类是目标类的子类。</li>
<li>用 CGlib 生成代理类不需要接口。</li>
<li>用 CGLib 生成的代理类重写了父类的各个方法。</li>
<li>拦截器中的 intercept 方法内容正好就是代理类中的方法体。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>代理分为静态代理和动态代理两种。</p>
</li>
<li><p>静态代理，代理类需要自己编写代码写成。</p>
</li>
<li><p>动态代理有 jdk 和 cglib，代理类通过 <code>Proxy.newInstance()</code>或者<code>ASM</code> 生成。</p>
</li>
<li><p>静态代理和动态代理的区别是在于要不要开发者自己定义 Proxy 类。</p>
</li>
<li><p>动态代理通过 <code>Proxy</code> 动态生成 <code>proxy class</code>，但是它也指定了一个 <code>InvocationHandler</code> 或者 <code>MethodInterceptor</code>的实现类。</p>
</li>
<li><p>代理模式本质上的目的是为了增强现有代码的功能。</p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/xrq730/p/4907999.html">https://www.cnblogs.com/xrq730/p/4907999.html</a></p>
<p><a href="https://xie.infoq.cn/article/9a9387805a496e1485dc8430f">https://xie.infoq.cn/article/9a9387805a496e1485dc8430f</a></p>
<p><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html">https://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html</a></p>
]]></content>
      <categories>
        <category>Java设计模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务</title>
    <url>/2022/06/22/MySQL%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p> 不是所有的 Mysql 存储引擎都实现了事务处理。支持事务的存储引擎有：<code>InnoDB</code> 和 <code>NDB Cluster</code>。不支持事务的存储引擎，代表有：<code>MyISAM</code>。  </p>
<p>用户可以根据业务是否需要事务处理（事务处理可以保证数据安全，但会增加系统开销），选择合适的存储引擎。 </p>
</blockquote>
<h2 id="1-事务简介"><a href="#1-事务简介" class="headerlink" title="1. 事务简介"></a>1. 事务简介</h2><blockquote>
<p> 事务简单来说：<strong>一个 Session 中所进行所有的操作，要么同时成功，要么同时失败</strong>。进一步说，事务指的是满足 ACID 特性的一组操作，可以通过 <code>Commit</code> 提交一个事务，也可以使用 <code>Rollback</code> 进行回滚。 </p>
</blockquote>
<p>  <img src="/img/work/1655390443220.jpg">  </p>
<p><strong>事务就是一组原子性的 SQL 语句</strong>。具体来说，事务指的是满足 ACID 特性的一组操作。 </p>
<p><strong>事务内的 SQL 语句，要么全执行成功，要么全执行失败</strong>。 </p>
<p><strong>通过加锁的方式，可以实现不同的事务隔离机制</strong>。 </p>
<p>想象一下，如果没有事务，在并发环境下，就可能出现丢失修改的问题。 </p>
<p>T1 和 T2 两个线程都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。 </p>
<p> <img src="/img/work/1655390926524.png"></p>
<h2 id="2-事务用法"><a href="#2-事务用法" class="headerlink" title="2. 事务用法"></a>2. 事务用法</h2><h3 id="2-1-事务处理指令"><a href="#2-1-事务处理指令" class="headerlink" title="2.1. 事务处理指令"></a>2.1. 事务处理指令</h3><p>Mysql 中，使用 <code>START TRANSACTION</code> 语句开始一个事务；使用 <code>COMMIT</code> 语句提交所有的修改；使用 <code>ROLLBACK</code> 语句撤销所有的修改。不能回退 <code>SELECT</code> 语句，回退 <code>SELECT</code> 语句也没意义；也不能回退 <code>CREATE</code> 和 <code>DROP</code> 语句。 </p>
<ul>
<li><p><code>START TRANSACTION</code> - 指令用于标记事务的起始点。</p>
</li>
<li><p><code>SAVEPOINT</code> - 指令用于创建保留点。</p>
</li>
<li><p><code>ROLLBACK TO</code> - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 <code>START TRANSACTION</code> 语句处。</p>
</li>
<li><p><code>COMMIT</code> - 提交事务。</p>
</li>
</ul>
<p>事务处理示例： </p>
<p>（1）创建一张示例表 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">-- 撤销表 user<br>DROP TABLE IF EXISTS user;<br><br>-- 创建表 user<br>CREATE TABLE user (<br>  id int(10) unsigned NOT NULL COMMENT &#x27;Id&#x27;,<br>  username varchar(64) NOT NULL DEFAULT &#x27;default&#x27; COMMENT &#x27;用户名&#x27;,<br>  password varchar(64) NOT NULL DEFAULT &#x27;default&#x27; COMMENT &#x27;密码&#x27;,<br>  email varchar(64) NOT NULL DEFAULT &#x27;default&#x27; COMMENT &#x27;邮箱&#x27;<br>) COMMENT=&#x27;用户表&#x27;;<br></code></pre></td></tr></table></figure>

<p>（2）执行事务操作 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">-- 开始事务<br>START TRANSACTION;<br><br>-- 插入操作 A<br>INSERT INTO `user`<br>VALUES (1, &#x27;root1&#x27;, &#x27;root1&#x27;, &#x27;xxxx@163.com&#x27;);<br><br>-- 创建保留点 updateA<br>SAVEPOINT updateA;<br><br>-- 插入操作 B<br>INSERT INTO `user`<br>VALUES (2, &#x27;root2&#x27;, &#x27;root2&#x27;, &#x27;xxxx@163.com&#x27;);<br><br>-- 回滚到保留点 updateA<br>ROLLBACK TO updateA;<br><br>-- 提交事务，只有操作 A 生效<br>COMMIT;<br></code></pre></td></tr></table></figure>

<p>（3）执行结果 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure>

<p> 结果： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">root1	root1	xxxx@163.com<br></code></pre></td></tr></table></figure>

<h3 id="2-2-AUTOCOMMIT"><a href="#2-2-AUTOCOMMIT" class="headerlink" title="2.2. AUTOCOMMIT"></a>2.2. AUTOCOMMIT</h3><p><strong>MySQL 默认采用隐式提交策略（<code>autocommit</code>）</strong>。每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。 </p>
<p>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；<code>autocommit</code> 标记是针对每个连接而不是针对服务器的。 </p>
<h2 id="3-ACID"><a href="#3-ACID" class="headerlink" title="3. ACID"></a>3. ACID</h2><p>ACID 是数据库事务正确执行的四个基本要素。 </p>
<ul>
<li><strong>原子性（Atomicity）</strong> <ul>
<li>事务被视为不可分割的最小单元，事务中的所有操作要么全部提交成功，要么全部失败回滚。</li>
<li>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
</ul>
</li>
<li> <strong>一致性（Consistency）</strong> </li>
<li>数据库在事务执行前后都保持一致性状态。</li>
<li>在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
<li> <strong>隔离性（Isolation）</strong> </li>
<li>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
<li> <strong>持久性（Durability）</strong> </li>
<li>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</li>
<li>可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。</li>
</ul>
<p><strong>一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易。</strong> </p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ul>
<p> <img src="/img/work/1655394301232.png"> </p>
<blockquote>
<p> MySQL 默认采用自动提交模式（<code>AUTO COMMIT</code>）。也就是说，如果不显式使用 <code>START TRANSACTION</code> 语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。 </p>
</blockquote>
<h2 id="4-事务隔离级别"><a href="#4-事务隔离级别" class="headerlink" title="4. 事务隔离级别"></a>4. 事务隔离级别</h2><h3 id="4-1-事务隔离简介"><a href="#4-1-事务隔离简介" class="headerlink" title="4.1. 事务隔离简介"></a>4.1. 事务隔离简介</h3><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题： </p>
<ul>
<li><strong>丢失修改</strong></li>
<li><strong>脏读</strong></li>
<li><strong>不可重复读</strong></li>
<li><strong>幻读</strong></li>
</ul>
<p>在 SQL 标准中，定义了四种事务隔离级别（级别由低到高）： </p>
<ul>
<li><strong>未提交读</strong></li>
<li><strong>提交读</strong></li>
<li><strong>可重复读</strong></li>
<li><strong>串行化</strong></li>
</ul>
<p>Mysql 中查看和设置事务隔离级别： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查看事务隔离级别</span><br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;transaction_isolation&#x27;</span>;<br><br><span class="hljs-comment">-- 设置事务隔离级别为 READ UNCOMMITTED</span><br><span class="hljs-keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;<br><br><br><span class="hljs-comment">-- 设置事务隔离级别为 READ COMMITTED</span><br><span class="hljs-keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;<br><br><span class="hljs-comment">-- 设置事务隔离级别为 REPEATABLE READ</span><br><span class="hljs-keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br><br><span class="hljs-comment">-- 设置事务隔离级别为 SERIALIZABLE</span><br><span class="hljs-keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br></code></pre></td></tr></table></figure>

<h3 id="4-2-未提交读"><a href="#4-2-未提交读" class="headerlink" title="4.2. 未提交读"></a>4.2. 未提交读</h3><p><strong><code>未提交读（READ UNCOMMITTED）</code></strong>  <strong>是指：事务中的修改，即使没有提交，对其它事务也是可见的</strong>。  </p>
<p>未提交读的问题：事务可以读取未提交的数据，也被称为 <strong>脏读（Dirty Read）</strong>。 </p>
<p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。 </p>
<p><img src="/img/work/image-20220622091329256.png"></p>
<h3 id="4-3-提交读"><a href="#4-3-提交读" class="headerlink" title="4.3. 提交读"></a>4.3. 提交读</h3><p><strong><code>提交读（READ COMMITTED）</code> 是指：事务提交后，其他事务才能看到它的修改</strong>。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。提交读解决了脏读的问题。</p>
<p>提交读是大多数数据库的默认事务隔离级别。</p>
<p>提交读有时也叫不可重复读，它的问题是：执行两次相同的查询，得到的结果可能不一致。</p>
<p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<p><img src="/img/work/image-20220622093915030.png"></p>
<h3 id="4-4-可重复读"><a href="#4-4-可重复读" class="headerlink" title="4.4. 可重复读"></a>4.4. 可重复读</h3><p><strong><code>可重复读（REPEATABLE READ）</code> 是指：保证在同一个事务中多次读取同样数据的结果是一样的</strong>。可重复读解决了不可重复读问题。</p>
<p>可重复读是 Mysql 的默认事务隔离级别。</p>
<p>可重复读是 Mysql 的默认事务隔离级别。</p>
<p>可重复读的问题：当某个事务读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务又再次读取该范围的记录时，会产生 <strong>幻读（Phantom Read）</strong>。</p>
<p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<p><img src="/img/work/image-20220622094838597.png"></p>
<h3 id="4-5-串行化"><a href="#4-5-串行化" class="headerlink" title="4.5. 串行化"></a>4.5. 串行化</h3><p><strong><code>串行化（SERIALIXABLE）</code> 是指：强制事务串行执行</strong>。</p>
<p>强制事务串行执行，则避免了所有的并发问题。串行化策略会在读取的每一行数据上都加锁，这可能导致大量的超时和锁竞争。这对于高并发应用基本上是不可接受的，所以一般不会采用这个级别。</p>
<h3 id="4-6-隔离级别小结"><a href="#4-6-隔离级别小结" class="headerlink" title="4.6. 隔离级别小结"></a>4.6. 隔离级别小结</h3><ul>
<li><p><strong><code>未提交读（READ UNCOMMITTED）</code></strong> - 事务中的修改，即使没有提交，对其它事务也是可见的。</p>
</li>
<li><p><strong><code>提交读（READ COMMITTED）</code></strong> - 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>
</li>
<li><p><strong><code>重复读（REPEATABLE READ）</code></strong> - 保证在同一个事务中多次读取同样数据的结果是一样的。</p>
</li>
<li><p><strong><code>串行化（SERIALIXABLE）</code></strong> - 强制事务串行执行。</p>
</li>
</ul>
<p>数据库隔离级别解决的问题：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">丢失修改</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">未提交读</td>
<td align="center">✔️</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">提交读</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">可串行化</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
</tr>
</tbody></table>
<h2 id="5-死锁"><a href="#5-死锁" class="headerlink" title="5. 死锁"></a>5. 死锁</h2><p><strong>死锁是指两个或多个事务竞争同一资源，并请求锁定对方占用的资源，从而导致恶性循环的现象</strong>。</p>
<p>产生死锁的场景：</p>
<ul>
<li>当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。</li>
<li>多个事务同时锁定同一个资源时，也会产生死锁。</li>
</ul>
<h3 id="5-1-死锁的原因"><a href="#5-1-死锁的原因" class="headerlink" title="5.1. 死锁的原因"></a>5.1. 死锁的原因</h3><p>行锁的具体实现算法有三种：record lock、gap lock 以及 next-key lock。record lock 是专门对索引项加锁；gap lock 是对索引项之间的间隙加锁；next-key lock 则是前面两种的组合，对索引项以其之间的间隙加锁。</p>
<p>只在可重复读或以上隔离级别下的特定操作才会取得 gap lock 或 next-key lock，在 Select、Update 和 Delete 时，除了基于唯一索引的查询之外，其它索引查询时都会获取 gap lock 或 next-key lock，即锁住其扫描的范围。主键索引也属于唯一索引，所以主键索引是不会使用 gap lock 或 next-key lock。</p>
<p>在 MySQL 中，gap lock 默认是开启的，即 innodb_locks_unsafe_for_binlog 参数值是 disable 的，且 MySQL 中默认的是 RR 事务隔离级别。</p>
<p>当我们执行以下查询 SQL 时，由于 order_no 列为非唯一索引，此时又是 RR 事务隔离级别，所以 SELECT 的加锁类型为 gap lock，这里的 gap 范围是 (4,+∞）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> demo.order_record <span class="hljs-keyword">where</span> order_no <span class="hljs-operator">=</span> <span class="hljs-number">4</span> <span class="hljs-keyword">for</span> update;<br></code></pre></td></tr></table></figure>

<p>执行查询 SQL 语句获取的 gap lock 并不会导致阻塞，而当我们执行以下插入 SQL 时，会在插入间隙上再次获取插入意向锁。插入意向锁其实也是一种 gap 锁，它与 gap lock 是冲突的，所以当其它事务持有该间隙的 gap lock 时，需要等待其它事务释放 gap lock 之后，才能获取到插入意向锁。</p>
<p>以上事务 A 和事务 B 都持有间隙 (4,+∞）的 gap 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的 gap 锁释放，于是就造成了循环等待，导致死锁。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> demo.order_record(order_no, status, create_date) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, ‘<span class="hljs-number">2019</span><span class="hljs-number">-07</span><span class="hljs-number">-13</span> <span class="hljs-number">10</span>:<span class="hljs-number">57</span>:<span class="hljs-number">03</span>’);<br></code></pre></td></tr></table></figure>

<p><img src="/img/work/image-20220622100911687.png"></p>
<p><strong>另一个死锁场景</strong></p>
<p>InnoDB 存储引擎的主键索引为聚簇索引，其它索引为辅助索引。如果使用辅助索引来更新数据库，就需要使用聚簇索引来更新数据库字段。如果两个更新事务使用了不同的辅助索引，或一个使用了辅助索引，一个使用了聚簇索引，就都有可能导致锁资源的循环等待。由于本身两个事务是互斥，也就构成了以上死锁的四个必要条件了。</p>
<p><img src="/img/work/image-20220622173554834.png"></p>
<p>出现死锁的步骤：</p>
<p><img src="/img/work/image-20220622173740032.png"></p>
<p>综上可知，在更新操作时，我们应该尽量使用主键来更新表字段，这样可以有效避免一些不必要的死锁发生。</p>
<h3 id="5-2-避免死锁"><a href="#5-2-避免死锁" class="headerlink" title="5.2. 避免死锁"></a>5.2. 避免死锁</h3><p>预防死锁的注意事项：</p>
<ul>
<li>在编程中尽量按照固定的顺序来处理数据库记录，假设有两个更新操作，分别更新两条相同的记录，但更新顺序不一样，有可能导致死锁；</li>
<li>在允许幻读和不可重复读的情况下，尽量使用 RC 事务隔离级别，可以避免 gap lock 导致的死锁问题；</li>
<li>更新表时，<strong>尽量使用主键更新</strong>；</li>
<li>避免长事务，<strong>尽量将长事务拆解</strong>，可以降低与其它事务发生冲突的概率；</li>
<li><strong>设置合理的锁等待超时参数</strong>，我们可以通过 <code>innodb_lock_wait_timeout</code> 设置合理的等待超时阈值，特别是在一些高并发的业务中，我们可以尽量将该值设置得小一些，避免大量事务等待，占用系统资源，造成严重的性能开销。</li>
</ul>
<p>另外，我们还可以将 order_no 列设置为唯一索引列。虽然不能防止幻读，但我们可以利用它的唯一性来保证订单记录不重复创建，这种方式唯一的缺点就是当遇到重复创建订单时会抛出异常。</p>
<p>我们还可以使用其它的方式来代替数据库实现幂等性校验。例如，使用 Redis 以及 ZooKeeper 来实现，运行效率比数据库更佳。</p>
<h3 id="5-3-解决死锁"><a href="#5-3-解决死锁" class="headerlink" title="5.3. 解决死锁"></a>5.3. 解决死锁</h3><p>当出现死锁以后，有两种策略：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 <code>innodb_lock_wait_timeout</code> 来设置。</li>
<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑。</li>
</ul>
<p>在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p>
<p>但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
<p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 <code>innodb_deadlock_detect</code> 的默认值本身就是 on。为了解决死锁问题，不同数据库实现了各自的死锁检测和超时机制。InnoDB 的处理策略是：<strong>将持有最少行级排它锁的事务进行回滚</strong>。</p>
<p>主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p>
<h2 id="6-分布式事务"><a href="#6-分布式事务" class="headerlink" title="6. 分布式事务"></a>6. 分布式事务</h2><p>在单一数据节点中，事务仅限于对单一数据库资源的访问控制，称之为 <strong>本地事务</strong>。几乎所有的成熟的关系型数据库都提供了对本地事务的原生支持。</p>
<p><strong>分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</strong></p>
<p>分布式事务的常见方案如下：</p>
<ul>
<li><p><strong>两阶段提交（2PC）</strong> - 将事务的提交过程分为两个阶段来进行处理：准备阶段和提交阶段。参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p>
</li>
<li><p><strong>三阶段提交（3PC）</strong>- 与二阶段提交不同的是，引入超时机制。同时在协调者和参与者中都引入超时机制。将二阶段的准备阶段拆分为 2 个阶段，插入了一个 preCommit 阶段，使得原先在二阶段提交中，参与者在准备之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。</p>
</li>
<li><p><strong>补偿事务（TCC）</strong></p>
<ul>
<li><strong>Try</strong> - 操作作为一阶段，负责资源的检查和预留。</li>
<li><strong>Confirm</strong> - 操作作为二阶段提交操作，执行真正的业务。</li>
<li><strong>Cancel</strong> - 是预留资源的取消。</li>
</ul>
</li>
<li><p><strong>本地消息表</strong> - 在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</p>
</li>
<li><p><strong>MQ 事务</strong> - 基于 MQ 的分布式事务方案其实是对本地消息表的封装。</p>
</li>
<li><p><strong>SAGA</strong> - Saga 事务核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</p>
</li>
</ul>
<p>分布式事务方案分析：</p>
<ul>
<li>2PC/3PC 依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。</li>
<li>TCC 适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。</li>
<li>本地消息表/MQ 事务 都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账/校验系统兜底。</li>
<li>Saga 事务 由于 Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。 Saga 相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。Saga 事务较适用于补偿动作容易处理的场景。</li>
</ul>
<h2 id="7-事务最佳实践"><a href="#7-事务最佳实践" class="headerlink" title="7. 事务最佳实践"></a>7. 事务最佳实践</h2><p>高并发场景下的事务到底该如何调优？</p>
<h3 id="7-1-尽量使用低级别事务隔离"><a href="#7-1-尽量使用低级别事务隔离" class="headerlink" title="7.1. 尽量使用低级别事务隔离"></a>7.1. 尽量使用低级别事务隔离</h3><p>结合业务场景，尽量使用低级别事务隔离</p>
<h3 id="7-2-避免行锁升级表锁"><a href="#7-2-避免行锁升级表锁" class="headerlink" title="7.2. 避免行锁升级表锁"></a>7.2. 避免行锁升级表锁</h3><p>在 InnoDB 中，行锁是通过索引实现的，如果不通过索引条件检索数据，行锁将会升级到表锁。我们知道，表锁是会严重影响到整张表的操作性能的，所以应该尽力避免。</p>
<h3 id="7-3-缩小事务范围"><a href="#7-3-缩小事务范围" class="headerlink" title="7.3. 缩小事务范围"></a>7.3. 缩小事务范围</h3><p>有时候，数据库并发访问量太大，会出现以下异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">MySQLQueryInterruptedException: Query execution was interrupted<br></code></pre></td></tr></table></figure>

<p>高并发时对一条记录进行更新的情况下，由于更新记录所在的事务还可能存在其他操作，导致一个事务比较长，当有大量请求进入时，就可能导致一些请求同时进入到事务中。</p>
<p>又因为锁的竞争是不公平的，当多个事务同时对一条记录进行更新时，极端情况下，一个更新操作进去排队系统后，可能会一直拿不到锁，最后因超时被系统打断踢出。</p>
<p><img src="/img/work/image-20220622195852431.png"></p>
<p>如上图中的操作，虽然都是在一个事务中，但锁的申请在不同时间，只有当其他操作都执行完，才会释放所有锁。因为扣除库存是更新操作，属于行锁，这将会影响到其他操作该数据的事务，所以我们应该尽量避免长时间地持有该锁，尽快释放该锁。又因为先新建订单和先扣除库存都不会影响业务，所以我们可以将扣除库存操作放到最后，也就是使用执行顺序 1，以此尽量减小锁的持有时间。</p>
<p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>
<p>知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p>
<h2 id="8-参考"><a href="#8-参考" class="headerlink" title="8.参考"></a>8.参考</h2><blockquote>
<p>本文的文章引自:<a href="https://dunwu.github.io/waterdrop/pages/00b04d/#_1-%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B">顿悟的MySQL事务</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL事务</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL工作流程</title>
    <url>/2022/06/14/MySQL%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-基础架构"><a href="#1-基础架构" class="headerlink" title="1.基础架构"></a>1.基础架构</h2><p>大体来说，MySQL可以分为Server层和存储引擎层两部分。</p>
<p><strong>Server层包括连接器、查询缓存、分析器、优化器、执行器等</strong>，涵盖MySQL的大多数核心服务功能，以及所有的内置函数(如日期、时间、数学和加密函数等)，所有跨存储引擎都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL5.5.5版本开始成为了默认存储引擎。</p>
<p><img src="/img/work/20200227201908.jpg"></p>
<h2 id="2-查询过程"><a href="#2-查询过程" class="headerlink" title="2. 查询过程"></a>2. 查询过程</h2><p>SQL语句在MySQL中是如何执行的?</p>
<p>MySQL 整个查询执行过程，总的来说分为 6 个步骤：</p>
<p>1.客户端和MySQL服务器建立连接;客户端向MySQL服务器发送一条查询请求。</p>
<p>2.MySQL服务器首先检查查询缓存，如果命中缓存，则立刻返回结果。否则进入下一阶段。</p>
<p>3.MySQL服务器进行SQL分析:语法分析、词法分析。</p>
<p>4.MySQL服务器用优化器生成对应的执行计划。</p>
<p>5.MySQL服务器根据执行计划，调用存储引擎的API来执行查询。</p>
<p>6.MySQL服务器将结果返回给客户端，同时缓存查询结果。</p>
<h3 id="2-1-连接"><a href="#2-1-连接" class="headerlink" title="2.1 连接"></a>2.1 连接</h3><p>使用MySQL第一步自然是要连接数据库。</p>
<p>MySQL客户端/服务端通信是<strong>半双工模式</strong>:即任一时刻，要么是服务端向客户端发送数据，要么是客户端向服务器发送数据。客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置<code>max_allowed_packet</code>参数。但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常。</p>
<p>MySQL客户端连接命令:<code>mysql -h&lt;主机&gt; -P&lt;端口&gt; -u&lt;用户名&gt;  -p&lt;密码&gt;</code>。如果没有显示指定密码，会要求输入密码才能访问。</p>
<p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 <code>show processlist</code> 命令中看到它。客户端如果太长时间没动静，连接器就会自动将它断开。<strong>客户端连接维持时间是由参数 <code>wait_timeout</code> 控制的，默认值是 8 小时</strong>。如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： <code>Lost connection to MySQL server during query</code>。这时候如果你要继续，就需要重连，然后再执行请求了。</p>
<p>建立连接的过程通常是比较复杂的，建议在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。为了在程序中提高数据库连接的复用，一般会使用数据库连接池来维护管理。</p>
<p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p>
<p>怎么解决这个问题呢？你可以考虑以下两种方案。</p>
<ul>
<li><strong>定期断开长连接</strong>。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li>
<li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 <code>mysql_reset_connection</code> 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li>
</ul>
<h3 id="2-2-查询缓存"><a href="#2-2-查询缓存" class="headerlink" title="2.2 查询缓存"></a>2.2 查询缓存</h3><blockquote>
<p><strong>不建议使用数据库缓存，因为往往弊大于利</strong>。</p>
</blockquote>
<p>解析一个查询语句前，如果查询缓存是打开的那么MySQL会检查这个查询语句是否命中查询缓存中的数据。如果当前查询恰好命中查询缓存，在检查一次用户权限后直接返回缓存中的结果。这种情况下，查询不会被解析，也不会生成执行计划，更不会执行。</p>
<p>MySQL 将缓存存放在一个引用表(不要理解成<code>table</code>，可以认为是类似于<code>HashMap</code>的数据结构),通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中。</p>
<p><strong>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、mysql 库中的系统表，其查询结果都不会被缓存</strong>。比如函数<code>NOW()</code>或者<code>CURRENT_DATE()</code>会因为不同的查询时间，返回不同的查询结果，再比如包含<code>CURRENT_USER</code>或者<code>CONNECION_ID()</code>的查询语句会因为不同的用户而返回不同的结果，将这样的查询结果缓存起来没有任何的意义。</p>
<p><strong>不建议使用数据库缓存，因为往往弊大于利</strong>。的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p>
<p>好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 <code>query_cache_type</code> 设置成 <code>DEMAND</code>，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 <code>SQL_CACHE</code> 显式指定，像下面这个语句一样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> SQL_CACHE <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> ID<span class="hljs-operator">=</span><span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：MySQL 8.0 版本直接将查询缓存的整块功能删掉了。</p>
</blockquote>
<h3 id="2-3-语法分析"><a href="#2-3-语法分析" class="headerlink" title="2.3 语法分析"></a>2.3 语法分析</h3><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。MySQL 通过关键字对 SQL 语句进行解析，并生成一颗对应的语法解析树。这个过程中，分析器主要通过语法规则来验证和解析。比如 SQL 中是否使用了错误的关键字或者关键字的顺序是否正确等等。预处理则会根据 MySQL 规则进一步检查解析树是否合法。比如检查要查询的数据表和数据列是否存在等等。</p>
<ul>
<li>分析器先会先做“<strong>词法分析</strong>”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</li>
<li>接下来，要做“<strong>语法分析</strong>”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒。</li>
</ul>
<h3 id="2-4-查询优化"><a href="#2-4-查询优化" class="headerlink" title="2.4 查询优化"></a>2.4 查询优化</h3><p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。 </p>
<p>经过前面的步骤生成的语法树被认为是合法的了，并且由优化器将其转化成执行计划。多数情况下，一条查询可以有很多种执行方式，最后都返回相应的结果。优化器的作用就是找到这其中最好的执行计划。 </p>
<p>MySQL 使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。在 MySQL 可以通过查询当前会话的 <code>last_query_cost</code> 的值来得到其计算当前查询的成本。 </p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">mysql&gt; select * from t_message limit <span class="hljs-number">10</span>;<br>...省略结果集<br><br>mysql&gt; show status like <span class="hljs-string">&#x27;last_query_cost&#x27;</span>;<br>+-----------------+-------------+<br><span class="hljs-params">| Variable_name   |</span> Value       <span class="hljs-params">|</span><br><span class="hljs-params">+-----------------+-------------+</span><br><span class="hljs-params">|</span> Last_query_cost <span class="hljs-params">| 6391.799000 |</span><br>+-----------------+-------------+<br></code></pre></td></tr></table></figure>

<p>示例中的结果表示优化器认为大概需要做 6391 个数据页的随机查找才能完成上面的查询。这个结果是根据一些列的统计信息计算得来的，这些统计信息包括：每张表或者索引的页面个数、索引的基数、索引和数据行的长度、索引的分布情况等等。 </p>
<p>有非常多的原因会导致 MySQL 选择错误的执行计划，比如统计信息不准确、不会考虑不受其控制的操作成本（用户自定义函数、存储过程）、MySQL 认为的最优跟我们想的不一样（我们希望执行时间尽可能短，但 MySQL 值选择它认为成本小的，但成本小并不意味着执行时间短）等等。 </p>
<p>MySQL 的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划： </p>
<ul>
<li>重新定义表的关联顺序（多张表关联查询时，并不一定按照 SQL 中指定的顺序进行，但有一些技巧可以指定关联顺序）</li>
<li>优化<code>MIN()</code>和<code>MAX()</code>函数（找某列的最小值，如果该列有索引，只需要查找 B+Tree 索引最左端，反之则可以找到最大值，具体原理见下文）</li>
<li>提前终止查询（比如：使用 Limit 时，查找到满足数量的结果集后会立即终止查询）</li>
<li>优化排序（在老版本 MySQL 会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于 I/O 密集型应用，效率会高很多）</li>
</ul>
<p>随着 MySQL 的不断发展，优化器使用的优化策略也在不断的进化，这里仅仅介绍几个非常常用且容易理解的优化策略，其他的优化策略，大家自行查阅吧。 </p>
<h3 id="2-5-查询执行引擎"><a href="#2-5-查询执行引擎" class="headerlink" title="2.5 查询执行引擎"></a>2.5 查询执行引擎</h3><p>在完成解析和优化阶段以后，MySQL 会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。整个执行过程的大部分操作均是通过调用存储引擎实现的接口来完成，这些接口被称为<code>handler API</code>。 </p>
<p>查询过程中的每一张表由一个<code>handler</code>实例表示。实际上，MySQL 在查询优化阶段就为每一张表创建了一个<code>handler</code>实例，优化器可以根据这些实例的接口来获取表的相关信息，包括表的所有列名、索引统计信息等。存储引擎接口提供了非常丰富的功能，但其底层仅有几十个接口，这些接口像搭积木一样完成了一次查询的大部分操作。 </p>
<h3 id="2-6-返回结果"><a href="#2-6-返回结果" class="headerlink" title="2.6 返回结果"></a>2.6 返回结果</h3><p>查询过程的最后一个阶段就是将结果返回给客户端。即使查询不到数据，MySQL 仍然会返回这个查询的相关信息，比如该查询影响到的行数以及执行时间等等。 </p>
<p>如果查询缓存被打开且这个查询可以被缓存，MySQL 也会将结果存放到缓存中。</p>
<p>结果集返回客户端是一个增量且逐步返回的过程。有可能 MySQL 在生成第一条结果时，就开始向客户端逐步返回结果集了。这样服务端就无须存储太多结果而消耗过多内存，也可以让客户端第一时间获得返回结果。需要注意的是，结果集中的每一行都会以一个满足 ① 中所描述的通信协议的数据包发送，再通过 TCP 协议进行传输，在传输过程中，可能对 MySQL 的数据包进行缓存然后批量发送。  </p>
<h2 id="3-更新过程"><a href="#3-更新过程" class="headerlink" title="3. 更新过程"></a>3. 更新过程</h2><p>MySQL 更新过程和 MySQL 查询过程类似，也会将流程走一遍。不一样的是：<strong>更新流程还涉及两个重要的日志模块，：redo log（重做日志）和 binlog（归档日志）</strong>。 </p>
<h3 id="3-1-redo-log"><a href="#3-1-redo-log" class="headerlink" title="3.1. redo log"></a>3.1. redo log</h3><p><strong>redo log 是 InnoDB 引擎特有的日志</strong>。<strong>redo log 即重做日志</strong>。redo log 是物理日志，记录的是“在某个数据页上做了什么修改”。 </p>
<p><strong>redo log 是基于 WAL 技术</strong>。WAL 的全称是 <strong>Write-Ahead Logging</strong>，它的关键点就是<strong>先写日志，再写磁盘</strong>。具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。 </p>
<p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写。 </p>
<p> <img src="/img/work/20200630180342.png"> </p>
<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。 </p>
<h3 id="3-2-bin-log"><a href="#3-2-bin-log" class="headerlink" title="3.2. bin log"></a>3.2. bin log</h3><p><strong>bin log 即归档日志</strong>。binlog 是逻辑日志，记录的是这个语句的原始逻辑。 </p>
<p>binlog 是可以追加写入的，即写到一定大小后会切换到下一个，并不会覆盖以前的日志。 </p>
<p><strong>binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用</strong>。 </p>
<p><code>sync_binlog</code> 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。 </p>
<h3 id="3-3-redo-log-vs-bin-log"><a href="#3-3-redo-log-vs-bin-log" class="headerlink" title="3.3. redo log vs bin log"></a>3.3. redo log vs bin log</h3><p>这两种日志有以下三点不同。 </p>
<ul>
<li>redo log 是 InnoDB 引擎特有的；  binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。 </li>
<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li>
<li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 </li>
</ul>
<p>有了对这两个日志的概念性理解，我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。 </p>
<ol>
<li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li>
</ol>
<p>这里我给出这个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。 </p>
<p> <img src="/img/work/20200714133806.png"> </p>
<h3 id="3-4-两阶段提交"><a href="#3-4-两阶段提交" class="headerlink" title="3.4. 两阶段提交"></a>3.4. 两阶段提交</h3><p>redo log 的写入拆成了两个步骤：prepare 和 commit，这就是”两阶段提交”。为什么日志需要“两阶段提交”。 </p>
<p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。 </p>
<ul>
<li><strong>先写 redo log 后写 binlog</strong>。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。 但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。 然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。  </li>
<li> <strong>先写 binlog 后写 redo log</strong>。  如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。 </li>
</ul>
<p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。 </p>
<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p><a href="https://book.douban.com/subject/23008813/">高性能MySQL</a></p>
<p> <a href="https://time.geekbang.org/column/intro/139">MySQL 实战 45 讲 </a></p>
<p><a href="https://dunwu.github.io/db-tutorial/pages/8262aa/#_3-3-redo-log-vs-bin-log">MySQL工作流</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引</title>
    <url>/2022/07/05/MySQL%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>索引是提高 MySQL 查询性能的一个重要途径，但过多的索引可能会导致过高的磁盘使用率以及过高的内存占用，从而影响应用程序的整体性能。应当尽量避免事后才想起添加索引，因为事后可能需要监控大量的 SQL 才能定位到问题所在，而且添加索引的时间肯定是远大于初始添加索引所需要的时间，可见索引的添加也是非常有技术含量的。</p>
<p>接下来将向你展示一系列创建高性能索引的策略，以及每条策略其背后的工作原理。但在此之前，先了解与索引相关的一些算法和数据结构，将有助于更好的理解后文的内容。</p>
</blockquote>
<h2 id="1-索引简介"><a href="#1-索引简介" class="headerlink" title="1. 索引简介"></a>1. 索引简介</h2><p><strong>索引是数据库为了提高查找效率的一种数据结构</strong>。</p>
<p>索引对于良好的性能非常关键，在数据量小且负载较低时，不恰当的索引对于性能的影响可能还不明显；但随着数据量逐渐增大，性能则会急剧下降。因此，索引优化应该是查询性能优化的最有效手段。</p>
<h3 id="1-1索引的分类"><a href="#1-1索引的分类" class="headerlink" title="1.1索引的分类"></a>1.1索引的分类</h3><h4 id="1-1-1-从存储结构上来划分"><a href="#1-1-1-从存储结构上来划分" class="headerlink" title="1.1.1 从存储结构上来划分"></a>1.1.1 从存储结构上来划分</h4><ul>
<li>Btree索引（B+tree，B-tree) </li>
<li>哈希索引 </li>
<li>full-index全文索引 </li>
<li>RTree</li>
</ul>
<h4 id="1-1-2从应用层次上来划分"><a href="#1-1-2从应用层次上来划分" class="headerlink" title="1.1.2从应用层次上来划分"></a>1.1.2从应用层次上来划分</h4><ul>
<li>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引。</li>
<li>唯一索引：索引列的值必须唯一，但允许有空值。</li>
<li>复合索引：一个索引包含多个列。</li>
</ul>
<h4 id="1-1-3-从表记录的排列顺序和索引的排列顺序是否一致来划分"><a href="#1-1-3-从表记录的排列顺序和索引的排列顺序是否一致来划分" class="headerlink" title="1.1.3 从表记录的排列顺序和索引的排列顺序是否一致来划分"></a>1.1.3 从表记录的排列顺序和索引的排列顺序是否一致来划分</h4><ul>
<li>聚集索引：表记录的排列顺序和索引的排列顺序一致。 </li>
<li>非聚集索引：表记录的排列顺序和索引的排列顺序不一致。</li>
</ul>
<h3 id="1-2-聚集索引和非聚集索引"><a href="#1-2-聚集索引和非聚集索引" class="headerlink" title="1.2 聚集索引和非聚集索引"></a>1.2 聚集索引和非聚集索引</h3><h4 id="1-2-1-简单概括"><a href="#1-2-1-简单概括" class="headerlink" title="1.2.1 简单概括"></a>1.2.1 简单概括</h4><ul>
<li>聚集索引：就是以主键创建的索引。 </li>
<li>非聚集索引：就是以非主键创建的索引（也叫做二级索引）。</li>
</ul>
<h4 id="1-2-2-详细概括"><a href="#1-2-2-详细概括" class="headerlink" title="1.2.2 详细概括"></a>1.2.2 详细概括</h4><p><strong>聚集索引:</strong></p>
<p>聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，因为只要找到第一个索引值记录，其余的连续性的记录在物理表中也会连续存放，一起就可以查询到。</p>
<p>缺点：新增比较慢，因为为了保证表中记录的物理顺序和索引顺序一致，在记录插入的时候，会对数据页重新排序。</p>
<p><strong>非聚集索引:</strong></p>
<p>索引的逻辑顺序与磁盘上行的物理存储顺序不同，非聚集索引在叶子节点存储的是主键和索引列，当我们使用非聚集索引查询数据时，需要拿到叶子上的主键再去表中查到想要查找的数据。这个过程就是我们所说的回表。</p>
<h4 id="1-2-3-聚集索引和非聚集索引的区别"><a href="#1-2-3-聚集索引和非聚集索引的区别" class="headerlink" title="1.2.3 聚集索引和非聚集索引的区别"></a>1.2.3 聚集索引和非聚集索引的区别</h4><ul>
<li>聚集索引在叶子节点存储的是表中的数据。 </li>
<li>非聚集索引在叶子节点存储的是主键和索引列。</li>
</ul>
<p><strong>举个例子</strong></p>
<p>比如汉语字典，想要查「阿」字，只需要翻到字典前几页，a开头的位置，接着「啊」「爱」都会出来。也就是说，字典的正文部分本身就是一个目录，不需要再去查其他目录来找到需要找的内容。我们把这种正文内容本身就是一种按照一定规则排列的目录称为==聚集索引==。</p>
<p>如果遇到不认识的字，只能根据“偏旁部首”进行查找，然后根据这个字后的页码直接翻到某页来找到要找的字。但结合部首目录和检字表而查到的字的排序并不是真正的正文的排序方法。</p>
<p>比如要查“玉”字，我们可以看到在查部首之后的检字表中“玉”的页码是587页，然后是珏，是251页。很显然，在字典中这两个字并没有挨着，现在看到的连续的“玉、珏、莹”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到结果所对应的页码。我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为==非聚集索引==。</p>
<h3 id="1-3-索引的优缺点"><a href="#1-3-索引的优缺点" class="headerlink" title="1.3 索引的优缺点"></a>1.3 索引的优缺点</h3><p>B 树是最常见的索引，按照顺序存储数据，所以 Mysql 可以用来做 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作。因为数据是有序的，所以 B 树也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。</p>
<p><strong>索引的优点：</strong></p>
<ul>
<li><strong>索引大大减少了服务器所需要扫描的数据量</strong>，从而加快检索速度。</li>
<li><strong>索引可以帮助服务器避免排序和临时表。</strong></li>
<li><strong>索引可以将随机IO变顺序IO。</strong></li>
<li>支持行级锁的数据库，如 InnoDB 会在访问行的时候加锁。<strong>使用索引可以减少访问的行数，从而减少锁的竞争，提高并发</strong>。</li>
<li>唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。</li>
</ul>
<p><strong>索引缺点:</strong></p>
<ul>
<li><strong>创建和维护索引要耗费时间，</strong>这会随着数据量的增加而增加。</li>
<li><strong>索引需要占用额外的物理空间</strong>，除了数据表占数据空间外，每一个索引还要占一定的物理空间，如果要建立组合索引那么需要的空间就会更大。</li>
<li><strong>写操作（<code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>）时很可能需要更新索引，导致数据库的写操作性能降低。</strong></li>
</ul>
<h3 id="1-4-何时使用索引"><a href="#1-4-何时使用索引" class="headerlink" title="1.4 何时使用索引"></a>1.4 何时使用索引</h3><blockquote>
<p>索引能够轻易将查询性能提升几个数量级。</p>
</blockquote>
<p><strong>什么情况适用索引：</strong></p>
<ul>
<li><strong>频繁读操作（ <code>SELECT</code> ）</strong></li>
<li><strong>表的数据量比较大</strong>。</li>
<li><strong>列名经常出现在 <code>WHERE</code> 或连接（<code>JOIN</code>）条件中</strong>。</li>
</ul>
<p><strong>什么情况不适用索引：</strong></p>
<ul>
<li><strong>频繁写操作</strong>（ <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code> ），也就意味着需要更新索引。</li>
<li><strong>列名不经常出现在 <code>WHERE</code> 或连接（<code>JOIN</code>）条件中</strong>，也就意味着索引会经常无法命中，没有意义，还增加空间开销。</li>
<li><strong>非常小的表</strong>，对于非常小的表，大部分情况下简单的全表扫描更高效。</li>
<li><strong>特大型的表</strong>，建立和使用索引的代价将随之增长。可以考虑使用分区技术或 Nosql。</li>
</ul>
<h2 id="2-索引的数据结构"><a href="#2-索引的数据结构" class="headerlink" title="2. 索引的数据结构"></a>2. 索引的数据结构</h2><p>在 Mysql 中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准；不同存储引擎的索引的数据结构也不相同。</p>
<p>不同存储引擎的索引的工作方式并不一样，这是因为存储引擎底层使用的数据结构及算法不一样。在 MySQL 中，某些存储引擎允许在创建索引时指定索引的数据结构类型，下表是常见存储引擎支持的索引的数据结构类型：</p>
<table>
<thead>
<tr>
<th>存储引擎</th>
<th>允许的数据结构类型</th>
</tr>
</thead>
<tbody><tr>
<td>InnoDB</td>
<td>BTREE</td>
</tr>
<tr>
<td>MyISAM</td>
<td>BTREE</td>
</tr>
<tr>
<td>Memory</td>
<td>HASH（默认）, BTREE</td>
</tr>
</tbody></table>
<blockquote>
<p>需要注意的是，用户不能为全文索引和空间索引指定数据结构类型：全文索引的实现取决于存储引擎，而空间索引被实现为 RTREE 数据结构。</p>
</blockquote>
<h3 id="2-1-哈希索引"><a href="#2-1-哈希索引" class="headerlink" title="2.1. 哈希索引"></a>2.1. 哈希索引</h3><p>哈希表是一种以键 - 值（key-value）对形式存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。</p>
<p><strong>哈希表</strong> 使用 <strong>哈希函数</strong> 组织数据，以支持快速插入和搜索的数据结构。哈希表的本质是一个数组，其思路是：使用 Hash 函数将 Key 转换为数组下标，利用数组的随机访问特性，使得我们能在 <code>O(1)</code> 的时间代价内完成检索。</p>
<p><img src="/img/work/image-20220702162145825.png"></p>
<p>有两种不同类型的哈希表：<strong>哈希集合</strong> 和 <strong>哈希映射</strong>。</p>
<ul>
<li><strong>哈希集合</strong> 是集合数据结构的实现之一，用于存储非重复值。</li>
<li><strong>哈希映射</strong> 是映射数据结构的实现之一，用于存储键值对。</li>
</ul>
<p>哈希索引基于哈希表实现，<strong>只适用于等值查询</strong>。对于每一行数据，哈希索引都会将所有的索引列计算一个哈希码（<code>hashcode</code>），哈希码是一个较小的值。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>在 Mysql 中，只有 Memory 存储引擎显示支持哈希索引。</p>
<p>哈希索引的<strong>优点</strong>：</p>
<ul>
<li>因为索引数据结构紧凑，所以<strong>查询速度非常快</strong>。</li>
</ul>
<p>哈希索引的<strong>缺点</strong>：</p>
<ul>
<li>哈希索引值包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响不大。</li>
<li><strong>哈希索引数据不是按照索引值顺序存储的</strong>，所以<strong>无法用于排序</strong>。</li>
<li>哈希索引<strong>不支持部分索引匹配查找</strong>，因为哈希索引时使用索引列的全部内容来进行哈希计算的。如，在数据列 (A,B) 上建立哈希索引，如果查询只有数据列 A，无法使用该索引。</li>
<li>哈希索引<strong>只支持等值比较查询</strong>，包括 <code>=</code>、<code>IN()</code>、<code>&lt;=&gt;</code>；不支持任何范围查询，如 <code>WHERE price &gt; 100</code>。</li>
<li>哈希索引有<strong>可能出现哈希冲突</strong><ul>
<li>出现哈希冲突时，必须遍历链表中所有的行指针，逐行比较，直到找到符合条件的行。</li>
<li>如果哈希冲突多的话，维护索引的代价会很高。</li>
</ul>
</li>
</ul>
<blockquote>
<p> 因为种种限制，所以哈希索引只适用于特定的场合。而一旦使用哈希索引，则它带来的性能提升会非常显著。</p>
</blockquote>
<h3 id="2-2-B-树索引"><a href="#2-2-B-树索引" class="headerlink" title="2.2. B 树索引"></a>2.2. B 树索引</h3><p>通常我们所说的索引是指<code>B-Tree</code>索引，它是目前关系型数据库中查找数据最为常用和有效的索引，大多数存储引擎都支持这种索引。使用<code>B-Tree</code>这个术语，是因为 MySQL 在<code>CREATE TABLE</code>或其它语句中使用了这个关键字，但实际上不同的存储引擎可能使用不同的数据结构，比如 InnoDB 就是使用的<code>B+Tree</code>。</p>
<p><code>B+Tree</code>中的 B 是指<code>balance</code>，意为平衡。需要注意的是，B+树索引并不能找到一个给定键值的具体行，它找到的只是被查找数据行所在的页，接着数据库会把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>
<h4 id="2-2-1-二叉搜索树"><a href="#2-2-1-二叉搜索树" class="headerlink" title="2.2.1  二叉搜索树"></a>2.2.1  二叉搜索树</h4><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。其查询时间复杂度是**O(log(N))**。</p>
<p>当然为了维持**O(log(N))**的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 **O(log(N))**。</p>
<p>随着数据库中数据的增加，索引本身大小随之增加，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级。可以想象一下一棵几百万节点的二叉树的深度是多少？如果将这么大深度的一颗二叉树放磁盘上，每读取一个节点，需要一次磁盘的 I/O 读取，整个查找的耗时显然是不能够接受的。那么如何减少查找过程中的 I/O 存取次数？</p>
<p>一种行之有效的解决方法是减少树的深度，将<strong>二叉树变为 N 叉树</strong>（多路搜索树），而 <strong>B+ 树就是一种多路搜索树</strong>。</p>
<h4 id="2-2-2-B-树"><a href="#2-2-2-B-树" class="headerlink" title="2.2.2 B+ 树"></a>2.2.2 B+ 树</h4><p>B+ 树索引适用于<strong>全键值查找</strong>、<strong>键值范围查找</strong>和<strong>键前缀查找</strong>，其中键前缀查找只适用于最左前缀查找。</p>
<p>理解<code>B+Tree</code>时，只需要理解其最重要的两个特征即可：</p>
<ul>
<li>第一，所有的关键字（可以理解为数据）都存储在叶子节点，非叶子节点并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。</li>
<li>其次，所有的叶子节点由指针连接。如下图为简化了的<code>B+Tree</code>。</li>
</ul>
<p><img src="/img/work/image-20220702164243015.png"></p>
<p>根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<ul>
<li><strong>聚簇索引（clustered）</strong>：又称为主键索引，其叶子节点存的是整行数据。因为无法同时把数据行存放在两个不同的地方，所以<strong>一个表只能有一个聚簇索引</strong>。<strong>InnoDB 的聚簇索引实际是在同一个结构中保存了 B 树的索引和数据行</strong>。</li>
<li>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为<strong>二级索引（secondary）</strong>。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于 249 个。</li>
</ul>
<p><strong>聚簇表示数据行和相邻的键值紧凑地存储在一起，因为数据紧凑，所以访问快</strong>。因为无法同时把数据行存放在两个不同的地方，所以<strong>一个表只能有一个聚簇索引</strong>。</p>
<p><strong>聚簇索引和非聚簇索引的查询有什么区别</strong></p>
<ul>
<li>如果语句是 <code>select * from T where ID=500</code>，即聚簇索引查询方式，则只需要搜索 ID 这棵 B+ 树；</li>
<li>如果语句是 <code>select * from T where k=5</code>，即非聚簇索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</li>
</ul>
<p>也就是说，<strong>基于非聚簇索引的查询需要多扫描一棵索引树</strong>。因此，我们在应用中应该尽量使用主键查询。</p>
<p><strong>显然，主键长度越小，非聚簇索引的叶子节点就越小，非聚簇索引占用的空间也就越小。</strong></p>
<p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。从性能和存储空间方面考量，自增主键往往是更合理的选择。有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p>
<ul>
<li>只有一个索引；</li>
<li>该索引必须是唯一索引。</li>
</ul>
<p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p>
<p>这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>
<h3 id="2-3-全文索引"><a href="#2-3-全文索引" class="headerlink" title="2.3. 全文索引"></a>2.3. 全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h3 id="2-4-空间数据索引"><a href="#2-4-空间数据索引" class="headerlink" title="2.4. 空间数据索引"></a>2.4. 空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h3 id="2-5-聚集索引和非聚集索引"><a href="#2-5-聚集索引和非聚集索引" class="headerlink" title="2.5 聚集索引和非聚集索引"></a>2.5 聚集索引和非聚集索引</h3><h2 id="3-索引的类型"><a href="#3-索引的类型" class="headerlink" title="3. 索引的类型"></a>3. 索引的类型</h2><p>主流的关系型数据库一般都支持以下索引类型：</p>
<h3 id="3-1-主键索引（PRIMARY）"><a href="#3-1-主键索引（PRIMARY）" class="headerlink" title="3.1. 主键索引（PRIMARY）"></a>3.1. 主键索引（<code>PRIMARY</code>）</h3><p>主键索引：一种特殊的唯一索引，不允许有空值。一个表只能有一个主键（在 InnoDB 中本质上即聚簇索引），一般是在建表的时候同时创建主键索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">table</span>` (<br>    `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    ...<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>)<br></code></pre></td></tr></table></figure>

<h3 id="3-2-唯一索引（UNIQUE）"><a href="#3-2-唯一索引（UNIQUE）" class="headerlink" title="3.2. 唯一索引（UNIQUE）"></a>3.2. 唯一索引（<code>UNIQUE</code>）</h3><p>唯一索引：<strong>索引列的值必须唯一，但允许有空值</strong>。如果是组合索引，则列值的组合必须唯一。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">table</span>` (<br>    ...<br>    <span class="hljs-keyword">UNIQUE</span> indexName (title(length))<br>)<br></code></pre></td></tr></table></figure>



<h3 id="3-3-普通索引（INDEX）"><a href="#3-3-普通索引（INDEX）" class="headerlink" title="3.3. 普通索引（INDEX）"></a>3.3. 普通索引（<code>INDEX</code>）</h3><p>普通索引：最基本的索引，没有任何限制。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">table</span>` (<br>    ...<br>    INDEX index_name (title(length))<br>)<br></code></pre></td></tr></table></figure>

<h3 id="3-4-全文索引（FULLTEXT）"><a href="#3-4-全文索引（FULLTEXT）" class="headerlink" title="3.4. 全文索引（FULLTEXT）"></a>3.4. 全文索引（<code>FULLTEXT</code>）</h3><p>全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。</p>
<p>全文索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的 WHERE 语句的参数匹配。全文索引配合 <code>match against</code> 操作使用，而不是一般的 WHERE 语句加 LIKE。它可以在 <code>CREATE TABLE</code>，<code>ALTER TABLE</code> ，<code>CREATE INDEX</code> 使用，不过目前只有 <code>char</code>、<code>varchar</code>，<code>text</code> 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用 <code>CREATE INDEX</code> 创建全文索引，要比先为一张表建立全文索引然后再将数据写入的速度快很多。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">table</span>` (<br>    `content` text <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">NULL</span>,<br>    ...<br>    FULLTEXT (content)<br>)<br></code></pre></td></tr></table></figure>



<h3 id="3-5-联合索引"><a href="#3-5-联合索引" class="headerlink" title="3.5. 联合索引"></a>3.5. 联合索引</h3><p>组合索引：多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">table</span>` (<br>    ...<br>    INDEX index_name (title(length), title(length), ...)<br>)<br></code></pre></td></tr></table></figure>



<p>下表是 MySQL 中常见的存储引擎对索引类型的支持情况：</p>
<table>
<thead>
<tr>
<th>索引类型</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>PRIMARY KEY</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>INDEX</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Unique</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>FULLTEXT</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>SPATIAL</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h2 id="4-索引的策略"><a href="#4-索引的策略" class="headerlink" title="4. 索引的策略"></a>4. 索引的策略</h2><p>假设有以下表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `city` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `addr` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `city` (`city`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB;<br></code></pre></td></tr></table></figure>

<h3 id="4-1-索引基本原则"><a href="#4-1-索引基本原则" class="headerlink" title="4.1. 索引基本原则"></a>4.1. 索引基本原则</h3><ul>
<li><strong>索引不是越多越好，不要为所有列都创建索引</strong>。要考虑到索引的维护代价、空间占用和查询时回表的代价。索引一定是按需创建的，并且要尽可能确保足够轻量。一旦创建了多字段的联合索引，我们要考虑尽可能利用索引本身完成数据查询，减少回表的成本。</li>
<li>要<strong>尽量避免冗余和重复索引</strong>。</li>
<li>要<strong>考虑删除未使用的索引</strong>。</li>
<li><strong>尽量的扩展索引，不要新建索引</strong>。</li>
<li><strong>频繁作为 <code>WHERE</code> 过滤条件的列应该考虑添加索引</strong>。</li>
</ul>
<h3 id="4-2-独立的列"><a href="#4-2-独立的列" class="headerlink" title="4.2. 独立的列"></a>4.2. 独立的列</h3><p><strong>“独立的列” 是指索引列不能是表达式的一部分，也不能是函数的参数</strong>。</p>
<p><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p>
<p>如果查询中的列不是独立的列，则数据库不会使用索引。</p>
<p>错误示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> actor_id <span class="hljs-keyword">FROM</span> actor <span class="hljs-keyword">WHERE</span> actor_id <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">WHERE</span> TO_DAYS(<span class="hljs-built_in">current_date</span>) <span class="hljs-operator">-</span> TO_DAYS(date_col) <span class="hljs-operator">&lt;=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<h3 id="4-3-覆盖索引"><a href="#4-3-覆盖索引" class="headerlink" title="4.3. 覆盖索引"></a>4.3. 覆盖索引</h3><p><strong>覆盖索引是指，索引上的信息足够满足查询请求，不需要回表查询数据。</strong></p>
<p>【示例】范围查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> T (<br>ID <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,<br>k <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>,<br>s <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>index k(k))<br>engine<span class="hljs-operator">=</span>InnoDB;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> T <span class="hljs-keyword">values</span>(<span class="hljs-number">100</span>,<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;aa&#x27;</span>),(<span class="hljs-number">200</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;bb&#x27;</span>),(<span class="hljs-number">300</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;cc&#x27;</span>),(<span class="hljs-number">500</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;ee&#x27;</span>),(<span class="hljs-number">600</span>,<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;ff&#x27;</span>),(<span class="hljs-number">700</span>,<span class="hljs-number">7</span>,<span class="hljs-string">&#x27;gg&#x27;</span>);<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> k <span class="hljs-keyword">between</span> <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>需要执行几次树的搜索操作，会扫描多少行？</p>
<ol>
<li>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</li>
<li>再到 ID 索引树查到 ID=300 对应的 R3；</li>
<li>在 k 索引树取下一个值 k=5，取得 ID=500；</li>
<li>再回到 ID 索引树查到 ID=500 对应的 R4；</li>
<li>在 k 索引树取下一个值 k=6，不满足条件，循环结束。</li>
</ol>
<p>在这个过程中，<strong>回到主键索引树搜索的过程，我们称为回表</strong>。可以看到，这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。</p>
<p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。索引包含所有需要查询的字段的值，称为覆盖索引。</p>
<p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p>
<h3 id="4-4-使用索引来排序"><a href="#4-4-使用索引来排序" class="headerlink" title="4.4. 使用索引来排序"></a>4.4. 使用索引来排序</h3><p>Mysql 有两种方式可以生成排序结果：通过排序操作；或者按索引顺序扫描。</p>
<p><strong>索引最好既满足排序，又用于查找行</strong>。这样，就可以通过命中覆盖索引直接将结果查出来，也就不再需要排序了。</p>
<p>这样整个查询语句的执行流程就变成了：</p>
<ol>
<li>从索引 (city,name,age) 找到第一个满足 city=’杭州’条件的记录，取出其中的 city、name 和 age 这三个字段的值，作为结果集的一部分直接返回；</li>
<li>从索引 (city,name,age) 取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；</li>
<li>重复执行步骤 2，直到查到第 1000 条记录，或者是不满足 city=’杭州’条件时循环结束。</li>
</ol>
<h3 id="4-5-前缀索引"><a href="#4-5-前缀索引" class="headerlink" title="4.5. 前缀索引"></a>4.5. 前缀索引</h3><p>有时候需要索引很长的字符列，这会让索引变得大且慢。</p>
<p>这时，可以使用前缀索引，即只索引开始的部分字符，这样可以<strong>大大节约索引空间</strong>，从而<strong>提高索引效率</strong>。但这样也<strong>会降低索引的选择性</strong>。对于 <code>BLOB</code>/<code>TEXT</code>/<code>VARCHAR</code> 这种文本类型的列，必须使用前缀索引，因为数据库往往不允许索引这些列的完整长度。</p>
<p><strong>索引的选择性</strong>是指：不重复的索引值和数据表记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。如果存在多条命中前缀索引的情况，就需要依次扫描，直到最终找到正确记录。</p>
<p><strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p>
<p>那么，如何确定前缀索引合适的长度呢？</p>
<p>可以使用下面这个语句，算出这个列上有多少个不同的值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> email) <span class="hljs-keyword">as</span> L <span class="hljs-keyword">from</span> SUser;<br></code></pre></td></tr></table></figure>

<p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下 4~7 个字节的前缀索引，可以用这个语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>  <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(email,<span class="hljs-number">4</span>)）<span class="hljs-keyword">as</span> L4,<br>  <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(email,<span class="hljs-number">5</span>)）<span class="hljs-keyword">as</span> L5,<br>  <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(email,<span class="hljs-number">6</span>)）<span class="hljs-keyword">as</span> L6,<br>  <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(email,<span class="hljs-number">7</span>)）<span class="hljs-keyword">as</span> L7,<br><span class="hljs-keyword">from</span> SUser;<br></code></pre></td></tr></table></figure>

<p>当然，<strong>使用前缀索引很可能会损失区分度</strong>，所以你需要预先设定一个可以接受的损失比例，比如 5%。然后，在返回的 L4~L7 中，找出不小于 L * 95% 的值，假设这里 L6、L7 都满足，你就可以选择前缀长度为 6。</p>
<p>此外，**<code>order by</code> 无法使用前缀索引，无法把前缀索引用作覆盖索引**。</p>
<h3 id="4-6-最左前缀匹配原则"><a href="#4-6-最左前缀匹配原则" class="headerlink" title="4.6. 最左前缀匹配原则"></a>4.6. 最左前缀匹配原则</h3><p>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p>
<p>MySQL 会一直向右匹配直到遇到范围查询 <code>(&gt;,&lt;,BETWEEN,LIKE)</code> 就停止匹配。</p>
<ul>
<li>索引可以简单如一个列(a)，也可以复杂如多个列(a, b, c, d)，即<strong>联合索引</strong>。</li>
<li>如果是联合索引，那么 key 也由多个列组成，同时，索引只能用于查找 key 是否<strong>存在（相等）</strong>，遇到范围查询(&gt;、&lt;、between、like 左匹配)等就<strong>不能进一步匹配</strong>了，后续退化为线性查找。</li>
<li>因此，<strong>列的排列顺序决定了可命中索引的列数</strong>。</li>
</ul>
<p><strong>不要为每个列都创建独立索引</strong>。</p>
<p><strong>将选择性高的列或基数大的列优先排在多列索引最前列</strong>。但有时，也需要考虑 <code>WHERE</code> 子句中的排序、分组和范围条件等因素，这些因素也会对查询性能造成较大影响。</p>
<p>例如：<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，如果建立（a,b,c,d）顺序的索引，d 是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d 的顺序可以任意调整。</p>
<p>让选择性最强的索引列放在前面，索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。</p>
<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> staff_id)<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> staff_id_selectivity,<br><span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> customer_id)<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> customer_id_selectivity,<br><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">FROM</span> payment;<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">staff_id_selectivity: <span class="hljs-number">0.0001</span><br>customer_id_selectivity: <span class="hljs-number">0.0373</span><br>               <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>): <span class="hljs-number">16049</span><br></code></pre></td></tr></table></figure>

<h3 id="4-7-和-in-可以乱序"><a href="#4-7-和-in-可以乱序" class="headerlink" title="4.7. = 和 in 可以乱序"></a>4.7. = 和 in 可以乱序</h3><p><strong>不需要考虑 <code>=</code>、<code>IN</code> 等的顺序</strong>，Mysql 会自动优化这些条件的顺序，以匹配尽可能多的索引列。</p>
<p>【示例】如有索引 (a, b, c, d)，查询条件 <code>c &gt; 3 and b = 2 and a = 1 and d &lt; 4</code> 与 <code>a = 1 and c &gt; 3 and b = 2 and d &lt; 4</code> 等顺序都是可以的，MySQL 会自动优化为 a = 1 and b = 2 and c &gt; 3 and d &lt; 4，依次命中 a、b、c、d。</p>
<h2 id="5-索引最佳实践"><a href="#5-索引最佳实践" class="headerlink" title="5. 索引最佳实践"></a>5. 索引最佳实践</h2><p>创建了索引，并非一定有效。比如不满足前缀索引、最左前缀匹配原则、查询条件涉及函数计算等情况都无法使用索引。此外，即使 SQL 本身符合索引的使用条件，MySQL 也会通过评估各种查询方式的代价，来决定是否走索引，以及走哪个索引。</p>
<p>因此，在尝试通过索引进行 SQL 性能优化的时候，务必通过执行计划（<code>EXPLAIN</code>）或实际的效果来确认索引是否能有效改善性能问题，否则增加了索引不但没解决性能问题，还增加了数据库增删改的负担。如果对 EXPLAIN 给出的执行计划有疑问的话，你还可以利用 <code>optimizer_trace</code> 查看详细的执行计划做进一步分析。</p>
<h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><p><a href="https://dunwu.github.io/waterdrop/pages/fcb19c/#_5-%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">基于顿悟的MySQL索引修改</a></p>
<p><a href="https://segmentfault.com/a/1190000014906118?utm_source=sf-similar-article">https://segmentfault.com/a/1190000014906118?utm_source=sf-similar-article</a></p>
<p><a href="https://www.infoq.cn/article/ojkwyykjoyc2ygb0sj2c">https://www.infoq.cn/article/ojkwyykjoyc2ygb0sj2c</a></p>
<p><a href="https://mp.weixin.qq.com/s/sT-Jz67p8Gadvcft-iO-9g">https://mp.weixin.qq.com/s/sT-Jz67p8Gadvcft-iO-9g</a></p>
<p><a href="https://book.douban.com/subject/23008813/">https://book.douban.com/subject/23008813/</a></p>
<p><a href="https://juejin.im/post/5b55b842f265da0f9e589e79">https://juejin.im/post/5b55b842f265da0f9e589e79</a></p>
<p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>
<p><a href="https://time.geekbang.org/column/intro/139">https://time.geekbang.org/column/intro/139</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL索引</tag>
      </tags>
  </entry>
  <entry>
    <title>StarRocks(一)StarRocks简介及部署</title>
    <url>/2022/02/10/StarRocks%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>关于 Apache Doris 和 DorisDB、StarRocks 的关系</strong></p>
<p><strong>Apache</strong> Doris和DorisDB是两个不同公司的产品。DorisDB开源后改名为StarRocks。现在的StarRocks有分为免费版和企业版。</p>
<p>StarRocks官网：<a href="https://starrocks.com/zh-CN/index">StarRocks - 新一代极速全场景MPP数据库</a></p>
<h1 id="1、StarRocks简介"><a href="#1、StarRocks简介" class="headerlink" title="1、StarRocks简介"></a>1、StarRocks简介</h1><h2 id="1-1、StarRocks介绍"><a href="#1-1、StarRocks介绍" class="headerlink" title="1.1、StarRocks介绍"></a>1.1、StarRocks介绍</h2><ul>
<li><p>StarRocks是新一代极速全场景MPP数据库</p>
</li>
<li><p>StarRocks充分吸收关系型OLAP数据库和分布式存储系统在大数据时代的优秀研究成果，在业界实践的基础上，进一步改进优化、升级架构，并增添了众多全新功能，形成了全新的企业级产品。</p>
</li>
<li><p>StarRocks致力于构建极速统一分析体验，满足企业用户的多种数据分析场景，支持多种数据模型(明细模型、聚合模型、更新模型)，多种导入方式（批量和实时），可整合和接入多种现有系统(Spark、Flink、Hive、 ElasticSearch)。</p>
</li>
<li><p>StarRocks兼容MySQL协议，可使用MySQL客户端和常用BI工具对接StarRocks来进行数据分析。</p>
</li>
<li><p>StarRocks采用分布式架构，对数据表进行水平划分并以多副本存储。集群规模可以灵活伸缩，能够支持10PB级别的数据分析; 支持MPP框架，并行加速计算; 支持多副本，具有弹性容错能力。</p>
</li>
<li><p>StarRocks采用关系模型，使用严格的数据类型和列式存储引擎，通过编码和压缩技术，降低读写放大；使用向量化执行方式，充分挖掘多核CPU的并行计算能力，从而显著提升查询性能。</p>
</li>
</ul>
<h2 id="1-2、StarRocks适合什么场景"><a href="#1-2、StarRocks适合什么场景" class="headerlink" title="1.2、StarRocks适合什么场景"></a>1.2、StarRocks适合什么场景</h2><blockquote>
<p> StarRocks可以满足企业级用户的多种分析需求，包括OLAP多维分析、定制报表、实时数据分析和Ad-hoc数据分析等。具体的业务场景包括：</p>
</blockquote>
<ul>
<li>OLAP多维分析：用户行为分析、用户画像、财务报表、系统监控分析</li>
<li>实时数据分析：电商数据分析、直播质量分析、物流运单分析、广告投放分析</li>
<li>高并发查询：广告主表分析、Dashbroad多页面分析</li>
<li>统一分析：通过使用一套系统解决上述场景，降低系统复杂度和多技术栈开发成本</li>
</ul>
<h2 id="1-3、StarRocks基本概念"><a href="#1-3、StarRocks基本概念" class="headerlink" title="1.3、StarRocks基本概念"></a>1.3、StarRocks基本概念</h2><ul>
<li>FE：FrontEnd简称FE，是StarRocks的前端节点，负责管理元数据，管理客户端连接，进行查询规划，查询调度等工作。</li>
<li>BE：BackEnd简称BE，是StarRocks的后端节点，负责数据存储，计算执行，以及compaction，副本管理等工作。</li>
<li>Broker：StarRocks中和外部HDFS/对象存储等外部数据对接的中转服务，辅助提供导入导出功能。</li>
<li>StarRocksManager：StarRocks的管理工具，提供StarRocks集群管理、在线查询、故障查询、监控报警的可视化工具。</li>
<li>Tablet：StarRocks中表的逻辑分片，也是StarRocks中副本管理的基本单位，每个表根据分区和分桶机制被划分成多个Tablet存储在不同BE节点上。</li>
</ul>
<h2 id="1-4、StarRocks系统架构"><a href="#1-4、StarRocks系统架构" class="headerlink" title="1.4、StarRocks系统架构"></a>1.4、StarRocks系统架构</h2><p><img src="/img/work/2.1-1.png"></p>
<p><strong>组件介绍</strong></p>
<p>​    StarRocks集群由FE和BE构成, 可以使用MySQL客户端访问StarRocks集群。</p>
<p><strong>FE:</strong></p>
<p>FE接收MySQL客户端的连接, 解析并执行SQL语句。</p>
<ul>
<li>管理元数据, 执行SQL DDL命令, 用Catalog记录库, 表, 分区, tablet副本等信息。</li>
<li>FE高可用部署, 使用复制协议选主和主从同步元数据, 所有的元数据修改操作, 由FE leader节点完成, FE follower节点可执行读操作。 元数据的读写满足顺序一致性。  FE的节点数目采用2n+1, 可容忍n个节点故障。  当FE leader故障时, 从现有的follower节点重新选主, 完成故障切换。</li>
<li>FE的SQL layer对用户提交的SQL进行解析, 分析, 改写, 语义分析和关系代数优化, 生产逻辑执行计划。</li>
<li>FE的Planner负责把逻辑计划转化为可分布式执行的物理计划, 分发给一组BE。</li>
<li>FE监督BE, 管理BE的上下线, 根据BE的存活和健康状态, 维持tablet副本的数量。</li>
<li>FE协调数据导入, 保证数据导入的一致性。</li>
</ul>
<p><strong>BE</strong></p>
<ul>
<li>BE管理tablet副本, tablet是table经过分区分桶形成的子表, 采用列式存储。</li>
<li>BE受FE指导, 创建或删除子表。</li>
<li>BE接收FE分发的物理执行计划并指定BE coordinator节点, 在BE coordinator的调度下, 与其他BE worker共同协作完成执行。</li>
<li>BE读本地的列存储引擎获取数据,并通过索引和谓词下沉快速过滤数据。</li>
<li>BE后台执行compact任务, 减少查询时的读放大。</li>
<li>数据导入时, 由FE指定BE coordinator, 将数据以fanout的形式写入到tablet多副本所在的BE上。</li>
</ul>
<h1 id="2、手动部署"><a href="#2、手动部署" class="headerlink" title="2、手动部署"></a>2、手动部署</h1><p>2.1、下载starrocks包:<a href="https://www.starrocks.com/zh-CN/download/community">https://www.starrocks.com/zh-CN/download/community</a></p>
<p>解压包: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">tar -xzvf starrocks-2.0.1.tar.gz <br></code></pre></td></tr></table></figure>



<p>目录结构:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs she">StarRocks-XX-1.0.0<br>├── be  # BE目录<br>│   ├── bin<br>│   │   ├── start_be.sh # BE启动命令<br>│   │   └── stop_be.sh  # BE关闭命令<br>│   ├── conf<br>│   │   └── be.conf     # BE配置文件<br>│   ├── lib<br>│   │   ├── starrocks_be  # BE可执行文件<br>│   │   └── meta_tool<br>│   └── www<br>├── fe  # FE目录<br>│   ├── bin<br>│   │   ├── start_fe.sh # FE启动命令<br>│   │   └── stop_fe.sh  # FE关闭命令<br>│   ├── conf<br>│   │   └── fe.conf     # FE配置文件<br>│   ├── lib<br>│   │   ├── starrocks-fe.jar  # FE jar包<br>│   │   └── *.jar           # FE 依赖的jar包<br>│   └── webroot<br>└── udf<br></code></pre></td></tr></table></figure>



<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>准备三台物理机, 需要以下环境支持：</p>
<ul>
<li>Linux (Centos 7+)</li>
<li>Java 1.8+</li>
</ul>
<p>CPU需要支持AVX2指令集，cat /proc/cpuinfo |grep avx2有结果输出表明CPU支持，如果没有支持，建议更换机器，StarRocks使用向量化技术需要一定的指令集支持才能发挥效果。</p>
<p>将StarRocks的二进制产品包分发到目标主机的部署路径并解压，可以考虑使用新建的StarRocks用户来管理。</p>
<h2 id="部署FE"><a href="#部署FE" class="headerlink" title="部署FE"></a>部署FE</h2><h3 id="FE的基本配置"><a href="#FE的基本配置" class="headerlink" title="FE的基本配置"></a>FE的基本配置</h3><p>FE的配置文件为StarRocks-XX-1.0.0/fe/conf/fe.conf, 默认配置已经足以启动集群, 有经验的用户可以查看手册的系统配置章节, 为生产环境定制配置，为了让用户更好的理解集群的工作原理, 此处只列出基础配置。</p>
<h3 id="FE单实例部署"><a href="#FE单实例部署" class="headerlink" title="FE单实例部署"></a>FE单实例部署</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd starrocks-2.0.1/fe<br></code></pre></td></tr></table></figure>

<p>第一步: 定制配置文件conf/fe.conf：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">JAVA_OPTS = &quot;-Xmx4096m -XX:+UseMembar -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=7 -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSClassUnloadingEnabled -XX:-CMSParallelRemarkEnabled -XX:CMSInitiatingOccupancyFraction=80 -XX:SoftRefLRUPolicyMSPerMB=0 -Xloggc:$STARROCKS_HOME/log/fe.gc.log&quot;<br></code></pre></td></tr></table></figure>

<p>可以根据FE内存大小调整 -Xmx4096m，为了避免GC建议16G以上，StarRocks的元数据都在内存中保存。</p>
<p>第二步: 创建元数据目录:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mkdir -p meta (1.19.x及以前的版本需要使用mkdir -p doris-meta)<br></code></pre></td></tr></table></figure>



<p>第三步: 启动FE进程:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">bin/start_fe.sh --daemon<br></code></pre></td></tr></table></figure>



<p>第四步: 确认启动FE启动成功。</p>
<ul>
<li> 查看日志log/fe.log确认。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">2022-02-16 20:32:14,686 INFO 1 [FeServer.start():46] thrift server started.<br><br>2022-02-16 20:32:14,696 INFO 1 [NMysqlServer.start():71] Open mysql server success on 9030<br><br>2022-02-16 20:32:14,696 INFO 1 [QeService.start():60] QE service start.<br><br>2022-02-16 20:32:14,825 INFO 76 [HttpServer$HttpServerThread.run():210] HttpServer started with port 8030<br></code></pre></td></tr></table></figure>

<ul>
<li>如果FE启动失败，可能是由于端口号被占用，修改配置文件conf/fe.conf中的端口号http_port。</li>
<li>使用jps命令查看java进程确认”StarRocksFe”存在。</li>
<li>使用浏览器访问8030端口, 打开StarRocks的WebUI, 用户名为root, 密码为空。</li>
</ul>
<h3 id="使用MySQL客户端访问FE"><a href="#使用MySQL客户端访问FE" class="headerlink" title="使用MySQL客户端访问FE"></a>使用MySQL客户端访问FE</h3><p>第一步: 安装mysql客户端(如果已经安装，可忽略此步)：</p>
<p>Ubuntu：sudo apt-get install mysql-client</p>
<p>Centos：sudo yum install mysql-client</p>
<p>第二步: 使用mysql客户端连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mysql -h 127.0.0.1 -P9030 -uroot<br></code></pre></td></tr></table></figure>

<p>注意：这里默认root用户密码为空，端口为fe/conf/fe.conf中的query_port配置项，默认为9030</p>
<p>第三步: 查看FE状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">mysql&gt;</span><span class="bash"> SHOW PROC <span class="hljs-string">&#x27;/frontends&#x27;</span>\G</span><br><br>************************* 1. row ************************<br>             Name: 172.16.139.24_9010_1594200991015<br>               IP: 172.16.139.24<br>         HostName: starrocks-sandbox01<br>      EditLogPort: 9010<br>         HttpPort: 8030<br>        QueryPort: 9030<br>          RpcPort: 9020<br>             Role: FOLLOWER<br>         IsMaster: true<br>        ClusterId: 861797858<br>             Join: true<br>            Alive: true<br>ReplayedJournalId: 64<br>    LastHeartbeat: 2020-03-23 20:15:07<br>         IsHelper: true<br>           ErrMsg:<br>1 row in set (0.03 sec)<br></code></pre></td></tr></table></figure>

<p>Role为FOLLOWER说明这是一个能参与选主的FE；IsMaster为true，说明该FE当前为主节点。</p>
<p>如果MySQL客户端连接不成功，请查看log/fe.warn.log日志文件，确认问题。由于是初次启动，如果在操作过程中遇到任何意外问题，都可以删除并重新创建FE的元数据目录，再从头开始操作。</p>
<h3 id="FE的高可用集群部署"><a href="#FE的高可用集群部署" class="headerlink" title="FE的高可用集群部署"></a>FE的高可用集群部署</h3><p>FE的高可用集群采用主从复制架构, 可避免FE单点故障. FE采用了类raft的bdbje协议完成选主, 日志复制和故障切换. 在FE集群中, 多实例分为两种角色: follower和observer; 前者为复制协议的可投票成员, 参与选主和提交日志, 一般数量为奇数(2n+1), 使用多数派(n+1)确认, 可容忍少数派(n)故障; 而后者属于非投票成员, 用于异步订阅复制日志, observer的状态落后于follower, 类似其他复制协议中的learner角色。</p>
<p>FE集群从follower中自动选出master节点, 所有更改状态操作都由master节点执行, 从FE的master节点可以读到最新的状态. 更改操作可以从非master节点发起, 继而转发给master节点执行,  非master节点记录最近一次更改操作在复制日志中的LSN, 读操作可以直接在非master节点上执行, 但需要等待非master节点的状态已经同步到最近一次更改操作的LSN, 因此读写非Master节点满足顺序一致性. Observer节点能够增加FE集群的读负载能力, 时效性要求放宽的非紧要用户可以读observer节点。</p>
<p>FE节点之间的时钟相差不能超过5s, 使用NTP协议校准时间。</p>
<p>一台机器上只可以部署单个FE节点。所有FE节点的http_port需要相同。</p>
<p>集群部署按照下列步骤逐个增加FE实例。</p>
<p>第一步: 分发二进制和配置文件, 配置文件和单实例情形相同。</p>
<p>第二步: 使用MySQL客户端连接已有的FE,  添加新实例的信息，信息包括角色、ip、port：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">ADD</span> FOLLOWER &quot;host:port&quot;;<br></code></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">ADD</span> OBSERVER &quot;host:port&quot;;<br></code></pre></td></tr></table></figure>

<p>host为机器的IP，如果机器存在多个IP，需要选取priority_networks里的IP，例如priority_networks=192.168.1.0/24 可以设置使用192.168.1.x 这个子网进行通信。port为edit_log_port，默认为9010。</p>
<blockquote>
<p>StarRocks的FE和BE因为安全考虑都只会监听一个IP来进行通信，如果一台机器有多块网卡，可能StarRocks无法自动找到正确的IP，例如 ifconfig 命令能看到 eth0 ip为 192.168.1.1, docker0: 172.17.0.1 ，我们可以设置 192.168.1.0/24 这一个子网来指定使用eth0作为通信的IP，这里采用是<a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">CIDR</a>的表示方法来指定IP所在子网范围，这样可以在所有的BE，FE上使用相同的配置。 priority_networks 是 FE 和 BE 相同的配置项，写在 fe.conf 和 be.conf 中。该配置项用于在 FE 或 BE 启动时，告诉进程应该绑定哪个IP。示例如下： <code>priority_networks=10.1.3.0/24</code></p>
</blockquote>
<p>如出现错误，需要删除FE，应用下列命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">system</span> <span class="hljs-keyword">drop</span> follower &quot;fe_host:edit_log_port&quot;;<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">system</span> <span class="hljs-keyword">drop</span> observer &quot;fe_host:edit_log_port&quot;;<br></code></pre></td></tr></table></figure>

<p>具体参考<a href="https://docs.starrocks.com/zh-cn/main/administration/Scale_up_down">扩容缩容</a>。</p>
<p>第三步: FE节点之间需要两两互联才能完成复制协议选主, 投票，日志提交和复制等功能。 FE节点首次启动时，需要指定现有集群中的一个节点作为helper节点, 从该节点获得集群的所有FE节点的配置信息，才能建立通信连接，因此首次启动需要指定–helper参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./bin/start_fe.sh --helper host:port --daemon<br></code></pre></td></tr></table></figure>

<p>host为helper节点的IP，如果有多个IP，需要选取priority_networks里的IP。port为edit_log_port，默认为9010。</p>
<p>当FE再次启动时，无须指定–helper参数，因为FE已经将其他FE的配置信息存储于本地目录, 因此可直接启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./bin/start_fe.sh --daemon<br></code></pre></td></tr></table></figure>



<p>第四步: 查看集群状态, 确认部署成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">mysql&gt;</span><span class="bash"> SHOW PROC <span class="hljs-string">&#x27;/frontends&#x27;</span>\G</span><br><br>********************* 1. row **********************<br>    Name: 172.26.108.172_9010_1584965098874<br>      IP: 172.26.108.172<br>HostName: starrocks-sandbox01<br>......<br>    Role: FOLLOWER<br>IsMaster: true<br>......<br>   Alive: true<br>......<br>********************* 2. row **********************<br>    Name: 172.26.108.174_9010_1584965098874<br>      IP: 172.26.108.174<br>HostName: starrocks-sandbox02<br>......<br>    Role: FOLLOWER<br>IsMaster: false<br>......<br>   Alive: true<br>......<br>********************* 3. row **********************<br>    Name: 172.26.108.175_9010_1584965098874<br>      IP: 172.26.108.175<br>HostName: starrocks-sandbox03<br>......<br>    Role: FOLLOWER<br>IsMaster: false<br>......<br>   Alive: true<br>......<br>3 rows in set (0.05 sec)<br></code></pre></td></tr></table></figure>

<p>节点的Alive显示为true则说明添加节点成功。以上例子中，</p>
<p>172.26.108.172_9010_1584965098874 为主FE节点。</p>
<h2 id="部署BE"><a href="#部署BE" class="headerlink" title="部署BE"></a>部署BE</h2><h3 id="BE的基本配置"><a href="#BE的基本配置" class="headerlink" title="BE的基本配置"></a>BE的基本配置</h3><p>BE的配置文件为StarRocks-2.0.1/be/conf/be.conf, 默认配置已经足以启动集群, 不建议初尝用户修改配置, 有经验的用户可以查看手册的系统配置章节, 为生产环境定制配置. 为了让用户更好的理解集群的工作原理, 此处只列出基础配置。</p>
<h3 id="BE部署"><a href="#BE部署" class="headerlink" title="BE部署"></a>BE部署</h3><p>用户可使用下面命令添加BE到StarRocks集群, 一般至少部署3个BE实例, 每个实例的添加步骤相同。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd StarRocks-2.0.1/be<br></code></pre></td></tr></table></figure>

<p>第一步: 创建数据目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mkdir -p storage<br></code></pre></td></tr></table></figure>

<p>第二步: 通过mysql客户端添加BE节点：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">ADD</span> BACKEND &quot;host:port&quot;;<br></code></pre></td></tr></table></figure>

<p>这里IP地址为和priority_networks设置匹配的IP，portheartbeat_service_port，默认为9050</p>
<p>如出现错误，需要删除BE节点，应用下列命令：</p>
<ul>
<li><code>alter system decommission backend &quot;be_host:be_heartbeat_service_port&quot;;</code></li>
</ul>
<p>具体参考<a href="https://docs.starrocks.com/zh-cn/main/administration/Scale_up_down">扩容缩容</a>。</p>
<p>第三步: 启动BE：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">bin/start_be.sh --daemon<br></code></pre></td></tr></table></figure>

<p>第四步: 查看BE状态, 确认BE就绪:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">mysql&gt;</span><span class="bash"> SHOW PROC <span class="hljs-string">&#x27;/backends&#x27;</span>\G</span><br><br>********************* 1. row **********************<br>            BackendId: 10002<br>              Cluster: default_cluster<br>                   IP: 172.16.139.24<br>             HostName: starrocks-sandbox01<br>        HeartbeatPort: 9050<br>               BePort: 9060<br>             HttpPort: 8040<br>             BrpcPort: 8060<br>        LastStartTime: 2020-03-23 20:19:07<br>        LastHeartbeat: 2020-03-23 20:34:49<br>                Alive: true<br> SystemDecommissioned: false<br>ClusterDecommissioned: false<br>            TabletNum: 0<br>     DataUsedCapacity: .000<br>        AvailCapacity: 327.292 GB<br>        TotalCapacity: 450.905 GB<br>              UsedPct: 27.41 %<br>       MaxDiskUsedPct: 27.41 %<br>               ErrMsg:<br>              Version:<br>1 row in set (0.01 sec)<br></code></pre></td></tr></table></figure>

<p>如果isAlive为true，则说明BE正常接入集群。如果BE没有正常接入集群，请查看log目录下的be.WARNING日志文件确定原因。</p>
<p>如果日志中出现类似以下的信息，说明priority_networks的配置存在问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">W0708 17:16:27.308156 11473 heartbeat\_server.cpp:82\] backend ip saved in master does not equal to backend local ip127.0.0.1 vs. 172.16.179.26<br></code></pre></td></tr></table></figure>

<p>此时需要，先用以下命令drop掉原来加进去的be，然后重新以正确的IP添加BE。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> DROPP BACKEND &quot;172.16.139.24:9050&quot;;<br></code></pre></td></tr></table></figure>

<p>由于是初次启动，如果在操作过程中遇到任何意外问题，都可以删除并重新创建storage目录，再从头开始操作。</p>
<h2 id="部署Broker"><a href="#部署Broker" class="headerlink" title="部署Broker"></a>部署Broker</h2><p>配置文件为apache_hdfs_broker/conf/apache_hdfs_broker.conf</p>
<blockquote>
<p>注意：Broker没有也不需要priority_networks参数，Broker的服务默认绑定在0.0.0.0上，只需要在ADD BROKER时，填写正确可访问的Broker IP即可。</p>
</blockquote>
<p>如果有特殊的hdfs配置，复制线上的hdfs-site.xml到conf目录下</p>
<p>启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./apache_hdfs_broker/bin/start_broker.sh --daemon<br></code></pre></td></tr></table></figure>

<p>添加broker节点到集群中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">MySQL<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">ADD</span> BROKER broker1 &quot;172.16.139.24:8000&quot;;<br></code></pre></td></tr></table></figure>

<p>查看broker状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">MySQL&gt; SHOW PROC &quot;/brokers&quot;\G<br>*************************** 1. row ***************************<br>          Name: broker1<br>            IP: 172.16.139.24<br>          Port: 8000<br>         Alive: true<br> LastStartTime: 2020-04-01 19:08:35<br>LastUpdateTime: 2020-04-01 19:08:45<br>        ErrMsg: <br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure>

<p>Alive为true代表状态正常。</p>
]]></content>
      <categories>
        <category>数据处理</category>
        <category>StarRocks</category>
      </categories>
      <tags>
        <tag>StarRocks</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM类加载子系统</title>
    <url>/2022/07/11/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/img/work/1656939084149.png"></p>
<h2 id="1-类加载机制概念"><a href="#1-类加载机制概念" class="headerlink" title="1. 类加载机制概念"></a>1. 类加载机制概念</h2><p><strong>Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的加载机制</strong>。Class 文件由类装载器装载后，在 JVM 中将形成一份描述 Class 结构的元信息对象，通过该元信息对象可以获知 Class 的结构信息：如构造函数，属性和方法等，Java 允许用户借由这个 Class 相关的元信息对象间接调用 Class 对象的功能，这里就是我们经常能见到的 Class 类。 </p>
<h2 id="2-类加载子系统作用"><a href="#2-类加载子系统作用" class="headerlink" title="2. 类加载子系统作用"></a>2. 类加载子系统作用</h2><ul>
<li>类加载子系统负责从文件系统或者网络中加载 class 文件，class 文件在文件开头有特定的文件标识（0xCAFEBABE）</li>
<li>ClassLoader 只负责 class 文件的加载。至于它是否可以运行，则由 Execution Engine 决定</li>
<li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是class文件中常量池部分的内存映射）</li>
<li>Class 对象是存放在堆区的</li>
</ul>
<h2 id="3-类加载器-ClassLoader-角色"><a href="#3-类加载器-ClassLoader-角色" class="headerlink" title="3. 类加载器 ClassLoader 角色"></a>3. 类加载器 ClassLoader 角色</h2><ol>
<li>class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到 JVM 当中来根据这个文件实例化出 n 个一模一样的实例</li>
<li>class file 加载到 JVM 中，被称为 DNA 元数据模板，放在方法区</li>
<li>在 .calss 文件 -&gt; JVM -&gt; 最终成为元数据模板，此过程就要一个运输工具（类装载器），扮演一个快递员的角色</li>
</ol>
<h2 id="4-类的生命周期"><a href="#4-类的生命周期" class="headerlink" title="4. 类的生命周期"></a>4. 类的生命周期</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：<strong>加载、验证、准备、解析、初始化、使用和卸载</strong>七个阶段。(验证、准备和解析又统称为连接，为了支持 Java 语言的<strong>运行时绑定</strong>，所以<strong>解析阶段也可以是在初始化之后进行的</strong>。以上顺序都只是说开始的顺序，实际过程中是交叉的混合式进行的，加载过程中可能就已经开始验证了) </p>
<p><img src="/img/work/1656941430035.png"></p>
<h3 id="4-1-加载-Loading-查找并加载类的二进制数据"><a href="#4-1-加载-Loading-查找并加载类的二进制数据" class="headerlink" title="4.1 加载(Loading): 查找并加载类的二进制数据"></a>4.1 加载(Loading): 查找并加载类的二进制数据</h3><ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流（简单点说就是找到文件系统中/jar 包中/或存在于任何地方的“<code>class 文件</code>”。 如果找不到二进制表示形式，则会抛出 <code>NoClassDefFound</code> 错误。）</li>
<li>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构</li>
<li><strong>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象</strong>，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p><img src="/img/work/1656943479793.png"></p>
<p>相对于类加载的其他阶段而言，<em>加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段</em>，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。 </p>
<p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个<code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。 </p>
<p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p>
<p><strong>加载 <code>.class</code> 文件的方式</strong> </p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络获取，典型场景：Web Applet</li>
<li>从 zip 压缩文件中读取，成为日后 jar、war 格式的基础</li>
<li>运行时计算生成，使用最多的是：动态代理技术</li>
<li>由其他文件生成，比如 JSP 应用</li>
<li>从专有数据库提取 .class 文件，比较少见</li>
<li>从加密文件中获取，典型的防 Class 文件被反编译的保护措施</li>
</ul>
<h3 id="4-2-连接-Linking"><a href="#4-2-连接-Linking" class="headerlink" title="4.2 连接(Linking)"></a>4.2 连接(Linking)</h3><h4 id="4-2-1-验证-Verify-确保被加载的类的正确性"><a href="#4-2-1-验证-Verify-确保被加载的类的正确性" class="headerlink" title="4.2.1  验证(Verify): 确保被加载的类的正确性"></a>4.2.1  验证(Verify): 确保被加载的类的正确性</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作: </p>
<ul>
<li> <code>文件格式验证</code>: 验证字节流是否符合Class文件格式的规范；例如: 是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。这些检查过程中可能会抛出 <code>VerifyError</code>， <code>ClassFormatError</code> 或 <code>UnsupportedClassVersionError</code>。 </li>
<li><code>元数据验证</code>:  对字节码描述的信息进行语义分析(注意: 对比<code>javac</code>编译阶段的语义分析),  以保证其描述的信息符合Java语言规范的要求; 如果类层次结构有问题（例如，该类是自己的超类或接口,死循环了），则 JVM 将抛出 <code>ClassCircularityError</code>。 而如果实现的接口并不是一个 interface，或者声明的超类是一个 interface，也会抛出 <code>IncompatibleClassChangeError</code>。 </li>
<li><code>字节码验证</code>: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 </li>
<li><code>符号引用验证</code>: 确保解析动作能正确执行。 </li>
</ul>
<blockquote>
<p> 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 </p>
</blockquote>
<h4 id="4-2-2-准备-Prepare"><a href="#4-2-2-准备-Prepare" class="headerlink" title="4.2.2 准备(Prepare)"></a>4.2.2 准备(Prepare)</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong>。对于该阶段有以下几点需要注意: </p>
<ul>
<li>这时候进行内存分配的仅包括类变量(<code>static</code>)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li>
<li> 这里所设置的初始值通常情况下是数据类型默认的零值(如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等)，而不是被在Java代码中被显式地赋予的值。 </li>
</ul>
<p>以下为零值对应的类型</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>零值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<p>假设一个类变量的定义为: <code>public static int value = 3</code>；那么变量value在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何Java方法，而把value赋值为3的<code>put static</code>指令是在程序编译后，存放于类构造器<code>()</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p>
<blockquote>
<p> 这里还需要注意如下几点 </p>
</blockquote>
<ul>
<li>对基本数据类型来说，对于类变量(static)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型<code>reference</code>来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。</li>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
<li>如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。假设上面的类变量value被定义为: <code>public static final int value = 3；</code>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为<code>static final</code>常量在编译期就将其结果放入了调用它的类的常量池中</li>
</ul>
<h4 id="4-2-3-解析（Resolve）"><a href="#4-2-3-解析（Resolve）" class="headerlink" title="4.2.3 解析（Resolve）"></a>4.2.3 解析（Resolve）</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点</code>限定符7类符号引用进行。对应常量池中的<code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code>等 </p>
<ul>
<li><p>符号引用就是一组符号来描述目标， 符号引用的字面量形式明确定义在《Java虚拟机规范》的 Class文件格式中 。</p>
</li>
<li><p><code>直接引用</code>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。（如果有了直接引用，那引用的目标必定在堆中存在）  </p>
</li>
</ul>
<h3 id="4-3-初始化（Initialization）"><a href="#4-3-初始化（Initialization）" class="headerlink" title="4.3 初始化（Initialization）"></a>4.3 初始化（Initialization）</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。JVM 规范明确规定, 必须在类的首次“主动使用”时才能执行类初始化。  </p>
<p>初始化的过程包括执行： </p>
<ul>
<li>类构造器方法</li>
<li>static 静态变量赋值语句</li>
<li>static 静态代码块</li>
</ul>
<p>如果是一个子类进行初始化会先对其父类进行初始化，保证其父类在子类之前进行初始化。所以其实在 java 中初始化一个类，那么必然先初始化过 <code>java.lang.Object</code> 类，因为所有的 java 类都继承自 java.lang.Object。 </p>
<blockquote>
<p>初始化阶段就是执行<strong>类构造器方法</strong> <code> &lt;clinit&gt; ()</code> 的过程,此方法不需要定义，是 javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。构造器方法中指令按语句在源文件中出现的顺序执行<code>&lt;clinit&gt;()</code>  不同于类的构造器（构造器是虚拟机视角下的 <code> &lt;init&gt; ()</code>）,若该类具有父类，JVM 会保证子类的 <code> &lt;init&gt; ()</code> 执行前，父类的 <code>&lt;init&gt;()</code> 已经执行完毕,虚拟机必须保证一个类的 <code>&lt;init&gt;()</code> 方法在多线程下被同步加锁</p>
</blockquote>
<p>例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassInitTest</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">30</span>;<br>  <span class="hljs-keyword">static</span>&#123;<br>    num1 = <span class="hljs-number">10</span>;<br>    num2 = <span class="hljs-number">10</span>;     <span class="hljs-comment">//num2写在定义变量之前，为什么不会报错呢？？</span><br>    System.out.println(num2);   <span class="hljs-comment">//這裡直接打印可以吗？ 报错，非法的前向引用，可以赋值，但不可调用</span><br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num2 = <span class="hljs-number">20</span>;  <span class="hljs-comment">//num2在准备阶段就被设置了默认初始值0，初始化阶段又将10改为20</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    System.out.println(num1);  <span class="hljs-comment">//10</span><br>    System.out.println(num2);   <span class="hljs-comment">//20</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-类加载时机"><a href="#5-类加载时机" class="headerlink" title="5. 类加载时机"></a>5. 类加载时机</h2><h4 id="5-1-Java类何时会被加载"><a href="#5-1-Java类何时会被加载" class="headerlink" title="5.1 Java类何时会被加载"></a>5.1 Java类何时会被加载</h4><p>Java 程序对类的使用方式分为：主动使用和被动使用。虚拟机规范规定<strong>有且只有 5 种情况必须立即对类进行“初始化”</strong>，即类的主动使用。</p>
<ul>
<li>创建类的实例、访问某个类或接口的静态变量，或者对该静态变量赋值、调用类的静态方法（即遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code> 这四条字节码指令时）</li>
<li>反射</li>
<li>初始化一个类的子类</li>
<li>Java 虚拟机启动时被标明为启动类的类</li>
<li>JDK7 开始提供的动态语言支持：<code>java.lang.invoke.MethodHandle</code> 实例的解析结果，<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code> 句柄对应的类没有初始化，则初始化</li>
</ul>
<p><strong>JVM 规范枚举了下述多种触发初始化情况：</strong></p>
<ul>
<li>当虚拟机启动时，初始化用户指定的主类，就是启动执行的 main 方法所在的类；</li>
<li>当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类，就是 new 一个类的时候要初始化；</li>
<li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li>
<li>子类的初始化会触发父类的初始化；</li>
<li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；</li>
<li>使用反射 API 对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射调用要么是已经有实例了，要么是静态方法，都需要初始化；</li>
<li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</li>
</ul>
<p><strong>同时以下几种情况不会执行类初始化：</strong></p>
<ul>
<li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li>
<li>定义对象数组，不会触发该类的初始化。</li>
<li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</li>
<li>通过类名获取 Class 对象，不会触发类的初始化，Hello.class 不会让 Hello 类初始化。</li>
<li>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。Class.forName(“jvm.Hello”)默认会加载 Hello 类。</li>
<li>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作（加载了，但是不初始化）。</li>
</ul>
<p>示例: 诸如 Class.forName(), classLoader.loadClass() 等 Java API, 反射API, 以及 JNI_FindClass 都可以启动类加载。 JVM 本身也会进行类加载。 比如在 JVM 启动时加载核心类，java.lang.Object, java.lang.Thread 等等。</p>
<p> <strong>eg:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotInitialization</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <br>        <span class="hljs-comment">//只输出SupperClass int 123,不会输出SubClass init</span><br>        <span class="hljs-comment">//对于静态字段，只有直接定义这个字段的类才会被初始化</span><br>        System.out.println(SubClass.value); <br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperClass</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;SupperClass init&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">123</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperClass</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;SubClass init&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6-类加载器"><a href="#6-类加载器" class="headerlink" title="6. 类加载器"></a>6. 类加载器</h2><ul>
<li>JVM 支持两种类型的类加载器，分别为<strong>引导类加载器</strong>（Bootstrap ClassLoader）和<strong>自定义类加载器</strong>（User-Defined ClassLoader）</li>
<li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器</li>
</ul>
<p>系统自带的类加载器分为三种：</p>
<ul>
<li>启动类加载器（BootstrapClassLoader）</li>
<li>扩展类加载器（ExtClassLoader）</li>
<li>应用类加载器（AppClassLoader）</li>
</ul>
<p>一般启动类加载器是由 JVM 内部实现的，在 Java 的 API 里无法拿到，但是我们可以侧面看到和影响它。后 2 种类加载器在 Oracle Hotspot JVM 里，都是在中<code>sun.misc.Launcher</code>定义的，扩展类加载器和应用类加载器一般都继承自<code>URLClassLoader</code>类，这个类也默认实现了从各种不同来源加载 class 字节码转换成 Class 的方法。</p>
<p><img src="/img/work/image-20220707172105603.png"></p>
<p>不同类加载器看似是继承(Inheritance)关系，实际是采用组合关系来复用父类加载器的相关代码</p>
<h4 id="6-1-启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#6-1-启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="6.1 启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>6.1 启动类加载器（引导类加载器，Bootstrap ClassLoader）</h4><ul>
<li>这个类加载使用 C/C++ 语言实现，嵌套在 JVM 内部</li>
<li>它用来加载 Java 的核心库（<code>JAVA_HOME/jre/lib/rt.jar</code>、<code>resource.jar</code>或<code>sun.boot.class.path</code>路径下的内容），用于提供 JVM 自身需要的类</li>
<li>并不继承自 <code>java.lang.ClassLoader</code>，没有父加载器</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</li>
<li>出于安全考虑，Bootstrap 启动类加载器只加载名为 java、Javax、sun 等开头的类</li>
</ul>
<h4 id="6-2-扩展类加载器（Extension-ClassLoader）"><a href="#6-2-扩展类加载器（Extension-ClassLoader）" class="headerlink" title="6.2 扩展类加载器（Extension ClassLoader）"></a>6.2 扩展类加载器（Extension ClassLoader）</h4><ul>
<li>Java 语言编写，由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现</li>
<li>派生于 ClassLoader</li>
<li>父类加载器为启动类加载器</li>
<li>从 <code>java.ext.dirs</code> 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 <code>jre/lib/ext</code> 子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载</li>
</ul>
<h4 id="6-3-应用程序类加载器（也叫系统类加载器，AppClassLoader）"><a href="#6-3-应用程序类加载器（也叫系统类加载器，AppClassLoader）" class="headerlink" title="6.3 应用程序类加载器（也叫系统类加载器，AppClassLoader）"></a>6.3 应用程序类加载器（也叫系统类加载器，AppClassLoader）</h4><ul>
<li>Java 语言编写，由 <code>sun.misc.Lanucher$AppClassLoader</code> 实现</li>
<li>派生于 ClassLoader</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量 <code>classpath</code> 或系统属性 <code>java.class.path</code> 指定路径下的类库</li>
<li>该类加载是<strong>程序中默认的类加载器</strong>，一般来说，Java 应用的类都是由它来完成加载的</li>
<li>通过 <code>ClassLoader#getSystemClassLoader()</code> 方法可以获取到该类加载器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoaderTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//获取系统类加载器</span><br>        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();<br>        System.out.println(systemClassLoader);  <span class="hljs-comment">//sun.misc.Launcher$AppClassLoader@135fbaa4</span><br><br>        <span class="hljs-comment">//获取其上层：扩展类加载器</span><br>        ClassLoader extClassLoader = systemClassLoader.getParent();<br>        System.out.println(extClassLoader);  <span class="hljs-comment">//sun.misc.Launcher$ExtClassLoader@2503dbd3</span><br><br>        <span class="hljs-comment">//再获取其上层：获取不到引导类加载器</span><br>        ClassLoader bootstrapClassLoader = extClassLoader.getParent();<br>        System.out.println(bootstrapClassLoader);     <span class="hljs-comment">//null</span><br><br>        <span class="hljs-comment">//对于用户自定义类来说，默认使用系统类加载器进行加载，输出和systemClassLoader一样</span><br>        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();<br>        System.out.println(classLoader);  <span class="hljs-comment">//sun.misc.Launcher$AppClassLoader@135fbaa4</span><br><br>        <span class="hljs-comment">//String 类使用引导类加载器进行加载。Java的核心类库都使用引导类加载器进行加载，所以也获取不到</span><br>        ClassLoader classLoader1 = String.class.getClassLoader();<br>        System.out.println(classLoader1);  <span class="hljs-comment">//null</span><br><br>        <span class="hljs-comment">//获取BootstrapClassLoader可以加载的api的路径</span><br>        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();<br>        <span class="hljs-keyword">for</span> (URL url : urls) &#123;<br>            System.out.println(url.toExternalForm());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-4-用户自定义类加载器"><a href="#6-4-用户自定义类加载器" class="headerlink" title="6.4 用户自定义类加载器"></a>6.4 用户自定义类加载器</h4><p>在 Java 的日常应用程序开发中，类的加载几乎是由 3 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式</p>
<blockquote>
<p>如果用户自定义了类加载器，则自定义类加载器都以应用类加载器作为父加载器。应用类加载器的父类加载器为扩展类加载器。这些类加载器是有层次关系的，启动加载器又叫根加载器，是扩展加载器的父加载器，但是直接从 ExClassLoader 里拿不到它的引用，同样会返回 null。</p>
</blockquote>
<p><strong>为什么要自定义类加载器？</strong></p>
<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源（可以从数据库、云端等指定来源加载类）</li>
<li>防止源码泄露（Java 代码容易被反编译，如果加密后，自定义加载器加载类的时候就可以先解密，再加载）</li>
</ul>
<p><strong>用户自定义加载器实现步骤</strong></p>
<ol>
<li>开发人员可以通过继承抽象类 <code>java.lang.ClassLoader</code> 类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在 JDK1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载类，但是 JDK1.2 之后已经不建议用户去覆盖 <code>loadClass()</code> 方式，而是建议把自定义的类加载逻辑写在 <code>findClass()</code> 方法中</li>
<li> 编写自定义类加载器时, 如果没有太过于复杂的需求, 可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁 </li>
</ol>
<p><strong>eg</strong>: </p>
<p>比如我们试着实现一个可以用来处理简单加密的字节码的类加载器，用来保护我们的 class 字节码文件不被使用者直接拿来破解 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello Class Initialized!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个 Hello 类非常简单，就是在自己被初始化的时候，打印出来一句“Hello Class Initialized!”。假设这个类的内容非常重要，我们不想把编译到得到的 Hello.class 给别人，但是我们还是想别人可以调用或执行这个类，应该怎么办呢？一个简单的思路是，我们把这个类的 class 文件二进制作为字节流先加密一下，然后尝试通过自定义的类加载器来加载加密后的数据。为了演示简单，我们使用 jdk 自带的 Base64 算法，把字节码加密成一个文本。在下面这个例子里，我们实现一个 HelloClassLoader，它继承自 ClassLoader 类，但是我们希望它通过我们提供的一段 Base64 字符串，来还原出来，并执行我们的 Hello 类里的打印一串字符串的逻辑。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">new</span> HelloClassLoader().findClass(<span class="hljs-string">&quot;jvm.Hello&quot;</span>).newInstance(); <span class="hljs-comment">// 加载并初始化Hello类</span><br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br><br>        String helloBase64 = <span class="hljs-string">&quot;yv66vgAAADQAHwoABgARCQASABMIABQKABUAFgcAFwcAGAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQALTGp2bS9IZWxsbzsBAAg8Y2xpbml0PgEAClNvdXJjZUZpbGUBAApIZWxsby5qYXZhDAAHAAgHABkMABoAGwEAGEhlbGxvIENsYXNzIEluaXRpYWxpemVkIQcAHAwAHQAeAQAJanZtL0hlbGxvAQAQamF2YS9sYW5nL09iamVjdAEAEGphdmEvbGFuZy9TeXN0ZW0BAANvdXQBABVMamF2YS9pby9QcmludFN0cmVhbTsBABNqYXZhL2lvL1ByaW50U3RyZWFtAQAHcHJpbnRsbgEAFShMamF2YS9sYW5nL1N0cmluZzspVgAhAAUABgAAAAAAAgABAAcACAABAAkAAAAvAAEAAQAAAAUqtwABsQAAAAIACgAAAAYAAQAAAAMACwAAAAwAAQAAAAUADAANAAAACAAOAAgAAQAJAAAAJQACAAAAAAAJsgACEgO2AASxAAAAAQAKAAAACgACAAAABgAIAAcAAQAPAAAAAgAQ&quot;</span>;<br><br>        <span class="hljs-keyword">byte</span>[] bytes = decode(helloBase64);<br>        <span class="hljs-keyword">return</span> defineClass(name,bytes,<span class="hljs-number">0</span>,bytes.length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] decode(String base64)&#123;<br>        <span class="hljs-keyword">return</span> Base64.getDecoder().decode(base64);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>直接执行这个类： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">java jvm.HelloClassLoader Hello Class Initialized!<br></code></pre></td></tr></table></figure>

<h4 id="6-5-ClassLoader-常用方法"><a href="#6-5-ClassLoader-常用方法" class="headerlink" title="6.5 ClassLoader 常用方法"></a>6.5 ClassLoader 常用方法</h4><p>ClassLoader 类，是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器） </p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getParent()</td>
<td>返回该类加载器的超类加载器</td>
</tr>
<tr>
<td>loadClass(String name)</td>
<td>加载名称为name的类，返回java.lang.Class类的实例</td>
</tr>
<tr>
<td>findClass(String name)</td>
<td>查找名称为name的类，返回java.lang.Class类的实例</td>
</tr>
<tr>
<td>findLoadedClass(String name)</td>
<td>查找名称为name的已经被加载过的类，返回java.lang.Class类的实例</td>
</tr>
<tr>
<td>defineClass(String name, byte[] b, int off, int len)</td>
<td>把字节数组b中内容转换为一个Java类，返回java.lang.Class类的实例</td>
</tr>
<tr>
<td>resolveClass(Class&lt;?&gt; c)</td>
<td>连接指定的一个Java类</td>
</tr>
</tbody></table>
<h4 id="6-6-对类加载器的引用"><a href="#6-6-对类加载器的引用" class="headerlink" title="6.6 对类加载器的引用"></a>6.6 对类加载器的引用</h4><p>JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么 JVM 会<strong>将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。 </p>
<h2 id="7-双亲委派机制"><a href="#7-双亲委派机制" class="headerlink" title="7. 双亲委派机制"></a>7. 双亲委派机制</h2><p>Java 虚拟机对 class 文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类的时候才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是双亲委派模式，即把请求交给父类处理，它是一种任务委派模式。</p>
<p>【示例】寻找类加载示例 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ClassLoader loader = Thread.currentThread().getContextClassLoader();<br>    System.out.println(loader);<br>    System.out.println(loader.getParent());<br>    System.out.println(loader.getParent().getParent());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">sun.misc.Launcher$AppClassLoader@18b4aac2<br>sun.misc.Launcher$ExtClassLoader@19e1023e<br>null<br></code></pre></td></tr></table></figure>

<p>从上面的结果可以看出，并没有获取到 <code>ExtClassLoader</code> 的父 Loader，原因是 <code>Bootstrap Loader</code>（引导类加载器）是用 C 语言实现的，找不到一个确定的返回父 Loader 的方式，于是就返回 null。 </p>
<h3 id="7-1-工作过程"><a href="#7-1-工作过程" class="headerlink" title="7.1 工作过程"></a>7.1 工作过程</h3><ul>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式</li>
</ul>
<p><img src="/img/work/1657545214711.png"></p>
<h3 id="7-2-优势"><a href="#7-2-优势" class="headerlink" title="7.2 优势"></a>7.2 优势</h3><ul>
<li><strong>避免类的重复加载</strong>：JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就属于两个不同的类(比如,Java中的Object类 ,无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，如果不采用双亲委派模型，由各个类加载器自己去加载的话，系统中会存在多种不同的 Object 类)</li>
<li><strong>保护程序安全，防止核心 API 被随意篡改</strong>: 避免用户自己编写的类动态替换 Java 的一些核心类，比如我们自定义类：<code>java.lang.String</code>      </li>
</ul>
<p>在 JVM 中表示两个 class 对象是否为同一个类存在两个必要条件： </p>
<ul>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的 ClassLoader（指ClassLoader实例对象）必须相同</li>
</ul>
<h3 id="7-3-沙箱安全机制"><a href="#7-3-沙箱安全机制" class="headerlink" title="7.3 沙箱安全机制"></a>7.3 沙箱安全机制</h3><p>如果我们自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件（rt.jar包中 <code>java\lang\String.class</code>），报错信息说没有 main 方法就是因为加载的是<code>rt.jar</code>包中的 String 类。这样就可以保证对 java 核心源代码的保护，这就是简单的沙箱安全机制。 </p>
<h3 id="7-4-破坏双亲委派模型"><a href="#7-4-破坏双亲委派模型" class="headerlink" title="7.4 破坏双亲委派模型"></a>7.4 破坏双亲委派模型</h3><ul>
<li>双亲委派模型并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的类加载器实现方式，可以“被破坏”，只要我们自定义类加载器，<strong>重写 <code>loadClass()</code> 方法</strong>，指定新的加载逻辑就破坏了，重写 <code>findClass()</code> 方法不会破坏双亲委派。</li>
<li> 双亲委派模型有一个问题：顶层 ClassLoader，无法加载底层 ClassLoader 的类。典型例子 JNDI、JDBC，所以加入了线程上下文类加载器(Thread Context ClassLoader),可以通过<code>Thread.setContextClassLoaser()</code> 设置该类加载器，然后顶层ClassLoader 再使用<code>Thread.getContextClassLoader()</code> 获得底层的 ClassLoader 进行加载。       </li>
<li> Tomcat 中使用了自定 ClassLoader，并且也破坏了双亲委托机制。每个应用使用 WebAppClassloader 进行单独加载，他首先使用 WebAppClassloader 进行类加载，如果加载不了再委托父加载器去加载，这样可以保证每个应用中的类不冲突。每个 tomcat 中可以部署多个项目，每个项目中存在很多相同的 class 文件（很多相同的jar包），他们加载到 jvm 中可以做到互不干扰。 </li>
</ul>
<p><img src="/img/work/1657546743314.png"></p>
<ul>
<li>利用破坏双亲委派来实现<strong>代码热替换</strong>（每次修改类文件，不需要重启服务）。因为一个 Class 只能被一个 ClassLoader 加载一次，否则会报 <code>java.lang.LinkageError</code>。当我们想要实现代码热部署时，可以每次都 new 一个自定义的 ClassLoader 来加载新的 Class文件。JSP 的实现动态修改就是使用此特性实现。</li>
</ul>
<h2 id="8-类的加载"><a href="#8-类的加载" class="headerlink" title="8.类的加载"></a>8.类的加载</h2><h3 id="8-1-类加载方式"><a href="#8-1-类加载方式" class="headerlink" title="8.1 类加载方式"></a>8.1 类加载方式</h3><p>类加载有三种方式： </p>
<ul>
<li>命令行启动应用时候由 JVM 初始化加载</li>
<li>通过 <code>Class.forName()</code> 方法动态加载</li>
<li>通过 <code>ClassLoader.loadClass()</code> 方法动态加载</li>
</ul>
<p><strong><code>Class.forName()</code> 和 <code>ClassLoader.loadClass()</code> 区别</strong> </p>
<ul>
<li><code>Class.forName()</code> 将类的 <code>.class</code> 文件加载到 jvm 中之外，还会对类进行解释，执行类中的 <code>static</code> 块；</li>
<li><code>ClassLoader.loadClass()</code> 只干一件事情，就是将 <code>.class</code> 文件加载到 jvm 中，不会执行 <code>static</code> 中的内容，只有在 <code>newInstance</code> 才会去执行 <code>static</code> 块。</li>
<li><code>Class.forName(name, initialize, loader)</code> 带参函数也可控制是否加载 <code>static</code> 块。并且只有调用了 <code>newInstance()</code> 方法采用调用构造函数，创建类的对象 。</li>
</ul>
<h3 id="8-2-加载类错误"><a href="#8-2-加载类错误" class="headerlink" title="8.2 加载类错误"></a>8.2 加载类错误</h3><p><strong>ClassNotFoundException</strong></p>
<p><code>ClassNotFoundException</code> 异常出镜率极高。**<code>ClassNotFoundException</code> 表示当前 <code>classpath</code> 下找不到指定类**。 </p>
<p>常见问题原因： </p>
<ul>
<li>调用 <code>Class</code> 的 <code>forName()</code> 方法，未找到类。</li>
<li>调用 <code>ClassLoader</code> 中的 <code>loadClass()</code> 方法，未找到类。</li>
<li>调用 <code>ClassLoader</code> 中的 <code>findSystemClass()</code> 方法，未找到类。</li>
</ul>
<p>【示例】执行以下代码，会抛出 <code>ClassNotFoundException</code> 异常： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassNotFoundExceptionDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class.forName(<span class="hljs-string">&quot;NotFound&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解决方法：检查 <code>classpath</code> 下有没有相应的 class 文件。 </p>
<p><strong>NoClassDefFoundError</strong></p>
<p>常见问题原因： </p>
<ul>
<li>类依赖的 Class 或者 jar 不存在。</li>
<li>类文件存在，但是存在不同的域中。</li>
</ul>
<p>解决方法: 现在Java  项目，一般使用 <code>maven</code>、<code>gradle</code> 等构建工具管理项目，仔细检查找不到的类所在的 jar 包是否已添加为依赖。 </p>
<p><strong>UnsatisfiedLinkError</strong></p>
<p>这个异常倒不是很常见，但是出错的话，通常是在 JVM 启动的时候如果一不小心将在 JVM 中的某个 lib 删除了，可能就会报这个错误了。 </p>
<p> 【示例】执行以下代码，会抛出 <code>UnsatisfiedLinkError</code> 错误 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsatisfiedLinkErrorDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nativeMethod</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.loadLibrary(<span class="hljs-string">&quot;NoLib&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> UnsatisfiedLinkErrorDemo().nativeMethod();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p> 【输出】 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">java.lang.UnsatisfiedLinkError: no NoLib in java.library.path<br>	at java.lang.ClassLoader.loadLibrary(ClassLoader.java:<span class="hljs-number">1867</span>)<br>	at java.lang.Runtime.loadLibrary0(Runtime.java:<span class="hljs-number">870</span>)<br>	at java.lang.System.loadLibrary(System.java:<span class="hljs-number">1122</span>)<br>	at io.github.dunwu.javacore.jvm.classloader.exception.UnsatisfiedLinkErrorDemo.&lt;clinit&gt;(UnsatisfiedLinkErrorDemo.java:<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure>

<p><strong>ClassCastException</strong></p>
<p> <code>ClassCastException</code> 异常通常是在程序中强制类型转换失败时出现。 </p>
<p> 【示例】执行以下代码，会抛出 <code>ClassCastException</code> 异常。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassCastExceptionDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Object obj = <span class="hljs-keyword">new</span> Object();<br>        EmptyClass newObj = (EmptyClass) obj;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmptyClass</span> </span>&#123;&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>【输出】 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ClassCastException: java.lang.Object cannot be cast to io.github.dunwu.javacore.jvm.classloader.exception.ClassCastExceptionDemo$EmptyClass<br>	at io.github.dunwu.javacore.jvm.classloader.exception.ClassCastExceptionDemo.main(ClassCastExceptionDemo.java:<span class="hljs-number">11</span>)<br></code></pre></td></tr></table></figure>

<h2 id="9-如何替换-JDK-的类"><a href="#9-如何替换-JDK-的类" class="headerlink" title="9.如何替换 JDK 的类"></a>9.如何替换 JDK 的类</h2><p>如何替换 JDK 中的类？比如，我们现在就拿 HashMap为例。 </p>
<p>当 Java 的原生 API 不能满足需求时，比如我们要修改 HashMap 类，就必须要使用到 Java 的 endorsed 技术。我们需要将自己的 HashMap 类，打包成一个 jar 包，然后放到 -Djava.endorsed.dirs 指定的目录中。注意类名和包名，应该和 JDK 自带的是一样的。但是，java.lang 包下面的类除外，因为这些都是特殊保护的。</p>
<p>因为我们上面提到的双亲委派机制，是无法直接在应用中替换 JDK 的原生类的。但是，有时候又不得不进行一下增强、替换，比如你想要调试一段代码，或者比 Java 团队早发现了一个 Bug。所以，Java 提供了 endorsed 技术，用于替换这些类。这个目录下的 jar 包，会比 rt.jar 中的文件，优先级更高，可以被最先加载到。</p>
<h2 id="10-参考"><a href="#10-参考" class="headerlink" title="10 参考"></a>10 参考</h2><ul>
<li> <a href="http://blog.itpub.net/31561269/viewspace-2222522/">Java ClassLoader</a> </li>
<li><a href="https://javakeeper.starfish.ink/java/JVM/Class-Loading.html#%E7%9B%B4%E5%87%BB%E9%9D%A2%E8%AF%95">类加载子系统</a></li>
<li><a href="https://dunwu.github.io/javacore/jvm/jvm-class-loader.html#_1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6">JVM 类加载</a></li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaIO之NIO</title>
    <url>/2022/01/23/JavaIO%E4%B9%8BNIO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><h3 id="1-Java-NIO就基本介绍"><a href="#1-Java-NIO就基本介绍" class="headerlink" title="1 Java NIO就基本介绍"></a>1 Java NIO就基本介绍</h3><ol>
<li><p><code>Java NIO</code> 全称 <strong><code>Java non-blocking IO</code></strong> ，是指 <code>JDK</code> 提供的新 <code>API</code>。从 <code>JDK1.4</code> 开始，<code>Java</code> 提供了一系列改进的输入/输出的新特性，被统称为 <code>NIO</code>（即 <code>NewIO</code>），是同步非阻塞的。</p>
</li>
<li><p><code>NIO</code> 相关类都被放在 <strong><code>java.nio</code></strong> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写。【基本案例】</p>
</li>
<li><p><code>NIO</code> 有三大核心部分: <strong><code>Channel</code>（通道）、<code>Buffer</code>（缓冲区）、<code>Selector</code>（选择器）</strong> 。</p>
</li>
<li><p><code>NIO</code> 是<strong>面向缓冲区，或者面向块编程</strong>的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</p>
</li>
<li><p><code>Java NIO</code> 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。【后面有案例说明】</p>
</li>
<li><p>通俗理解：<code>NIO</code> 是可以做到用一个线程来处理多个操作的。假设有 <code>10000</code> 个请求过来,根据实际情况，可以分配 <code>50</code> 或者 <code>100</code> 个线程来处理。不像之前的阻塞 <code>IO</code> 那样，非得分配 <code>10000</code> 个。</p>
</li>
<li><p><code>HTTP 2.0</code> 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 <code>HTTP 1.1</code> 大了好几个数量级。</p>
</li>
</ol>
<p>案例说明 <code>NIO</code> 的 <code>Buffer</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.nio;<br><br><span class="hljs-keyword">import</span> java.nio.IntBuffer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicBuffer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//举例说明 Buffer 的使用(简单说明)</span><br>        <span class="hljs-comment">//创建一个 Buffer，大小为 5，即可以存放 5 个 int</span><br>        IntBuffer intBuffer = IntBuffer.allocate(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">//向buffer存放数据</span><br>        <span class="hljs-comment">//intBuffer.put(10);</span><br>        <span class="hljs-comment">//intBuffer.put(11);</span><br>        <span class="hljs-comment">//intBuffer.put(12);</span><br>        <span class="hljs-comment">//intBuffer.put(13);</span><br>        <span class="hljs-comment">//intBuffer.put(14);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intBuffer.capacity(); i++) &#123;<br>            intBuffer.put(i * <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-comment">//如何从 buffer 读取数据</span><br>        <span class="hljs-comment">//将 buffer 转换，读写切换(!!!)</span><br>        intBuffer.flip();<br>        <span class="hljs-keyword">while</span> (intBuffer.hasRemaining()) &#123;<br>            System.out.println(intBuffer.get());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-NIO和BIO的比较"><a href="#2-NIO和BIO的比较" class="headerlink" title="2 NIO和BIO的比较"></a>2 NIO和BIO的比较</h3><ol>
<li><code>BIO</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据，块 <code>I/O</code> 的效率比流 <code>I/O</code> 高很多。</li>
<li><code>BIO</code> 是阻塞的，<code>NIO</code> 则是非阻塞的。</li>
<li><code>BIO</code> 基于字节流和字符流进行操作，而 <code>NIO</code> 基于 <code>Channel</code>（通道）和 <code>Buffer</code>（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<code>Selector</code>（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li>
</ol>
<h3 id="3-NIO三大核心原理示意图"><a href="#3-NIO三大核心原理示意图" class="headerlink" title="3 NIO三大核心原理示意图"></a>3 NIO三大核心原理示意图</h3><p>一张图描述 <code>NIO</code> 的 <code>Selector</code>、<code>Channel</code> 和 <code>Buffer</code> 的关系。</p>
<p><strong>3.1 Selector、Channel和Buffer关系图</strong></p>
<p>关系图的说明:</p>
<p><img src="/img/work/chapter03_01.png" alt="Selector、Channel和Buffer关系图"></p>
<ol>
<li>每个 <code>Channel</code> 都会对应一个 <code>Buffer</code>。</li>
<li><code>Selector</code> 对应一个线程，一个线程对应多个 <code>Channel</code>（连接）。</li>
<li>该图反应了有三个 <code>Channel</code> 注册到该 <code>Selector</code> 程序</li>
<li>程序切换到哪个 <code>Channel</code> 是由事件决定的，<code>Event</code> 就是一个重要的概念。</li>
<li><code>Selector</code> 会根据不同的事件，在各个通道上切换。</li>
<li><code>Buffer</code> 就是一个内存块，底层是有一个数组。</li>
<li>数据的读取写入是通过 <code>Buffer</code>，这个和 <code>BIO</code>，<code>BIO</code> 中要么是输入流，或者是输出流，不能双向，但是 <code>NIO</code> 的 <code>Buffer</code> 是可以读也可以写，需要 <code>flip</code> 方法切换， <code>Channel</code> 是双向的，可以返回底层操作系统的情况，比如 <code>Linux</code>，底层的操作系统通道就是双向的。</li>
</ol>
<h3 id="4-缓冲区-Buffer"><a href="#4-缓冲区-Buffer" class="headerlink" title="4 缓冲区(Buffer)"></a>4 缓冲区(Buffer)</h3><blockquote>
<p>缓冲区（<code>Buffer</code>）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个<strong>容器对象（含数组）</strong>，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<code>Channel</code> 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 <code>Buffer</code>，如图:【后面举例说明】</p>
</blockquote>
<p><img src="/img/work/chapter03_02.png"></p>
<h4 id="4-2-Buffer-类及其子类"><a href="#4-2-Buffer-类及其子类" class="headerlink" title="4.2 Buffer 类及其子类"></a>4.2 Buffer 类及其子类</h4><ol>
<li><p>在 <code>NIO</code> 中，<code>Buffer</code> 是一个顶层父类，它是一个抽象类，类的层级关系图：</p>
<p><img src="/img/work/chapter03_03.png" alt="img"></p>
</li>
<li><p><code>Buffer</code> 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息：</p>
</li>
</ol>
<p><img src="/img/work/chapter03_05.png"></p>
<ol start="3">
<li><code>Buffer</code> 类相关方法一览</li>
</ol>
<p><img src="/img/work/chapter03_06.png"></p>
<h4 id="4-3-ByteBuffer"><a href="#4-3-ByteBuffer" class="headerlink" title="4.3 ByteBuffer"></a>4.3 ByteBuffer</h4><p>从前面可以看出对于 <code>Java</code> 中的基本数据类型（<code>boolean</code> 除外），都有一个 <code>Buffer</code> 类型与之相对应，最常用的自然是 <code>ByteBuffer</code> 类（二进制数据），该类的主要方法如下：</p>
<p><img src="/img/work/chapter03_07.png"></p>
<h3 id="5-通道（Channel）"><a href="#5-通道（Channel）" class="headerlink" title="5 通道（Channel）"></a>5 通道（Channel）</h3><h4 id="5-1-基本介绍"><a href="#5-1-基本介绍" class="headerlink" title="5.1 基本介绍"></a>5.1 基本介绍</h4><ol>
<li><code>NIO</code> 的通道类似于流，但有些区别如下：</li>
</ol>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲:</li>
</ul>
<ol start="2">
<li><code>BIO</code> 中的 <code>Stream</code> 是单向的，例如 <code>FileInputStream</code> 对象只能进行读取数据的操作，而 <code>NIO</code> 中的通道（<code>Channel</code>）是双向的，可以读操作，也可以写操作。</li>
<li><code>Channel</code> 在 <code>NIO</code> 中是一个接口 <code>public interface Channel extends Closeable&#123;&#125;</code></li>
<li>常用的 <code>Channel</code> 类有: <strong><code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code></strong> 。【<code>ServerSocketChannel</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code>】</li>
<li><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</li>
<li>图示</li>
</ol>
<p><img src="/img/work/chapter03_08.png"></p>
<h4 id="5-2-FileChannel"><a href="#5-2-FileChannel" class="headerlink" title="5.2 FileChannel"></a>5.2 FileChannel</h4><p><code>FileChannel</code> 主要用来对本地文件进行 <code>IO</code> 操作，常见的方法有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(ByteBuffer dst)</span><span class="hljs-comment">//从通道读取数据并放到缓冲区中</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">write</span><span class="hljs-params">(ByteBuffer src)</span> <span class="hljs-comment">//把缓冲区的数据写到通道中</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">transferFrom</span><span class="hljs-params">(ReadableByteChannel src, <span class="hljs-keyword">long</span> position, <span class="hljs-keyword">long</span> count)</span><span class="hljs-comment">//从目标通道中复制数据到当前通道</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">transferTo</span><span class="hljs-params">(<span class="hljs-keyword">long</span> position, <span class="hljs-keyword">long</span> count, WritableByteChannel target)</span><span class="hljs-comment">//把数据从当前通道复制给目标通道</span></span><br></code></pre></td></tr></table></figure>



<p><strong>实例1-本地文件写数据</strong></p>
<ol>
<li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 “hello,尚硅谷” 写入到 <code>file01.txt</code> 中</li>
<li>文件不存在就创建</li>
<li>代码演示</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel01</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String str = <span class="hljs-string">&quot;hello,尚硅谷&quot;</span>;<br>        <span class="hljs-comment">//创建一个输出流 -》 channel</span><br>        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;/Users/pudewu/software07/Java/stud_code/java-basic/file01.txt&quot;</span>);<br><br>        <span class="hljs-comment">//通过 FileOutputStream获取对应的FileChannel</span><br>        <span class="hljs-comment">//这个 fileChannel 真实类型是FileChannelImpl</span><br>        FileChannel fileChannel = fileOutputStream.getChannel();<br><br>        <span class="hljs-comment">//创建一个缓冲区ByteBuffer</span><br>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>        <span class="hljs-comment">//将str放入byteBuffer</span><br>        byteBuffer.put(str.getBytes());<br><br>        <span class="hljs-comment">//对 byteBuffer进行flip</span><br>        byteBuffer.flip();<br><br>        <span class="hljs-comment">//将byteBuffer数据写入到 fileChannel</span><br>        fileChannel.write(byteBuffer);<br>        fileOutputStream.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>实例2-本地文件读数据</strong></p>
<ol>
<li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 <code>file01.txt</code> 中的数据读入到程序，并显示在控制台屏幕</li>
<li>假定文件已经存在</li>
<li>代码演示</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel02</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//创建文件的输入流</span><br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/Users/pudewu/software07/Java/stud_code/java-basic/file01.txt&quot;</span>);<br>        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(file);<br><br>        <span class="hljs-comment">//通过fileInputStream获取对应的FileChannel -&gt; 实际类型FileChannelImpl</span><br>        FileChannel fileChannel = fileInputStream.getChannel();<br><br>        <span class="hljs-comment">//创建缓冲区</span><br>        ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="hljs-keyword">int</span>) file.length());<br><br>        <span class="hljs-comment">//将通道的数据读入到Buffer</span><br>        fileChannel.read(byteBuffer);<br><br>        <span class="hljs-comment">//将 byteBuffer的字节数据转成String</span><br>        System.out.println(<span class="hljs-keyword">new</span> String(byteBuffer.array()));<br><br>        fileInputStream.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>实例3-使用一个Buffer完成文件读取、写入</strong></p>
<ol>
<li>使用 <code>FileChannel</code>（通道）和方法 <code>read、write</code>，完成文件的拷贝</li>
<li>拷贝一个文本文件 <code>1.txt</code>，放在项目下即可</li>
<li>代码演示</li>
</ol>
<p><img src="/img/work/chapter03_09.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel03</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;file01.txt&quot;</span>);<br><br>        FileChannel fileChannel01 = fileInputStream.getChannel();<br><br>        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;file02.txt&quot;</span>);<br>        FileChannel fileChannel02 = fileOutputStream.getChannel();<br><br>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">512</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            byteBuffer.clear();<br><br>            <span class="hljs-keyword">int</span> read = fileChannel01.read(byteBuffer);<br>            System.out.println(<span class="hljs-string">&quot;read=&quot;</span> + read);<br>            <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//将buffer中的数据写入到 fileChannel02--file02.txt</span><br>            byteBuffer.flip();<br>            fileChannel02.write(byteBuffer);<br>        &#125;<br><br>        fileChannel01.close();<br>        fileChannel02.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>实例4-拷贝文件transferFrom方法</strong></p>
<ol>
<li>实例要求：</li>
<li>使用 <code>FileChannel</code>（通道）和方法 <code>transferFrom</code>，完成文件的拷贝</li>
<li>拷贝一张图片</li>
<li>代码演示</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel04</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        <span class="hljs-comment">//创建相关流</span><br>        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;wallhaven-lqkxmr.jpg&quot;</span>);<br>        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;fengjing.jpg&quot;</span>);<br>        <br>        <span class="hljs-comment">//获取各个流对应的FileChannel</span><br>        FileChannel sourceChannel = fileInputStream.getChannel();<br>        FileChannel targetChannel = fileOutputStream.getChannel();<br><br>        <span class="hljs-comment">//使用transferForm 完成拷贝</span><br>        targetChannel.transferFrom(sourceChannel,<span class="hljs-number">0</span>,sourceChannel.size());<br><br>        <span class="hljs-comment">//关闭相关通道和流</span><br>        sourceChannel.close();<br>        targetChannel.close();<br>        fileInputStream.close();<br>        fileOutputStream.close();<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-3-关于Buffer和Channel注意事项和细节"><a href="#5-3-关于Buffer和Channel注意事项和细节" class="headerlink" title="5.3 关于Buffer和Channel注意事项和细节"></a>5.3 关于Buffer和Channel注意事项和细节</h4><ol>
<li><code>ByteBuffer</code> 支持类型化的 <code>put</code> 和 <code>get</code>，<code>put</code> 放入的是什么数据类型，<code>get</code> 就应该使用相应的数据类型来取出，否则可能有 <code>BufferUnderflowException</code> 异常。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOByteBufferPutGet</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建一个Buffer</span><br>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">64</span>);<br><br>        <span class="hljs-comment">//类型化方式放入数据</span><br>        byteBuffer.putInt(<span class="hljs-number">100</span>);<br>        byteBuffer.putLong(<span class="hljs-number">9</span>);<br>        byteBuffer.putChar(<span class="hljs-string">&#x27;尚&#x27;</span>);<br>        byteBuffer.putShort((<span class="hljs-keyword">short</span>) <span class="hljs-number">4</span>);<br><br>        <span class="hljs-comment">//取出</span><br>        byteBuffer.flip();<br><br>        System.out.println();<br><br>        System.out.println(byteBuffer.getInt());<br>        System.out.println(byteBuffer.getLong());<br>        System.out.println(byteBuffer.getChar());<br>        System.out.println(byteBuffer.getShort());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>可以将一个普通 <code>Buffer</code> 转成只读 <code>Buffer</code>【举例说明】</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadOnlyBuffer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//创建一个buffer</span><br>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">64</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">64</span>; i++) &#123;<br>            buffer.put((<span class="hljs-keyword">byte</span>) i);<br>        &#125;<br><br>        <span class="hljs-comment">//读取</span><br>        buffer.flip();<br><br>        <span class="hljs-comment">//得到一个只读的buffer</span><br>        ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();<br>        System.out.println(readOnlyBuffer.getClass());<br><br>        <span class="hljs-keyword">while</span> (readOnlyBuffer.hasRemaining()) &#123;<br>            System.out.println(readOnlyBuffer.get());<br>        &#125;<br><br>        <span class="hljs-comment">//ReadOnlyBufferException</span><br>        readOnlyBuffer.put((<span class="hljs-keyword">byte</span>) <span class="hljs-number">100</span>); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li><code>NIO</code> 还提供了 <code>MappedByteBuffer</code>，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由 <code>NIO</code> 来完成。</li>
</ol>
<p><strong>MappedByteBuffer 可让文件直接在内存（堆外内存）修改,操作系统不需要拷贝一次</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MappedByteBufferTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br><br>        RandomAccessFile randomAccessFile = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br><br>        <span class="hljs-comment">//获取对应的通道</span><br>        FileChannel fileChannel = randomAccessFile.getChannel();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数 1:FileChannel.MapMode.READ_WRITE 使用的读写模式</span><br><span class="hljs-comment">         * 参数 2：0：可以直接修改的起始位置</span><br><span class="hljs-comment">         * 参数 3:5: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存</span><br><span class="hljs-comment">         * 可以直接修改的范围就是 0-5</span><br><span class="hljs-comment">         * 实际类型 DirectByteBuffer</span><br><span class="hljs-comment">         */</span><br>        MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br><br>        mappedByteBuffer.put(<span class="hljs-number">0</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;H&#x27;</span>);<br>        mappedByteBuffer.put(<span class="hljs-number">3</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;9&#x27;</span>);<br>        <br>        <span class="hljs-comment">//IndexOutOfBoundsException</span><br>        mappedByteBuffer.put(<span class="hljs-number">5</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;Y&#x27;</span>);<br><br>        randomAccessFile.close();<br>        System.out.println(<span class="hljs-string">&quot;修改成功~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最终成功文件为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs txt">H9<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>前面我们讲的读写操作，都是通过一个 <code>Buffer</code> 完成的，<code>NIO</code> 还支持通过多个 <code>Buffer</code>（即 <code>Buffer</code>数组）完成读写操作，即 <code>Scattering</code> 和 <code>Gathering</code></li>
</ol>
<p><strong>Scattering：将数据写入到 buffer 时，可以采用 buffer 数组，依次写入 [分散]</strong> </p>
<p><strong>Gathering：从 buffer 读取数据时，可以采用 buffer 数组，依次读</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScatteringAndGatheringTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        <span class="hljs-comment">//使用 ServerSocketChannel 和 SocketChannel 网络</span><br>        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<br><br>        InetSocketAddress inetSocketAddress = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">7000</span>);<br><br>        <span class="hljs-comment">//绑定端口到 socket，并启动</span><br>        serverSocketChannel.socket().bind(inetSocketAddress);<br><br>        <span class="hljs-comment">//创建 buffer 数组</span><br>        ByteBuffer[] byteBuffers = <span class="hljs-keyword">new</span> ByteBuffer[<span class="hljs-number">2</span>];<br><br>        byteBuffers[<span class="hljs-number">0</span>] = ByteBuffer.allocate(<span class="hljs-number">5</span>);<br>        byteBuffers[<span class="hljs-number">1</span>] = ByteBuffer.allocate(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">//等客户端连接 (telnet)</span><br>        SocketChannel socketChannel = serverSocketChannel.accept();<br><br>        <span class="hljs-comment">//假定从客户端接收 8 个字节</span><br>        <span class="hljs-keyword">int</span> messageLength = <span class="hljs-number">8</span>;<br><br>        <span class="hljs-comment">//循环的读取</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">int</span> byteRead = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">while</span> (byteRead &lt; messageLength ) &#123;<br>                <span class="hljs-keyword">long</span> read = socketChannel.read(byteBuffers);<br><br>                byteRead += read;<br><br>                System.out.println(<span class="hljs-string">&quot;byteRead = &quot;</span> + byteRead);<br><br>                Arrays.asList(byteBuffers).stream().map(buffer -&gt; <span class="hljs-string">&quot;position = &quot;</span> + buffer.position() + <span class="hljs-string">&quot;, limit = &quot;</span> + buffer.limit()).forEach(System.out::println);<br><br><br>            &#125;<br><br>            <span class="hljs-comment">//将所有的 buffer 进行 flip</span><br>            Arrays.asList(byteBuffers).forEach(e -&gt; e.flip());<br><br><br><br>            <span class="hljs-comment">//将数据读出显示到客户端</span><br>            <span class="hljs-keyword">long</span> byteWrite = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">while</span> (byteWrite &lt; messageLength) &#123;<br>                <span class="hljs-keyword">long</span> l = socketChannel.write(byteBuffers);<br>                byteWrite += l;<br>            &#125;<br><br><br>            <span class="hljs-comment">//将所有buffer进行clear</span><br>            Arrays.asList(byteBuffers).forEach(e -&gt; e.clear());<br><br>            System.out.println(<span class="hljs-string">&quot;byteRead = &quot;</span> + byteRead + <span class="hljs-string">&quot;, byteWrite = &quot;</span> + byteWrite + <span class="hljs-string">&quot;, messagelength = &quot;</span> + messageLength);<br>        &#125;<br><br><br><br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="6-Selector-选择器"><a href="#6-Selector-选择器" class="headerlink" title="6 Selector(选择器)"></a>6 Selector(选择器)</h3><h4 id="6-4-基本介绍"><a href="#6-4-基本介绍" class="headerlink" title="6.4 基本介绍"></a>6.4 基本介绍</h4><ol>
<li><code>Java</code> 的 <code>NIO</code>，用非阻塞的 <code>IO</code> 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <code>Selector</code>（选择器）。</li>
<li><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。【示意图】</li>
<li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li>
<li>避免了多线程之间的上下文切换导致的开销。</li>
</ol>
<h4 id="6-2-Selector示意图和特点说明"><a href="#6-2-Selector示意图和特点说明" class="headerlink" title="6.2 Selector示意图和特点说明"></a>6.2 Selector示意图和特点说明</h4><p><img src="/img/work/chapter03_10.png" alt="img"></p>
<p>说明如下:</p>
<ol>
<li>Netty的IO线程NioEventLoop聚合了Selector(选择器，也叫多路复用器)，可以同时并发处理成百上千个客户端连接。</li>
<li>当线程从某个客户端<code>Socket</code>通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</li>
<li>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</li>
<li>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</li>
<li>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li>
</ol>
<h4 id="6-3-Selector类相关方法"><a href="#6-3-Selector类相关方法" class="headerlink" title="6.3 Selector类相关方法"></a>6.3 Selector类相关方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Selector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Closeable</span> </span>&#123;<br>  <br>  <span class="hljs-comment">//得到一个选择器对象</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Selector <span class="hljs-title">open</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">return</span> SelectorProvider.provider().openSelector();<br>    &#125;<br>  <br>  <span class="hljs-comment">//监控所有注册的通道，当其中有io操作可以进行时，将对应的SelectionKey加入到内部集合并返回，参数用来设置超时时间。</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span></span>;<br>  <br>  <br>  <span class="hljs-comment">//从内部集合中得到所有的SelectionKey</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Set&lt;SelectionKey&gt; <span class="hljs-title">selectedKeys</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="6-4-注意事项"><a href="#6-4-注意事项" class="headerlink" title="6.4 注意事项"></a>6.4 注意事项</h4><ol>
<li>NIO中的<code>ServerSocketChannel</code>功能类似<code>ServerSocket</code>、<code>SocketChannel</code>功能类似<code>Socket</code></li>
<li><code>Selector</code> 相关方法说明<ul>
<li><code>selector.select();</code> //阻塞</li>
<li><code>selector.select(1000);</code> //阻塞 1000 毫秒，在 1000 毫秒后返回</li>
<li><code>selector.wakeup();</code> //唤醒 selector</li>
<li><code>selector.selectNow();</code> //不阻塞，立马返还</li>
</ul>
</li>
</ol>
<h3 id="7-NIO-非阻塞网络编程原理分析图"><a href="#7-NIO-非阻塞网络编程原理分析图" class="headerlink" title="7 [NIO 非阻塞网络编程原理分析图"></a>7 [NIO 非阻塞网络编程原理分析图</h3><p><code>NIO</code> 非阻塞网络编程相关的（<code>Selector</code>、<code>SelectionKey</code>、<code>ServerScoketChannel</code> 和 <code>SocketChannel</code>）关系梳理图</p>
<p><img src="/img/work/chapter03_22.png"></p>
<p>对上图的说明：</p>
<ol>
<li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li>
<li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li>
<li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li>
<li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li>
<li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li>
<li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li>
<li>可以通过得到的 <code>channel</code>，完成业务处理。</li>
<li>代码撑腰。。。</li>
</ol>
<h3 id="8-SelectionKey"><a href="#8-SelectionKey" class="headerlink" title="8 SelectionKey"></a>8 SelectionKey</h3><ol>
<li> <code>SelectionKey</code>，表示 <code>Selector</code> 和网络通道的注册关系，共四种： </li>
</ol>
<ul>
<li><code>int OP_ACCEPT</code>: 有新的网络连接可以 <code>accept</code>，值为 <code>16</code> </li>
<li><code>int OP_CONNECT</code>：代表连接已经建立，值为 <code>8</code></li>
<li><code>int OP_READ</code>：代表读操作，值为 <code>1</code></li>
<li><code>int OP_WRITE</code>：代表写操作，值为 <code>4</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_READ = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_WRITE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_CONNECT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_ACCEPT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure>



<ol start="2">
<li><code>SelectionKey</code> 相关方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectionKey</span></span>&#123;<br>    <span class="hljs-comment">//得到与之关联的Selector对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Selector <span class="hljs-title">selector</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-comment">//得到与之关联的通道</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> SelectableChannel <span class="hljs-title">channel</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-comment">//得到与之关联的共享数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">attachment</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> attachment;<br>    &#125;<br>    <br>    <span class="hljs-comment">//设置或改变监听事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> SelectionKey <span class="hljs-title">interestOps</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ops)</span></span>;<br>    <br>    <span class="hljs-comment">// 是否可以accept</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAcceptable</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (readyOps() &amp; OP_ACCEPT) != <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//是否可以读</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isReadable</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (readyOps() &amp; OP_READ) != <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isWritable</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (readyOps() &amp; OP_WRITE) != <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="9-ServerSocketChannel"><a href="#9-ServerSocketChannel" class="headerlink" title="9 ServerSocketChannel"></a>9 ServerSocketChannel</h3><ol>
<li><code>ServerSocketChannel</code> 在服务器端监听新的客户端 <code>Socket</code> 连接</li>
<li>相关方法如下</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerSocketChannel</span>    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSelectableChannel</span>    <span class="hljs-keyword">implements</span> <span class="hljs-title">NetworkChannel</span></span>&#123;<br>    <br>    <span class="hljs-comment">//得到一个ServerSocketChannel通道</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ServerSocketChannel <span class="hljs-title">open</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function">    <span class="hljs-comment">//设置服务器端端口号    </span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ServerSocketChannel <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress local)</span>    </span><br><span class="hljs-function">    </span><br><span class="hljs-function">        </span><br><span class="hljs-function">    <span class="hljs-comment">//接受一个连接，返回代表这个连接的通道对象  </span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> SocketChannel <span class="hljs-title">accept</span><span class="hljs-params">()</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="10-SocketChannel"><a href="#10-SocketChannel" class="headerlink" title="10 SocketChannel"></a>10 SocketChannel</h3><ol>
<li><p><code>SocketChannel</code>，网络 <code>IO</code> 通道，具体负责进行读写操作。<code>NIO</code> 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</p>
</li>
<li><p>相关方法如下</p>
<p> <img src="/img/work/chapter03_14.png"> </p>
</li>
</ol>
<h3 id="11-NIO-网络编程应用实例-群聊系统"><a href="#11-NIO-网络编程应用实例-群聊系统" class="headerlink" title="11 NIO 网络编程应用实例 - 群聊系统"></a>11 NIO 网络编程应用实例 - 群聊系统</h3><p> 实例要求： </p>
<ol>
<li><p>编写一个 <code>NIO</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</p>
</li>
<li><p>实现多人群聊</p>
</li>
<li><p>服务器端：可以监测用户上线，离线，并实现消息转发功能</p>
</li>
<li><p>客户端：通过 <code>Channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</p>
</li>
<li><p>目的：进一步理解 <code>NIO</code> 非阻塞网络编程机制</p>
</li>
<li><p>示意图分析和代码</p>
</li>
</ol>
<p><img src="/img/work/chapter03_15.png"></p>
<p>server端代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatServer</span> </span>&#123;<br><br>    <span class="hljs-comment">//定义属性</span><br>    <span class="hljs-keyword">private</span> Selector selector;<br><br>    <span class="hljs-keyword">private</span> ServerSocketChannel listenChannel;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">6667</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatServer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-comment">//得到选择器</span><br>            selector = Selector.open();<br><br>            <span class="hljs-comment">//ServerSocketChannel</span><br>            listenChannel = ServerSocketChannel.open();<br><br>            <span class="hljs-comment">//绑定端口</span><br>            listenChannel.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(PORT));<br><br>            <span class="hljs-comment">//设置非阻塞模式</span><br>            listenChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br><br>            <span class="hljs-comment">//将该ListenChannel 注册到 selector</span><br>            listenChannel.register(selector, SelectionKey.OP_ACCEPT);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">int</span> count = selector.select();<br><br>                <span class="hljs-comment">//有事件处理</span><br>                <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">//遍历得到SelectionKey集合</span><br>                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();<br><br>                    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br><br>                        <span class="hljs-comment">//取出selectionKey</span><br>                        SelectionKey key = iterator.next();<br>                        <span class="hljs-comment">//监听到 accept</span><br>                        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                            SocketChannel sc = listenChannel.accept();<br>                            sc.configureBlocking(<span class="hljs-keyword">false</span>);<br><br>                            <span class="hljs-comment">//将该sc注册到selector</span><br>                            sc.register(selector,SelectionKey.OP_READ);<br><br>                            <span class="hljs-comment">//提示</span><br>                            System.out.println(sc.getRemoteAddress() + <span class="hljs-string">&quot;上线&quot;</span>);<br>                        &#125;<br><br>                        <span class="hljs-comment">// 通道发送read事件，即通道是刻度的状态</span><br>                        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                            <span class="hljs-comment">//处理读（专门写方法）</span><br>                            readData(key);<br>                        &#125;<br><br>                        <span class="hljs-comment">//当前的 key删除，防止重复处理</span><br>                        iterator.remove();<br><br>                    &#125;<br><br><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;等待。。。&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//发生异常处理</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readData</span><span class="hljs-params">(SelectionKey selectionKey)</span> </span>&#123;<br>        SocketChannel channel = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-comment">//得到channel</span><br>            channel = (SocketChannel) selectionKey.channel();<br><br>            <span class="hljs-comment">//创建buffer</span><br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>            <span class="hljs-keyword">int</span> read = channel.read(buffer);<br><br>            <span class="hljs-keyword">if</span> (read &gt; <span class="hljs-number">0</span> ) &#123;<br>                <span class="hljs-comment">//把缓存区的数据转成字符串</span><br>                String msg = <span class="hljs-keyword">new</span> String(buffer.array());<br>                <span class="hljs-comment">//输出该消息</span><br>                System.out.println(<span class="hljs-string">&quot;from客户端：&quot;</span> + msg);<br><br>                <span class="hljs-comment">//向其他的客户端转发消息(去掉自己)，专门写一个方法来处理</span><br>                sendInfoToOtherClients(msg,channel);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(channel.getRemoteAddress()+ <span class="hljs-string">&quot;离线了&quot;</span>);<br><br>                <span class="hljs-comment">//取消注册</span><br>                selectionKey.cancel();<br><br>                <span class="hljs-comment">//关闭通道</span><br>                channel.close();<br><br>            &#125; <span class="hljs-keyword">catch</span> (IOException e1) &#123;<br>                e1.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendInfoToOtherClients</span><span class="hljs-params">(String msg,SocketChannel self)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器转发消息。。。。&quot;</span>);<br>        <span class="hljs-comment">//遍历所有注册到selector上的SocketChannel，并排除self</span><br>        <span class="hljs-keyword">for</span> (SelectionKey key : selector.keys()) &#123;<br>            <span class="hljs-comment">//通过key取出对应的SocketChannel</span><br>            SelectableChannel targetChannel = key.channel();<br>            <span class="hljs-comment">//排除自己</span><br>            <span class="hljs-keyword">if</span> (targetChannel <span class="hljs-keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != self) &#123;<br>                <span class="hljs-comment">//转型</span><br>                SocketChannel socketChannel = (SocketChannel) targetChannel;<br><br>                <span class="hljs-comment">//将msg 存储到Buffer</span><br>                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());<br><br>                <span class="hljs-comment">//将buffer的数据写入通道</span><br>                socketChannel.write(buffer);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建服务器对象</span><br>        GroupChatServer groupChatServer = <span class="hljs-keyword">new</span> GroupChatServer();<br>        groupChatServer.listen();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<p>客户端代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatClient</span> </span>&#123;<br><br>    <span class="hljs-comment">//服务器ip</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String HOST = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><br>    <span class="hljs-comment">//服务器端口</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">6667</span>;<br><br>    <span class="hljs-keyword">private</span> Selector selector;<br><br>    <span class="hljs-keyword">private</span> SocketChannel socketChannel;<br><br>    <span class="hljs-keyword">private</span> String username;<br><br>    <span class="hljs-comment">//构造器，完成初始化工作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatClient</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        selector = Selector.open();<br><br>        <span class="hljs-comment">//连接服务器</span><br>        socketChannel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(HOST, PORT));<br><br>        <span class="hljs-comment">//设置非阻塞</span><br>        socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br><br>        <span class="hljs-comment">//将channel 注册到selector</span><br>        socketChannel.register(selector, SelectionKey.OP_READ);<br><br>        <span class="hljs-comment">//得到 username</span><br>        username = socketChannel.getLocalAddress().toString().substring(<span class="hljs-number">1</span>);<br><br>        System.out.println(username + <span class="hljs-string">&quot; is ok&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//向服务器发送消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendInfo</span><span class="hljs-params">(String info)</span> </span>&#123;<br>        info = username + <span class="hljs-string">&quot;说:&quot;</span> + info;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            socketChannel.write(ByteBuffer.wrap(info.getBytes()));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> readChannels = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            readChannels = selector.select();<br><br>            <span class="hljs-keyword">if</span> (readChannels &gt; <span class="hljs-number">0</span>) &#123;<br>                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();<br><br>                <span class="hljs-keyword">if</span> (iterator.hasNext()) &#123;<br>                    SelectionKey key = iterator.next();<br><br>                    <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                        SocketChannel sc = (SocketChannel) key.channel();<br>                        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>                        sc.read(buffer);<br><br>                        String msg = <span class="hljs-keyword">new</span> String(buffer.array());<br><br>                        System.out.println(msg);<br>                    &#125;<br>                &#125;<br>                iterator.remove();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//启动客户端</span><br>        GroupChatClient client = <span class="hljs-keyword">new</span> GroupChatClient();<br><br>        <span class="hljs-keyword">new</span> Thread() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                    client.readInfo();<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        sleep(<span class="hljs-number">3000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;.start();<br><br>        <span class="hljs-comment">//发送数据给服务端</span><br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br><br>        <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;<br>            String line = scanner.nextLine();<br>            client.sendInfo(line);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="12-NIO-与零拷贝"><a href="#12-NIO-与零拷贝" class="headerlink" title="12 NIO 与零拷贝"></a>12 NIO 与零拷贝</h3><h4 id="12-1-零拷贝基本介绍"><a href="#12-1-零拷贝基本介绍" class="headerlink" title="12.1 零拷贝基本介绍"></a>12.1 零拷贝基本介绍</h4><ol>
<li>零拷贝是网络编程的关键，很多性能优化都离不开。</li>
<li>在 <code>Java</code> 程序中，常用的零拷贝有 <code>mmap</code>（内存映射）和 <code>sendFile</code>。那么，他们在 <code>OS</code> 里，到底是怎么样的一个的设计？我们分析 <code>mmap</code> 和 <code>sendFile</code> 这两个零拷贝</li>
<li>另外我们看下 <code>NIO</code> 中如何使用零拷贝</li>
</ol>
<h4 id="12-2-传统IO数据的读写"><a href="#12-2-传统IO数据的读写" class="headerlink" title="12.2 传统IO数据的读写"></a>12.2 传统IO数据的读写</h4><p><code>Java</code> 传统 <code>IO</code> 和网络编程的一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(file, <span class="hljs-string">&quot;rw&quot;</span>);<br><br><span class="hljs-keyword">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>) file.length()];<br>raf.read(arr);<br><br>Socket socket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>).accept();<br>socket.getOutputStream().write(arr);<br></code></pre></td></tr></table></figure>



<h4 id="12-3-传统IO模型"><a href="#12-3-传统IO模型" class="headerlink" title="12.3 传统IO模型"></a>12.3 传统IO模型</h4><p><img src="/img/work/chapter03_17.png" alt="img"></p>
<p><strong>DMA</strong>：<code>direct memory access</code> 直接内存拷贝（不使用 <code>CPU</code>）</p>
<h4 id="12-4-mmap优化"><a href="#12-4-mmap优化" class="headerlink" title="12.4 mmap优化"></a>12.4 mmap优化</h4><ol>
<li><code>mmap</code> 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图</li>
<li><code>mmap</code> 示意图</li>
</ol>
<p><img src="/img/work/chapter03_18.png"></p>
<p>3.12.5 sendFile优化</p>
<ol>
<li><code>Linux2.1</code> 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 <code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换</li>
<li>示意图和小结</li>
</ol>
<p><img src="/img/work/chapter03_19.png"></p>
<ol start="3">
<li><p>提示：零拷贝从操作系统角度，是没有 <code>cpu</code> 拷贝</p>
</li>
<li><p><code>Linux在2.4</code> 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socketbuffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图和小结：</p>
</li>
</ol>
<p><img src="/img/work/chapter03_20.png"></p>
<ol start="5">
<li>这里其实有一次 <code>cpu</code> 拷贝 <code>kernel buffer</code> -&gt; <code>socket buffer</code> 但是，拷贝的信息很少，比如 <code>lenght</code>、<code>offset</code> 消耗低，可以忽略</li>
</ol>
<p>3.12.4 零拷贝的再次理解</p>
<ol>
<li>我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的（只有 <code>kernel buffer</code> 有一份数据）。</li>
<li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 <code>CPU</code> 缓存伪共享以及无 <code>CPU</code> 校验和计算。</li>
</ol>
<h4 id="12-5-mmap-和-sendFile-的区别"><a href="#12-5-mmap-和-sendFile-的区别" class="headerlink" title="12.5 mmap 和 sendFile 的区别"></a>12.5 mmap 和 sendFile 的区别</h4><ol>
<li><code>mmap</code> 适合小数据量读写，<code>sendFile</code> 适合大文件传输。</li>
<li><code>mmap</code> 需要 <code>4</code> 次上下文切换，<code>3</code> 次数据拷贝；<code>sendFile</code> 需要 <code>3</code> 次上下文切换，最少 <code>2</code> 次数据拷贝。</li>
<li><code>sendFile</code> 可以利用 <code>DMA</code> 方式，减少 <code>CPU</code> 拷贝，<code>mmap</code> 则不能（必须从内核拷贝到 <code>Socket</code>缓冲区）。</li>
</ol>
<h4 id="12-6-NIO零拷贝案例"><a href="#12-6-NIO零拷贝案例" class="headerlink" title="12.6 NIO零拷贝案例"></a>12.6 NIO零拷贝案例</h4><p>案例要求：</p>
<ol>
<li>使用传统的 <code>IO</code> 方法传递一个大文件</li>
<li>使用 <code>NIO</code> 零拷贝方式传递（<code>transferTo</code>）一个大文件</li>
<li>看看两种传递方式耗时时间分别是多少</li>
</ol>
<p>Server端:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewIOServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        InetSocketAddress inetSocketAddress = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8001</span>);<br>        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<br>        ServerSocket serverSocket = serverSocketChannel.socket();<br>        serverSocket.bind(inetSocketAddress);<br><br>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">4096</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            SocketChannel socketChannel = serverSocketChannel.accept();<br>            <span class="hljs-keyword">int</span> readCount = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (-<span class="hljs-number">1</span> != readCount) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    readCount = socketChannel.read(byteBuffer);<br>                &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//倒带 position = 0 mark 作废</span><br>                byteBuffer.rewind();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Client端:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewIOClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        SocketChannel socketChannel = SocketChannel.open();<br><br>        socketChannel.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">8001</span>));<br>        String filename = <span class="hljs-string">&quot;/Users/pudewu/Downloads/激活码包含专用激活 (3).zip&quot;</span>;<br><br>        <span class="hljs-comment">//得到一个文件Channel</span><br>        FileChannel fileChannel = <span class="hljs-keyword">new</span> FileInputStream(filename).getChannel();<br><br>        <span class="hljs-comment">//准备发送</span><br>        <span class="hljs-keyword">long</span> currentTimeMillis = System.currentTimeMillis();<br>        <span class="hljs-comment">//在 linux 下一个 transferTo 方法就可以完成传输</span><br>        <span class="hljs-comment">//在 windows 下一次调用 transferTo 只能发送 8m, 就需要分段传输文件,而且要主要</span><br>        <span class="hljs-comment">//传输时的位置=》课后思考...</span><br>        <span class="hljs-comment">//transferTo 底层使用到零拷贝</span><br>        <span class="hljs-keyword">long</span> transferCount = fileChannel.transferTo(<span class="hljs-number">0</span>, fileChannel.size(), socketChannel);<br>        System.out.println(<span class="hljs-string">&quot;发送的总的字节数 = &quot;</span> + transferCount + <span class="hljs-string">&quot; 耗时: &quot;</span> + (System.currentTimeMillis() - currentTimeMillis));<br><br>        <span class="hljs-comment">//关闭</span><br>        fileChannel.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="12-7-JavaAIO-基本介绍"><a href="#12-7-JavaAIO-基本介绍" class="headerlink" title="12.7 JavaAIO 基本介绍"></a>12.7 JavaAIO 基本介绍</h4><ol>
<li><code>JDK7</code> 引入了 <code>AsynchronousI/O</code>，即 <code>AIO</code>。在进行 <code>I/O</code> 编程中，常用到两种模式：<code>Reactor</code> 和 <code>Proactor</code>。<code>Java</code> 的 <code>NIO</code> 就是 <code>Reactor</code>，当有事件触发时，服务器端得到通知，进行相应的处理</li>
<li><code>AIO</code> 即 <code>NIO2.0</code>，叫做异步不阻塞的 <code>IO</code>。<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li>
<li>目前 <code>AIO</code> 还没有广泛应用，<code>Netty</code> 也是基于 <code>NIO</code>，而不是 <code>AIO</code>，因此我们就不详解 <code>AIO</code> 了，有兴趣的同学可以参考<a href="http://www.52im.net/thread-306-1-1.html">《Java新一代网络编程模型AIO原理及Linux系统AIO介绍》</a></li>
</ol>
<h4 id="12-8-BIO、NIO、AIO对比表"><a href="#12-8-BIO、NIO、AIO对比表" class="headerlink" title="12.8 BIO、NIO、AIO对比表"></a>12.8 BIO、NIO、AIO对比表</h4><table>
<thead>
<tr>
<th></th>
<th>BIO</th>
<th>NIO</th>
<th>AIO</th>
</tr>
</thead>
<tbody><tr>
<td>IO模型</td>
<td>同步阻塞</td>
<td>同步非阻塞（多路复用）</td>
<td>异步非阻塞</td>
</tr>
<tr>
<td>编程难度</td>
<td>简单</td>
<td>复杂</td>
<td>复杂</td>
</tr>
<tr>
<td>可靠性</td>
<td>差</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>吞吐量</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
</tbody></table>
<p><strong>举例说明</strong></p>
<ol>
<li>同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。</li>
<li>同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说下，先干其他事情，一会过来看是否轮到自己.</li>
<li>异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发</li>
</ol>
<h3 id="13-参考"><a href="#13-参考" class="headerlink" title="13 参考"></a>13 参考</h3><p><a href="https://dongzl.github.io/netty-handbook/#/_content/chapter03">Java NIO编程</a></p>
<p><a href="https://www.bilibili.com/video/av76227904/">尚硅谷Ntty视频教程</a></p>
<p><a href="https://ke.qq.com/course/463900">尚硅谷Netty视频教程</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础概念</title>
    <url>/2021/10/24/Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h2><h3 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h3><ol>
<li>简单易学；</li>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性(Java虚拟机实现平台无关性)；</li>
<li>支持多线程；</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持网络编程并且很方便(Java语言诞生本身就是为简化网络编程设计的，因此Java语言不仅支持网络编程而且很方便)；</li>
<li>编译与解释并存；</li>
</ol>
<h3 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>Java虚拟机(JVM)是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现(Windows，Linux，Macos)，目的是使用相同的字节码,他们都会给出相同的结果。</p>
<h4 id="什么是字节码？采用字节码的"><a href="#什么是字节码？采用字节码的" class="headerlink" title="什么是字节码？采用字节码的"></a>什么是字节码？采用字节码的</h4><blockquote>
<p>在Java中，JVM可以理解的代码就叫做 <code>字节码</code> (即扩展名为<code>.class</code>的文件)，它不面向任何特定的处理器，只面向虚拟机。Java语言通过字节码的方式，在一定程度上解决了传统解型语言执行效率低的问题，同时又保留解释型语言可移值的特点。所以Java程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无需重新编译便可在多种不同操作系统的计算机上运行。</p>
</blockquote>
<p> <strong>Java 程序从源代码到运行一般有下面 3 步：</strong> </p>
<p><img src="/img/work/1634221350574.png"></p>
<p>我们需要格外注意的是.class -&gt; 机器码。在这一步JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了JIT编译器，而JIT编译器属于运行时编译。当JIT编译器完成第一次编译之后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定高于Java解释器的。这也解释了我们为什么经常会说Java是编译与解释共存的语言。</p>
<blockquote>
<p> HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。 </p>
</blockquote>
<p> <strong>总结：</strong> </p>
<p> Java 虚拟机（JVM）是运行 Java 字节码的虚拟机 。 JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，  它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。 </p>
<h4 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h4><p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器(javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。 </p>
<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。 </p>
<p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。 </p>
<h3 id="Java-语言“编译与解释并存"><a href="#Java-语言“编译与解释并存" class="headerlink" title="Java 语言“编译与解释并存"></a>Java 语言“编译与解释并存</h3><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读， 有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p>
<p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>*.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。</p>
<h3 id="Java-和-C-的区别"><a href="#Java-和-C-的区别" class="headerlink" title="Java 和 C++的区别"></a>Java 和 C++的区别</h3><ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li>
<li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li>
</ul>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>八个基本类型</p>
<ul>
<li>byte（字节型）</li>
<li>short（短整型）</li>
<li>int（整型）</li>
<li>long（长整型）</li>
<li>float（单精度浮点型）</li>
<li>double（双精度浮点型）</li>
<li>boolean（布尔型）</li>
<li>char（字符型）</li>
</ul>
<h3 id="对应包装类"><a href="#对应包装类" class="headerlink" title="对应包装类"></a>对应包装类</h3><ul>
<li>Byte</li>
<li>Short</li>
<li>Integer</li>
<li>Long</li>
<li>Float</li>
<li>Double</li>
<li>Boolean</li>
<li>Character</li>
</ul>
<h3 id="详细划分"><a href="#详细划分" class="headerlink" title="详细划分"></a>详细划分</h3><p><strong>具体可分为四类</strong></p>
<ul>
<li>整型 byte short int long</li>
<li>浮点型 float double</li>
<li>逻辑型 boolean</li>
<li>字符型 char</li>
</ul>
<h3 id="八种基本数据类型的默认值"><a href="#八种基本数据类型的默认值" class="headerlink" title="八种基本数据类型的默认值"></a>八种基本数据类型的默认值</h3><p><img src="/img/work/image-20211021215018133.png"></p>
<p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer x = <span class="hljs-number">2</span>;     <span class="hljs-comment">// 装箱</span><br><span class="hljs-keyword">int</span> y = x;         <span class="hljs-comment">// 拆箱</span><br></code></pre></td></tr></table></figure>



<h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于:</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer x = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">123</span>);<br>Integer y = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">123</span>);<br>System.out.println(x == y);    <span class="hljs-comment">// false</span><br>Integer z = Integer.valueOf(<span class="hljs-number">123</span>);<br>Integer k = Integer.valueOf(<span class="hljs-number">123</span>);<br>System.out.println(z == k);   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p><strong>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br><br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-comment">// high value may be configured by property</span><br>    <span class="hljs-keyword">int</span> h = <span class="hljs-number">127</span>;<br>    String integerCacheHighPropValue =<br>        sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>    <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">int</span> i = parseInt(integerCacheHighPropValue);<br>            i = Math.max(i, <span class="hljs-number">127</span>);<br>            <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>            <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>        &#125;<br>    &#125;<br>    high = h;<br><br>    cache = <span class="hljs-keyword">new</span> Integer[(high - low) + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> j = low;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>        cache[k] = <span class="hljs-keyword">new</span> Integer(j++);<br><br>    <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>    <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译器会<strong>在缓冲池范围内的基本类型</strong>自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer m = <span class="hljs-number">123</span>;<br>Integer n = <span class="hljs-number">123</span>;<br>System.out.println(m == n); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>基本类型对应的缓冲池如下:</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p>
<p>如果在缓冲池之外：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer m = <span class="hljs-number">323</span>;<br>Integer n = <span class="hljs-number">323</span>;<br>System.out.println(m == n); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>String 被声明为 final，因此它不可被继承。</p>
<p>内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br><br></code></pre></td></tr></table></figure>

<h3 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h3><p><strong>1. 可以缓存 hash 值</strong></p>
<p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
<p><strong>2. String Pool 的需要</strong></p>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p>
<p><img src="/img/work/image-20211021222448391.png"></p>
<p><strong>3. 安全性</strong></p>
<p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p>
<p><strong>4. 线程安全</strong></p>
<p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>
<h3 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h3><p><strong>1. 可变性</strong></p>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<p><strong>2. 线程安全</strong></p>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h3><p>使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用。intern() 首先把 s1 引用的对象放到 String Pool(字符串常量池)中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;aaa&quot;</span>);<br>String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;aaa&quot;</span>);<br>System.out.println(s1 == s2);           <span class="hljs-comment">// false</span><br>String s3 = s1.intern();<br>System.out.println(s1.intern() == s3);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String s4 = <span class="hljs-string">&quot;bbb&quot;</span>;<br>String s5 = <span class="hljs-string">&quot;bbb&quot;</span>;<br>System.out.println(s4 == s5);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>在 Java 7 之前，字符串常量池被放在运行时常量池中，它属于永久代。而在 Java 7，字符串常量池被移到 Native Method 中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p>
<p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中改变指针引用的对象，那么这两个指针此时指向的是完全不同的对象，一方改变其所指向对象的内容对另一方没有影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>    String name;<br><br>    Dog(String name) &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function">String <span class="hljs-title">getObjectAddress</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.toString();<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassByValueExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;A&quot;</span>);<br>        System.out.println(dog.getObjectAddress()); <span class="hljs-comment">// Dog@4554617c</span><br>        func(dog);<br>        System.out.println(dog.getObjectAddress()); <span class="hljs-comment">// Dog@4554617c</span><br>        System.out.println(dog.getName());          <span class="hljs-comment">// A</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Dog dog)</span> </span>&#123;<br>        System.out.println(dog.getObjectAddress()); <span class="hljs-comment">// Dog@4554617c</span><br>        dog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;B&quot;</span>);<br>        System.out.println(dog.getObjectAddress()); <span class="hljs-comment">// Dog@74a14482</span><br>        System.out.println(dog.getName());          <span class="hljs-comment">// B</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>但是如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassByValueExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;A&quot;</span>);<br>        func(dog);<br>        System.out.println(dog.getName());          <span class="hljs-comment">// B</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Dog dog)</span> </span>&#123;<br>        dog.setName(<span class="hljs-string">&quot;B&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="float-与-double"><a href="#float-与-double" class="headerlink" title="float 与 double"></a>float 与 double</h3><p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">float</span> f = <span class="hljs-number">1.1</span>;  <span class="hljs-comment">//编译错误</span><br></code></pre></td></tr></table></figure>

<p>1.1f 字面量才是 float 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">float</span> f = <span class="hljs-number">1.1f</span>;<br></code></pre></td></tr></table></figure>

<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">short</span> s1 = <span class="hljs-number">1</span>;<br>s1 = s1 + <span class="hljs-number">1</span>;  <span class="hljs-comment">//编译错误</span><br></code></pre></td></tr></table></figure>

<p>但是使用 += 运算符可以执行隐式类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">s1 += <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">s1 = (<span class="hljs-keyword">short</span>) (s1 + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String s = <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-keyword">switch</span> (s) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;a&quot;</span>:<br>        System.out.println(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;b&quot;</span>:<br>        System.out.println(<span class="hljs-string">&quot;bbb&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</strong></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>Java 中有三个访问权限修饰符: private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p>
<p>可以对类或类中的成员(字段以及方法)加上访问修饰符。</p>
<ul>
<li>类可见表示其它类可以用这个类创建实例对象。</li>
<li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li>
</ul>
<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p>
<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p>
<p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p>
<p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 共有字段，如果在某个时刻，我们想要使用 int 去存储 id 字段，那么就需要去修改所有的客户端代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessExample</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String id;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessExample</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id + <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = Integer.valueOf(id);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessWithInnerClassExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> x;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> InnerClass innerClass;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccessWithInnerClassExample</span><span class="hljs-params">()</span> </span>&#123;<br>        innerClass = <span class="hljs-keyword">new</span> InnerClass();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> innerClass.x;  <span class="hljs-comment">// 直接访问</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><p><strong>1. 抽象类</strong></p>
<p>抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</p>
<p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClassExample</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> y;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;func2&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractExtendClassExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClassExample</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;func1&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// AbstractClassExample ac1 = new AbstractClassExample(); // &#x27;AbstractClassExample&#x27; is abstract; cannot be instantiated</span><br>AbstractClassExample ac2 = <span class="hljs-keyword">new</span> AbstractExtendClassExample();<br>ac2.func1();<br><br></code></pre></td></tr></table></figure>

<p><strong>2. 接口</strong></p>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>
<p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p>
<p>接口的成员(字段 + 方法)默认都是 public 的，并且不允许定义为 private 或者 protected。</p>
<p>接口的字段默认都是 static 和 final 的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;func2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">123</span>;<br>    <span class="hljs-comment">// int y;               // Variable &#x27;y&#x27; might not have been initialized</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> z = <span class="hljs-number">0</span>;       <span class="hljs-comment">// Modifier &#x27;public&#x27; is redundant for interface fields</span><br>    <span class="hljs-comment">// private int k = 0;   // Modifier &#x27;private&#x27; not allowed here</span><br>    <span class="hljs-comment">// protected int l = 0; // Modifier &#x27;protected&#x27; not allowed here</span><br>    <span class="hljs-comment">// private void fun3(); // Modifier &#x27;private&#x27; not allowed here</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>3. 比较</strong></p>
<ul>
<li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li>
<li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>
<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li>
<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li>
</ul>
<p><strong>4. 使用选择</strong></p>
<p>使用接口:</p>
<ul>
<li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li>
<li>需要使用多重继承。</li>
</ul>
<p> 使用抽象类:</p>
<ul>
<li>需要在几个相关的类中共享代码。</li>
<li>需要能控制继承来的成员的访问权限，而不是都为 public。</li>
<li>需要继承非静态和非常量字段。</li>
</ul>
<p>在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul>
<li>访问父类的构造函数: 可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</li>
<li>访问父类的成员: 如果子类重写了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperExample</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> y;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SuperExample</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.x = x;<br>        <span class="hljs-keyword">this</span>.y = y;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;SuperExample.func()&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperExtendExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> z;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SuperExtendExample</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(x, y);<br>        <span class="hljs-keyword">this</span>.z = z;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.func();<br>        System.out.println(<span class="hljs-string">&quot;SuperExtendExample.func()&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><br>SuperExample e = <span class="hljs-keyword">new</span> SuperExtendExample(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>e.func();<br><br></code></pre></td></tr></table></figure>



<h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><p><strong>1. 重写(Override)</strong></p>
<p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p>
<p>为了满足里式替换原则，重写有有以下两个限制:</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
</ul>
<p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。</p>
<p><strong>2. 重载(Overload)</strong></p>
<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p>
<p>应该注意的是，返回值不同，其它都相同不算是重载。</p>
<h2 id="Object-通用方法"><a href="#Object-通用方法" class="headerlink" title="Object 通用方法"></a>Object 通用方法</h2><h3 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyAll</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, <span class="hljs-keyword">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;&#125;<br></code></pre></td></tr></table></figure>



<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p><strong>1. 等价关系</strong></p>
<p>(一)自反性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">x.equals(x); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>(二)对称性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">x.equals(y) == y.equals(x); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>(三)传递性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))<br>    x.equals(z); <span class="hljs-comment">// true;</span><br></code></pre></td></tr></table></figure>

<p>(四)一致性</p>
<p>多次调用 equals() 方法结果不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">x.equals(y) == x.equals(y); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>(五)与 null 的比较</p>
<p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">x.equals(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// false;</span><br></code></pre></td></tr></table></figure>



<p><strong>2. equals() 与 ==</strong></p>
<ul>
<li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer x = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br>Integer y = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br>System.out.println(x.equals(y)); <span class="hljs-comment">// true</span><br>System.out.println(x == y);      <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p><strong>3. 实现</strong></p>
<ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EqualExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> z;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EqualExample</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.x = x;<br>        <span class="hljs-keyword">this</span>.y = y;<br>        <span class="hljs-keyword">this</span>.z = z;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        EqualExample that = (EqualExample) o;<br><br>        <span class="hljs-keyword">if</span> (x != that.x) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (y != that.y) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> z == that.z;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p>
<p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p>
<p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">EqualExample e1 = <span class="hljs-keyword">new</span> EqualExample(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>EqualExample e2 = <span class="hljs-keyword">new</span> EqualExample(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>System.out.println(e1.equals(e2)); <span class="hljs-comment">// true</span><br>HashSet&lt;EqualExample&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>set.add(e1);<br>set.add(e2);<br>System.out.println(set.size());   <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<p>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p>
<p>一个数与 31 相乘可以转换成移位和减法: <code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">17</span>;<br>    result = <span class="hljs-number">31</span> * result + x;<br>    result = <span class="hljs-number">31</span> * result + y;<br>    result = <span class="hljs-number">31</span> * result + z;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToStringExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ToStringExample</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.number = number;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ToStringExample example = <span class="hljs-keyword">new</span> ToStringExample(<span class="hljs-number">123</span>);<br>System.out.println(example.toString());<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ToStringExample@4554617c<br></code></pre></td></tr></table></figure>

<h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p><strong>1. cloneable</strong></p>
<p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">CloneExample e1 = <span class="hljs-keyword">new</span> CloneExample();<br><span class="hljs-comment">// CloneExample e2 = e1.clone(); // &#x27;clone()&#x27; has protected access in &#x27;java.lang.Object&#x27;</span><br></code></pre></td></tr></table></figure>

<p>重写 clone() 得到以下实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> CloneExample <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> (CloneExample)<span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">CloneExample e1 = <span class="hljs-keyword">new</span> CloneExample();<br><span class="hljs-keyword">try</span> &#123;<br>    CloneExample e2 = e1.clone();<br>&#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">java.lang.CloneNotSupportedException: CloneExample<br></code></pre></td></tr></table></figure>

<p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>2. 浅拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用同一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShallowCloneExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ShallowCloneExample</span><span class="hljs-params">()</span> </span>&#123;<br>        arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            arr[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        arr[index] = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> arr[index];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> ShallowCloneExample <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> (ShallowCloneExample) <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ShallowCloneExample e1 = <span class="hljs-keyword">new</span> ShallowCloneExample();<br>ShallowCloneExample e2 = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    e2 = e1.clone();<br>&#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br>e1.set(<span class="hljs-number">2</span>, <span class="hljs-number">222</span>);<br>System.out.println(e2.get(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 222</span><br><br></code></pre></td></tr></table></figure>

<p><strong>3. 深拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用不同对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeepCloneExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DeepCloneExample</span><span class="hljs-params">()</span> </span>&#123;<br>        arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            arr[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        arr[index] = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> arr[index];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> DeepCloneExample <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        DeepCloneExample result = (DeepCloneExample) <span class="hljs-keyword">super</span>.clone();<br>        result.arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            result.arr[i] = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">DeepCloneExample e1 = <span class="hljs-keyword">new</span> DeepCloneExample();<br>DeepCloneExample e2 = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    e2 = e1.clone();<br>&#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br>e1.set(<span class="hljs-number">2</span>, <span class="hljs-number">222</span>);<br>System.out.println(e2.get(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 2</span><br><br></code></pre></td></tr></table></figure>

<p><strong>4. clone() 的替代方案</strong></p>
<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneConstructorExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CloneConstructorExample</span><span class="hljs-params">()</span> </span>&#123;<br>        arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            arr[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CloneConstructorExample</span><span class="hljs-params">(CloneConstructorExample original)</span> </span>&#123;<br>        arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[original.arr.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; original.arr.length; i++) &#123;<br>            arr[i] = original.arr[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        arr[index] = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> arr[index];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">CloneConstructorExample e1 = <span class="hljs-keyword">new</span> CloneConstructorExample();<br>CloneConstructorExample e2 = <span class="hljs-keyword">new</span> CloneConstructorExample(e1);<br>e1.set(<span class="hljs-number">2</span>, <span class="hljs-number">222</span>);<br>System.out.println(e2.get(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 2</span><br><br></code></pre></td></tr></table></figure>



<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p><strong>1. 数据</strong></p>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// x = 2;  // cannot assign value to final variable &#x27;x&#x27;</span><br><span class="hljs-keyword">final</span> A y = <span class="hljs-keyword">new</span> A();<br>y.a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p><strong>2. 方法</strong></p>
<p>声明方法不能被子类重写。</p>
<p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p>
<p><strong>3. 类</strong></p>
<p>声明类不允许被继承。</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>1. 静态变量</strong></p>
<p>静态变量: 又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。</p>
<p>实例变量: 每创建一个实例就会产生一个实例变量，它与该实例同生共死。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x;         <span class="hljs-comment">// 实例变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> y;  <span class="hljs-comment">// 静态变量</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// int x = A.x;  // Non-static field &#x27;x&#x27; cannot be referenced from a static context</span><br>        A a = <span class="hljs-keyword">new</span> A();<br>        <span class="hljs-keyword">int</span> x = a.x;<br>        <span class="hljs-keyword">int</span> y = A.y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>2. 静态方法</strong></p>
<p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法(abstract)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>&#123;<br>    &#125;<br>    <span class="hljs-comment">// public abstract static void func2();  // Illegal combination of modifiers: &#x27;abstract&#x27; and &#x27;static&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> y;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> a = x;<br>        <span class="hljs-comment">// int b = y;  // Non-static field &#x27;y&#x27; cannot be referenced from a static context</span><br>        <span class="hljs-comment">// int b = this.y;     // &#x27;A.this&#x27; cannot be referenced from a static context</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>3. 静态语句块</strong></p>
<p>静态语句块在类初始化时运行一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;123&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        A a1 = <span class="hljs-keyword">new</span> A();<br>        A a2 = <span class="hljs-keyword">new</span> A();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure>

<p><strong>4. 静态内部类</strong></p>
<p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClass</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// InnerClass innerClass = new InnerClass(); // &#x27;OuterClass.this&#x27; cannot be referenced from a static context</span><br>        OuterClass outerClass = <span class="hljs-keyword">new</span> OuterClass();<br>        InnerClass innerClass = outerClass.<span class="hljs-function">new <span class="hljs-title">InnerClass</span><span class="hljs-params">()</span></span>;<br>        StaticInnerClass staticInnerClass = <span class="hljs-keyword">new</span> StaticInnerClass();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<p><strong>5. 静态导包</strong></p>
<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> com.xxx.ClassName.*<br></code></pre></td></tr></table></figure>

<p><strong>6. 初始化顺序</strong></p>
<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String staticField = <span class="hljs-string">&quot;静态变量&quot;</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;静态语句块&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String field = <span class="hljs-string">&quot;实例变量&quot;</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&#123;<br>    System.out.println(<span class="hljs-string">&quot;普通语句块&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后才是构造函数的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InitialOrderTest</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;构造函数&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>存在继承的情况下，初始化顺序为:</p>
<ul>
<li>父类(静态变量、静态语句块)</li>
<li>子类(静态变量、静态语句块)</li>
<li>父类(实例变量、普通语句块)</li>
<li>父类(构造函数)</li>
<li>子类(实例变量、普通语句块)</li>
<li>子类(构造函数)</li>
</ul>
<p>引用自:</p>
<hr>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md</a></p>
<p><a href="https://www.pdai.tech/md/java/basic/java-basic-lan-basic.html">https://www.pdai.tech/md/java/basic/java-basic-lan-basic.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器之Map</title>
    <url>/2021/12/14/Java%E5%AE%B9%E5%99%A8%E4%B9%8BMap/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Map集合概述"><a href="#1-Map集合概述" class="headerlink" title="1.Map集合概述"></a>1.Map集合概述</h2><h3 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h3><blockquote>
<p>如果程序中存储了几百万个学生，而且经常需要使用学号来搜索某个学生，那么这个需求有效的数据结构就是Map。Map是一种依照键（key）存储元素的容器，键（key）很像下标，在List中下标是整数。在Map中键（key）可以使任意类型的对象。Map中不能有重复的键（Key），每个键（key）都有一个对应的值（value）。一个键（key）和它对应的值构成map集合中的一个元素。Map中的元素是两个对象，一个对象作为键，一个对象作为值。键不可以重复，但是值可以重复。</p>
</blockquote>
<h3 id="1-2-Map架构"><a href="#1-2-Map架构" class="headerlink" title="1.2 Map架构"></a>1.2 Map架构</h3><p><img src="/img/work/image-20211129105948926.png" alt="map集合关系图"></p>
<p>Map 家族主要成员功能如下：</p>
<ul>
<li><p><code>Map</code> 是 Map 容器家族的祖先，Map 是一个用于保存键值对(key-value)的接口。<strong>Map 中不能包含重复的键；每个键最多只能映射到一个值。</strong></p>
</li>
<li><p><code>AbstractMap</code> 继承了 <code>Map</code> 的抽象类，它实现了 <code>Map</code> 中的核心 API。其它 <code>Map</code> 的实现类可以通过继承 <code>AbstractMap</code> 来减少重复编码。</p>
</li>
<li><p><code>SortedMap</code> 继承了 <code>Map</code> 的接口。<code>SortedMap</code> 中的内容是排序的键值对，排序的方法是通过实现比较器(<code>Comparator</code>)完成的。</p>
</li>
<li><p><code>NavigableMap</code> 继承了 <code>SortedMap</code> 的接口。相比于 <code>SortedMap</code>，<code>NavigableMap</code> 有一系列的“导航”方法；如”获取大于/等于某对象的键值对”、“获取小于/等于某对象的键值对”等等。</p>
</li>
<li><p><code>HashMap</code> 继承了 <code>AbstractMap</code>，但没实现 <code>NavigableMap</code> 接口。<code>HashMap</code> 的主要作用是储存无序的键值对，而 <code>Hash</code> 也体现了它的查找效率很高。<code>HashMap</code> 是使用最广泛的 <code>Map</code>。</p>
</li>
<li><p><code>Hashtable</code> 虽然没有继承 <code>AbstractMap</code>，但它继承了 <code>Dictionary</code>（<code>Dictionary</code> 也是键值对的接口），而且也实现 <code>Map</code> 接口。因此，<code>Hashtable</code> 的主要作用是储存无序的键值对。和 HashMap 相比，<code>Hashtable</code> 在它的主要方法中使用 <code>synchronized</code> 关键字修饰，来保证线程安全。但是，由于它的锁粒度太大，非常影响读写速度，所以，现代 Java 程序几乎不会使用 <code>Hashtable</code> ，如果需要保证线程安全，一般会用 <code>ConcurrentHashMap</code> 来替代。</p>
</li>
<li><p><code>TreeMap</code> 继承了 <code>AbstractMap</code>，且实现了 <code>NavigableMap</code> 接口。<code>TreeMap</code> 的主要作用是储存有序的键值对，排序依据根据元素类型的 <code>Comparator</code> 而定。</p>
</li>
<li><p><code>WeakHashMap</code> 继承了 <code>AbstractMap</code>。<code>WeakHashMap</code> 的键是<strong>弱引用</strong> （即 <code>WeakReference</code>），它的主要作用是当 GC 内存不足时，会自动将 <code>WeakHashMap</code> 中的 key 回收，这避免了 <code>WeakHashMap</code> 的内存空间无限膨胀。很明显，<code>WeakHashMap</code> 适用于作为缓存。</p>
</li>
<li><p><code>LinkedHashMap</code>继承了HashMap,HashMap是无序的，当我们希望有顺序地去存储key-value时，就需要使用LinkedHashMap了。</p>
</li>
</ul>
<h3 id="1-3-Map集合与Collection集合的区别"><a href="#1-3-Map集合与Collection集合的区别" class="headerlink" title="1.3 Map集合与Collection集合的区别"></a>1.3 Map集合与Collection集合的区别</h3><ul>
<li>collection中的集合，元素是孤立存在的(单身狗)，向集合中存储元素采用一个个元素的方式存储。</li>
<li>map中的集合，元素是成对存在的(情侣、夫妻)，每个元素由键(key)与值(value)两个部分组成，通过键可以找到其所对应的值。</li>
<li>collection中的集合成为单列集合，map中的集合称为双列集合。</li>
<li>Collection接口的底层是由哈希表或哈希表+链表实现的。</li>
<li>Map接口的底层是由哈希表和链接列表实现的。</li>
</ul>
<h3 id="1-4-Map集合特点"><a href="#1-4-Map集合特点" class="headerlink" title="1.4 Map集合特点"></a>1.4 Map集合特点</h3><ul>
<li><p>Map集合是一个双列集合，一个元素包含两个值（一个key，一个value）。</p>
</li>
<li><p>Map集合中的元素，key和value的数据类型可以相同，也可以不同。</p>
</li>
<li><p>Map集合中的元素，key是不允许重复的， value是可以重复的。</p>
</li>
<li><p>Map集合中的元素，key和 value是一一对应的。</p>
</li>
</ul>
<h3 id="1-4-Map-接口"><a href="#1-4-Map-接口" class="headerlink" title="1.4 Map 接口"></a>1.4 Map 接口</h3><p>Map 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>Map 是一个用于保存键值对(key-value)的接口。<strong>Map 中不能包含重复的键；每个键最多只能映射到一个值。</strong></p>
<p>Map 接口提供三种 <code>Collection</code> 视图，允许以<strong>键集</strong>、<strong>值集</strong>或<strong>键-值映射关系集</strong>的形式访问数据。</p>
<p>Map 有些实现类，可以有序的保存元素，如 <code>TreeMap</code>；另一些实现类则不保证顺序，如 <code>HashMap</code> 类。</p>
<p>Map 的实现类应该提供 2 个“标准的”构造方法：</p>
<ul>
<li>void（无参数）构造方法，用于创建空 Map；</li>
<li>带有单个 Map 类型参数的构造方法，用于创建一个与其参数具有相同键-值映射关系的新 Map。</li>
</ul>
<p>实际上，后一个构造方法允许用户复制任意 Map，生成所需类的一个等价 Map。尽管无法强制执行此建议（因为接口不能包含构造方法），但是 JDK 中所有通用的 Map 实现都遵从它。</p>
<p><strong>Map.Entry 接口:</strong></p>
<p><code>Map.Entry</code> 一般用于通过迭代器（<code>Iterator</code>）访问问 <code>Map</code>。</p>
<p><code>Map.Entry</code> 是 Map 中内部的一个接口，<code>Map.Entry</code> 代表了 <strong>键值对</strong> 实体，Map 通过 <code>entrySet()</code> 获取 <code>Map.Entry</code> 集合，从而通过该集合实现对键值对的操作。</p>
<h3 id="1-5-Map接口常用的方法"><a href="#1-5-Map接口常用的方法" class="headerlink" title="1.5 Map接口常用的方法"></a>1.5 Map接口常用的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span></span><br><span class="hljs-function"><span class="hljs-comment">// 把指定的键与指定的值添加到Map集合中。</span></span><br><span class="hljs-function"> </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span></span><br><span class="hljs-function"><span class="hljs-comment">// 把指定的键所对应的键值对元素在Map集合中删除,返回被删除元素的值</span></span><br><span class="hljs-function"> </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span></span><br><span class="hljs-function"><span class="hljs-comment">// 根据指定的键,在Map集合中获取对应的值。</span></span><br><span class="hljs-function"> </span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(Object key)</span></span><br><span class="hljs-function"><span class="hljs-comment">// 判断集合中是否包含指定的键。</span></span><br><span class="hljs-function"> </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;K&gt; <span class="hljs-title">keySet</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">// 获取Map集合中所有的键,存储到Set集合中。</span></span><br><span class="hljs-function"> </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Map. Entry&lt;K,V&gt; <span class="hljs-title">entrySet</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">// 获取到Map集合中所有的键值对对象的集合(Set集合)。</span></span><br></code></pre></td></tr></table></figure>



<h2 id="2-HashMap"><a href="#2-HashMap" class="headerlink" title="2.HashMap"></a>2.HashMap</h2><blockquote>
<p> 底层是哈希表数据结构，线程是不同步的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法。 </p>
</blockquote>
<h3 id="2-1-HashMap要点"><a href="#2-1-HashMap要点" class="headerlink" title="2.1 HashMap要点"></a>2.1 HashMap要点</h3><p>从 <code>HashMap</code> 的命名，也可以看出：**<code>HashMap</code> 以散列方式存储键值对**。 </p>
<p><strong><code>HashMap</code> 允许使用空值和空键</strong>。（<code>HashMap</code> 类大致等同于 <code>Hashtable</code>，除了它是不同步的并且允许为空值。）这个类不保序；特别是，它的元素顺序可能会随着时间的推移变化。 </p>
<p><strong><code>HashMap</code> 有两个影响其性能的参数：初始容量和负载因子</strong>。 </p>
<ul>
<li>容量是哈希表中桶的数量，初始容量就是哈希表创建时的容量。</li>
<li>加载因子是散列表在其容量自动扩容之前被允许的最大饱和量。当哈希表中的 entry 数量超过负载因子和当前容量的乘积时，散列表就会被重新映射（即重建内部数据结构），一般散列表大约是存储桶数量的两倍。</li>
</ul>
<p>通常，默认加载因子（0.75）在时间和空间成本之间提供了良好的平衡。较高的值会减少空间开销，但会增加查找成本（反映在大部分 <code>HashMap</code> 类的操作中，包括 <code>get</code> 和 <code>put</code>）。在设置初始容量时，应考虑映射中的条目数量及其负载因子，以尽量减少重新运行操作的次数。如果初始容量大于最大入口数除以负载因子，则不会发生重新刷新操作。 </p>
<p>如果许多映射要存储在 <code>HashMap</code> 实例中，使用足够大的容量创建映射将允许映射存储的效率高于根据需要执行自动重新散列以增长表。请注意，使用多个具有相同 <code>hashCode()</code> 的密钥是降低任何散列表性能的一个可靠方法。为了改善影响，当键是 <code>Comparable</code> 时，该类可以使用键之间的比较顺序来帮助断开关系。 </p>
<p> <code>HashMap</code> 不是线程安全的。 </p>
<h3 id="2-2-HashMap-原理"><a href="#2-2-HashMap-原理" class="headerlink" title="2.2. HashMap 原理"></a>2.2. HashMap 原理</h3><p><strong>HashMap 数据结构</strong></p>
<p><code>HashMap</code> 的核心字段 </p>
<ul>
<li><code>table</code> - <code>HashMap</code> 使用一个 <code>Node[]</code> 类型的数组 <code>table</code> 来储存元素。</li>
<li><code>size</code> - 初始容量。 初始为 16，每次容量不够自动扩容</li>
<li><code>loadFactor</code> - 负载因子。自动扩容之前被允许的最大饱和量，默认 0.75。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">// 该表在初次使用时初始化，并根据需要调整大小。分配时，长度总是2的幂。</span><br>    <span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br>    <span class="hljs-comment">// 保存缓存的 entrySet()。请注意，AbstractMap 字段用于 keySet() 和 values()。</span><br>    <span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<br>    <span class="hljs-comment">// map 中的键值对数</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-comment">// 这个HashMap被结构修改的次数结构修改是那些改变HashMap中的映射数量或者修改其内部结构（例如，重新散列）的修改。</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;<br>    <span class="hljs-comment">// 下一个调整大小的值（容量*加载因子）。</span><br>    <span class="hljs-keyword">int</span> threshold;<br>    <span class="hljs-comment">// 散列表的加载因子</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>HashMap 构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 默认加载因子0.75</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span></span>; <span class="hljs-comment">// 默认加载因子0.75；以 initialCapacity 初始化容量</span><br><span class="hljs-comment">// 以 initialCapacity 初始化容量；以 loadFactor 初始化加载因子</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> <span class="hljs-comment">// 默认加载因子0.75</span></span><br></code></pre></td></tr></table></figure>

<p> <strong>put 方法的实现</strong></p>
<p> put 方法大致的思路为： </p>
<ul>
<li>对 key 的 <code>hashCode()</code> 做 hash 计算，然后根据 hash 值再计算 Node 的存储位置;</li>
<li>如果没有哈希碰撞，直接放到桶里；如果有哈希碰撞，以链表的形式存在桶后。</li>
<li>如果哈希碰撞导致链表过长(大于等于 <code>TREEIFY_THRESHOLD</code>，数值为 8)，就把链表转换成红黑树；</li>
<li>如果节点已经存在就替换旧值</li>
<li>桶数量超过容量*负载因子（即 load factor * current capacity），HashMap 调用 <code>resize</code> 自动扩容一倍</li>
</ul>
<p> 具体代码的实现如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>&#125;<br><br><span class="hljs-comment">// hashcode 无符号位移 16 位</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>    <span class="hljs-comment">// tab 为空则创建</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// 计算 index，并对 null 做处理</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 节点存在</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-comment">// 该链为树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 该链为链表</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 写入</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            V oldValue = e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为什么计算 hash 使用 hashcode 无符号位移 16 位? </p>
<p>假设要添加两个对象 a 和 b，如果数组长度是 16，这时对象 a 和 b 通过公式 (n - 1) &amp; hash 运算，也就是 (16-1)＆a.hashCode 和 (16-1)＆b.hashCode，15 的二进制为 0000000000000000000000000001111，假设对象 A 的 hashCode 为 1000010001110001000001111000000，对象 B 的 hashCode 为 0111011100111000101000010100000，你会发现上述与运算结果都是 0。这样的哈希结果就太让人失望了，很明显不是一个好的哈希算法。</p>
<p>但如果我们将 hashCode 值右移 16 位（h &gt;&gt;&gt; 16 代表无符号右移 16 位），也就是取 int 类型的一半，刚好可以将该二进制数对半切开，并且使用位异或运算（如果两个数对应的位置相反，则结果为 1，反之为 0），这样的话，就能避免上面的情况发生。这就是 hash() 方法的具体实现方式。<strong>简而言之，就是尽量打乱 hashCode 真正参与运算的低 16 位。</strong></p>
<p><strong>get 方法的实现</strong> </p>
<p> 在理解了 put 之后，get 就很简单了。大致思路如下： </p>
<ul>
<li>对 key 的 hashCode() 做 hash 计算，然后根据 hash 值再计算桶的 index</li>
<li>如果桶中的第一个节点命中，直接返回；</li>
<li> 如果有冲突，则通过 <code>key.equals(k)</code> 去查找对应的 entry </li>
<li>若为树，则在红黑树中通过 key.equals(k) 查找，O(logn)；</li>
<li>若为链表，则在链表中通过 key.equals(k) 查找，O(n)。</li>
</ul>
<p> 具体代码的实现如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-keyword">int</span> n; K k;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 直接命中</span><br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-comment">// 未命中</span><br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 在树中 get</span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <span class="hljs-comment">// 在链表中 get</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>hash 方法的实现:</strong></p>
<p> HashMap **计算桶下标（index）公式：<code>key.hashCode() ^ (h &gt;&gt;&gt; 16)</code>**。 </p>
<p> 下面针对这个公式来详细讲解。 </p>
<p> 在 <code>get</code> 和 <code>put</code> 的过程中，计算下标时，先对 <code>hashCode</code> 进行 <code>hash</code> 操作，然后再通过 <code>hash</code> 值进一步计算下标，如下图所示： </p>
<p><img src="/img/work/1638192040292.png"></p>
<p> 在对 <code>hashCode()</code> 计算 hash 时具体实现是这样的： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到这个方法大概的作用就是：高 16bit 不变，低 16bit 和高 16bit 做了一个异或。 </p>
<p>在设计 hash 方法时，因为目前的 table 长度 n 为 2 的幂，而计算下标的时候，是这样实现的(使用 <code>&amp;</code> 位操作，而非 <code>%</code> 求余)： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">(n - <span class="hljs-number">1</span>) &amp; hash<br></code></pre></td></tr></table></figure>

<p>设计者认为这方法很容易发生碰撞。为什么这么说呢？不妨思考一下，在 n - 1 为 15(0x1111) 时，其实散列真正生效的只是低 4bit 的有效位，当然容易碰撞了。 </p>
<p>因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高 16bit 和低 16bit 异或了一下。设计者还解释到因为现在大多数的 hashCode 的分布已经很不错了，就算是发生了碰撞也用 O(logn)的 tree 去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table 长度比较小时)，从而引起的碰撞。 </p>
<p>如果还是产生了频繁的碰撞，会发生什么问题呢？作者注释说，他们使用树来处理频繁的碰撞(we use trees to handle large sets of collisions in bins)，在 <a href="http://openjdk.java.net/jeps/180">JEP-180 (opens new window)</a>中，描述了这个问题： </p>
<blockquote>
<p> Improve the performance of java.util.HashMap under high hash-collision conditions by using balanced trees rather than linked lists to store map entries. Implement the same improvement in the LinkedHashMap class. </p>
</blockquote>
<p>之前已经提过，在获取 HashMap 的元素时，基本分两步： </p>
<ol>
<li>首先根据 hashCode()做 hash，然后确定 bucket 的 index；</li>
<li>如果 bucket 的节点的 key 不是我们需要的，则通过 keys.equals()在链中找。</li>
</ol>
<p>在 JDK8 之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行 get 时，两步的时间复杂度是 O(1)+O(n)。因此，当碰撞很厉害的时候 n 很大，O(n)的速度显然是影响速度的。 </p>
<p>因此在 JDK8 中，利用红黑树替换链表，这样复杂度就变成了 O(1)+O(logn)了，这样在 n 很大的时候，能够比较理想的解决这个问题，在 JDK8：HashMap 的性能提升一文中有性能测试的结果。 </p>
<p>如果对Hashcode计算还是不太清楚，建议参考下这位博主:</p>
<p><a href="https://blog.csdn.net/qq_33709582/article/details/113337405"><strong>真正搞懂hashCode和hash算法</strong></a></p>
<p> <strong>resize 的实现</strong></p>
<p>当 <code>put</code> 时，如果发现目前的 bucket 占用程度已经超过了 Load Factor 所希望的比例，那么就会发生 resize。在 resize 的过程，简单的说就是把 bucket 扩充为 2 倍，之后重新计算 index，把节点再放到新的 bucket 中。 </p>
<p>当超过限制的时候会 resize，然而又因为我们使用的是 2 次幂的扩展(指长度扩为原来 2 倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。 </p>
<p>怎么理解呢？例如我们从 16 扩展为 32 时，具体的变化如下所示： </p>
<p> <img src="/img/work/HashMap-resize-01.png"> </p>
<p>因此元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化： </p>
<p> <img src="/img/work/HashMap-resize-02.png"> </p>
<p>因此，我们在扩充 HashMap 的时候，不需要重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原索引+oldCap”。可以看看下图为 16 扩充为 32 的 resize 示意图： </p>
<p> <img src="/img/work/HashMap-resize-03.png"> </p>
<p>这个设计确实非常的巧妙，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 resize 的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-keyword">int</span> oldThr = threshold;<br>    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 没超过最大值，就扩充为原来的 2 倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br><br>    <span class="hljs-comment">// 计算新的 resize 上限</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?<br>                    (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 把每个 bucket 都移动到新的 buckets 中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// 原索引</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-comment">// 原索引+oldCap</span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">// 原索引放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                        loTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-comment">// 原索引+oldCap放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="3-LinkedHashMap-类"><a href="#3-LinkedHashMap-类" class="headerlink" title="3. LinkedHashMap 类"></a>3. LinkedHashMap 类</h2><p><img src="/img/work/1638877273531.png" alt="LinkedHashMap关系图"></p>
<h3 id="3-1-LinkedHashMap-要点"><a href="#3-1-LinkedHashMap-要点" class="headerlink" title="3.1. LinkedHashMap 要点"></a>3.1. LinkedHashMap 要点</h3><p><strong><code>LinkedHashMap</code> 通过维护一个保存所有条目（Entry）的双向链表，保证了元素迭代的顺序（即插入顺序）</strong>。 </p>
<table>
<thead>
<tr>
<th>关注点</th>
<th>结论</th>
</tr>
</thead>
<tbody><tr>
<td>是否允许键值对为 null</td>
<td>Key 和 Value 都允许 null</td>
</tr>
<tr>
<td>是否允许重复数据</td>
<td>Key 重复会覆盖、Value 允许重复</td>
</tr>
<tr>
<td>是否有序</td>
<td>按照元素插入顺序存储</td>
</tr>
<tr>
<td>是否线程安全</td>
<td>非线程安全</td>
</tr>
</tbody></table>
<h3 id="3-2-LinkedHashMap和HashMap区别"><a href="#3-2-LinkedHashMap和HashMap区别" class="headerlink" title="3.2 LinkedHashMap和HashMap区别"></a>3.2 LinkedHashMap和HashMap区别</h3><p> 从上面的类图中我们可以看到,<code>LinkedHashMap</code>直接继承自<code>HashMap</code>，所以<code>LinkedHashMap</code>拥有<code>HashMap</code>的大部分特性，最多只允许一个<code>key</code>为<code>null</code>，可以有多个<code>value</code>为<code>null</code>。一些主要的方法和属性也直接继承自<code>HashMap</code>，并对其中某些方法进行了重写。<code>LinkedHashMap</code>与<code>HashMap</code>最大的不同在于<code>LinkedHashMap</code>保持了元素的有序性，即遍历<code>LinkedHashMap</code>的时候，得到的元素的顺序与添加元素的顺序是相同的，可以按照插入序 <code>(insertion-order)</code>或访问序 <code>(access-order)</code>来对哈希表中的元素进行遍历。 </p>
<blockquote>
<p>所谓插入顺序，就是 <code>Entry</code>被添加到 <code>Map</code> 中的顺序，更新一个 <code>Key</code> 关联的 <code>Value</code> 并不会对插入顺序造成影响,而访问顺序则是对所有 <code>Entry</code> 按照最近访问<code>(least-recently)</code>到最远访问<code>(most-recently)</code>进行排序，读写都会影响到访问顺序，但是对迭代器 <code>(entrySet(), keySet(), values())</code> 的访问不会影响到访问顺序。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用<code>get</code>方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。 </p>
</blockquote>
<h3 id="3-3-顺序存取原理"><a href="#3-3-顺序存取原理" class="headerlink" title="3.3 顺序存取原理"></a>3.3 顺序存取原理</h3><p><code>LinkedHashMap</code>之所以能实现存取的顺序性，主要是他重新定义了 <code>Entry</code> ，这个新的 <code>Entry</code> 继承自<code>HashMap.Node</code>，并做了新的扩展，下面我们结合源码来分析一下。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>.<span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    Entry&lt;K,V&gt; before, after;<br>    Entry(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword">super</span>(hash, key, value, next);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="3-3-存取结构"><a href="#3-3-存取结构" class="headerlink" title="3.3 存取结构"></a>3.3 存取结构</h3><p>由上面的代码我们可以看出，这个自定义的 <code>Entry</code>比 <code>HashMap.Node</code>多了两个属性，<code>before</code>和<code>after</code>。正是使用这两个关键的属性，在<code>LinkedHashMap</code>内部实现了一个双向链表。数据结构的知识大家再回忆一下（想不起来的可以去面壁了），双向链表就是每个节点除了存储数据本身之外，还保存着两个指针，在<code>java</code>里面就是指向对象的引用，一个是前驱节点，也就是他的前一个节点的引用，一个是后继节点，也就是他的后一个节点的引用。这样，就可以实现存储一个有序节点的数据结构了。（这里说明下，在jdk1.7中，使用的结构为环形双向链表）另外，继承自<code>HashMap.Node</code>的<code>Entry</code>自身还保留着用于维持单链表的<code>next</code>属性，因此<code>LinkedHashMap</code>的<code>Entry</code>节点具有三个指针域，<code>next</code>指针维护<code>Hash</code>桶中冲突<code>key</code>的链表，<code>before</code>和<code>after</code>维护双向链表。结构如下图所示： </p>
<p> <img src="/img/work/LinkedHashMap.png" alt="LinkedHashMap存储结构"> </p>
<p>以上就是<code>LinkedHashMap</code>的数据结构，但是光有数据机构显然无法完成有序的存取，下面我们继续来看一下，<code>LinkedHashMap</code>的存取过程。 </p>
<h3 id="3-4-存取过程"><a href="#3-4-存取过程" class="headerlink" title="3.4 存取过程"></a>3.4 存取过程</h3><p>上面提到<code>LinkedHashMap</code>继承自<code>HashMap</code>，所以，<code>LinkedHashMap</code>的自身便拥有了<code>HashMap</code>全部的属性和方法。由代码我们也能看出，<code>LinkedHashMap</code>自身并没有实现<code>put</code>方法，而是直接使用其父类<code>HashMap</code>的<code>put</code>方法。不同的是，在创建<code>Entry</code>时，重写了父类的<code>newNode(int hash, K key, V value, Node e) &#123;&#125;</code>方法，并实现了父类预留的回调方法，通过重写父类的方法和回调方法，<code>LinkedHashMap</code>扩展了<code>HashMap</code>，使其拥有了保持存取顺序性的能力。从这点我们也可以看出，<code>java</code>的开发团队将这一功能实现的比较优雅，其中的思想值得我们在开发中借鉴和学习，这也是我们阅读<code>java</code>源码的意义所在。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建新的节点</span><br> <span class="hljs-function">Node&lt;K,V&gt; <span class="hljs-title">newNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;<br>     LinkedHashMap.Entry&lt;K,V&gt; p =<br>         <span class="hljs-keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);<br>     linkNodeLast(p);<br>     <span class="hljs-keyword">return</span> p;<br> &#125;<br> <span class="hljs-comment">// link at the end of list</span><br> <span class="hljs-comment">//将节点添加到双向链表尾部</span><br> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">linkNodeLast</span><span class="hljs-params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;<br>     LinkedHashMap.Entry&lt;K,V&gt; last = tail;<br>     tail = p;<br>     <span class="hljs-keyword">if</span> (last == <span class="hljs-keyword">null</span>)<br>         head = p;<br>     <span class="hljs-keyword">else</span> &#123;<br>         p.before = last;<br>         last.after = p;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<p><code>LinkedHashMap</code>的<code>put</code>过程和<code>HashMap</code>大致相同，包括计算<code>hash</code>值、计算<code>table</code>数组索引、判断数组是否为空等步骤，不同的是创建节点的过程。从上面的代码中我们可以看出，重写的这个<code>newNode</code>方法代码比较简洁，首先实例化一个双链表结构的<code>Entry p</code>，这里会首先调用其父类 <code>HashMap.Node</code>的构造方法，维护着一个单链表的结构。实例化结束后，会调用一个<code>linkNodeLast</code>的私有方法，这个方法完成了将新的元素添加至双向链表的尾部的功能。我们知道，在<code>HashMap</code>中，如果单链表超过一定的长度，就会被转换为红黑树，那么在<code>LinkedHashMap</code>中也是同样的逻辑，于是就有了下面的代码。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建新的红黑树节点</span><br><span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">newTreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;<br>     TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">new</span> TreeNode&lt;K,V&gt;(hash, key, value, next);<br>     linkNodeLast(p);<br>     <span class="hljs-keyword">return</span> p;<br> &#125;<br> <span class="hljs-comment">//将链表节点转换为红黑树节点</span><br> <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">replacementTreeNode</span><span class="hljs-params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;<br>     LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;<br>     TreeNode&lt;K,V&gt; t = <span class="hljs-keyword">new</span> TreeNode&lt;K,V&gt;(q.hash, q.key, q.value, next);<br>     transferLinks(q, t);<span class="hljs-comment">//将双向链表中的TreeNode替换为新的普通节点</span><br>     <span class="hljs-keyword">return</span> t;<br> &#125;<br></code></pre></td></tr></table></figure>

<p>这两个也是被重写的方法，当存储结构为红黑树的时候，调用<code>newTreeNode</code>方法创建红黑树节点。当需要将链表转换为红黑树结构时，调用<code>replacementTreeNode</code>方法将双向链表中的<code>TreeNode</code>替换为新的链表节点。<br>由以上分析过程可以得出结论，在 <code>LinkedHashMap</code> 中，所有的 <code>Entry</code> 都被串联在一个双向链表中。每次在新建一个节点时都会将新建的节点链接到双向链表的末尾。这样从双向链表的尾部向头部遍历就可以保证插入顺序了，头部节点是最早添加的节点，而尾部节点则是最近添加的节点。上面我们还提到，<code>LinkedHashMap</code>可以实现插入的顺序和访问的顺序，那么访问的顺序是怎样实现的呢？下面我们来看一下。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>();<br>    accessOrder = <span class="hljs-keyword">false</span>;<br>    putMapEntries(m, <span class="hljs-keyword">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<p>我们通过观察<code>LinkedHashMap</code>的构造函数可以发现有这样一个字段，<code>accessOrder</code>，他的初始值为<code>false</code>。这个字段的意思是是否使用访问序,所以<code>LinkedHashMap</code>的默认顺序为插入顺序。上文我们提到了在<code>HashMap</code>类中预留了几个回调方法，这几个方法在<code>HashMap</code>中并没有实现，而在<code>LinkedHashMap</code>中这几个方法都有了具体的实现,这些方法就是为了实现访问序，下面我们结合代码来看一下。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//移除节点的回调方法</span><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeRemoval</span><span class="hljs-params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="hljs-comment">// unlink</span><br>     <span class="hljs-comment">//移除一个节点，双向链表中的连接关系需要调整</span><br>     LinkedHashMap.Entry&lt;K,V&gt; p =<br>         (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;<br>     p.before = p.after = <span class="hljs-keyword">null</span>;<br>     <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>)<br>         head = a;<br>     <span class="hljs-keyword">else</span><br>         b.after = a;<br>     <span class="hljs-keyword">if</span> (a == <span class="hljs-keyword">null</span>)<br>         tail = b;<br>     <span class="hljs-keyword">else</span><br>         a.before = b;<br> &#125;<br><span class="hljs-comment">//插入节点的回调方法</span><br><span class="hljs-comment">//构造方法中调用 putMapEntries调用时  evict为false </span><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeInsertion</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123; <span class="hljs-comment">// possibly remove eldest</span><br>     LinkedHashMap.Entry&lt;K,V&gt; first;<br>    <span class="hljs-comment">//first是头元素，也是最老的元素</span><br>    <span class="hljs-comment">//在插入序中，就是最先插入的元素</span><br>    <span class="hljs-comment">//在访问序中，就是最远被访问的元素</span><br>    <span class="hljs-comment">//这里removeEldestEntry(first)始终返回true，即不删除最老的元素</span><br>    <span class="hljs-comment">//如果是一个容量固定的cache，可调整removeEldestEntry(first)的实现</span><br>     <span class="hljs-keyword">if</span> (evict &amp;&amp; (first = head) != <span class="hljs-keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;<br>         K key = first.key;<br>         removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>     &#125;<br> &#125;<br> <span class="hljs-comment">//访问元素之后的回调方法</span><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="hljs-comment">// move node to last</span><br>     LinkedHashMap.Entry&lt;K,V&gt; last;<br>    <span class="hljs-comment">//如果是访问序，且当前节点并不是尾节点</span><br>    <span class="hljs-comment">//将该节点置为双向链表的尾部</span><br>     <span class="hljs-keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;<br>         LinkedHashMap.Entry&lt;K,V&gt; p =<br>             (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;<br>         p.after = <span class="hljs-keyword">null</span>;<br>         <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>)<br>             head = a;<br>         <span class="hljs-keyword">else</span><br>             b.after = a;<br>         <span class="hljs-keyword">if</span> (a != <span class="hljs-keyword">null</span>)<br>             a.before = b;<br>         <span class="hljs-keyword">else</span><br>             last = b;<br>         <span class="hljs-keyword">if</span> (last == <span class="hljs-keyword">null</span>)<br>             head = p;<br>         <span class="hljs-keyword">else</span> &#123;<br>             p.before = last;<br>             last.after = p;<br>         &#125;<br>         tail = p;<br>         ++modCount;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<p>在插入节点、删除节点和访问节点后会调用相应的回调函数。可以看到，在 <code>afterNodeAccess</code> 方法中，如果该<code>LinkedHashMap</code>是访问序，且当前访问的节点不是尾部节点，则该节点会被置为双链表的尾节点。即，在访问序下，最近访问的节点会是尾节点，头节点则是最远访问的节点。</p>
<h3 id="3-5-遍历"><a href="#3-5-遍历" class="headerlink" title="3.5 遍历"></a>3.5 遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//所有的节点都被串联在双向链表中，迭代器在迭代时可以利用双向链表的链接关系进行</span><br><span class="hljs-comment">//双向链表的顺序是按照插入序或访问序排列的</span><br><span class="hljs-comment">// Iterators</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedHashIterator</span> </span>&#123;<br>    LinkedHashMap.Entry&lt;K,V&gt; next;<br>    LinkedHashMap.Entry&lt;K,V&gt; current;<br>    <span class="hljs-keyword">int</span> expectedModCount;<br>    LinkedHashIterator() &#123;<br>        next = head;<br>        expectedModCount = modCount;<br>        current = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> next != <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> LinkedHashMap.<span class="hljs-function">Entry&lt;K,V&gt; <span class="hljs-title">nextNode</span><span class="hljs-params">()</span> </span>&#123;<br>        LinkedHashMap.Entry&lt;K,V&gt; e = next;<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>        current = e;<br>        next = e.after;<span class="hljs-comment">//直接访问after引用</span><br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>        Node&lt;K,V&gt; p = current;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>        current = <span class="hljs-keyword">null</span>;<br>        K key = p.key;<br>        removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);<br>        expectedModCount = modCount;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>可以看到，在遍历所有节点时是通过节点的 <code>after</code> 引用进行的。这样，可以从双链表的头部遍历到到双链表的尾部。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_33642117/article/details/52049764"><strong>Java Map集合的详解</strong></a></p>
<p><a href="https://blog.csdn.net/qq_33709582/article/details/113337405"><strong>真正搞懂hashCode和hash算法</strong></a></p>
<p><a href="https://dunwu.github.io/javacore/container/java-container-map.html#_1-map-%E7%AE%80%E4%BB%8B"> <strong>Java 容器之 Map</strong> </a></p>
<p><a href="https://www.cnblogs.com/liyihua/p/12199448.html"><strong>对Map集合的学习</strong></a></p>
<p><a href="https://yanglukuan.github.io/2017/09/05/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BLinkedHashMap%E8%AF%A6%E8%A7%A3/"><strong>Java集合框架之LinkedHashMap</strong></a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java-容器</category>
      </categories>
      <tags>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发容器</title>
    <url>/2022/06/02/Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-同步容器"><a href="#1-同步容器" class="headerlink" title="1. 同步容器"></a>1. 同步容器</h2><h3 id="1-1-同步容器简介"><a href="#1-1-同步容器简介" class="headerlink" title="1.1. 同步容器简介"></a>1.1. 同步容器简介</h3><p>在 Java 中，同步容器主要包括 2 类： </p>
<ul>
<li> <code>Vector</code>、<code>Stack</code>、<code>Hashtable</code> </li>
<li> <code>Vector</code> - <code>Vector</code> 实现了 <code>List</code> 接口。 <code>Vector</code> 实际上就是一个数组，和 <code>ArrayList</code> 类似。但是 <code>Vector</code> 中的方法都是 <code>synchronized</code> 方法，即进行了同步措施。 </li>
<li><code>Stack</code> - <code>Stack</code> 也是一个同步容器，它的方法也用 <code>synchronized</code> 进行了同步，它实际上是继承于 <code>Vector</code> 类。</li>
<li><code>Hashtable</code>- <code>Hashtable</code> 实现了 <code>Map</code> 接口，它和 <code>HashMap</code> 很相似，但是 <code>Hashtable</code> 进行了同步处理，而 <code>HashMap</code> 没有。</li>
<li><code>Collections</code> 类中提供的静态工厂方法创建的类（由 <code>Collections.synchronizedXXX</code> 等方法）</li>
</ul>
<h3 id="1-2-同步容器的问题"><a href="#1-2-同步容器的问题" class="headerlink" title="1.2. 同步容器的问题"></a>1.2. 同步容器的问题</h3><p>同步容器的同步原理就是在其 <code>get</code>、<code>set</code>、<code>size</code> 等主要方法上用 <code>synchronized</code> 修饰。 <strong><code>synchronized</code> 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块</strong>。 </p>
<p><strong>性能问题</strong></p>
<p><code>synchronized</code> 的互斥同步会产生阻塞和唤醒线程的开销。显然，这种方式比没有使用 <code>synchronized</code> 的容器性能要差很多。 </p>
<blockquote>
<p> 注：尤其是在 Java 1.6 没有对 <code>synchronized</code> 进行优化前，阻塞开销很高。 </p>
</blockquote>
<p><strong>安全问题</strong></p>
<p>同步容器真的绝对安全吗？ </p>
<p>其实也未必。在做复合操作（非原子操作）时，仍然需要加锁来保护。常见复合操作如下： </p>
<ul>
<li><strong>迭代</strong>：反复访问元素，直到遍历完全部元素；</li>
<li><strong>跳转</strong>：根据指定顺序寻找当前元素的下一个（下 n 个）元素；</li>
<li><strong>条件运算</strong>：例如若没有则添加等；</li>
</ul>
<p>❌ 不安全的示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VectorDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> Vector&lt;Integer&gt; vector = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            vector.clear();<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                vector.add(i);<br>            &#125;<br><br>            Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;<br>                    vector.remove(i);<br>                &#125;<br>            &#125;);<br><br>            Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;<br>                    vector.get(i);<br>                &#125;<br>            &#125;);<br><br>            t1.start();<br>            t2.start();<br><br>            <span class="hljs-keyword">while</span> (Thread.activeCount() &gt; <span class="hljs-number">10</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;同时存在10个以上线程，退出！&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上程序执行时可能会出现数组越界错误。</p>
<p><code>Vector</code> 是线程安全的，那为什么还会报这个错？ </p>
<p>这是因为，对于 Vector，虽然能保证每一个时刻只能有一个线程访问它，但是不排除这种可能： </p>
<p>当某个线程在某个时刻执行这句时： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vector.size();i++)<br>    vector.get(i);<br></code></pre></td></tr></table></figure>

<p>假若此时 vector 的 size 方法返回的是 10，i 的值为 9 </p>
<p>然后另外一个线程执行了这句： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vector.size();i++)<br>    vector.remove(i);<br></code></pre></td></tr></table></figure>

<p>将下标为 9 的元素删除了。</p>
<p>那么通过 get 方法访问下标为 9 的元素肯定就会出问题了。</p>
<p><strong>线程安全示例</strong></p>
<p>因此为了保证线程安全，必须在方法调用端做额外的同步措施，如下面所示： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VectorDemo2</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> Vector&lt;Integer&gt; vector = <span class="hljs-keyword">new</span> Vector&lt;Integer&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                vector.add(i);<br>            &#125;<br><br>            Thread thread1 = <span class="hljs-keyword">new</span> Thread() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">synchronized</span> (VectorDemo2.class) &#123;   <span class="hljs-comment">//进行额外的同步</span><br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;<br>                            vector.remove(i);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;;<br><br>            Thread thread2 = <span class="hljs-keyword">new</span> Thread() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">synchronized</span> (VectorDemo2.class) &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vector.size(); i++) &#123;<br>                            vector.get(i);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;;<br><br>            thread1.start();<br>            thread2.start();<br><br>            <span class="hljs-keyword">while</span> (Thread.activeCount() &gt; <span class="hljs-number">10</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;同时存在 10 个以上线程，退出&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-并发容器简介"><a href="#2-并发容器简介" class="headerlink" title="2. 并发容器简介"></a>2. 并发容器简介</h2><p>同步容器将所有对容器状态的访问都串行化，以保证线程安全性，这种策略会严重降低并发性。 </p>
<p>Java 1.5 后提供了多种并发容器，<strong>使用并发容器来替代同步容器，可以极大地提高伸缩性并降低风险</strong>。 </p>
<p>J.U.C 包中提供了几个非常有用的并发容器作为线程安全的容器： </p>
<table>
<thead>
<tr>
<th align="center"><strong>并发容器</strong></th>
<th align="center"><strong>对应的普通容器</strong></th>
<th align="center"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">ConcurrentHashMap</td>
<td align="center">HashMap</td>
<td align="center">Java 1.8 之前采用分段锁机制细化锁粒度，降低阻塞，从而提高并发性；Java 1.8 之后基于 CAS 实现。</td>
</tr>
<tr>
<td align="center">ConcurrentSkipListMap</td>
<td align="center">SortedMap</td>
<td align="center">基于跳表实现的</td>
</tr>
<tr>
<td align="center"><code>CopyOnWriteArrayList</code></td>
<td align="center">ArrayList</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CopyOnWriteArraySet</td>
<td align="center">Set</td>
<td align="center">基于 <code>CopyOnWriteArrayList</code> 实现。</td>
</tr>
<tr>
<td align="center">ConcurrentSkipListSet</td>
<td align="center">SortedSet</td>
<td align="center">基于 <code>ConcurrentSkipListMap</code> 实现。</td>
</tr>
<tr>
<td align="center">ConcurrentLinkedQueue</td>
<td align="center">Queue</td>
<td align="center">线程安全的无界队列。底层采用单链表。支持 FIFO。</td>
</tr>
<tr>
<td align="center">ConcurrentLinkedDeque</td>
<td align="center">Deque</td>
<td align="center">线程安全的无界双端队列。底层采用双向链表。支持 FIFO 和 FILO。</td>
</tr>
<tr>
<td align="center">ArrayBlockingQueue</td>
<td align="center">Queue</td>
<td align="center">数组实现的阻塞队列。</td>
</tr>
<tr>
<td align="center">LinkedBlockingQueue</td>
<td align="center">Queue</td>
<td align="center">链表实现的阻塞队列。</td>
</tr>
<tr>
<td align="center">LinkedBlockingDeque</td>
<td align="center">Deque</td>
<td align="center">双向链表实现的双端阻塞队列。</td>
</tr>
</tbody></table>
<p>J.U.C 包中提供的并发容器命名一般分为三类： </p>
<ul>
<li> Concurrent </li>
</ul>
<ol>
<li>这类型的锁竞争相对于 <code>CopyOnWrite</code> 要高一些，但写操作代价要小一些。</li>
<li>此外，<code>Concurrent</code> 往往提供了较低的遍历一致性，即：当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历。代价就是，在获取容器大小 <code>size()</code> ，容器是否为空等方法，不一定完全精确，但这是为了获取并发吞吐量的设计取舍，可以理解。与之相比，如果是使用同步容器，就会出现 <code>fail-fast</code> 问题，即：检测到容器在遍历过程中发生了修改，则抛出 <code>ConcurrentModificationException</code>，不再继续遍历。</li>
</ol>
<ul>
<li><code>CopyOnWrite</code> - 一个线程写，多个线程读。读操作时不加锁，写操作时通过在副本上加锁保证并发安全，空间开销较大。</li>
<li><code>Blocking</code> - 内部实现一般是基于锁，提供阻塞队列的能力。</li>
</ul>
<p>错误示例，产生 <code>ConcurrentModificationException</code> 异常： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeKeys</span><span class="hljs-params">(Map&lt;String, Object&gt; map, <span class="hljs-keyword">final</span> String... keys)</span> </span>&#123;<br>    map.keySet().removeIf(key -&gt; ArrayUtil.contains(keys, key));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>错误示例，产生 <code>ConcurrentModificationException</code> 异常： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; <span class="hljs-function">Map&lt;K, V&gt; <span class="hljs-title">removeKeys</span><span class="hljs-params">(Map&lt;String, Object&gt; map, <span class="hljs-keyword">final</span> String... keys)</span> </span>&#123;<br>	<span class="hljs-keyword">for</span> (K key : keys) &#123;<br>		map.remove(key);<br>	&#125;<br>	<span class="hljs-keyword">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-1-并发场景下的-Map"><a href="#2-1-并发场景下的-Map" class="headerlink" title="2.1. 并发场景下的 Map"></a>2.1. 并发场景下的 Map</h3><p>如果对数据有强一致要求，则需使用 <code>Hashtable</code>；在大部分场景通常都是弱一致性的情况下，使用 <code>ConcurrentHashMap</code> 即可；如果数据量在千万级别，且存在大量增删改操作，则可以考虑使用 <code>ConcurrentSkipListMap</code>。</p>
<h3 id="2-2-并发场景下的-List"><a href="#2-2-并发场景下的-List" class="headerlink" title="2.2. 并发场景下的 List"></a>2.2. 并发场景下的 List</h3><p>读多写少用 <code>CopyOnWriteArrayList</code>。 </p>
<p>写多读少用 <code>ConcurrentLinkedQueue</code> ，但由于是无界的，要有容量限制，避免无限膨胀，导致内存溢出。 </p>
<h2 id="3-Map"><a href="#3-Map" class="headerlink" title="3. Map"></a>3. Map</h2><p>Map 接口的两个实现是 ConcurrentHashMap 和 ConcurrentSkipListMap，它们从应用的角度来看，主要区别在于<strong>ConcurrentHashMap 的 key 是无序的，而 ConcurrentSkipListMap 的 key 是有序的</strong>。所以如果你需要保证 key 的顺序，就只能使用 ConcurrentSkipListMap。 </p>
<p>使用 ConcurrentHashMap 和 ConcurrentSkipListMap 需要注意的地方是，它们的 key 和 value 都不能为空，否则会抛出<code>NullPointerException</code>这个运行时异常。 </p>
<h3 id="3-1-ConcurrentHashMap"><a href="#3-1-ConcurrentHashMap" class="headerlink" title="3.1. ConcurrentHashMap"></a>3.1. ConcurrentHashMap</h3><p><code>ConcurrentHashMap</code> 是线程安全的 <code>HashMap</code> ，用于替代 <code>Hashtable</code>。 </p>
<p><strong><code>ConcurrentHashMap</code> 的特性</strong></p>
<p><code>ConcurrentHashMap</code> <code>实现了</code> <code>ConcurrentMap</code> 接口，而 <code>ConcurrentMap</code> 接口扩展了 <code>Map</code> 接口。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>ConcurrentHashMap</code> 的实现包含了 <code>HashMap</code> 所有的基本特性，如：数据结构、读写策略等。 </p>
<p><code>ConcurrentHashMap</code> 没有实现对 <code>Map</code> 加锁以提供独占访问。因此无法通过在客户端加锁的方式来创建新的原子操作。但是，一些常见的复合操作，如：“若没有则添加”、“若相等则移除”、“若相等则替换”，都已经实现为原子操作，并且是围绕 <code>ConcurrentMap</code> 的扩展接口而实现。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">// 仅当 K 没有相应的映射值才插入</span><br>    <span class="hljs-function">V <span class="hljs-title">putIfAbsent</span><span class="hljs-params">(K key, V value)</span></span>;<br><br>    <span class="hljs-comment">// 仅当 K 被映射到 V 时才移除</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object key, Object value)</span></span>;<br><br>    <span class="hljs-comment">// 仅当 K 被映射到 oldValue 时才替换为 newValue</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">replace</span><span class="hljs-params">(K key, V oldValue, V newValue)</span></span>;<br><br>    <span class="hljs-comment">// 仅当 K 被映射到某个值时才替换为 newValue</span><br>    <span class="hljs-function">V <span class="hljs-title">replace</span><span class="hljs-params">(K key, V value)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不同于 <code>Hashtable</code>，<code>ConcurrentHashMap</code> 提供的迭代器不会抛出 <code>ConcurrentModificationException</code>，因此不需要在迭代过程中对容器加锁。 </p>
<blockquote>
<p> 注意：一些需要对整个 <code>Map</code> 进行计算的方法，如 <code>size</code> 和 <code>isEmpty</code> ，由于返回的结果在计算时可能已经过期，所以<strong>并非实时的精确值</strong>。这是一种策略上的权衡，在并发环境下，这类方法由于总在不断变化，所以获取其实时精确值的意义不大。<code>ConcurrentHashMap</code> 弱化这类方法，以换取更重要操作（如：<code>get</code>、<code>put</code>、<code>containesKey</code>、<code>remove</code> 等）的性能。 </p>
</blockquote>
<p><strong>ConcurrentHashMap 的用法</strong></p>
<p>示例：不会出现 <code>ConcurrentModificationException</code> </p>
<p><code>ConcurrentHashMap</code> 的基本操作与 <code>HashMap</code> 的用法基本一样。不同于 <code>HashMap</code>、<code>Hashtable</code>，<code>ConcurrentHashMap</code> 提供的迭代器不会抛出 <code>ConcurrentModificationException</code>，因此不需要在迭代过程中对容器加锁。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMapDemo</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Map&lt;Integer, Character&gt; hashMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;写操作线程开始执行&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>                hashMap.put(i, (<span class="hljs-keyword">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;读操作线程开始执行&quot;</span>);<br>            <span class="hljs-keyword">for</span> (Integer key : hashMap.keySet()) &#123;<br>                System.out.println(key + <span class="hljs-string">&quot; - &quot;</span> + hashMap.get(key));<br>            &#125;<br>        &#125;);<br><br>        t1.start();<br>        t2.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>ConcurrentHashMap 的原理</strong></p>
<blockquote>
<p> <code>ConcurrentHashMap</code> 一直在演进，尤其在 Java 1.7 和 Java 1.8，其数据结构和并发机制有很大的差异。 </p>
</blockquote>
<ul>
<li>Java 1.7<ul>
<li>数据结构：<strong>数组＋单链表</strong></li>
<li>并发机制：采用分段锁机制细化锁粒度，降低阻塞，从而提高并发性。</li>
</ul>
</li>
<li>Java 1.8<ul>
<li>数据结构：<strong>数组＋单链表＋红黑树</strong></li>
<li>并发机制：取消分段锁，之后基于 CAS + synchronized 实现。</li>
</ul>
</li>
</ul>
<p> <strong>Java 1.7 的实现</strong></p>
<p>分段锁，是将内部进行分段（Segment），里面是 <code>HashEntry</code> 数组，和 <code>HashMap</code> 类似，哈希相同的条目也是以链表形式存放。 <code>HashEntry</code> 内部使用 <code>volatile</code> 的 <code>value</code> 字段来保证可见性，也利用了不可变对象的机制，以改进利用 <code>Unsafe</code> 提供的底层能力，比如 volatile access，去直接完成部分操作，以最优化性能，毕竟 <code>Unsafe</code> 中的很多操作都是 JVM intrinsic 优化过的。 </p>
<p> <img src="/img/work/20200605214405.png"> </p>
<p>在进行并发写操作时，<code>ConcurrentHashMap</code> 会获取可重入锁（<code>ReentrantLock</code>），以保证数据一致性。所以，在并发修改期间，相应 <code>Segment</code> 是被锁定的。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;, <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">// 将整个hashmap分成几个小的map，每个segment都是一个锁；与hashtable相比，这么设计的目的是对于put, remove等操作，可以减少并发冲突，对不属于同一个片段的节点可以并发操作，大大提高了性能</span><br>    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments;<br><br>    <span class="hljs-comment">// 本质上Segment类就是一个小的hashmap，里面table数组存储了各个节点的数据，继承了ReentrantLock, 可以作为互拆锁使用</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Segment</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;<br>        <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;<br>    &#125;<br><br>    <span class="hljs-comment">// 基本节点，存储Key， Value值</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashEntry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;<br>        <span class="hljs-keyword">final</span> K key;<br>        <span class="hljs-keyword">volatile</span> V value;<br>        <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt; next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Java 1.8 的实现</strong></p>
<ul>
<li>数据结构改进：与 HashMap 一样，将原先 <strong>数组＋单链表</strong> 的数据结构，变更为 <strong>数组＋单链表＋红黑树</strong> 的结构。当出现哈希冲突时，数据会存入数组指定桶的单链表，当链表长度达到 8，则将其转换为红黑树结构，这样其查询的时间复杂度可以降低到 O(logN)，以改进性能。</li>
<li> 并发机制改进： </li>
<li>取消 segments 字段，<strong>直接采用 <code>transient volatile HashEntry[] table</code> 保存数据，采用 table 数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率</strong>。</li>
<li>使用 CAS + <code>sychronized</code> 操作，在特定场景进行无锁并发操作。使用 Unsafe、LongAdder 之类底层手段，进行极端情况的优化。现代 JDK 中，synchronized 已经被不断优化，可以不再过分担心性能差异，另外，相比于 ReentrantLock，它可以减少内存消耗，这是个非常大的优势。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">int</span> hash = spread(key.hashCode());<br>    <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> n, i, fh;<br>        <span class="hljs-comment">// 如果table为空，初始化；否则，根据hash值计算得到数组索引i，如果tab[i]为空，直接新建节点Node即可。注：tab[i]实质为链表或者红黑树的首节点。</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            tab = initTable();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>,<br>                         <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))<br>                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br>        <span class="hljs-comment">// 如果tab[i]不为空并且hash值为MOVED，说明该链表正在进行transfer操作，返回扩容完成后的table。</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br>            V oldVal = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-comment">// 针对首个节点进行加锁操作，而不是segment，进一步减少线程冲突</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-comment">// 如果在链表中找到值为key的节点e，直接设置e.val = value即可。</span><br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            <span class="hljs-comment">// 如果没有找到值为key的节点，直接新建Node并加入链表即可。</span><br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key,<br>                                                          value, <span class="hljs-keyword">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// 如果首节点为TreeBin类型，说明为红黑树结构，执行putTreeVal操作。</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                       value)) != <span class="hljs-keyword">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 如果节点数&gt;＝8，那么转换链表结构为红黑树结构。</span><br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 计数增加1，有可能触发transfer操作(扩容)。</span><br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>ConcurrentHashMap 的实战</strong></p>
<h5 id="ConcurrentHashMap-错误示例"><a href="#ConcurrentHashMap-错误示例" class="headerlink" title="ConcurrentHashMap 错误示例"></a>ConcurrentHashMap 错误示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMapErroDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> THREAD_COUNT = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ITEM_COUNT = <span class="hljs-number">1000</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ConcurrentHashMap&lt;String,Long&gt; concurrentHashMap = getData(ITEM_COUNT - <span class="hljs-number">100</span>);<br>        <span class="hljs-comment">//初始化900个元素</span><br>        System.out.println(<span class="hljs-string">&quot;init size:&quot;</span> + concurrentHashMap.size());<br>        ForkJoinPool forkJoinPool = <span class="hljs-keyword">new</span> ForkJoinPool(THREAD_COUNT);<br>        forkJoinPool.execute(() -&gt; IntStream.rangeClosed(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>).parallel().forEach(i -&gt; &#123;<br>            <span class="hljs-comment">//查询还需要补充多少个元素</span><br>            <span class="hljs-keyword">int</span> gap = ITEM_COUNT - concurrentHashMap.size();<br>            System.out.println(<span class="hljs-string">&quot;gap size:&quot;</span> + gap);<br>            <span class="hljs-comment">//补充元素</span><br>            concurrentHashMap.putAll(getData(gap));<br>        &#125;));<br><br>        <span class="hljs-comment">//等待所有任务完成</span><br>        forkJoinPool.shutdown();<br>        forkJoinPool.awaitTermination(<span class="hljs-number">1</span>,TimeUnit.HOURS);<br>        <span class="hljs-comment">//最后元素个数会是1000吗？</span><br>        System.out.println(<span class="hljs-string">&quot;finish size:&quot;</span> + concurrentHashMap.size());<br><br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ConcurrentHashMap&lt;String, Long&gt; <span class="hljs-title">getData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> LongStream.rangeClosed(<span class="hljs-number">1</span>, count).boxed().collect(toConcurrentMap(i -&gt; UUID.randomUUID().toString(), i -&gt; i, (o1, o2) -&gt; o1, ConcurrentHashMap::<span class="hljs-keyword">new</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>初始大小 900 符合预期，还需要填充 100 个元素。</p>
<p>预期结果为 1000 个元素，实际大于 1000 个元素。</p>
<p>【分析】 </p>
<p>ConcurrentHashMap 对外提供的方法或能力的限制： </p>
<ul>
<li>使用了 ConcurrentHashMap，不代表对它的多个操作之间的状态是一致的，是没有其他线程在操作它的，如果需要确保需要手动加锁。</li>
<li>诸如 size、isEmpty 和 containsValue 等聚合方法，在并发情况下可能会反映 ConcurrentHashMap 的中间状态。因此在并发情况下，这些方法的返回值只能用作参考，而不能用于流程控制。显然，利用 size 方法计算差异值，是一个流程控制。</li>
<li>诸如 putAll 这样的聚合方法也不能确保原子性，在 putAll 的过程中去获取数据可能会获取到部分数据。</li>
</ul>
<p><strong>ConcurrentHashMap 错误示例修正 1.0 版</strong></p>
<p>通过 synchronized 加锁，当然可以保证数据一致性，但是牺牲了 ConcurrentHashMap 的性能，没有真正发挥出 ConcurrentHashMap 的特性。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线程个数</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> THREAD_COUNT = <span class="hljs-number">10</span>;<br>   <span class="hljs-comment">//总元素数量</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ITEM_COUNT = <span class="hljs-number">1000</span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       ConcurrentHashMap&lt;String, Long&gt; concurrentHashMap = getData(ITEM_COUNT - <span class="hljs-number">100</span>);<br>       <span class="hljs-comment">//初始900个元素</span><br>       System.out.println(<span class="hljs-string">&quot;init size:&quot;</span> + concurrentHashMap.size());<br>       ForkJoinPool forkJoinPool = <span class="hljs-keyword">new</span> ForkJoinPool(THREAD_COUNT);<br>       <span class="hljs-comment">//使用线程池并发处理逻辑</span><br>       forkJoinPool.execute(() -&gt; IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>).parallel().forEach(i -&gt; &#123;<br>           <span class="hljs-comment">//查询还需要补充多少个元素</span><br>           <span class="hljs-keyword">synchronized</span> (concurrentHashMap) &#123;<br>               <span class="hljs-keyword">int</span> gap = ITEM_COUNT - concurrentHashMap.size();<br>               System.out.println(<span class="hljs-string">&quot;gap size:&quot;</span> + gap);<br>               <span class="hljs-comment">//补充元素</span><br>               concurrentHashMap.putAll(getData(gap));<br>           &#125;<br>       &#125;));<br>       <span class="hljs-comment">//等待所有任务完成</span><br>       forkJoinPool.shutdown();<br>       forkJoinPool.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.HOURS);<br>       <span class="hljs-comment">//最后元素个数会是1000吗？</span><br>       System.out.println(<span class="hljs-string">&quot;finish size:&quot;</span> + concurrentHashMap.size());<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ConcurrentHashMap&lt;String, Long&gt; <span class="hljs-title">getData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> LongStream.rangeClosed(<span class="hljs-number">1</span>, count)<br>           .boxed()<br>           .collect(<br>               Collectors.toConcurrentMap(<br>                   i -&gt; UUID.randomUUID().toString(),<br>                   i -&gt; i,<br>                   (o1, o2) -&gt; o1,<br>                   ConcurrentHashMap::<span class="hljs-keyword">new</span>));<br>   &#125;<br></code></pre></td></tr></table></figure>

<p><strong>ConcurrentHashMap 错误示例修正 2.0 版</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//循环次数</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> LOOP_COUNT = <span class="hljs-number">10000000</span>;<br>   <span class="hljs-comment">//线程个数</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> THREAD_COUNT = <span class="hljs-number">10</span>;<br>   <span class="hljs-comment">//总元素数量</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ITEM_COUNT = <span class="hljs-number">1000</span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       StopWatch stopWatch = <span class="hljs-keyword">new</span> StopWatch();<br>       stopWatch.start(<span class="hljs-string">&quot;normaluse&quot;</span>);<br>       Map&lt;String, Long&gt; normaluse = normaluse();<br>       stopWatch.stop();<br>       Assert.isTrue(normaluse.size() == ITEM_COUNT, <span class="hljs-string">&quot;normaluse size error&quot;</span>);<br>       Assert.isTrue(normaluse.values().stream()<br>               .mapToLong(aLong -&gt; aLong).reduce(<span class="hljs-number">0</span>, Long::sum) == LOOP_COUNT<br>           , <span class="hljs-string">&quot;normaluse count error&quot;</span>);<br>       stopWatch.start(<span class="hljs-string">&quot;gooduse&quot;</span>);<br>       Map&lt;String, Long&gt; gooduse = gooduse();<br>       stopWatch.stop();<br>       Assert.isTrue(gooduse.size() == ITEM_COUNT, <span class="hljs-string">&quot;gooduse size error&quot;</span>);<br>       Assert.isTrue(gooduse.values().stream()<br>               .mapToLong(l -&gt; l)<br>               .reduce(<span class="hljs-number">0</span>, Long::sum) == LOOP_COUNT<br>           , <span class="hljs-string">&quot;gooduse count error&quot;</span>);<br>       System.out.println(stopWatch.prettyPrint());<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Long&gt; <span class="hljs-title">normaluse</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       ConcurrentHashMap&lt;String, Long&gt; freqs = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(ITEM_COUNT);<br>       ForkJoinPool forkJoinPool = <span class="hljs-keyword">new</span> ForkJoinPool(THREAD_COUNT);<br>       forkJoinPool.execute(() -&gt; IntStream.rangeClosed(<span class="hljs-number">1</span>, LOOP_COUNT).parallel().forEach(i -&gt; &#123;<br>               String key = <span class="hljs-string">&quot;item&quot;</span> + ThreadLocalRandom.current().nextInt(ITEM_COUNT);<br>               <span class="hljs-keyword">synchronized</span> (freqs) &#123;<br>                   <span class="hljs-keyword">if</span> (freqs.containsKey(key)) &#123;<br>                       freqs.put(key, freqs.get(key) + <span class="hljs-number">1</span>);<br>                   &#125; <span class="hljs-keyword">else</span> &#123;<br>                       freqs.put(key, <span class="hljs-number">1L</span>);<br>                   &#125;<br>               &#125;<br>           &#125;<br>       ));<br>       forkJoinPool.shutdown();<br>       forkJoinPool.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.HOURS);<br>       <span class="hljs-keyword">return</span> freqs;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Long&gt; <span class="hljs-title">gooduse</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       ConcurrentHashMap&lt;String, LongAdder&gt; freqs = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(ITEM_COUNT);<br>       ForkJoinPool forkJoinPool = <span class="hljs-keyword">new</span> ForkJoinPool(THREAD_COUNT);<br>       forkJoinPool.execute(() -&gt; IntStream.rangeClosed(<span class="hljs-number">1</span>, LOOP_COUNT).parallel().forEach(i -&gt; &#123;<br>               String key = <span class="hljs-string">&quot;item&quot;</span> + ThreadLocalRandom.current().nextInt(ITEM_COUNT);<br>               freqs.computeIfAbsent(key, k -&gt; <span class="hljs-keyword">new</span> LongAdder()).increment();<br>           &#125;<br>       ));<br>       forkJoinPool.shutdown();<br>       forkJoinPool.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.HOURS);<br>       <span class="hljs-keyword">return</span> freqs.entrySet().stream()<br>           .collect(Collectors.toMap(<br>               e -&gt; e.getKey(),<br>               e -&gt; e.getValue().longValue())<br>           );<br>   &#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-List"><a href="#4-List" class="headerlink" title="4. List"></a>4. List</h2><h3 id="4-1-CopyOnWriteArrayList"><a href="#4-1-CopyOnWriteArrayList" class="headerlink" title="4.1. CopyOnWriteArrayList"></a>4.1. CopyOnWriteArrayList</h3><p><code>CopyOnWriteArrayList</code> 是线程安全的 <code>ArrayList</code>。<code>CopyOnWrite</code> 字面意思为<strong>写的时候会将共享变量新复制一份</strong>出来。复制的好处在于<strong>读操作是无锁的</strong>（也就是无阻塞）。 </p>
<p>CopyOnWriteArrayList <strong>仅适用于写操作非常少的场景</strong>，而且能够容忍读写的短暂不一致。如果读写比例均衡或者有大量写操作的话，使用 CopyOnWriteArrayList 的性能会非常糟糕。 </p>
<h4 id="4-1-1-CopyOnWriteArrayList-原理"><a href="#4-1-1-CopyOnWriteArrayList-原理" class="headerlink" title="4.1.1 CopyOnWriteArrayList 原理"></a>4.1.1 CopyOnWriteArrayList 原理</h4><p>CopyOnWriteArrayList 内部维护了一个数组，成员变量 array 就指向这个内部数组，所有的读操作都是基于 array 进行的，如下图所示，迭代器 Iterator 遍历的就是 array 数组。 </p>
<p> <img src="/img/work/20200702204541.png"> </p>
<ul>
<li>lock - 执行写时复制操作，需要使用可重入锁加锁</li>
<li>array - 对象数组，用于存放元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** The lock protecting all mutators */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br><span class="hljs-comment">/** The array, accessed only via getArray/setArray. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Object[] array;<br></code></pre></td></tr></table></figure>

<p> <img src="/img/work/CopyOnWriteArrayList.png"> </p>
<p>（1）读操作 </p>
<p>在 <code>CopyOnWriteAarrayList</code> 中，读操作不同步，因为它们在内部数组的快照上工作，所以多个迭代器可以同时遍历而不会相互阻塞 （图 1,2,4） 。 </p>
<p>CopyOnWriteArrayList 的读操作是不用加锁的，性能很高。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> get(getArray(), index);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">get</span><span class="hljs-params">(Object[] a, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (E) a[index];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>（2）写操作 </p>
<p>所有的写操作都是同步的。他们在备份数组（图 3）的副本上工作。写操作完成后，后备阵列将被替换为复制的阵列，并释放锁定。支持数组变得易变，所以替换数组的调用是原子（图 5）。 </p>
<p>写操作后创建的迭代器将能够看到修改的结构（图 6,7）。 </p>
<p>写时复制集合返回的迭代器不会抛出 <code>ConcurrentModificationException</code>，因为它们在数组的快照上工作，并且无论后续的修改（2,4）如何，都会像迭代器创建时那样完全返回元素。 </p>
<p><strong>添加操作</strong> - 添加的逻辑很简单，先将原容器 copy 一份，然后在新副本上执行写操作，之后再切换引用。当然此过程是要加锁的。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-comment">//ReentrantLock加锁，保证线程安全</span><br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-keyword">int</span> len = elements.length;<br>        <span class="hljs-comment">//拷贝原容器，长度为原容器长度加一</span><br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//在新副本上执行添加操作</span><br>        newElements[len] = e;<br>        <span class="hljs-comment">//将原容器引用指向新副本</span><br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//解锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>删除操作</strong> - 删除操作同理，将除要删除元素之外的其他元素拷贝到新副本中，然后切换引用，将原容器引用指向新副本。同属写操作，需要加锁。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">//加锁</span><br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-keyword">int</span> len = elements.length;<br>        E oldValue = get(elements, index);<br>        <span class="hljs-keyword">int</span> numMoved = len - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">//如果要删除的是列表末端数据，拷贝前len-1个数据到新副本上，再切换引用</span><br>            setArray(Arrays.copyOf(elements, len - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//否则，将除要删除元素之外的其他元素拷贝到新副本中，并切换引用</span><br>            Object[] newElements = <span class="hljs-keyword">new</span> Object[len - <span class="hljs-number">1</span>];<br>            System.arraycopy(elements, <span class="hljs-number">0</span>, newElements, <span class="hljs-number">0</span>, index);<br>            System.arraycopy(elements, index + <span class="hljs-number">1</span>, newElements, index,<br>                              numMoved);<br>            setArray(newElements);<br>        &#125;<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//解锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>使用示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CopyOnWriteArrayListDemo</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        List&lt;String&gt; list;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReadTask</span><span class="hljs-params">(List&lt;String&gt; list)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.list = list;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (String str : list) &#123;<br>                System.out.println(str);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        List&lt;String&gt; list;<br><br>        <span class="hljs-keyword">int</span> index;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WriteTask</span><span class="hljs-params">(List&lt;String&gt; list, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.list = list;<br>            <span class="hljs-keyword">this</span>.index = index;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            list.remove(index);<br>            list.add(index,<span class="hljs-string">&quot;Write_&quot;</span> + index);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NUM = <span class="hljs-number">10</span>;<br><br>        <span class="hljs-comment">// ArrayList 在并发迭代访问时会抛出 ConcurrentModificationException 异常</span><br>        <span class="hljs-comment">// List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br>        CopyOnWriteArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM; i++) &#123;<br>            list.add(<span class="hljs-string">&quot;main_&quot;</span> + i);<br>            <br>        &#125;<br><br>        ExecutorService executorService = Executors.newFixedThreadPool(NUM);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM; i++) &#123;<br>            executorService.execute(<span class="hljs-keyword">new</span> ReadTask(list));<br>            executorService.execute(<span class="hljs-keyword">new</span> WriteTask(list,i));<br>        &#125;<br>        executorService.shutdown();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> CopyOnWriteArrayListDemo().run();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="CopyOnWriteArrayList-实战"><a href="#CopyOnWriteArrayList-实战" class="headerlink" title="CopyOnWriteArrayList 实战"></a>CopyOnWriteArrayList 实战</h4><h2 id="5-Set"><a href="#5-Set" class="headerlink" title="5. Set"></a>5. Set</h2><p>Set 接口的两个实现是 CopyOnWriteArraySet 和 ConcurrentSkipListSet，使用场景可以参考前面讲述的 CopyOnWriteArrayList 和 ConcurrentSkipListMap，它们的原理都是一样的。 </p>
<h2 id="6-Queue"><a href="#6-Queue" class="headerlink" title="6. Queue"></a>6. Queue</h2><p>Java 并发包里面 Queue 这类并发容器是最复杂的，你可以从以下两个维度来分类。一个维度是<strong>阻塞与非阻塞</strong>，所谓阻塞指的是：<strong>当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞</strong>。另一个维度是<strong>单端与双端</strong>，单端指的是只能队尾入队，队首出队；而双端指的是队首队尾皆可入队出队。Java 并发包里<strong>阻塞队列都用 Blocking 关键字标识，单端队列使用 Queue 标识，双端队列使用 Deque 标识</strong>。 </p>
<h3 id="6-1-BlockingQueue"><a href="#6-1-BlockingQueue" class="headerlink" title="6.1. BlockingQueue"></a>6.1. BlockingQueue</h3><p><code>BlockingQueue</code> 顾名思义，是一个<strong>阻塞队列</strong>。**<code>BlockingQueue</code> 基本都是基于锁实现<strong>。在 <code>BlockingQueue</code> 中，</strong>当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞**。 </p>
<p><code>BlockingQueue</code> 接口定义如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>核心API： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取并移除队列头结点，如果必要，其会等待直到队列出现元素</span><br><span class="hljs-function">E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br><br><span class="hljs-comment">// 插入元素，如果队列已满，则等待直到队列出现空闲空间</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br></code></pre></td></tr></table></figure>

<p><code>BlockingQueue</code> 对插入操作、移除操作、获取元素操作提供了四种不同的方法用于不同的场景中使用： </p>
<ul>
<li>抛出异常:  如果试图的操作无法立即执行，抛一个异常。 ；</li>
<li>特定值:    如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。 </li>
<li> 阻塞:  如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。 </li>
<li> 超时:   如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。 </li>
</ul>
<p> 总结如下： </p>
<table>
<thead>
<tr>
<th></th>
<th>抛异常</th>
<th>特定值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>Insert</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>Remove</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>Examine</td>
<td>element()</td>
<td>peek()</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><code>BlockingQueue</code> 的各个实现类都遵循了这些规则。</p>
<p><code>BlockingQueue</code> 不接受 <code>null</code> 值元素。</p>
<p>JDK 提供了以下阻塞队列： </p>
<ul>
<li><code>ArrayBlockingQueue</code> - 一个由<strong>数组结构组成的有界阻塞队列</strong>。</li>
<li><code>LinkedBlockingQueue</code> - 一个由<strong>链表结构组成的有界阻塞队列</strong>。</li>
<li><code>PriorityBlockingQueue</code> - 一个<strong>支持优先级排序的无界阻塞队列</strong>。</li>
<li><code>SynchronousQueue</code> - 一个<strong>不存储元素的阻塞队列</strong>。</li>
<li><code>DelayQueue</code> - 一个使用优先级队列实现的无界阻塞队列。</li>
<li><code>LinkedTransferQueue</code> - 一个<strong>由链表结构组成的无界阻塞队列</strong>。</li>
</ul>
<p> <code>BlockingQueue</code> 基本都是基于锁实现。 </p>
<h3 id="6-2-PriorityBlockingQueue-类"><a href="#6-2-PriorityBlockingQueue-类" class="headerlink" title="6.2. PriorityBlockingQueue 类"></a>6.2. PriorityBlockingQueue 类</h3><p><code>PriorityBlockingQueue</code> 类定义如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-2-1-PriorityBlockingQueue-要点"><a href="#6-2-1-PriorityBlockingQueue-要点" class="headerlink" title="6.2.1 PriorityBlockingQueue 要点"></a>6.2.1 PriorityBlockingQueue 要点</h4><ul>
<li><code>PriorityBlockingQueue</code> 可以视为 <code>PriorityQueue</code> 的线程安全版本。</li>
<li><code>PriorityBlockingQueue</code> 实现了 <code>BlockingQueue</code>，也是一个阻塞队列。</li>
<li><code>PriorityBlockingQueue</code> 实现了 <code>Serializable</code>，支持序列化。</li>
<li><code>PriorityBlockingQueue</code> 不接受 <code>null</code> 值元素。</li>
<li><code>PriorityBlockingQueue</code> 的插入操作 <code>put</code> 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</li>
</ul>
<h4 id="6-2-2-PriorityBlockingQueue-原理"><a href="#6-2-2-PriorityBlockingQueue-原理" class="headerlink" title="6.2.2 PriorityBlockingQueue 原理"></a>6.2.2 PriorityBlockingQueue 原理</h4><p> <code>PriorityBlockingQueue</code> 有两个重要成员： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Object[] queue;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>queue</code> 是一个 <code>Object</code> 数组，用于保存 <code>PriorityBlockingQueue</code> 的元素。</li>
<li>而可重入锁 <code>lock</code> 则用于在执行插入、删除操作时，保证这个方法在当前线程释放锁之前，其他线程不能访问。</li>
</ul>
<p><code>PriorityBlockingQueue</code> 的容量虽然有初始化大小，但是不限制大小，如果当前容量已满，插入新元素时会自动扩容。 </p>
<h3 id="6-3-ArrayBlockingQueue-类"><a href="#6-3-ArrayBlockingQueue-类" class="headerlink" title="6.3. ArrayBlockingQueue 类"></a>6.3. ArrayBlockingQueue 类</h3><p><code>ArrayBlockingQueue</code> 是由数组结构组成的<strong>有界阻塞队列</strong>。 </p>
<h4 id="6-3-1-ArrayBlockingQueue-要点"><a href="#6-3-1-ArrayBlockingQueue-要点" class="headerlink" title="6.3.1 ArrayBlockingQueue 要点"></a>6.3.1 ArrayBlockingQueue 要点</h4><p><code>ArrayBlockingQueue</code> 类定义如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-comment">// 数组的大小就决定了队列的边界，所以初始化时必须指定容量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123; <span class="hljs-comment">//... &#125;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity, <span class="hljs-keyword">boolean</span> fair)</span> </span>&#123; <span class="hljs-comment">//... &#125;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity, <span class="hljs-keyword">boolean</span> fair, Collection&lt;? extends E&gt; c)</span> </span>&#123; <span class="hljs-comment">//... &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p> 说明： </p>
<ul>
<li><code>ArrayBlockingQueue</code> 实现了 <code>BlockingQueue</code>，也是一个阻塞队列。</li>
<li><code>ArrayBlockingQueue</code> 实现了 <code>Serializable</code>，支持序列化。</li>
<li><code>ArrayBlockingQueue</code> 是基于数组实现的有界阻塞队列。所以初始化时必须指定容量。</li>
</ul>
<h4 id="6-3-2-ArrayBlockingQueue-原理"><a href="#6-3-2-ArrayBlockingQueue-原理" class="headerlink" title="6.3.2 ArrayBlockingQueue 原理"></a>6.3.2 ArrayBlockingQueue 原理</h4><p><code>ArrayBlockingQueue</code> 的重要成员如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于存放元素的数组</span><br><span class="hljs-keyword">final</span> Object[] items;<br><span class="hljs-comment">// 下一次读取操作的位置</span><br><span class="hljs-keyword">int</span> takeIndex;<br><span class="hljs-comment">// 下一次写入操作的位置</span><br><span class="hljs-keyword">int</span> putIndex;<br><span class="hljs-comment">// 队列中的元素数量</span><br><span class="hljs-keyword">int</span> count;<br><br><span class="hljs-comment">// 以下几个就是控制并发用的同步器</span><br><span class="hljs-keyword">final</span> ReentrantLock lock;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;<br></code></pre></td></tr></table></figure>

<p><code>ArrayBlockingQueue</code> 内部以 <code>final</code> 的数组保存数据，数组的大小就决定了队列的边界。 </p>
<p><code>ArrayBlockingQueue</code> 实现并发同步的原理就是，读操作和写操作都需要获取到 AQS 独占锁才能进行操作。 </p>
<ul>
<li>如果队列为空，这个时候读操作的线程进入到读线程队列排队，等待写线程写入新的元素，然后唤醒读线程队列的第一个等待线程。</li>
<li>如果队列已满，这个时候写操作的线程进入到写线程队列排队，等待读线程将队列元素移除，然后唤醒写线程队列的第一个等待线程。</li>
</ul>
<p>对于 <code>ArrayBlockingQueue</code>，我们可以在构造的时候指定以下三个参数： </p>
<ul>
<li>队列容量，其限制了队列中最多允许的元素个数；</li>
<li>指定独占锁是公平锁还是非公平锁。非公平锁的吞吐量比较高，公平锁可以保证每次都是等待最久的线程获取到锁；</li>
<li>可以指定用一个集合来初始化，将此集合中的元素在构造方法期间就先添加到队列中。</li>
</ul>
<h3 id="6-4-LinkedBlockingQueue-类"><a href="#6-4-LinkedBlockingQueue-类" class="headerlink" title="6.4. LinkedBlockingQueue 类"></a>6.4. LinkedBlockingQueue 类</h3><p><code>LinkedBlockingQueue</code> 是由链表结构组成的有界阻塞队列。容易被误解为无边界，但其实其行为和内部代码都是基于有界的逻辑实现的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被设置为 <code>Integer.MAX_VALUE</code>，成为了无界队列。 </p>
<h4 id="6-4-1-LinkedBlockingQueue-要点"><a href="#6-4-1-LinkedBlockingQueue-要点" class="headerlink" title="6.4.1 LinkedBlockingQueue 要点"></a>6.4.1 LinkedBlockingQueue 要点</h4><p><code>LinkedBlockingQueue</code> 类定义如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>LinkedBlockingQueue</code> 实现了 <code>BlockingQueue</code>，也是一个阻塞队列。</p>
</li>
<li><p><code>LinkedBlockingQueue</code> 实现了 <code>Serializable</code>，支持序列化。</p>
</li>
<li><p><code>LinkedBlockingQueue</code> 是基于单链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用。</p>
</li>
<li><p><code>LinkedBlockingQueue</code> 中元素按照插入顺序保存（FIFO）。</p>
</li>
</ul>
<h4 id="6-4-2-LinkedBlockingQueue-原理"><a href="#6-4-2-LinkedBlockingQueue-原理" class="headerlink" title="6.4.2 LinkedBlockingQueue 原理"></a>6.4.2 LinkedBlockingQueue 原理</h4><p><code>LinkedBlockingQueue</code> 中的重要数据结构： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 队列容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> capacity;<br><span class="hljs-comment">// 队列中的元素数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 队头</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node&lt;E&gt; head;<br><span class="hljs-comment">// 队尾</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><span class="hljs-comment">// take, poll, peek 等读操作的方法需要获取到这个锁</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-comment">// 如果读操作的时候队列是空的，那么等待 notEmpty 条件</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty = takeLock.newCondition();<br><span class="hljs-comment">// put, offer 等写操作的方法需要获取到这个锁</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-comment">// 如果写操作的时候队列是满的，那么等待 notFull 条件</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull = putLock.newCondition();<br></code></pre></td></tr></table></figure>

<p>这里用了两对 <code>Lock</code> 和 <code>Condition</code>，简单介绍如下： </p>
<ul>
<li><code>takeLock</code> 和 <code>notEmpty</code> 搭配：如果要获取（take）一个元素，需要获取 <code>takeLock</code> 锁，但是获取了锁还不够，如果队列此时为空，还需要队列不为空（<code>notEmpty</code>）这个条件（<code>Condition</code>）。</li>
<li><code>putLock</code> 需要和 <code>notFull</code> 搭配：如果要插入（put）一个元素，需要获取 <code>putLock</code> 锁，但是获取了锁还不够，如果队列此时已满，还需要队列不是满的（notFull）这个条件（<code>Condition</code>）。</li>
</ul>
<h3 id="6-5-SynchronousQueue-类"><a href="#6-5-SynchronousQueue-类" class="headerlink" title="6.5. SynchronousQueue 类"></a>6.5. SynchronousQueue 类</h3><p>SynchronousQueue 是<strong>不存储元素的阻塞队列</strong>。每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作。那么这个队列的容量是多少呢？是 1 吗？其实不是的，其内部容量是 0。 </p>
<p><code>SynchronousQueue</code> 定义如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronousQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p> <code>SynchronousQueue</code> 这个类，在线程池的实现类 <code>ScheduledThreadPoolExecutor</code> 中得到了应用。 </p>
<p> <code>SynchronousQueue</code> 的队列其实是虚的，即队列容量为 0。数据必须从某个写线程交给某个读线程，而不是写到某个队列中等待被消费。 </p>
<p> <code>SynchronousQueue</code> 中不能使用 peek 方法（在这里这个方法直接返回 null），peek 方法的语义是只读取不移除，显然，这个方法的语义是不符合 SynchronousQueue 的特征的。 </p>
<p> <code>SynchronousQueue</code> 也不能被迭代，因为根本就没有元素可以拿来迭代的。 </p>
<p> 虽然 <code>SynchronousQueue</code> 间接地实现了 Collection 接口，但是如果你将其当做 Collection 来用的话，那么集合是空的。 </p>
<p> 当然，<code>SynchronousQueue</code> 也不允许传递 null 值的（并发包中的容器类好像都不支持插入 null 值，因为 null 值往往用作其他用途，比如用于方法的返回值代表操作失败）。 </p>
<h3 id="6-6-ConcurrentLinkedDeque-类"><a href="#6-6-ConcurrentLinkedDeque-类" class="headerlink" title="6.6. ConcurrentLinkedDeque 类"></a>6.6. ConcurrentLinkedDeque 类</h3><p><code>Deque</code> 的侧重点是支持对队列头尾都进行插入和删除，所以提供了特定的方法，如:</p>
<ul>
<li>尾部插入时需要的 <code>addLast(e)</code>、<code>offerLast(e)</code>。</li>
<li>尾部删除所需要的 <code>removeLast()</code>、<code>pollLast()</code>。</li>
</ul>
<h3 id="6-7-Queue-的并发应用"><a href="#6-7-Queue-的并发应用" class="headerlink" title="6.7. Queue 的并发应用"></a>6.7. Queue 的并发应用</h3><p>Queue 被广泛使用在生产者 - 消费者场景。而在并发场景，利用 <code>BlockingQueue</code> 的阻塞机制，可以减少很多并发协调工作。 </p>
<p>这么多并发 Queue 的实现，如何选择呢？ </p>
<ul>
<li>考虑应用场景中对队列边界的要求。<code>ArrayBlockingQueue</code> 是有明确的容量限制的，而 <code>LinkedBlockingQueue</code> 则取决于我们是否在创建时指定，<code>SynchronousQueue</code> 则干脆不能缓存任何元素。</li>
<li>从空间利用角度，数组结构的 <code>ArrayBlockingQueue</code> 要比 <code>LinkedBlockingQueue</code> 紧凑，因为其不需要创建所谓节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。</li>
<li>通用场景中，<code>LinkedBlockingQueue</code> 的吞吐量一般优于 <code>ArrayBlockingQueue</code>，因为它实现了更加细粒度的锁操作。</li>
<li><code>ArrayBlockingQueue</code> 实现比较简单，性能更好预测，属于表现稳定的“选手”。</li>
<li>可能令人意外的是，很多时候 <code>SynchronousQueue</code> 的性能表现，往往大大超过其他实现，尤其是在队列元素较小的场景。</li>
</ul>
<h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><ul>
<li><p><a href="https://dunwu.github.io/javacore/concurrent/Java%E5%B9%B6%E5%8F%91%E5%92%8C%E5%AE%B9%E5%99%A8.html#_1-%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8"> 顿悟|Java并发容器</a></p>
</li>
<li><p><a href="https://blog.csdn.net/u010425776/article/details/54890215">https://blog.csdn.net/u010425776/article/details/54890215</a></p>
</li>
<li><p><a href="https://blog.csdn.net/wangxiaotongfan/article/details/52074160">https://blog.csdn.net/wangxiaotongfan/article/details/52074160</a></p>
</li>
<li><p><a href="https://my.oschina.net/hosee/blog/675884">https://my.oschina.net/hosee/blog/675884</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/c0642afe03e0">https://www.jianshu.com/p/c0642afe03e0</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/f6730d5784ad">https://www.jianshu.com/p/f6730d5784ad</a></p>
</li>
<li><p><a href="http://www.javarticles.com/2012/06/copyonwritearraylist.html">http://www.javarticles.com/2012/06/copyonwritearraylist.html</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/xrq730/p/5020760.html">https://www.cnblogs.com/xrq730/p/5020760.html</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/leesf456/p/5547853.html">https://www.cnblogs.com/leesf456/p/5547853.html</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/chengxiao/p/6881974.html">http://www.cnblogs.com/chengxiao/p/6881974.html</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/dolphin0520/p/3933404.html">http://www.cnblogs.com/dolphin0520/p/3933404.html</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>并发容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发工具类</title>
    <url>/2022/06/12/Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1.CountDownLatch"></a>1.CountDownLatch</h2><blockquote>
<p> 字面意思为 <strong>递减计数锁</strong>。用于<strong>控制一个线程等待多个线程</strong>。 </p>
<p> <code>CountDownLatch</code> 维护一个计数器 count，表示需要等待的事件数量。<code>countDown</code> 方法递减计数器，表示有一个事件已经发生。调用 <code>await</code> 方法的线程会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。 </p>
</blockquote>
<p>CountDownLatch 这个类是比较典型的 AQS 的共享模式的使用，这是一个高频使用的类。 </p>
<h3 id="1-1-使用例子"><a href="#1-1-使用例子" class="headerlink" title="1.1 使用例子"></a>1.1 使用例子</h3><p> 我们看下 Doug Lea 在 java doc 中给出的例子，这个例子非常实用，我经常会写到这个代码。 </p>
<p>假设我们有 N ( N &gt; 0 ) 个任务，那么我们会用 N 来初始化一个 CountDownLatch，然后将这个 latch 的引用传递到各个线程中，在每个线程完成了任务后，调用 latch.countDown() 代表完成了一个任务。 </p>
<p>调用 latch.await() 的方法的线程会阻塞，直到所有的任务完成。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver2</span> </span>&#123; <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CountDownLatch doneSignal = <span class="hljs-keyword">new</span> CountDownLatch(N);<br>        Executor e = Executors.newFixedThreadPool(<span class="hljs-number">8</span>);<br><br>        <span class="hljs-comment">// 创建 N 个任务，提交给线程池来执行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) <span class="hljs-comment">// create and start threads</span><br>            e.execute(<span class="hljs-keyword">new</span> WorkerRunnable(doneSignal, i));<br><br>        <span class="hljs-comment">// 等待所有的任务完成，这个方法才会返回</span><br>        doneSignal.await();           <span class="hljs-comment">// wait for all to finish</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkerRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch doneSignal;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i;<br><br>    WorkerRunnable(CountDownLatch doneSignal, <span class="hljs-keyword">int</span> i) &#123;<br>        <span class="hljs-keyword">this</span>.doneSignal = doneSignal;<br>        <span class="hljs-keyword">this</span>.i = i;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            doWork(i);<br>            <span class="hljs-comment">// 这个线程的任务完成了，调用 countDown 方法</span><br>            doneSignal.countDown();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>        &#125; <span class="hljs-comment">// return;</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span> </span>&#123; ...&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以说 CountDownLatch 非常实用，我们常常会将一个比较大的任务进行拆分，然后开启多个线程来执行，等所有线程都执行完了以后，再往下执行其他操作。这里例子中，<strong>只有 main 线程调用了 await 方法</strong>。 </p>
<p>我们再来看另一个例子，这个例子很典型，用了两个 CountDownLatch： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span> </span>&#123; <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CountDownLatch startSignal = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br>        CountDownLatch doneSignal = <span class="hljs-keyword">new</span> CountDownLatch(N);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) <span class="hljs-comment">// create and start threads</span><br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Worker(startSignal, doneSignal)).start();<br><br>        <span class="hljs-comment">// 这边插入一些代码，确保上面的每个线程先启动起来，才执行下面的代码。</span><br>        doSomethingElse();            <span class="hljs-comment">// don&#x27;t let run yet</span><br>        <span class="hljs-comment">// 因为这里 N == 1，所以，只要调用一次，那么所有的 await 方法都可以通过</span><br>        startSignal.countDown();      <span class="hljs-comment">// let all threads proceed</span><br>        doSomethingElse();<br>        <span class="hljs-comment">// 等待所有任务结束</span><br>        doneSignal.await();           <span class="hljs-comment">// wait for all to finish</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch startSignal;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch doneSignal;<br><br>    Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;<br>        <span class="hljs-keyword">this</span>.startSignal = startSignal;<br>        <span class="hljs-keyword">this</span>.doneSignal = doneSignal;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 为了让所有线程同时开始任务，我们让所有线程先阻塞在这里</span><br>            <span class="hljs-comment">// 等大家都准备好了，再打开这个门栓</span><br>            startSignal.await();<br>            doWork();<br>            doneSignal.countDown();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>        &#125; <span class="hljs-comment">// return;</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">()</span> </span>&#123; ...&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个例子中，doneSignal 同第一个例子的使用，我们说说这里的 startSignal。N 个新开启的线程都调用了startSignal.await() 进行阻塞等待，它们阻塞在<strong>栅栏</strong>上，只有当条件满足的时候（startSignal.countDown()），它们才能同时通过这个栅栏，目的是让所有的线程站在一个起跑线上。 </p>
<p> <img src="/img/work/5.png"> </p>
<p>如果始终只有一个线程调用 await 方法等待任务完成，那么 CountDownLatch 就会简单很多，所以之后的源码分析读者一定要在脑海中构建出这么一个场景：有 m 个线程是做任务的，有 n 个线程在某个栅栏上等待这 m 个线程做完任务，直到所有 m 个任务完成后，n 个线程同时通过栅栏。 </p>
<h3 id="1-2-源码分析"><a href="#1-2-源码分析" class="headerlink" title="1.2 源码分析"></a>1.2 源码分析</h3><p>构造方法，需要传入一个不小于 0 的整数： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CountDownLatch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;count &lt; 0&quot;</span>);<br>    <span class="hljs-keyword">this</span>.sync = <span class="hljs-keyword">new</span> Sync(count);<br>&#125;<br><span class="hljs-comment">// 老套路了，内部封装一个 Sync 类继承自 AQS</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    Sync(<span class="hljs-keyword">int</span> count) &#123;<br>        <span class="hljs-comment">// 这样就 state == count 了</span><br>        setState(count);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>代码都是套路，先分析套路：AQS 里面的 state 是一个整数值，这边用一个 int count 参数其实初始化就是设置了这个值，所有调用了 await 方法的等待线程会挂起，然后有其他一些线程会做 state = state - 1 操作，当 state 减到 0 的同时，那个将 state 减为 0 的线程会负责唤醒 所有调用了 await 方法的线程。都是套路啊，只是 Doug Lea 的套路很深，代码很巧妙，不然我们也没有要分析源码的必要。 </p>
</blockquote>
<p>对于 CountDownLatch，我们仅仅需要关心两个方法，一个是 countDown() 方法，另一个是 await() 方法。 </p>
<p>countDown() 方法每次调用都会将 state 减 1，直到 state 的值为 0；而 await 是一个阻塞方法，当 state 减为 0 的时候，await 方法才会返回。await 可以被多个线程调用，读者这个时候脑子里要有个图：所有调用了 await 方法的线程阻塞在 AQS 的阻塞队列中，等待条件满足（state == 0），将线程从队列中一个个唤醒过来。</p>
<p>我们用以下程序来分析源码，t1 和 t2 负责调用 countDown() 方法，t3 和 t4 调用 await 方法阻塞：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountDownLatchDemo</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">2</span>);<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程t1 正在处理任务中。。。。&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">5000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;线程t1 任务处理完毕.&quot;</span>);<br><br>            <span class="hljs-comment">//休息 5秒后(模拟线程工作了5秒),调用countDown()</span><br>            latch.countDown();<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程t2 正在处理任务中。。。。&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">10000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;线程t2 处理任务完毕&quot;</span>);<br><br>            <span class="hljs-comment">//休息10秒(模拟线程工作了10秒)，调用countDown()</span><br>            latch.countDown();<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br><br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><br>            <span class="hljs-comment">//阻塞，等待state为0</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                latch.await();<br>                System.out.println(<span class="hljs-string">&quot;线程t3从await中返回了&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程 t3 await 被中断&quot;</span>);<br>                Thread.currentThread().interrupt();<br>            &#125;<br><br>        &#125;, <span class="hljs-string">&quot;t3&quot;</span>);<br><br>        Thread t4 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                latch.await();<br>                System.out.println(<span class="hljs-string">&quot;线程t4从await中返回了&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程 t4 await 被中断&quot;</span>);<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t4&quot;</span>);<br><br>        t3.start();<br>        t4.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs txt">线程t1 正在处理任务中。。。。<br>线程t2 正在处理任务中。。。。<br>线程t1 任务处理完毕.<br>线程t2 处理任务完毕<br>线程t3从await中返回了<br>线程t4从await中返回了<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这两条输出，顺序不是绝对的 </p>
<p>后面的分析，我们假设 t3 先进入阻塞队列 </p>
</blockquote>
<p>接下来，我们按照流程一步一步走：先 await 等待，然后被唤醒，await 方法返回。 </p>
<p>首先，我们来看 await() 方法，它代表线程阻塞，等待 state 的值减为 0 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 这也是老套路了，我在第二篇的中断那一节说过了</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br><br>    <span class="hljs-comment">// t3 和 t4 调用 await 的时候，state 都大于 0（state 此时为 2）。</span><br>    <span class="hljs-comment">// 也就是说，这个 if 返回 true，然后往里看</span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireSharedInterruptibly(arg);<br>&#125;<br><br><span class="hljs-comment">// 只有当 state == 0 的时候，这个方法才会返回 1</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从方法名我们就可以看出，这个方法是获取共享锁，并且此方法是可中断的（中断的时候抛出 InterruptedException 退出这个方法）。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 1. 入队</span><br>    <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);<br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-comment">// 同上，只要 state 不等于 0，那么这个方法返回 -1</span><br>                <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 2</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>        &#125;<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们来仔细分析这个方法，线程 t3 经过第 1 步 addWaiter 入队以后，我们应该可以得到这个： </p>
<p> <img src="/img/work/2.png"> </p>
<p>由于 tryAcquireShared 这个方法会返回 -1，所以 if (r &gt;= 0) 这个分支不会进去。到 shouldParkAfterFailedAcquire 的时候，t3 将 head 的 waitStatus 值设置为 -1，如下： </p>
<p> <img src="/img/work/3.png"> </p>
<p>然后进入到 parkAndCheckInterrupt 的时候，t3 挂起。 </p>
<p>我们再分析 t4 入队，t4 会将前驱节点 t3 所在节点的 waitStatus 设置为 -1，t4 入队后，应该是这样的： </p>
<p> <img src="/img/work/4.png"> </p>
<p>然后，t4 也挂起。接下来，t3 和 t4 就等待唤醒了。 </p>
<p>接下来，我们来看唤醒的流程。为了让下面的示意图更丰富些，我们假设用 10 初始化 CountDownLatch。 </p>
<p> <img src="/img/work/1.png"> </p>
<p>当然，我们的例子中，其实没有 10 个线程，只有 2 个线程 t1 和 t2，只是为了让图好看些罢了。 </p>
<p>我们再一步步看具体的流程。首先，我们看 countDown() 方法: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countDown</span><span class="hljs-params">()</span> </span>&#123;<br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-comment">// 只有当 state 减为 0 的时候，tryReleaseShared 才返回 true</span><br>    <span class="hljs-comment">// 否则只是简单的 state = state - 1 那么 countDown() 方法就结束了</span><br>    <span class="hljs-comment">//    将 state 减到 0 的那个操作才是最复杂的，继续往下吧</span><br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        <span class="hljs-comment">// 唤醒 await 的线程</span><br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-comment">// 这个方法很简单，用自旋的方法实现 state 减 1</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">int</span> nextc = c-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>            <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>countDown 方法就是每次调用都将 state 值减 1，如果 state 减到 0 了，那么就调用下面的方法进行唤醒阻塞队列中的线程： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用这个方法的时候，state == 0</span><br><span class="hljs-comment">// 这个方法先不要看所有的代码，按照思路往下到我写注释的地方，我们先跑通一个流程，其他的之后还会仔细分析</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Node h = head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-keyword">int</span> ws = h.waitStatus;<br>            <span class="hljs-comment">// t3 入队的时候，已经将头节点的 waitStatus 设置为 Node.SIGNAL（-1） 了</span><br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-comment">// 将 head 的 waitStatue 设置为 0</span><br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                <span class="hljs-comment">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span><br>                <span class="hljs-comment">// 在这里，也就是唤醒 t3</span><br>                unparkSuccessor(h);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                       !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE)) <span class="hljs-comment">// todo</span><br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>            <span class="hljs-keyword">if</span> (h == head)               <span class="hljs-comment">// loop if head changed</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一旦 t3 被唤醒后，我们继续回到 await 的这段代码，parkAndCheckInterrupt 返回，我们先不考虑中断的情况： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);<br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    setHeadAndPropagate(node, r); <span class="hljs-comment">// 2. 这里是下一步</span><br>                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                <span class="hljs-comment">// 1. 唤醒后这个方法返回</span><br>                parkAndCheckInterrupt())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来，t3 会进到 setHeadAndPropagate(node, r) 这个方法，先把 head 给占了，然后唤醒队列中其他的线程： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;<br>    Node h = head; <span class="hljs-comment">// Record old head for check below</span><br>    setHead(node);<br><br>    <span class="hljs-comment">// 下面说的是，唤醒当前 node 之后的节点，即 t3 已经醒了，马上唤醒 t4</span><br>    <span class="hljs-comment">// 类似的，如果 t4 后面还有 t5，那么 t4 醒了以后，马上将 t5 给唤醒了</span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||<br>        (h = head) == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>        Node s = node.next;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared())<br>            <span class="hljs-comment">// 又是这个方法，只是现在的 head 已经不是原来的空节点了，是 t3 的节点了</span><br>            doReleaseShared();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>又回到这个方法了，那么接下来，我们好好分析 doReleaseShared 这个方法，我们根据流程，头节点 head 此时是 t3 节点了： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用这个方法的时候，state == 0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      Node h = head;<br>      <span class="hljs-comment">// 1. h == null: 说明阻塞队列为空</span><br>      <span class="hljs-comment">// 2. h == tail: 说明头结点可能是刚刚初始化的头节点，</span><br>      <span class="hljs-comment">//   或者是普通线程节点，但是此节点既然是头节点了，那么代表已经被唤醒了，阻塞队列没有其他节点了</span><br>      <span class="hljs-comment">// 所以这两种情况不需要进行唤醒后继节点</span><br>      <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;<br>        <span class="hljs-keyword">int</span> ws = h.waitStatus;<br>        <span class="hljs-comment">// t4 将头节点(此时是 t3)的 waitStatus 设置为 Node.SIGNAL（-1） 了</span><br>        <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>          <span class="hljs-comment">// 这里 CAS 失败的场景请看下面的解读</span><br>          <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>            <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>          <span class="hljs-comment">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span><br>          <span class="hljs-comment">// 在这里，也就是唤醒 t4</span><br>          unparkSuccessor(h);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                 <span class="hljs-comment">// 这个 CAS 失败的场景是：执行到这里的时候，刚好有一个节点入队，入队会将这个 ws 设置为 -1</span><br>                 !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>          <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        <br>      &#125;<br>      <span class="hljs-comment">// 如果到这里的时候，前面唤醒的线程已经占领了 head，那么再循环</span><br>      <span class="hljs-comment">// 否则，就是 head 没变，那么退出循环，</span><br>      <span class="hljs-comment">// 退出循环是不是意味着阻塞队列中的其他节点就不唤醒了？当然不是，唤醒的线程之后还是会调用这个方法的</span><br>      <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们分析下最后一个 if 语句，然后才能解释第一个 CAS 为什么可能会失败：</p>
<ol>
<li>h == head：说明头节点还没有被刚刚用 unparkSuccessor 唤醒的线程（这里可以理解为 t4）占有，此时 break 退出循环。</li>
<li>h != head：头节点被刚刚唤醒的线程（这里可以理解为 t4）占有，那么这里重新进入下一轮循环，唤醒下一个节点（这里是 t4 ）。我们知道，等到 t4 被唤醒后，其实是会主动唤醒 t5、t6、t7…，那为什么这里要进行下一个循环来唤醒 t5 呢？我觉得是出于吞吐量的考虑。</li>
</ol>
<p>满足上面的 2 的场景，那么我们就能知道为什么上面的 CAS 操作 compareAndSetWaitStatus(h, Node.SIGNAL, 0) 会失败了？</p>
<p>因为当前进行 for 循环的线程到这里的时候，可能刚刚唤醒的线程 t4 也刚刚好到这里了，那么就有可能 CAS 失败了。</p>
<p>for 循环第一轮的时候会唤醒 t4，t4 醒后会将自己设置为头节点，如果在 t4 设置头节点后，for 循环才跑到 if (h == head)，那么此时会返回 false，for 循环会进入下一轮。t4 唤醒后也会进入到这个方法里面，那么 for 循环第二轮和 t4 就有可能在这个 CAS 相遇，那么就只会有一个成功了。</p>
<h2 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2. CyclicBarrier"></a>2. CyclicBarrier</h2><p>字面意思是“可重复使用的栅栏”或“周期性的栅栏”，总之不是用了一次就没用了的，CyclicBarrier 相比 CountDownLatch 来说，要简单很多，其源码没有什么高深的地方，它是 ReentrantLock 和 Condition 的组合使用。看如下示意图，CyclicBarrier 和 CountDownLatch 是不是很像，只是 CyclicBarrier 可以有不止一个栅栏，因为它的栅栏（Barrier）可以重复使用（Cyclic）。</p>
<p><img src="/img/work/cyclicbarrier-2.png"></p>
<p>首先，CyclicBarrier 的源码实现和 CountDownLatch 大相径庭，CountDownLatch 基于 AQS 的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现。</p>
<p>因为 CyclicBarrier 的源码相对来说简单许多，读者只要熟悉Condition ，那么这里的源码是毫无压力的，就是几个特殊概念罢了。</p>
<p>先用一张图来描绘下 CyclicBarrier 里面的一些概念，和它的基本使用流程：</p>
<p><img src="/img/work/cyclicbarrier-3.png"></p>
<blockquote>
<p>看图我们也知道了，CyclicBarrier 的源码最重要的就是 await() 方法了。</p>
</blockquote>
<p>大家先把图看完，然后我们开始源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrier</span> </span>&#123;<br>  <span class="hljs-comment">// 我们说了，CyclicBarrier 是可以重复使用的，我们把每次从开始使用到穿过栅栏当做&quot;一代&quot;，或者&quot;一个周期&quot;</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generation</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> broken = <span class="hljs-keyword">false</span>;<br>  &#125;<br>  <span class="hljs-comment">/** The lock for guarding barrier entry */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>  <br>  <span class="hljs-comment">// CyclicBarrier 是基于 Condition 的</span><br>  <span class="hljs-comment">// Condition 是“条件”的意思，CyclicBarrier 的等待线程通过 barrier 的“条件”是大家都到了栅栏上</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition trip = lock.newCondition();<br>  <br>  <span class="hljs-comment">// 参与的线程数</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> parties;<br>  <br>  <span class="hljs-comment">// 如果设置了这个，代表越过栅栏之前，要执行相应的操作</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable barrierCommand;<br>  <br>  <span class="hljs-comment">// 当前所处的“代”</span><br>  <span class="hljs-keyword">private</span> Generation generation = <span class="hljs-keyword">new</span> Generation();<br>  <br>  <span class="hljs-comment">// 还没有到栅栏的线程数，这个值初始为 parties，然后递减</span><br>  <span class="hljs-comment">// 还没有到栅栏的线程数 = parties - 已经到栅栏的数量</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (parties &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-keyword">this</span>.parties = parties;<br>    <span class="hljs-keyword">this</span>.count = parties;<br>    <span class="hljs-keyword">this</span>.barrierCommand = barrierAction;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parties)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(parties, <span class="hljs-keyword">null</span>);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先，先看怎么开启新的一代：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 开启新的一代，当最后一个线程到达栅栏上的时候，调用这个方法来唤醒其他线程，同时初始化“下一代”</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextGeneration</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 首先，需要唤醒所有的在栅栏上等待的线程</span><br>    trip.signalAll();<br>    <span class="hljs-comment">// 更新 count 的值</span><br>    count = parties;<br>    <span class="hljs-comment">// 重新生成“新一代”</span><br>    generation = <span class="hljs-keyword">new</span> Generation();<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>开启新的一代，类似于重新实例化一个 CyclicBarrier 实例</p>
</blockquote>
<p>看看怎么打破一个栅栏：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">breakBarrier</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 设置状态 broken 为 true</span><br>    generation.broken = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">// 重置 count 为初始值 parties</span><br>    count = parties;<br>    <span class="hljs-comment">// 唤醒所有已经在等待的线程</span><br>    trip.signalAll();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这两个方法之后用得到，现在开始分析最重要的等待通过栅栏方法 await 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不带超时机制</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> dowait(<span class="hljs-keyword">false</span>, <span class="hljs-number">0L</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(toe); <span class="hljs-comment">// cannot happen</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 带超时机制，如果超时抛出 TimeoutException 异常</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException,</span><br><span class="hljs-function">           BrokenBarrierException,</span><br><span class="hljs-function">           TimeoutException </span>&#123;<br>    <span class="hljs-keyword">return</span> dowait(<span class="hljs-keyword">true</span>, unit.toNanos(timeout));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>继续往里看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dowait</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> timed, <span class="hljs-keyword">long</span> nanos)</span></span><br><span class="hljs-function">  <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException,TimeoutException </span>&#123;<br>  <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>  <span class="hljs-comment">// 先要获取到锁，然后在 finally 中要记得释放锁</span><br>  <span class="hljs-comment">// 如果记得 Condition 部分的话，我们知道 condition 的 await() 会释放锁，被 signal() 唤醒的时候需要重新获取锁</span><br>  lock.lock();<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">final</span> Generation g = generation;<br>    <span class="hljs-comment">// 检查栅栏是否被打破，如果被打破，抛出 BrokenBarrierException 异常</span><br>    <span class="hljs-keyword">if</span> (g.broken)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BrokenBarrierException();<br>    <span class="hljs-comment">// 检查中断状态，如果中断了，抛出 InterruptedException 异常</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>      breakBarrier();<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>    &#125;<br>    <span class="hljs-comment">// index 是这个 await 方法的返回值</span><br>    <span class="hljs-comment">// 注意到这里，这个是从 count 递减后得到的值</span><br>    <span class="hljs-keyword">int</span> index = --count;<br>    <span class="hljs-comment">// 如果等于 0，说明所有的线程都到栅栏上了，准备通过</span><br>    <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// tripped</span><br>      <span class="hljs-keyword">boolean</span> ranAction = <span class="hljs-keyword">false</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果在初始化的时候，指定了通过栅栏前需要执行的操作，在这里会得到执行</span><br>        <span class="hljs-keyword">final</span> Runnable command = barrierCommand;<br>        <span class="hljs-keyword">if</span> (command != <span class="hljs-keyword">null</span>)<br>          command.run();<br>        <span class="hljs-comment">// 如果 ranAction 为 true，说明执行 command.run() 的时候，没有发生异常退出的情况</span><br>        ranAction = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">// 唤醒等待的线程，然后开启新的一代</span><br>        nextGeneration();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (!ranAction)<br>          <span class="hljs-comment">// 进到这里，说明执行指定操作的时候，发生了异常，那么需要打破栅栏</span><br>          <span class="hljs-comment">// 之前我们说了，打破栅栏意味着唤醒所有等待的线程，设置 broken 为 true，重置 count 为 parties</span><br>          breakBarrier();<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// loop until tripped, broken, interrupted, or timed out</span><br>    <span class="hljs-comment">// 如果是最后一个线程调用 await，那么上面就返回了</span><br>    <span class="hljs-comment">// 下面的操作是给那些不是最后一个到达栅栏的线程执行的</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果带有超时机制，调用带超时的 Condition 的 await 方法等待，直到最后一个线程调用 await</span><br>        <span class="hljs-keyword">if</span> (!timed)<br>          trip.await();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0L</span>)<br>          nanos = trip.awaitNanos(nanos);<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>        <span class="hljs-comment">// 如果到这里，说明等待的线程在 await（是 Condition 的 await）的时候被中断</span><br>        <span class="hljs-keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;<br>          <span class="hljs-comment">// 打破栅栏</span><br>          breakBarrier();<br>          <span class="hljs-comment">// 打破栅栏后，重新抛出这个 InterruptedException 异常给外层调用的方法</span><br>          <span class="hljs-keyword">throw</span> ie;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 到这里，说明 g != generation, 说明新的一代已经产生，即最后一个线程 await 执行完成，</span><br>          <span class="hljs-comment">// 那么此时没有必要再抛出 InterruptedException 异常，记录下来这个中断信息即可</span><br>          <span class="hljs-comment">// 或者是栅栏已经被打破了，那么也不应该抛出 InterruptedException 异常，</span><br>          <span class="hljs-comment">// 而是之后抛出 BrokenBarrierException 异常</span><br>          Thread.currentThread().interrupt();<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 唤醒后，检查栅栏是否是“破的”</span><br>      <span class="hljs-keyword">if</span> (g.broken)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BrokenBarrierException();<br>      <span class="hljs-comment">// 这个 for 循环除了异常，就是要从这里退出了</span><br>      <span class="hljs-comment">// 我们要清楚，最后一个线程在执行完指定任务(如果有的话)，会调用 nextGeneration 来开启一个新的代</span><br>      <span class="hljs-comment">// 然后释放掉锁，其他线程从 Condition 的 await 方法中得到锁并返回，然后到这里的时候，其实就会满足 g != generation 的</span><br>      <span class="hljs-comment">// 那什么时候不满足呢？barrierCommand 执行过程中抛出了异常，那么会执行打破栅栏操作，</span><br>      <span class="hljs-comment">// 设置 broken 为true，然后唤醒这些线程。这些线程会从上面的 if (g.broken) 这个分支抛 BrokenBarrierException 异常返回</span><br>      <span class="hljs-comment">// 当然，还有最后一种可能，那就是 await 超时，此种情况不会从上面的 if 分支异常返回，也不会从这里返回，会执行后面的代码</span><br>      <span class="hljs-keyword">if</span> (g != generation)<br>        <span class="hljs-keyword">return</span> index;<br>      <span class="hljs-comment">// 如果醒来发现超时了，打破栅栏，抛出异常</span><br>      <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>        breakBarrier();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TimeoutException();<br>      &#125;<br>    &#125;<br>  &#125;<span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面开始收尾工作。</p>
<p>首先，我们看看怎么得到有多少个线程到了栅栏上，处于等待状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumberWaiting</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> parties - count;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>判断一个栅栏是否被打破了，这个很简单，直接看 broken 的值即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBroken</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> generation.broken;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>前面我们在说 await 的时候也几乎说清楚了，什么时候栅栏会被打破，总结如下：</p>
<ul>
<li>中断，我们说了，如果某个等待的线程发生了中断，那么会打破栅栏，同时抛出 InterruptedException 异常；</li>
<li>超时，打破栅栏，同时抛出 TimeoutException 异常；</li>
<li>指定执行的操作抛出了异常，这个我们前面也说过。</li>
</ul>
<p>最后，我们来看看怎么重置一个栅栏：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        breakBarrier();   <span class="hljs-comment">// break the current generation</span><br>        nextGeneration(); <span class="hljs-comment">// start a new generation</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们设想一下，如果初始化时，指定了线程 parties = 4，前面有 3 个线程调用了 await 等待，在第 4 个线程调用 await 之前，我们调用 reset 方法，那么会发生什么？</p>
<p>首先，打破栅栏，那意味着所有等待的线程（3个等待的线程）会唤醒，await 方法会通过抛出 BrokenBarrierException 异常返回。然后开启新的一代，重置了 count 和 generation，相当于一切归零了。</p>
<p>使用示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierDemo</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">4</span>;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(N, () -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前线程&quot;</span> + Thread.currentThread().getName());<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>            MyThread myThread = <span class="hljs-keyword">new</span> MyThread(cyclicBarrier);<br>            <span class="hljs-keyword">new</span> Thread(myThread).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> CyclicBarrier cyclicBarrier;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.cyclicBarrier = cyclicBarrier;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;正在写入数据...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 以睡眠来模拟写入数据操作</span><br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>                System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;写入数据完毕，等待其他线程写入完毕&quot;</span>);<br>                cyclicBarrier.await();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h2><p>有了 CountDownLatch 的基础后，分析 Semaphore 会简单很多。Semaphore 是什么呢？它类似一个资源池（读者可以类比线程池），每个线程需要调用 acquire() 方法获取资源，然后才能执行，执行完后，需要 release 资源，让给其他的线程用。</p>
<p>大概大家也可以猜到，Semaphore 其实也是 AQS 中共享锁的使用，因为每个线程共享一个池嘛。</p>
<p>套路解读：创建 Semaphore 实例的时候，需要一个参数 permits，这个基本上可以确定是设置给 AQS 的 state 的，然后每个线程调用 acquire 的时候，执行 state = state - 1，release 的时候执行 state = state + 1，当然，acquire  的时候，如果 state = 0，说明没有资源了，需要等待其他线程 release。</p>
<p><strong>使用示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SemaphoreDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THREAD_COUNT = <span class="hljs-number">30</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; THREAD_COUNT; i++) &#123;<br>            threadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        semaphore.acquire();<br>                        System.out.println(<span class="hljs-string">&quot;save data&quot;</span>);<br>                        semaphore.release();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br><br>        threadPool.shutdown();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>源码分析:</strong></p>
<p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Semaphore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permits)</span> </span>&#123;<br>    sync = <span class="hljs-keyword">new</span> NonfairSync(permits);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Semaphore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permits, <span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> FairSync(permits) : <span class="hljs-keyword">new</span> NonfairSync(permits);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里和 ReentrantLock 类似，用了公平策略和非公平策略。</p>
<p>看 acquire 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireUninterruptibly</span><span class="hljs-params">()</span> </span>&#123;<br>    sync.acquireShared(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permits)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">if</span> (permits &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    sync.acquireSharedInterruptibly(permits);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireUninterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permits)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (permits &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    sync.acquireShared(permits);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这几个方法也是老套路了，大家基本都懂了吧，这边多了两个可以传参的 acquire 方法，不过大家也都懂的吧，如果我们需要一次获取超过一个的资源，会用得着这个的。</p>
<p>我们接下来看不抛出 InterruptedException 异常的 acquireUninterruptibly() 方法吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireUninterruptibly</span><span class="hljs-params">()</span> </span>&#123;<br>    sync.acquireShared(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>前面说了，Semaphore 分公平策略和非公平策略，我们对比一下两个 tryAcquireShared 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 公平策略：</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 区别就在于是不是会先判断是否有线程在排队，然后才进行 CAS 减操作</span><br>        <span class="hljs-keyword">if</span> (hasQueuedPredecessors())<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> available = getState();<br>        <span class="hljs-keyword">int</span> remaining = available - acquires;<br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>            compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 非公平策略：</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> nonfairTryAcquireShared(acquires);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> available = getState();<br>        <span class="hljs-keyword">int</span> remaining = available - acquires;<br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>            compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>也是老套路了，所以从源码分析角度的话，我们其实不太需要关心是不是公平策略还是非公平策略，它们的区别往往就那么一两行。</p>
<p>我们再回到 acquireShared 方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于 tryAcquireShared(arg) 返回小于 0 的时候，说明 state 已经小于 0 了（没资源了），此时 acquire 不能立马拿到资源，需要进入到阻塞队列等待，虽然贴了很多代码，不在乎多这点了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);<br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted)<br>                        selfInterrupt();<br>                    failed = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法我就不介绍了，线程挂起后等待有资源被 release 出来。接下来，我们就要看 release 的方法了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 任务介绍，释放一个资源</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;<br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> current = getState();<br>        <span class="hljs-keyword">int</span> next = current + releases;<br>        <span class="hljs-comment">// 溢出，当然，我们一般也不会用这么大的数</span><br>        <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br>        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>tryReleaseShared 方法总是会返回 true，然后是 doReleaseShared，这个也是我们熟悉的方法了，我就贴下代码，不分析了，这个方法用于唤醒所有的等待线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Node h = head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-keyword">int</span> ws = h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Semphore 的源码确实很简单，基本上都是分析过的老代码的组合使用了。</p>
<p><code>Semaphore</code> 应用场景：</p>
<ul>
<li><code>Semaphore</code> 可以用于实现资源池，如数据库连接池。</li>
<li><code>Semaphore</code> 可以用于将任何一种容器变成有界阻塞容器。</li>
</ul>
<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p><a href="https://dunwu.github.io/javacore/concurrent/Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_1-countdownlatch">Java工具类</a></p>
<p><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-3">并发工具详解</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>并发工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发核心机制-CAS及ThreadLocal</title>
    <url>/2022/05/09/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-CAS%E5%8F%8AThreadLocal/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-CAS"><a href="#1-CAS" class="headerlink" title="1.CAS"></a>1.CAS</h2><h3 id="1-1-CAS-的要点"><a href="#1-1-CAS-的要点" class="headerlink" title="1.1 CAS 的要点"></a>1.1 CAS 的要点</h3><p>互斥同步是最常见的并发正确性保障手段。  </p>
<p><strong>互斥同步最主要的问题是线程阻塞和唤醒所带来的性能问题</strong>，因此互斥同步也被称为阻塞同步。 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。  </p>
<p>随着硬件指令集的发展， 我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。    </p>
<p>为什么说乐观锁需要 <strong>硬件指令集的发展</strong> 才能进行？因为需要操作和冲突检测这两个步骤具备原子性。而这点是由硬件来完成，如果再使用互斥同步来保证就失去意义了。硬件支持的原子性操作最典型的是：CAS。 </p>
<p><strong>CAS（Compare and Swap），字面意思为比较并交换。CAS 有 3 个操作数，分别是：内存值 M，期望值 E，更新值 U。当且仅当内存值 M 和期望值 E 相等时，将内存值 M 修改为 U，否则什么都不做</strong>。 </p>
<h3 id="1-2-CAS的应用"><a href="#1-2-CAS的应用" class="headerlink" title="1.2 CAS的应用"></a>1.2 CAS的应用</h3><p><strong>CAS 只适用于线程冲突较少的情况</strong>。 </p>
<p>CAS 的典型应用场景是： </p>
<ul>
<li>原子类</li>
<li>自旋锁</li>
</ul>
<h4 id="1-2-1-原子类"><a href="#1-2-1-原子类" class="headerlink" title="1.2.1 原子类"></a>1.2.1 原子类</h4><blockquote>
<p> 原子类是 CAS 在 Java 中最典型的应用。 </p>
</blockquote>
<p>我们先来看一个常见的代码片段。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(a==b) &#123;<br>    a++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果 <code>a++</code> 执行前， a 的值被修改了怎么办？还能得到预期值吗？出现该问题的原因是在并发环境下，以上代码片段不是原子操作，随时可能被其他线程所篡改。 </p>
<p>解决这种问题的最经典方式是应用原子类的 <code>incrementAndGet</code> 方法 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerDemo</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        AtomicInteger integer = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            executorService.execute(() -&gt; integer.incrementAndGet());<br>        &#125;<br><br>        executorService.shutdown();<br><br>        executorService.awaitTermination(<span class="hljs-number">3</span>, TimeUnit.SECONDS);<br><br>        System.out.println(<span class="hljs-string">&quot;Final Count is: &quot;</span> + integer.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>J.U.C 包中提供了 <code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code> 分别针对 <code>Boolean</code>、<code>Integer</code>、<code>Long</code> 执行原子操作，操作和上面的示例大体相似，不做赘述。 </p>
<h4 id="1-2-2-自旋锁"><a href="#1-2-2-自旋锁" class="headerlink" title="1.2.2 自旋锁"></a>1.2.2 自旋锁</h4><p>利用原子类（本质上是 CAS），可以实现自旋锁。 </p>
<p>所谓自旋锁，是指线程反复检查锁变量是否可用，直到成功为止。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。  </p>
<p>示例：非线程安全示例 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicReferenceDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            executorService.execute(<span class="hljs-keyword">new</span> MyThread());<br>        &#125;<br>        executorService.shutdown();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 卖出了第 &quot;</span> + ticket + <span class="hljs-string">&quot; 张票&quot;</span>);<br>                ticket--;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p> 输出结果： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 卖出了第 <span class="hljs-number">10</span> 张票<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 卖出了第 <span class="hljs-number">10</span> 张票<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 卖出了第 <span class="hljs-number">10</span> 张票<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 卖出了第 <span class="hljs-number">8</span> 张票<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 卖出了第 <span class="hljs-number">9</span> 张票<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 卖出了第 <span class="hljs-number">6</span> 张票<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 卖出了第 <span class="hljs-number">7</span> 张票<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 卖出了第 <span class="hljs-number">4</span> 张票<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 卖出了第 <span class="hljs-number">5</span> 张票<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 卖出了第 <span class="hljs-number">2</span> 张票<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 卖出了第 <span class="hljs-number">3</span> 张票<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 卖出了第 <span class="hljs-number">1</span> 张票<br></code></pre></td></tr></table></figure>

<p>很明显，出现了重复售票的情况。 </p>
<p>【示例】使用自旋锁来保证线程安全 </p>
<p>可以通过自旋锁这种非阻塞同步来保证线程安全，下面使用 <code>AtomicReference</code> 来实现一个自旋锁。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicReferenceDemo2</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        threadSafeDemo();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">threadSafeDemo</span><span class="hljs-params">()</span> </span>&#123;<br>        SpinLock lock = <span class="hljs-keyword">new</span> SpinLock();<br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            executorService.execute(<span class="hljs-keyword">new</span> MyThread(lock));<br>        &#125;<br>        executorService.shutdown();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpinLock</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>            Thread current = Thread.currentThread();<br>            <span class="hljs-keyword">while</span> (!atomicReference.compareAndSet(<span class="hljs-keyword">null</span>, current)) &#123;&#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>            Thread current = Thread.currentThread();<br>            atomicReference.compareAndSet(current, <span class="hljs-keyword">null</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> SpinLock lock;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(SpinLock lock)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.lock = lock;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                lock.lock();<br>                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 卖出了第 &quot;</span> + ticket + <span class="hljs-string">&quot; 张票&quot;</span>);<br>                    ticket--;<br>                &#125;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">pool-1-thread-2 卖出了第 10 张票<br>pool-1-thread-1 卖出了第 9 张票<br>pool-1-thread-3 卖出了第 8 张票<br>pool-1-thread-2 卖出了第 7 张票<br>pool-1-thread-3 卖出了第 6 张票<br>pool-1-thread-1 卖出了第 5 张票<br>pool-1-thread-2 卖出了第 4 张票<br>pool-1-thread-1 卖出了第 3 张票<br>pool-1-thread-3 卖出了第 2 张票<br>pool-1-thread-1 卖出了第 1 张票<br></code></pre></td></tr></table></figure>

<h3 id="1-3-CAS的原理"><a href="#1-3-CAS的原理" class="headerlink" title="1.3 CAS的原理"></a>1.3 CAS的原理</h3><p> Java 主要利用 <code>Unsafe</code> 这个类提供的 CAS 操作。<code>Unsafe</code> 的 CAS 依赖的是 JVM 针对不同的操作系统实现的硬件指令 <code>Atomic::cmpxchg</code>。<code>Atomic::cmpxchg</code> 的实现使用了汇编的 CAS 操作，并使用 CPU 提供的 <code>lock</code> 信号保证其原子性。 </p>
<h3 id="1-4-CAS的问题"><a href="#1-4-CAS的问题" class="headerlink" title="1.4 CAS的问题"></a>1.4 CAS的问题</h3><p>一般情况下，CAS 比锁性能更高。因为 CAS 是一种非阻塞算法，所以其避免了线程阻塞和唤醒的等待时间。</p>
<p>但是，事物总会有利有弊，CAS 也存在三大问题：</p>
<ul>
<li>ABA 问题</li>
<li>循环时间长开销大</li>
<li>只能保证一个共享变量的原子性</li>
</ul>
<h4 id="1-4-1-ABA-问题"><a href="#1-4-1-ABA-问题" class="headerlink" title="1.4.1 ABA 问题"></a>1.4.1 ABA 问题</h4><p><strong>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过</strong>。 </p>
<p>J.U.C 包提供了一个带有标记的<strong>原子引用类 <code>AtomicStampedReference</code> 来解决这个问题</strong>，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用<strong>传统的互斥同步可能会比原子类更高效</strong>。 </p>
<h4 id="1-4-2-循环时间长开销大"><a href="#1-4-2-循环时间长开销大" class="headerlink" title="1.4.2 循环时间长开销大"></a>1.4.2 循环时间长开销大</h4><p><strong>自旋 CAS （不断尝试，直到成功为止）如果长时间不成功，会给 CPU 带来非常大的执行开销</strong>。 </p>
<p>如果 JVM 能支持处理器提供的 <code>pause</code> 指令那么效率会有一定的提升，<code>pause</code> 指令有两个作用： </p>
<ul>
<li>它可以延迟流水线执行指令（de-pipeline）,使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li>
<li>它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。</li>
</ul>
<p>比较花费 CPU 资源，即使没有任何用也会做一些无用功。 </p>
<h4 id="1-4-3-只能保证一个共享变量的原子性"><a href="#1-4-3-只能保证一个共享变量的原子性" class="headerlink" title="1.4.3 只能保证一个共享变量的原子性"></a>1.4.3 只能保证一个共享变量的原子性</h4><p>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量 <code>i ＝ 2, j = a</code>，合并一下 <code>ij=2a</code>，然后用 CAS 来操作 <code>ij</code>。从 Java 1.5 开始 JDK 提供了 <code>AtomicReference</code> 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。 </p>
<h2 id="2-UnSafe类详解"><a href="#2-UnSafe类详解" class="headerlink" title="2.UnSafe类详解"></a>2.UnSafe类详解</h2><blockquote>
<p>上文我们了解到Java原子类是通过UnSafe类实现的，这节主要分析下UnSafe类。UnSafe类在J.U.C中CAS操作有很广泛的应用。 </p>
</blockquote>
<p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。</p>
<p>这个类尽管里面的方法都是 public 的，但是并没有办法使用它们，JDK API 文档也没有提供任何关于这个类的方法的解释。总而言之，对于 Unsafe 类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然 JDK 库里面的类是可以随意使用的。</p>
<p>先来看下这张图，对UnSafe类总体功能： </p>
<p><img src="/img/work/java-thread-x-atomicinteger-unsafe.png"></p>
<p>如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍。 </p>
<h3 id="2-1-Unsafe与CAS"><a href="#2-1-Unsafe与CAS" class="headerlink" title="2.1 Unsafe与CAS"></a>2.1 Unsafe与CAS</h3><p>反编译出来的代码： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object paramObject, <span class="hljs-keyword">long</span> paramLong, <span class="hljs-keyword">int</span> paramInt)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">do</span><br>      i = getIntVolatile(paramObject, paramLong);<br>    <span class="hljs-keyword">while</span> (!compareAndSwapInt(paramObject, paramLong, i, i + paramInt));<br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getAndAddLong</span><span class="hljs-params">(Object paramObject, <span class="hljs-keyword">long</span> paramLong1, <span class="hljs-keyword">long</span> paramLong2)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">long</span> l;<br>    <span class="hljs-keyword">do</span><br>      l = getLongVolatile(paramObject, paramLong1);<br>    <span class="hljs-keyword">while</span> (!compareAndSwapLong(paramObject, paramLong1, l, l + paramLong2));<br>    <span class="hljs-keyword">return</span> l;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndSetInt</span><span class="hljs-params">(Object paramObject, <span class="hljs-keyword">long</span> paramLong, <span class="hljs-keyword">int</span> paramInt)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">do</span><br>      i = getIntVolatile(paramObject, paramLong);<br>    <span class="hljs-keyword">while</span> (!compareAndSwapInt(paramObject, paramLong, i, paramInt));<br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getAndSetLong</span><span class="hljs-params">(Object paramObject, <span class="hljs-keyword">long</span> paramLong1, <span class="hljs-keyword">long</span> paramLong2)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">long</span> l;<br>    <span class="hljs-keyword">do</span><br>      l = getLongVolatile(paramObject, paramLong1);<br>    <span class="hljs-keyword">while</span> (!compareAndSwapLong(paramObject, paramLong1, l, paramLong2));<br>    <span class="hljs-keyword">return</span> l;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">getAndSetObject</span><span class="hljs-params">(Object paramObject1, <span class="hljs-keyword">long</span> paramLong, Object paramObject2)</span></span><br><span class="hljs-function">  </span>&#123;<br>    Object localObject;<br>    <span class="hljs-keyword">do</span><br>      localObject = getObjectVolatile(paramObject1, paramLong);<br>    <span class="hljs-keyword">while</span> (!compareAndSwapObject(paramObject1, paramLong, localObject, paramObject2));<br>    <span class="hljs-keyword">return</span> localObject;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>从源码中发现，内部使用自旋的方式进行CAS更新(while循环进行CAS更新，如果更新失败，则循环再次重试)。</p>
<p>又从Unsafe类中发现，原子操作其实只支持下面三个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapObject</span><span class="hljs-params">(Object paramObject1, <span class="hljs-keyword">long</span> paramLong, Object paramObject2, Object paramObject3)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapInt</span><span class="hljs-params">(Object paramObject, <span class="hljs-keyword">long</span> paramLong, <span class="hljs-keyword">int</span> paramInt1, <span class="hljs-keyword">int</span> paramInt2)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapLong</span><span class="hljs-params">(Object paramObject, <span class="hljs-keyword">long</span> paramLong1, <span class="hljs-keyword">long</span> paramLong2, <span class="hljs-keyword">long</span> paramLong3)</span></span>;<br></code></pre></td></tr></table></figure>

<h3 id="2-2-Unsafe底层"><a href="#2-2-Unsafe底层" class="headerlink" title="2.2 Unsafe底层"></a>2.2 Unsafe底层</h3><p>不妨再看看Unsafe的compareAndSwap*方法来实现CAS操作，它是一个本地方法，实现位于unsafe.cpp中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))<br>  UnsafeWrapper(<span class="hljs-string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);<br>  oop p = JNIHandles::resolve(obj);<br>  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);<br>  <span class="hljs-keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;<br>UNSAFE_END<br></code></pre></td></tr></table></figure>

<p>可以看到它通过 <code>Atomic::cmpxchg</code> 来实现比较和替换操作。其中参数x是即将更新的值，参数e是原内存的值。</p>
<p>如果是Linux的x86，<code>Atomic::cmpxchg</code>方法的实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">inline</span> jint <span class="hljs-title">Atomic::cmpxchg</span> <span class="hljs-params">(jint exchange_value, <span class="hljs-keyword">volatile</span> jint* dest, jint compare_value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> mp = os::is_MP();<br>  <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span> <span class="hljs-params">(LOCK_IF_MP(%<span class="hljs-number">4</span>) <span class="hljs-string">&quot;cmpxchgl %1,(%3)&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">                    : <span class="hljs-string">&quot;=a&quot;</span> (exchange_value)</span></span><br><span class="hljs-params"><span class="hljs-function">                    : <span class="hljs-string">&quot;r&quot;</span> (exchange_value), <span class="hljs-string">&quot;a&quot;</span> (compare_value), <span class="hljs-string">&quot;r&quot;</span> (dest), <span class="hljs-string">&quot;r&quot;</span> (mp)</span></span><br><span class="hljs-params"><span class="hljs-function">                    : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>)</span></span>;<br>  <span class="hljs-keyword">return</span> exchange_value;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而windows的x86的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">inline jint Atomic::cmpxchg (jint exchange_value, <span class="hljs-keyword">volatile</span> jint* dest, jint compare_value) &#123;<br>    <span class="hljs-keyword">int</span> mp = os::isMP(); <span class="hljs-comment">//判断是否是多处理器</span><br>    _asm &#123;<br>        mov edx, dest<br>        mov ecx, exchange_value<br>        mov eax, <span class="hljs-function">compare_value</span><br><span class="hljs-function">        <span class="hljs-title">LOCK_IF_MP</span><span class="hljs-params">(mp)</span></span><br><span class="hljs-function">        cmpxchg dword ptr [edx], ecx</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">// Adding a lock prefix to an instruction on MP machine</span></span><br><span class="hljs-function"><span class="hljs-comment">// VC++ doesn&#x27;t like the lock prefix to be on a single line</span></span><br><span class="hljs-function"><span class="hljs-comment">// so we can&#x27;t insert a label after the lock prefix.</span></span><br><span class="hljs-function"><span class="hljs-comment">// By emitting a lock prefix, we can define a label after it.</span></span><br><span class="hljs-function">#define <span class="hljs-title">LOCK_IF_MP</span><span class="hljs-params">(mp)</span> __asm cmp mp, 0  \</span><br><span class="hljs-function">                       __asm je L0      \</span><br><span class="hljs-function">                       __asm _emit 0xF0 \</span><br><span class="hljs-function">                       __asm L0:</span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure>

<p>如果是多处理器，为cmpxchg指令添加lock前缀。反之，就省略lock前缀(单处理器会不需要lock前缀提供的内存屏障效果)。这里的lock前缀就是使用了处理器的总线锁(最新的处理器都使用缓存锁代替总线锁来提高性能)。</p>
<blockquote>
<p>cmpxchg(void* ptr, int old, int new)，如果ptr和old的值一样，则把new写到ptr内存，否则返回ptr的值，整个操作是原子的。在Intel平台下，会用lock cmpxchg来实现，使用lock触发缓存锁，这样另一个线程想访问ptr的内存，就会被block住。</p>
</blockquote>
<h2 id="3-ThreadLocal"><a href="#3-ThreadLocal" class="headerlink" title="3. ThreadLocal"></a>3. ThreadLocal</h2><blockquote>
<p><strong><code>ThreadLocal</code> 是一个存储线程本地副本的工具类</strong>。要保证线程安全，不一定非要进行同步。同步只是保证共享数据争用时的正确性，如果一个方法本来就不涉及共享数据，那么自然无须同步。</p>
<p>Java 中的 <strong>无同步方案</strong> 有：</p>
<ul>
<li><strong>可重入代码</strong> - 也叫纯代码。如果一个方法，它的<strong>返回结果是可以预测的</strong>，即只要输入了相同的数据，就能返回相同的结果，那它就满足可重入性，当然也是线程安全的。</li>
<li><strong>线程本地存储</strong> - 使用 <strong><code>ThreadLocal</code> 为共享变量在每个线程中都创建了一个本地副本</strong>，这个副本只能被当前线程访问，其他线程无法访问，那么自然是线程安全的。</li>
</ul>
</blockquote>
<p>总结而言：ThreadLocal是一个将在多线程中为每一个线程创建单独的变量副本的类; 当使用ThreadLocal来维护变量时, ThreadLocal会为每个线程创建单独的变量副本, 避免因多线程操作共享变量而导致的数据不一致的情况。</p>
<h3 id="3-1-ThreadLocal理解"><a href="#3-1-ThreadLocal理解" class="headerlink" title="3.1 ThreadLocal理解"></a>3.1 ThreadLocal理解</h3><blockquote>
<p>提到ThreadLocal被提到应用最多的是session管理和数据库链接管理，这里以数据访问为例帮助你理解ThreadLocal：</p>
</blockquote>
<ul>
<li>如下数据库管理类在单线程使用是没有任何问题的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionManager</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Connection connect = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">openConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (connect == <span class="hljs-keyword">null</span>) &#123;<br>            connect = DriverManager.getConnection();<br>        &#125;<br>        <span class="hljs-keyword">return</span> connect;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (connect != <span class="hljs-keyword">null</span>)<br>            connect.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>很显然，在多线程中使用会存在线程安全问题：</p>
<ol>
<li>这里面的2个方法都没有进行同步，很可能在openConnection方法中会多次创建connect；</li>
<li>由于connect是共享变量，那么必然在调用connect的地方需要使用到同步来保障线程安全，因为很可能一个线程在使用connect进行数据库操作，而另外一个线程调用closeConnection关闭链接。</li>
</ol>
<p>为了解决上述线程安全的问题,第一考虑：互斥同步;将这段代码的两个方法进行同步处理，并且在调用connect的地方需要进行同步处理，比如用Synchronized或者ReentrantLock互斥锁。</p>
<p>这里抛出一个问题：这地方到底需不需要将connect变量进行共享?</p>
<p>事实上，是不需要的。假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，即一个线程不需要关心其他线程是否对这个connect进行了修改的。即改后的代码可以这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionManager</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Connection connect = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">openConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (connect == <span class="hljs-keyword">null</span>) &#123;<br>            connect = DriverManager.getConnection();<br>        &#125;<br>        <span class="hljs-keyword">return</span> connect;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (connect != <span class="hljs-keyword">null</span>)<br>            connect.close();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dao</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span> </span>&#123;<br>        ConnectionManager connectionManager = <span class="hljs-keyword">new</span> ConnectionManager();<br>        Connection connection = connectionManager.openConnection();<br><br>        <span class="hljs-comment">// 使用connection进行操作</span><br><br>        connectionManager.closeConnection();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样处理确实也没有任何问题，由于每次都是在方法内部创建的连接，那么线程之间自然不存在线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不仅严重影响程序执行效率，还可能导致服务器压力巨大。</p>
<p>那么如何使用比较好呢？使用<strong>ThreadLocal</strong></p>
<p>种情况下使用ThreadLocal是再适合不过的了，因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。下面就是网上出现最多的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionManager</span> </span>&#123;<br>    <br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Connection&gt; dbConnectionLocal = ThreadLocal.withInitial(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>            throwables.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;);<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dbConnectionLocal.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>再注意下ThreadLocal的修饰符</li>
</ul>
<p>ThreaLocal的JDK文档中说明：ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread。如果我们希望通过某个类将状态(例如用户ID、事务ID)与线程关联起来，那么通常在这个类中定义private static类型的ThreadLocal 实例。</p>
<blockquote>
<p>但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。</p>
</blockquote>
<h3 id="3-2-ThreadLocal-的原理"><a href="#3-2-ThreadLocal-的原理" class="headerlink" title="3.2 ThreadLocal 的原理"></a>3.2 ThreadLocal 的原理</h3><h4 id="3-2-1-如何实现线程隔离"><a href="#3-2-1-如何实现线程隔离" class="headerlink" title="3.2.1 如何实现线程隔离"></a>3.2.1 如何实现线程隔离</h4><p>主要是用到了Thread对象中的一个ThreadLocalMap类型的变量threadLocals, 负责存储当前线程的关于Connection的对象, dbConnectionLocal(以上述例子中为例) 这个变量为Key, 以新建的Connection对象为Value; 这样的话, 线程第一次读取的时候如果不存在就会调用ThreadLocal的initialValue方法创建一个Connection对象并且返回;</p>
<p>具体关于为线程分配变量副本的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;<br>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            T result = (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>首先获取当前线程对象t, 然后从线程t中获取到ThreadLocalMap的成员属性threadLocals</li>
<li>如果当前线程的threadLocals已经初始化(即不为null) 并且存在以当前ThreadLocal对象为Key的值, 则直接返回当前线程要获取的对象(本例中为Connection);</li>
<li>如果当前线程的threadLocals已经初始化(即不为null)但是不存在以当前ThreadLocal对象为Key的的对象, 那么重新创建一个Connection对象, 并且添加到当前线程的threadLocals Map中,并返回。</li>
<li>如果当前线程的threadLocals属性还没有被初始化, 则重新创建一个ThreadLocalMap对象, 并且创建一个Connection对象并添加到ThreadLocalMap对象中并返回。</li>
</ul>
<p>如果存在则直接返回很好理解, 那么对于如何初始化的代码又是怎样的呢?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">setInitialValue</span><span class="hljs-params">()</span> </span>&#123;<br>    T value = initialValue();<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>        map.set(<span class="hljs-keyword">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>首先调用我们上面写的重载过后的initialValue方法, 产生一个Connection对象</li>
<li>继续查看当前线程的threadLocals是不是空的, 如果ThreadLocalMap已被初始化, 那么直接将产生的对象添加到ThreadLocalMap中, 如果没有初始化, 则创建并添加对象到其中;</li>
</ul>
<p>同时, ThreadLocal还提供了直接操作Thread对象中的threadLocals的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>        map.set(<span class="hljs-keyword">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样我们也可以不实现initialValue, 将初始化工作放到DBConnectionFactory的getConnection方法中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;<br>    Connection connection = dbConnectionLocal.get();<br>    <span class="hljs-keyword">if</span> (connection == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            connection = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>            dbConnectionLocal.set(connection);<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> connection;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么我们看过代码之后就很清晰的知道了为什么ThreadLocal能够实现变量的多线程隔离了;其实就是用了Map的数据结构给当前线程缓存了, 要使用的时候就从本线程的threadLocals对象中获取就可以了, key就是当前线程;</p>
<p>当然了在当前线程下获取当前线程里面的Map里面的对象并操作肯定没有线程并发问题了, 当然能做到变量的线程间隔离了;</p>
<p>现在我们知道了ThreadLocal到底是什么了, 又知道了如何使用ThreadLocal以及其基本实现原理了是不是就可以结束了呢? 其实还有一个问题就是ThreadLocalMap是个什么对象, 为什么要用这个对象呢?</p>
<h4 id="3-2-2-ThreadLocalMap对象是什么"><a href="#3-2-2-ThreadLocalMap对象是什么" class="headerlink" title="3.2.2  ThreadLocalMap对象是什么"></a>3.2.2  ThreadLocalMap对象是什么</h4><p>本质上来讲, 它就是一个Map, 但是这个ThreadLocalMap与我们平时见到的Map有点不一样</p>
<ul>
<li>它没有实现Map接口;</li>
<li>它没有public的方法, 最多有一个default的构造方法, 因为这个ThreadLocalMap的方法仅仅在ThreadLocal类中调用, 属于静态内部类</li>
<li>ThreadLocalMap的Entry实现继承了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</li>
<li>该方法仅仅用了一个Entry数组来存储Key, Value; Entry并不是链表形式, 而是每个bucket里面仅仅放一个Entry;</li>
</ul>
<p>要了解ThreadLocalMap的实现, 我们先从入口开始, 就是往该Map中添加一个值:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;<br><br>    <span class="hljs-comment">// We don&#x27;t use a fast path as with get() because it is at</span><br>    <span class="hljs-comment">// least as common to use set() to create new entries as</span><br>    <span class="hljs-comment">// it is to replace existing ones, in which case, a fast</span><br>    <span class="hljs-comment">// path would fail more often than not.</span><br><br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (Entry e = tab[i];<br>         e != <span class="hljs-keyword">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>) &#123;<br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    tab[i] = <span class="hljs-keyword">new</span> Entry(key, value);<br>    <span class="hljs-keyword">int</span> sz = ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>先进行简单的分析, 对该代码表层意思进行解读:</p>
<ul>
<li><p>看下当前threadLocal的在数组中的索引位置 比如: <code>i = 2</code>, 看 <code>i = 2</code> 位置上面的元素(Entry)的<code>Key</code>是否等于threadLocal 这个 Key, 如果等于就很好说了, 直接将该位置上面的Entry的Value替换成最新的就可以了;</p>
</li>
<li><p>如果当前位置上面的 Entry 的 Key为空, 说明ThreadLocal对象已经被回收了, 那么就调用replaceStaleEntry</p>
</li>
<li><p>如果清理完无用条目(ThreadLocal被回收的条目)、并且数组中的数据大小 &gt; 阈值的时候对当前的Table进行重新哈希 所以, 该HashMap是处理冲突检测的机制是向后移位, 清除过期条目 最终找到合适的位置;</p>
</li>
</ul>
<p>了解完Set方法, 后面就是Get方法了:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Entry <span class="hljs-title">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    Entry e = table[i];<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>先找到ThreadLocal的索引位置, 如果索引位置处的entry不为空并且键与threadLocal是同一个对象, 则直接返回; 否则去后面的索引位置继续查找。</p>
<h3 id="3-3-ThreadLocal问题"><a href="#3-3-ThreadLocal问题" class="headerlink" title="3.3 ThreadLocal问题"></a>3.3 ThreadLocal问题</h3><h4 id="3-3-1-如何解决-Hash-冲突"><a href="#3-3-1-如何解决-Hash-冲突" class="headerlink" title="3.3.1 如何解决 Hash 冲突"></a>3.3.1 如何解决 Hash 冲突</h4><p><code>ThreadLocalMap</code> 虽然是类似 <code>Map</code> 结构的数据结构，但它并没有实现 <code>Map</code> 接口。它不支持 <code>Map</code> 接口中的 <code>next</code> 方法，这意味着 <code>ThreadLocalMap</code> 中解决 Hash 冲突的方式并非 <strong>拉链表</strong> 方式。</p>
<p>实际上，**<code>ThreadLocalMap</code> 采用线性探测的方式来解决 Hash 冲突**。所谓线性探测，就是根据初始 key 的 hashcode 值确定元素在 table 数组中的位置，如果发现这个位置上已经被其他的 key 值占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。</p>
<h4 id="3-3-2-内存泄漏问题"><a href="#3-3-2-内存泄漏问题" class="headerlink" title="3.3.2 内存泄漏问题"></a>3.3.2 内存泄漏问题</h4><p><code>ThreadLocalMap</code> 的 <code>Entry</code> 继承了 <code>WeakReference</code>，所以它的 <strong>key （<code>ThreadLocal</code> 对象）是弱引用，而 value （变量副本）是强引用</strong>。</p>
<ul>
<li>如果 <code>ThreadLocal</code> 对象没有外部强引用来引用它，那么 <code>ThreadLocal</code> 对象会在下次 GC 时被回收。</li>
<li>此时，<code>Entry</code> 中的 key 已经被回收，但是 value 由于是强引用不会被垃圾收集器回收。如果创建 <code>ThreadLocal</code> 的线程一直持续运行，那么 value 就会一直得不到回收，产生<strong>内存泄露</strong>。</li>
</ul>
<p>那么如何避免内存泄漏呢？方法就是：<strong>使用 <code>ThreadLocal</code> 的 <code>set</code> 方法后，显示的调用 <code>remove</code> 方法</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> ThreadLocal();<br><span class="hljs-keyword">try</span> &#123;<br>    threadLocal.set(<span class="hljs-string">&quot;xxx&quot;</span>);<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    threadLocal.remove();<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="3-4-ThreadLocal-的应用"><a href="#3-4-ThreadLocal-的应用" class="headerlink" title="3.4 ThreadLocal 的应用"></a>3.4 ThreadLocal 的应用</h3><p><code>ThreadLocal</code> 的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-function">ThreadLocal&lt;S&gt; <span class="hljs-title">withInitial</span><span class="hljs-params">(Supplier&lt;? extends S&gt; supplier)</span> </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>get</code> - 用于获取 <code>ThreadLocal</code> 在当前线程中保存的变量副本。</li>
<li><code>set</code> - 用于设置当前线程中变量的副本。</li>
<li><code>remove</code> - 用于删除当前线程中变量的副本。如果此线程局部变量随后被当前线程读取，则其值将通过调用其 <code>initialValue</code> 方法重新初始化，除非其值由中间线程中的当前线程设置。 这可能会导致当前线程中多次调用 <code>initialValue</code> 方法。</li>
<li><code>initialValue</code> - 为 ThreadLocal 设置默认的 <code>get</code> 初始值，需要重写 <code>initialValue</code> 方法 。</li>
</ul>
<p><code>ThreadLocal</code> 常用于防止对可变的单例（Singleton）变量或全局变量进行共享。典型应用场景有：管理数据库连接、Session。</p>
<p>【示例】数据库连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = ThreadLocal.withInitial(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> DriverManager.getConnection(<span class="hljs-string">&quot;DB_URL&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>            throwables.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;);<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> connectionHolder.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>【示例】Session 管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalSessionDemo</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Session&gt; sessionHolder = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Session <span class="hljs-title">getSession</span><span class="hljs-params">()</span> </span>&#123;<br>        Session session = sessionHolder.get();<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (session == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//创建session</span><br>                session = createSession();<br>                sessionHolder.set(session);<br>            &#125;    <br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> session;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Session <span class="hljs-title">createSession</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//创建session操作</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>【示例】完整使用 <code>ThreadLocal</code> 示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="hljs-number">0</span>);<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            Integer count = threadLocal.get();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                count ++;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            threadLocal.set(count);<br>            threadLocal.remove();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + count);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            executorService.execute(<span class="hljs-keyword">new</span> MyThread());<br>        &#125;<br>        executorService.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> : <span class="hljs-number">10</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span> : <span class="hljs-number">10</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">7</span> : <span class="hljs-number">10</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">9</span> : <span class="hljs-number">10</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">8</span> : <span class="hljs-number">10</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> : <span class="hljs-number">10</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> : <span class="hljs-number">10</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> : <span class="hljs-number">10</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">10</span> : <span class="hljs-number">10</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> : <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>



<h3 id="3-5-ThreadLocal-的误区"><a href="#3-5-ThreadLocal-的误区" class="headerlink" title="3.5 ThreadLocal 的误区"></a>3.5 ThreadLocal 的误区</h3><p>ThreadLocal 适用于变量在线程间隔离，和在方法或类间共享的场景。</p>
<p>前文提到，ThreadLocal 是线程隔离的，那么是不是使用 ThreadLocal 就一定高枕无忧呢？</p>
<p> <strong>ThreadLocal 错误案例</strong></p>
<p>使用 Spring Boot 创建一个 Web 应用程序，使用 ThreadLocal 存放一个 Integer 的值，来暂且代表需要在线程中保存的用户信息，这个值初始是 null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ThreadLocal&lt;Integer&gt; currentUser = ThreadLocal.withInitial(() -&gt; <span class="hljs-keyword">null</span>);<br><br>   <span class="hljs-meta">@GetMapping(&quot;wrong&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title">wrong</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;id&quot;)</span> Integer userId)</span> </span>&#123;<br>       <span class="hljs-comment">//设置用户信息之前先查询一次ThreadLocal中的用户信息</span><br>       String before = Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + currentUser.get();<br>       <span class="hljs-comment">//设置用户信息到ThreadLocal</span><br>       currentUser.set(userId);<br>       <span class="hljs-comment">//设置用户信息之后再查询一次ThreadLocal中的用户信息</span><br>       String after = Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + currentUser.get();<br>       <span class="hljs-comment">//汇总输出两次查询结果</span><br>       Map&lt;String, String&gt; result = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>       result.put(<span class="hljs-string">&quot;before&quot;</span>, before);<br>       result.put(<span class="hljs-string">&quot;after&quot;</span>, after);<br>       <span class="hljs-keyword">return</span> result;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>【预期】从代码逻辑来看，我们预期第一次获取的值始终应该是 null。</p>
<p>【实际】</p>
<p>为了方便复现，将 Tomcat 工作线程设为 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">server.tomcat.max-threads=1<br></code></pre></td></tr></table></figure>

<p>当访问 id = 1 时，符合预期</p>
<p>当访问 id = 2 时，before 的应答不是 null，而是 1，不符合预期。</p>
<p>【分析】实际情况和预期存在偏差。Spring Boot 程序运行在 Tomcat 中，执行程序的线程是 Tomcat 的工作线程，而 Tomcat 的工作线程是基于线程池的。<strong>线程池会重用固定的几个线程，一旦线程重用，那么很可能首次从</strong> <strong>ThreadLocal 获取的值是之前其他用户的请求遗留的值。这时，ThreadLocal 中的用户信息就是其他用户的信息</strong>。</p>
<p><strong>并不能认为没有显式开启多线程就不会有线程安全问题</strong>。使用类似 ThreadLocal 工具来存放一些数据时，需要特别注意在代码运行完后，显式地去清空设置的数据。</p>
<p><strong>ThreadLocal 错误案例修正</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;right&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title">right</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;id&quot;)</span> Integer userId)</span> </span>&#123;<br>    String before = Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + currentUser.get();<br>    currentUser.set(userId);<br>    <span class="hljs-keyword">try</span> &#123;<br>        String after = Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + currentUser.get();<br>        Map&lt;String, String&gt; result = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        result.put(<span class="hljs-string">&quot;before&quot;</span>, before);<br>        result.put(<span class="hljs-string">&quot;after&quot;</span>, after);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//在finally代码块中删除ThreadLocal中的数据，确保数据不串</span><br>        currentUser.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><p><a href="https://dunwu.github.io/javacore/concurrent/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6.html#_4-cas">https://dunwu.github.io/javacore/concurrent/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6.html#_4-cas</a></p>
<p><a href="https://blog.csdn.net/vking_wang/article/details/14225379">https://blog.csdn.net/vking_wang/article/details/14225379</a></p>
<p><a href="https://mp.weixin.qq.com/s/mo3-y-45_ao54b5T7ez7iA">https://mp.weixin.qq.com/s/mo3-y-45_ao54b5T7ez7iA</a></p>
<p><a href="https://www.xttblog.com/?p=3087">https://www.xttblog.com/?p=3087</a></p>
<p><a href="https://blog.csdn.net/whut2010hj/article/details/81413887">https://blog.csdn.net/whut2010hj/article/details/81413887</a></p>
<p><a href="https://segmentfault.com/a/1190000018399795">https://segmentfault.com/a/1190000018399795</a></p>
<p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-threadlocal.html#threadlocal%E7%AE%80%E4%BB%8B">https://www.pdai.tech/md/java/thread/java-thread-x-threadlocal.html#threadlocal%E7%AE%80%E4%BB%8B</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>并发核心机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程基础</title>
    <url>/2022/04/04/Java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-线程简介"><a href="#1-线程简介" class="headerlink" title="1.线程简介"></a>1.线程简介</h2><h3 id="1-1-什么是进程"><a href="#1-1-什么是进程" class="headerlink" title="1.1 什么是进程"></a>1.1 什么是进程</h3><p>简言之，<strong>进程可视为一个正在运行的程序</strong>。它是系统运行程序的基本单位，因此进程是动态的。进程是具有一定独立功能的程序关于某个数据集合上的一次运动活动。进程是操作系统进行资源分配的基本单位。</p>
<h3 id="1-2-什么是线程"><a href="#1-2-什么是线程" class="headerlink" title="1.2 什么是线程"></a>1.2 什么是线程</h3><p> 线程是操作系统进行调度的基本单位。线程也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。 </p>
<h3 id="1-3-进程和线程的区别"><a href="#1-3-进程和线程的区别" class="headerlink" title="1.3 进程和线程的区别"></a>1.3 进程和线程的区别</h3><ul>
<li>一个程序至少有一个进程，一个进程至少有一个线程。</li>
<li>线程比进程划分更细，所以执行开销更小，并发性更高。</li>
<li>进程是一个实体，拥有独立的资源；而同一个进程中的多个线程共享进程的资源。</li>
</ul>
<h2 id="2-线程状态"><a href="#2-线程状态" class="headerlink" title="2.线程状态"></a>2.线程状态</h2><h3 id="2-1-线程状态介绍"><a href="#2-1-线程状态介绍" class="headerlink" title="2.1  线程状态介绍"></a>2.1  线程状态介绍</h3><table>
<thead>
<tr>
<th align="left">状态名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NEW</td>
<td align="left">初始状态，线程被构建，但是还没有调用start()方法</td>
</tr>
<tr>
<td align="left">RUNNABLE</td>
<td align="left">运行状态，Java线程将操作系统中的就绪和运行两种状态称为<strong>运行中</strong></td>
</tr>
<tr>
<td align="left">BLOCKED</td>
<td align="left">阻塞状态,表示线程阻塞于锁</td>
</tr>
<tr>
<td align="left">WAITING</td>
<td align="left">等待状态,表示线程进入等待状态，进入该状态表示当前线程需要其他线程通知(notify或者notifyAll)</td>
</tr>
<tr>
<td align="left">TIME_WAITING</td>
<td align="left">超时等待状态,可以指定等待时间自己返回</td>
</tr>
<tr>
<td align="left">TERMINATED</td>
<td align="left">终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody></table>
<p> 查看Thread类中定义了一个State枚举类型 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">State</span> </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Thread state for a thread which has not yet started.</span><br><span class="hljs-comment">         */</span><br>        NEW,<br><br><br>        RUNNABLE,<br><br>        BLOCKED,<br><br>        <br>        WAITING,<br><br><br>        TIMED_WAITING,<br><br><br>        TERMINATED;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p> <img src="/img/work/1689841-383f7101e6588094.png" alt="线程状态图"> </p>
<p><strong>说明:</strong> 各种状态一目了然，值得一提的是”blocked”这个状态： </p>
<p><strong>线程在Running的过程中可能会遇到阻塞(Blocked)情况</strong> </p>
<ol>
<li>调用join()和sleep()方法，sleep()时间结束或被打断， join()中断,  IO完成都会回到Runnable状态，等待JVM的调度。 </li>
<li>调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable）。 </li>
<li>对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。</li>
</ol>
<p>此外，在runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。 </p>
<h3 id="2-2-线程各状态"><a href="#2-2-线程各状态" class="headerlink" title="2.2 线程各状态"></a>2.2 线程各状态</h3><p><strong>NEW</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线程状态为NEW状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadNewDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Thread1 -----&quot;</span>);<br>        &#125;);<br><br>        System.out.println(thread.getState());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 这个时候线程刚刚创建，还没有调用start()方法,所以状态为NEW </p>
<p><strong>TERMINATED</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTerminatedDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程开始执行&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;线程执行结束&quot;</span>);<br>        &#125;);<br><br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">3000</span>);<br><br>        System.out.println(thread.getState());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>线程执行结束后查看状态为TERMINATED,加sleep是为了保证在getState的时候线程已经执行结束 </p>
<p><strong>终止(Terminated)</strong> - 线程执行完 <code>run</code> 方法，或者因异常退出了 <code>run</code> 方法。此状态意味着：线程结束了生命周期。</p>
<p><strong>RUNNABLE</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadRunnableDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><br>        &#125;);<br><br>        thread.start();<br>        System.out.println(thread.getState());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 调用了start()方法后线程处于RUNNABLE状态。 </p>
<p><strong>注意</strong>:线程创建之后它将处于 NEW（新建） 状态，调⽤ start() ⽅法后开始运⾏，线程这时候处于READY（可运⾏） 状态。可运⾏状态的线程获得了 cpu 时间⽚（timeslice）后就处于RUNNING（运⾏） 状态。操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态。所以Java系统把这两个状态统称为RUNNABLE状态。</p>
<p><strong>BLOCKED</strong></p>
<p>这边我们模拟一个我们模拟找桌子用餐的场景 学生1和学生2同时争夺一个座位用餐，学生一先抢到座位，学生2就处于阻塞的状态，只能等待学生1用餐结束 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadBlockedDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Thread.currentThread().getName());<br><br>        Table table = <span class="hljs-keyword">new</span> Table();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(table::use, <span class="hljs-string">&quot;s1&quot;</span>);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(table::use, <span class="hljs-string">&quot;s2&quot;</span>);<br>        t1.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        t2.start();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        System.out.println(t2.getState());<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Table</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">use</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;-使用桌子&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;- 结束用餐&quot;</span>);<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>线程处于被阻塞状态</strong>:表示线程在等待 <code>synchronized</code> 的隐式锁（Monitor lock）。<code>synchronized</code> 修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，即处于阻塞状态。当占用 <code>synchronized</code> 隐式锁的线程释放锁，并且等待的线程获得 <code>synchronized</code> 隐式锁时，就又会从 <code>BLOCKED</code> 转换到 <code>RUNNABLE</code> 状态。</p>
<p><strong>WAITING</strong></p>
<p>这边我们模拟学生1在得到座位后发现自己忘记点餐了，所以只能让出座位这个资源。进入wait状态 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadWaitDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        System.out.println(Thread.currentThread().getName());<br>        Table1 table1 = <span class="hljs-keyword">new</span> Table1();<br>        Thread student1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                table1.use();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;s1&quot;</span>);<br><br>        student1.start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        System.out.println(student1.getState());<br>        Thread.currentThread().getState();<br><br><br><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Table1</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;-使用桌子&quot;</span>);<br>            <span class="hljs-comment">//忘记桌子</span><br>            System.out.println(<span class="hljs-string">&quot;忘记点餐了&quot;</span>);<br>            wait(<span class="hljs-number">100</span>);<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;就餐结束&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>等待（Waiting）</strong> - 此状态意味着：<strong>线程无限期等待，直到被其他线程显式地唤醒</strong>。 阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 <code>synchronized</code> 的隐式锁。而等待是主动的，通过调用 <code>Object.wait</code> 等方法进入。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>没有设置 Timeout 参数的 <code>Object.wait</code> 方法</td>
<td><code>Object.notify</code> / <code>Object.notifyAll</code></td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 <code>Thread.join</code> 方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td><code>LockSupport.park</code> 方法（Java 并发包中的锁，都是基于它实现的）</td>
<td><code>LockSupport.unpark</code></td>
</tr>
</tbody></table>
<p><strong>TIME_WAITING</strong></p>
<p><strong>定时等待（Timed waiting）</strong> - 此状态意味着：<strong>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒</strong>。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>Thread.sleep</code> 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>获得 <code>synchronized</code> 隐式锁的线程，调用设置了 Timeout 参数的 <code>Object.wait</code> 方法</td>
<td>时间结束 / <code>Object.notify</code> / <code>Object.notifyAll</code></td>
</tr>
<tr>
<td>设置了 Timeout 参数的 <code>Thread.join</code> 方法</td>
<td>时间结束 / 被调用的线程执行完毕</td>
</tr>
<tr>
<td><code>LockSupport.parkNanos</code> 方法</td>
<td><code>LockSupport.unpark</code></td>
</tr>
<tr>
<td><code>LockSupport.parkUntil</code> 方法</td>
<td><code>LockSupport.unpark</code></td>
</tr>
</tbody></table>
<h2 id="3-线程创建"><a href="#3-线程创建" class="headerlink" title="3.线程创建"></a>3.线程创建</h2><p>创建线程的方式有三种:</p>
<ul>
<li>继承<code>Thread</code>类</li>
<li>实现 <code>Runnable</code> 接口</li>
<li>实现 <code>Callable</code> 接口</li>
</ul>
<h3 id="3-1-Thread"><a href="#3-1-Thread" class="headerlink" title="3.1 Thread"></a><strong>3.1 Thread</strong></h3><p>通过继承 <code>Thread</code> 类创建线程的步骤： </p>
<ol>
<li>定义 <code>Thread</code> 类的子类，并覆写该类的 <code>run</code> 方法。<code>run</code> 方法的方法体就代表了线程要完成的任务，因此把 <code>run</code> 方法称为执行体。</li>
<li>创建 <code>Thread</code> 子类的实例，即创建了线程对象。</li>
<li>调用线程对象的 <code>start</code> 方法来启动该线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyThread t1 = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;线程A&quot;</span>);<br>        MyThread t2 = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;线程B&quot;</span>);<br>        t1.start();<br>        t2.start();<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">5</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(name);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;卖出了第 &quot;</span> + ticket + <span class="hljs-string">&quot; 张票&quot;</span>);<br>                ticket --;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-2-Runnable"><a href="#3-2-Runnable" class="headerlink" title="3.2. Runnable"></a>3.2. Runnable</h3><p><strong>实现 <code>Runnable</code> 接口优于继承 <code>Thread</code> 类</strong>，因为： </p>
<ul>
<li>Java 不支持多重继承，所有的类都只允许继承一个父类，但可以实现多个接口。如果继承了 <code>Thread</code> 类就无法继承其它类，这不利于扩展。</li>
<li>类可能只要求可执行就行，继承整个 <code>Thread</code> 类开销过大。</li>
</ul>
<p>通过实现 <code>Runnable</code> 接口创建线程的步骤： </p>
<ol>
<li>定义 <code>Runnable</code> 接口的实现类，并覆写该接口的 <code>run</code> 方法。该 <code>run</code> 方法的方法体同样是该线程的线程执行体。</li>
<li>创建 <code>Runnable</code> 实现类的实例，并以此实例作为 <code>Thread</code> 的 target 来创建 <code>Thread</code> 对象，该 <code>Thread</code> 对象才是真正的线程对象。</li>
<li>调用线程对象的 <code>start</code> 方法来启动该线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunnableDemo</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 实例化对象</span><br>        Thread tA = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread(), <span class="hljs-string">&quot;Runnable 线程-A&quot;</span>);<br>        Thread tB = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread(), <span class="hljs-string">&quot;Runnable 线程-B&quot;</span>);<br>        <span class="hljs-comment">// 调用线程主体</span><br>        tA.start();<br>        tB.start();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">5</span>;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;卖出了第 &quot;</span> + ticket + <span class="hljs-string">&quot; 张票&quot;</span>);<br>                ticket --;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="3-3-Callable、Future、FutureTask"><a href="#3-3-Callable、Future、FutureTask" class="headerlink" title="3.3. Callable、Future、FutureTask"></a>3.3. Callable、Future、FutureTask</h3><p><strong>继承 Thread 类和实现 Runnable 接口这两种创建线程的方式都没有返回值</strong>。所以，线程执行完后，无法得到执行结果。但如果期望得到执行结果该怎么做？ </p>
<p>为了解决这个问题，Java 1.5 后，提供了 <code>Callable</code> 接口和 <code>Future</code> 接口，通过它们，可以在线程执行结束后，返回执行结果。 </p>
<p><strong>Callable</strong></p>
<p>Callable 接口只声明了一个方法，这个方法叫做 call()： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> computed result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception if unable to compute a result</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">V <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么怎么使用 Callable 呢？一般情况下是配合 ExecutorService 来使用的，在 ExecutorService 接口中声明了若干个 submit 方法的重载版本： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span></span>;<br>&lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task, T result)</span></span>;<br>Future&lt;?&gt; submit(Runnable task);<br></code></pre></td></tr></table></figure>

<p>第一个 submit 方法里面的参数类型就是 Callable。 </p>
<p><strong>Future</strong></p>
<p>Future 就是对于具体的 Callable 任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过 get 方法获取执行结果，该方法会阻塞直到任务返回结果。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;<br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>FutureTask</strong></p>
<p>FutureTask 类实现了 RunnableFuture 接口，RunnableFuture 继承了 Runnable 接口和 Future 接口。</p>
<p>所以，FutureTask 既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FutureTask</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> </span>&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Runnable</span>, <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>事实上，FutureTask 是 Future 接口的一个唯一实现类。 </p>
<p><strong>Callable + Future + FutureTask 示例</strong></p>
<p>通过实现 <code>Callable</code> 接口创建线程的步骤： </p>
<ol>
<li>创建 <code>Callable</code> 接口的实现类，并实现 <code>call</code> 方法。该 <code>call</code> 方法将作为线程执行体，并且有返回值。</li>
<li>创建 <code>Callable</code> 实现类的实例，使用 <code>FutureTask</code> 类来包装 <code>Callable</code> 对象，该 <code>FutureTask</code> 对象封装了该 <code>Callable</code> 对象的 <code>call</code> 方法的返回值。</li>
<li>使用 <code>FutureTask</code> 对象作为 <code>Thread</code> 对象的 target 创建并启动新线程。</li>
<li>调用 <code>FutureTask</code> 对象的 <code>get</code> 方法来获得线程执行结束后的返回值。 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableDemo</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Callable&lt;Long&gt; callable = <span class="hljs-keyword">new</span> MyThread();<br><br>        FutureTask&lt;Long&gt; task = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(callable);<br><br>        <span class="hljs-keyword">new</span> Thread(task,<span class="hljs-string">&quot;callable线程&quot;</span>).start();<br><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;任务耗时:&quot;</span> + (task.get() / <span class="hljs-number">1000000</span> + <span class="hljs-string">&quot;毫秒&quot;</span>) );<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br><br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Long</span>&gt; </span>&#123;<br><br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">10000</span>;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>            <span class="hljs-keyword">long</span> bengin = System.nanoTime();<br><br>            <span class="hljs-keyword">while</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;卖出了第:&quot;</span> + ticket  + <span class="hljs-string">&quot;票&quot;</span>);<br>                ticket --;<br>            &#125;<br><br><br>            <span class="hljs-keyword">long</span> end = System.nanoTime();<br><br><br>            <span class="hljs-keyword">return</span> end - bengin;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="4-线程的基本用法"><a href="#4-线程的基本用法" class="headerlink" title="4.线程的基本用法"></a>4.线程的基本用法</h2><p>线程（<code>Thread</code>）基本方法清单： </p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>run</code></td>
<td align="center">线程的执行实体</td>
</tr>
<tr>
<td align="center"><code>start</code></td>
<td align="center">线程的启动方法</td>
</tr>
<tr>
<td align="center"><code>currentThread</code></td>
<td align="center">返回对当前正在执行的线程对象的引用。</td>
</tr>
<tr>
<td align="center"><code>setName</code></td>
<td align="center">设置线程名称</td>
</tr>
<tr>
<td align="center"><code>getName</code></td>
<td align="center">获取线程名称。</td>
</tr>
<tr>
<td align="center"><code>setPriority</code></td>
<td align="center">设置线程优先级。Java中的线程优先级的范围是 [1,10]，一般来说，高优先级的线程在运行时会具有优先权。可以通过 <code>thread.setPriority(Thread.MAX_PRIORITY)</code> 的方式设置，默认优先级为 5。</td>
</tr>
<tr>
<td align="center"><code>getPriority</code></td>
<td align="center">获取线程优先级。</td>
</tr>
<tr>
<td align="center"><code>setDaemon</code></td>
<td align="center">设置线程为守护线程。</td>
</tr>
<tr>
<td align="center"><code>isDaemon</code></td>
<td align="center">判断线程是否为守护线程。</td>
</tr>
<tr>
<td align="center"><code>isAlive</code></td>
<td align="center">判断线程是否启动。</td>
</tr>
<tr>
<td align="center"><code>interrupt</code></td>
<td align="center">中断另一个线程的运行状态。</td>
</tr>
<tr>
<td align="center"><code>interrupted</code></td>
<td align="center">测试当前线程是否已被中断。通过此方法可以清除线程的中断状态。换句话说，如果要连续调用此方法两次，则第二次调用将返回 false（除非当前线程在第一次调用清除其中断状态之后且在第二次调用检查其状态之前再次中断）。</td>
</tr>
<tr>
<td align="center"><code>join</code></td>
<td align="center">可以使一个线程强制运行，线程强制运行期间，其他线程无法运行，必须等待此线程完成之后才可以继续执行。</td>
</tr>
<tr>
<td align="center"><code>Thread.sleep</code></td>
<td align="center">静态方法。将当前正在执行的线程休眠。</td>
</tr>
<tr>
<td align="center"><code>Thread.yield</code></td>
<td align="center">静态方法。将当前正在执行的线程暂停，让其他线程执行。</td>
</tr>
</tbody></table>
<h3 id="4-1-Executor"><a href="#4-1-Executor" class="headerlink" title="4.1 Executor"></a>4.1 Executor</h3><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。 </p>
<p> 主要有三种 Executor: </p>
<ul>
<li>CachedThreadPool: 一个任务创建一个线程；</li>
<li>FixedThreadPool: 所有任务只能使用固定大小的线程；</li>
<li>SingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ExecutorService executorService = Executors.newCachedThreadPool();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        executorService.execute(<span class="hljs-keyword">new</span> MyRunnable());<br>    &#125;<br>    executorService.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="4-2-线程睡眠"><a href="#4-2-线程睡眠" class="headerlink" title="4.2 线程睡眠"></a>4.2 线程睡眠</h3><p><strong>使用 <code>Thread.sleep</code> 方法可以使得当前正在执行的线程进入休眠状态。</strong> </p>
<p>使用 <code>Thread.sleep</code> 需要向其传入一个整数值，这个值表示线程将要休眠的毫秒数。 </p>
<p><code>Thread.sleep</code> 方法可能会抛出 <code>InterruptedException</code>，因为异常不能跨线程传播回 <code>main</code> 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSleepDemo</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;线程A&quot;</span>,<span class="hljs-number">500</span>)).start();<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;线程B&quot;</span>,<span class="hljs-number">1000</span>)).start();<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;线程C&quot;</span>,<span class="hljs-number">1500</span>)).start();<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> String name;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> time;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> time)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>            <span class="hljs-keyword">this</span>.time = time;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 休眠指定的时间</span><br>                Thread.sleep(<span class="hljs-keyword">this</span>.time);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot;休眠&quot;</span> + <span class="hljs-keyword">this</span>.time + <span class="hljs-string">&quot;毫秒。&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="4-3-线程礼让"><a href="#4-3-线程礼让" class="headerlink" title="4.3 线程礼让"></a>4.3 线程礼让</h3><p> <code>Thread.yield</code> 方法的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行 。 </p>
<p> 该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadYieldDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyThread t = <span class="hljs-keyword">new</span> MyThread();<br>        <span class="hljs-keyword">new</span> Thread(t,<span class="hljs-string">&quot;线程A&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(t,<span class="hljs-string">&quot;线程B&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() +<span class="hljs-string">&quot;运行, i = &quot;</span> + i);<br><br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程礼让:&quot;</span> );<br><br>                    Thread.yield();<br>                &#125;<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-4-终止线程"><a href="#4-4-终止线程" class="headerlink" title="4.4 终止线程"></a>4.4 终止线程</h3><blockquote>
<p> <strong><code>Thread</code> 中的 <code>stop</code> 方法有缺陷，已废弃</strong>。  </p>
<p>使用 <code>Thread.stop</code> 停止线程会导致它解锁所有已锁定的监视器（由于未经检查的 <code>ThreadDeath</code> 异常会在堆栈中传播，这是自然的结果）。 如果先前由这些监视器保护的任何对象处于不一致状态，则损坏的对象将对其他线程可见，从而可能导致任意行为。</p>
<p> stop() 方法会真的杀死线程，不给线程喘息的机会，如果线程持有 ReentrantLock 锁，被 stop() 的线程并不会自动调用 ReentrantLock 的 unlock() 去释放锁，那其他线程就再也没机会获得 ReentrantLock 锁，这实在是太危险了。所以该方法就不建议使用了，类似的方法还有 suspend() 和 resume() 方法，这两个方法同样也都不建议使用了，所以这里也就不多介绍了。<code>Thread.stop</code> 的许多用法应由仅修改某些变量以指示目标线程应停止运行的代码代替。 目标线程应定期检查此变量，如果该变量指示要停止运行，则应按有序方式从其运行方法返回。如果目标线程等待很长时间（例如，在条件变量上），则应使用中断方法来中断等待。 </p>
</blockquote>
<p><strong>interrupted()</strong></p>
<p> 当一个线程运行时，另一个线程可以直接通过 <code>interrupt</code> 方法中断其运行状态。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadInterruptDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyThread thread = <span class="hljs-keyword">new</span> MyThread();<br>        Thread t = <span class="hljs-keyword">new</span> Thread(thread, <span class="hljs-string">&quot;线程&quot;</span>);<br>        t.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;3、main线程休眠被终止&quot;</span>);<br>        &#125;<br>        t.interrupt();<span class="hljs-comment">//中断线程执行</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;1.进入Run（）方法&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br><br>                System.out.println(<span class="hljs-string">&quot;2、已经完成了休眠&quot;</span>);<br><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                System.out.println(<span class="hljs-string">&quot;3、Mthread线程休眠被终止了&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br><br><br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;4、run()方法正常结束&quot;</span>);<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果线程的<code>run</code>方法执行一个无限循环，并且没有执行<code>sleep</code>等会抛出<code>InterruptedException</code> 的操作，那么调用线程的 <code>interrupt</code> 方法就无法使线程提前结束。 </p>
<p>但是调用 <code>interrupt</code> 方法会设置线程的中断标记，此时调用 <code>interrupted</code> 方法会返回 <code>true</code>。因此可以在循环体中使用 <code>interrupted</code> 方法来判断线程是否处于中断状态，从而提前结束线程。 </p>
<p>安全地终止线程有两种方法：</p>
<ul>
<li>定义 <code>volatile</code> 标志位，在 <code>run</code> 方法中使用标志位控制线程终止</li>
<li>使用 <code>interrupt</code> 方法和 <code>Thread.interrupted</code> 方法配合使用来控制线程终止</li>
</ul>
<p>【示例】使用 <code>volatile</code> 标志位控制线程终止 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadStopDemo2</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        MyTask task = <span class="hljs-keyword">new</span> MyTask();<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(task, <span class="hljs-string">&quot;MyTask&quot;</span>);<br>        thread.start();<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">50</span>);<br>        task.cancel();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> count = <span class="hljs-number">0L</span>;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 线程启动&quot;</span>);<br>            <span class="hljs-keyword">while</span> (flag) &#123;<br>                System.out.println(count++);<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 线程终止&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 通过 volatile 标志位来控制线程终止</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span> </span>&#123;<br>            flag = <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<p>【示例】使用 <code>interrupt</code> 方法和 <code>Thread.interrupted</code> 方法配合使用来控制线程终止 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadStopDemo3</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        MyTask task = <span class="hljs-keyword">new</span> MyTask();<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(task, <span class="hljs-string">&quot;MyTask&quot;</span>);<br>        thread.start();<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">50</span>);<br>        thread.interrupt();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> count = <span class="hljs-number">0L</span>;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 线程启动&quot;</span>);<br>            <span class="hljs-comment">// 通过 Thread.interrupted 和 interrupt 配合来控制线程终止</span><br>            <span class="hljs-keyword">while</span> (!Thread.interrupted()) &#123;<br>                System.out.println(count++);<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 线程终止&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>InterruptedException</strong></p>
<p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p>
<p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruptExample</span> </span>&#123;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                System.out.println(<span class="hljs-string">&quot;Thread run&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyThread thread = <span class="hljs-keyword">new</span> MyThread();<br>        thread.start();<br>        thread.interrupt();<br>        System.out.println(<span class="hljs-string">&quot;Main run&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>Executor 的中断操作</strong></p>
<p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p>
<p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExecutorShutdown</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executorService = Executors.newCachedThreadPool();<br><br>        executorService.execute(() -&gt; &#123;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                System.out.println(<span class="hljs-string">&quot;Thread run&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br><br>        executorService.shutdownNow();<br>        System.out.println(<span class="hljs-string">&quot;main run&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExecutorShutdown</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executorService = Executors.newCachedThreadPool();<br><br>        Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                System.out.println(<span class="hljs-string">&quot;Thread run&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br><br>        future.cancel(<span class="hljs-keyword">true</span>);<br>        System.out.println(<span class="hljs-string">&quot;main run&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="4-5-守护线程"><a href="#4-5-守护线程" class="headerlink" title="4.5 守护线程"></a>4.5 守护线程</h3><p> 什么是守护线程？ </p>
<ul>
<li><strong>守护线程（Daemon Thread）是在后台执行并且不会阻止 JVM 终止的线程</strong>。<strong>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程</strong>。</li>
<li>与守护线程（Daemon Thread）相反的，叫用户线程（User Thread），也就是非守护线程。</li>
</ul>
<p> 为什么需要守护线程？ </p>
<ul>
<li>守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。典型的应用就是垃圾回收器。</li>
</ul>
<p> 如何使用守护线程？ </p>
<ul>
<li>可以使用 <code>isDaemon</code> 方法判断线程是否为守护线程。</li>
<li> 可以使用 <code>setDaemon</code> 方法设置线程为守护线程。 </li>
<li>正在运行的用户线程无法设置为守护线程，所以 <code>setDaemon</code> 必须在 <code>thread.start</code> 方法之前设置，否则会抛出 <code>llegalThreadStateException</code> 异常；</li>
<li>一个守护线程创建的子线程依然是守护线程。</li>
<li>不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDaemonDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread(), <span class="hljs-string">&quot;线程&quot;</span>);<br>        t.setDaemon(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 此线程在后台运行</span><br>        System.out.println(<span class="hljs-string">&quot;线程 t 是否是守护进程：&quot;</span> + t.isDaemon());<br>        t.start(); <span class="hljs-comment">// 启动线程</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;在运行。&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-线程通信"><a href="#5-线程通信" class="headerlink" title="5.线程通信"></a>5.线程通信</h2><blockquote>
<p> 当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调 </p>
</blockquote>
<h3 id="5-1-wait-notify-notifyAll"><a href="#5-1-wait-notify-notifyAll" class="headerlink" title="5.1 wait/notify/notifyAll"></a>5.1 wait/notify/notifyAll</h3><ul>
<li><code>wait</code> - <code>wait</code> 会自动释放当前线程占有的对象锁，并请求操作系统挂起当前线程，<strong>让线程从 <code>Running</code> 状态转入 <code>Waiting</code> 状态</strong>，等待 <code>notify</code> / <code>notifyAll</code> 来唤醒。如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 <code>notify</code> 或者 <code>notifyAll</code> 来唤醒挂起的线程，造成死锁。</li>
<li><code>notify</code>-唤醒一个正在 <code>Waiting</code> 状态的线程，并让它拿到对象锁，具体唤醒哪一个线程由 JVM 控制 。</li>
<li><code>notifyAll</code> - 唤醒所有正在 <code>Waiting</code> 状态的线程，接下来它们需要竞争对象锁。</li>
</ul>
<p>注意：</p>
<ul>
<li><strong><code>wait</code>、<code>notify</code>、<code>notifyAll</code> 都是 <code>Object</code> 类中的方法</strong>，而非 <code>Thread</code>。</li>
<li>**<code>wait</code>、<code>notify</code>、<code>notifyAll</code> 只能用在 <code>synchronized</code> 方法或者 <code>synchronized</code> 代码块中使用，否则会在运行时抛出 <code>IllegalMonitorStateException</code>**。</li>
</ul>
<p>为什么 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 不定义在 <code>Thread</code> 中？为什么 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 要配合 <code>synchronized</code> 使用？</p>
<p>首先，需要了解几个基本知识点：</p>
<ul>
<li>每一个 Java 对象都有一个与之对应的 <strong>监视器（monitor）</strong></li>
<li>每一个监视器里面都有一个 <strong>对象锁</strong> 、一个 <strong>等待队列</strong>、一个 <strong>同步队列</strong></li>
</ul>
<p>了解了以上概念，我们回过头来理解前面两个问题。</p>
<p>为什么这几个方法不定义在 <code>Thread</code> 中？</p>
<p>由于每个对象都拥有对象锁，让当前线程等待某个对象锁，自然应该基于这个对象（<code>Object</code>）来操作，而非使用当前线程（<code>Thread</code>）来操作。因为当前线程可能会等待多个线程的锁，如果基于线程（<code>Thread</code>）来操作，就非常复杂了。</p>
<p>为什么 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 要配合 <code>synchronized</code> 使用？</p>
<p>如果调用某个对象的 <code>wait</code> 方法，当前线程必须拥有这个对象的对象锁，因此调用 <code>wait</code> 方法必须在 <code>synchronized</code> 方法和 <code>synchronized</code> 代码块中。</p>
<p><strong>生产者、消费者模式是 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 的一个经典使用案例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadWaitNotifyDemo02</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> QUEUE_SIZE = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Producer(<span class="hljs-string">&quot;生产者A&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Producer(<span class="hljs-string">&quot;生产者B&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Consumer(<span class="hljs-string">&quot;消费者A&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Consumer(<span class="hljs-string">&quot;消费者B&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Consumer(<span class="hljs-string">&quot;消费者C&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Consumer(<span class="hljs-string">&quot;消费者D&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br>        Consumer (String name) &#123;<br>            <span class="hljs-keyword">super</span>(name);<br>        &#125;<br><br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>                    <span class="hljs-keyword">while</span> (queue.size() == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            System.out.println(<span class="hljs-string">&quot;队列空,等待数据&quot;</span>);<br>                            queue.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                            queue.notifyAll();<br>                        &#125;<br>                    &#125;<br><br>                    queue.poll();<br>                    queue.notifyAll();<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">500</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br><br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;从队列中取走一个元素，队列当前有：&quot;</span> + queue.size() + <span class="hljs-string">&quot;个元素&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        Producer(String name) &#123;<br>            <span class="hljs-keyword">super</span>(name);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>                    <span class="hljs-keyword">while</span> (queue.size() == QUEUE_SIZE) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;队列满，等待有空余空间&quot;</span>);<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            queue.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                            queue.notifyAll();<br>                        &#125;<br><br>                    &#125;<br>                    queue.offer(<span class="hljs-number">1</span>);<br>                    queue.notifyAll();<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">500</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br><br>                    System.out.println(Thread.currentThread().getName() +  <span class="hljs-string">&quot; 向队列取中插入一个元素，队列当前有：&quot;</span> + queue.size() + <span class="hljs-string">&quot;个元素&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="5-2-join"><a href="#5-2-join" class="headerlink" title="5.2 join"></a>5.2 join</h3><p>在线程操作中，可以使用 <code>join</code> 方法让一个线程强制运行，线程强制运行期间，其他线程无法运行，必须等待此线程完成之后才可以继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadJoinDemo</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyThread mt = <span class="hljs-keyword">new</span> MyThread(); <span class="hljs-comment">// 实例化Runnable子类对象</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(mt, <span class="hljs-string">&quot;mythread&quot;</span>); <span class="hljs-comment">// 实例化Thread对象</span><br>        t.start(); <span class="hljs-comment">// 启动线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    t.join(); <span class="hljs-comment">// 线程强制运行</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;Main 线程运行 --&gt; &quot;</span> + i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 运行，i = &quot;</span> + i); <span class="hljs-comment">// 取得当前线程的名字</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="5-3-管道"><a href="#5-3-管道" class="headerlink" title="5.3 管道"></a>5.3 管道</h3><p>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。 管道输入/输出流主要包括了如下 4 种具体实现：<code>PipedOutputStream</code>、<code>PipedInputStream</code>、<code>PipedReader</code> 和 <code>PipedWriter</code>，前两种面向字节，而后两种面向字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Piped</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        PipedWriter out = <span class="hljs-keyword">new</span> PipedWriter();<br>        PipedReader in = <span class="hljs-keyword">new</span> PipedReader();<br>        <span class="hljs-comment">//将输出流和输入流进行连接，否则在使用时会抛出IO异常</span><br>        out.connect(in);<br>        Thread printThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Print(in), <span class="hljs-string">&quot;PrintThread&quot;</span>);<br>        printThread.start();<br>        <span class="hljs-keyword">int</span> receive = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> ((receive = System.in.read()) != -<span class="hljs-number">1</span>) &#123;<br>                out.write(receive);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            out.close();<br>        &#125;<br><br><br><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Print</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> PipedReader in;<br><br><br>        Print(PipedReader in) &#123;<br>            <span class="hljs-keyword">this</span>.in = in;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> receive = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">try</span> &#123;<br><br>                <span class="hljs-keyword">while</span> ((receive = in.read()) != -<span class="hljs-number">1</span>) &#123;<br>                    System.out.println((<span class="hljs-keyword">char</span>) receive);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6.参考资料"></a>6.参考资料</h2><p><a href="https://juejin.cn/post/6977684312930025502">Java线程状态</a></p>
<p><a href="https://dunwu.github.io/javacore/concurrent/Java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B">Java线程简介</a></p>
<p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-thread-basic.html">Java并发-线程基础</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>线程基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存结构</title>
    <url>/2022/07/17/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p> 本文主要对JVM 内存结构进行讲解，注意不要和Java内存模型混淆了。 本文主要参考了<strong>海星的javakeeper</strong>文章并做了适当修改调整，学习JVM不应只是为了面试，更重要的是构建自己的 JVM 知识体系 </p>
</blockquote>
<p><img src="/img/work/1657548944651.png"></p>
<h2 id="1-内存简介"><a href="#1-内存简介" class="headerlink" title="1. 内存简介"></a>1. 内存简介</h2><h3 id="1-1-物理内存和虚拟内存"><a href="#1-1-物理内存和虚拟内存" class="headerlink" title="1.1. 物理内存和虚拟内存"></a>1.1. 物理内存和虚拟内存</h3><p>所谓物理内存就是通常所说的 RAM（随机存储器）。 </p>
<p>虚拟内存使得多个进程在同时运行时可以共享物理内存，这里的共享只是空间上共享，在逻辑上彼此仍然是隔离的。 </p>
<h3 id="1-2-内核空间和用户空间"><a href="#1-2-内核空间和用户空间" class="headerlink" title="1.2. 内核空间和用户空间"></a>1.2. 内核空间和用户空间</h3><p>一个计算机通常有固定大小的内存空间，但是程序并不能使用全部的空间。因为这些空间被划分为内核空间和用户空间，而程序只能使用用户空间的内存。</p>
<h3 id="1-3-使用内存的Java组件"><a href="#1-3-使用内存的Java组件" class="headerlink" title="1.3 使用内存的Java组件"></a>1.3 使用内存的Java组件</h3><p>Java启动后，作为一个进程运行在操作系统中</p>
<p>有哪些 Java 组件需要占用内存呢？ </p>
<ul>
<li>堆内存：Java 堆、类和类加载器</li>
<li>栈内存：线程</li>
<li>本地内存：NIO、JNI、</li>
</ul>
<h2 id="2-运行时数据区"><a href="#2-运行时数据区" class="headerlink" title="2. 运行时数据区"></a>2. 运行时数据区</h2><p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。 </p>
<p>下图是 JVM 整体架构，中间部分就是 Java 虚拟机定义的各种运行时数据区域。 </p>
<p><img src="/img/work/1657549836213.png"></p>
<p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。 </p>
<p>另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。 </p>
<ul>
<li>线程私有：程序计数器、栈、本地栈</li>
<li>线程共享：堆、堆外内存（永久代或元空间、代码缓存）</li>
</ul>
<blockquote>
<p>下面我们就来一一解毒下这些内存区域，先从最简单的入手 </p>
</blockquote>
<h2 id="3-程序计数器"><a href="#3-程序计数器" class="headerlink" title="3. 程序计数器"></a>3. 程序计数器</h2><p>程序计数寄存器（<strong>Program Counter Register</strong>），Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的线程信息，CPU 只有把数据装载到寄存器才能够运行。 </p>
<p>这里，并非是广义上所指的物理寄存器，叫程序计数器（或PC计数器或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会。<strong>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</strong>。 </p>
<p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。 </p>
<h3 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1 作用"></a>3.1 作用</h3><p>PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。 </p>
<p><img src="/img/work/1657553375207.png"></p>
<p>（分析：进入class文件所在目录，执行 <code>javap -v xx.class</code> 反解析（或者通过 IDEA 插件 <code>Jclasslib</code> 直接查看，上图），可以看到当前类对应的Code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等信息。） </p>
<h3 id="3-2-概述"><a href="#3-2-概述" class="headerlink" title="3.2 概述"></a>3.2 概述</h3><ul>
<li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li>
<li>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 natice 方法，则是未指定值（undefined）</li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li>
<li>它是唯一一个在 JVM 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域</li>
</ul>
<blockquote>
<p>👨‍💻：使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</p>
<p>🙋‍♂️：因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
</blockquote>
<blockquote>
<p>👨‍💻：PC寄存器为什么会被设定为线程私有的？</p>
<p>🙋‍♂️：多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。</p>
</blockquote>
<h2 id="4-虚拟机栈"><a href="#4-虚拟机栈" class="headerlink" title="4. 虚拟机栈"></a>4. 虚拟机栈</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>Java 虚拟机栈(Java Virtual Machine Stacks)，早期也叫 Java 栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。</p>
<p><strong>作用:</strong> 主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p>
<p><strong>特点：</strong></p>
<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li>
<li>JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着<strong>入栈</strong>（进栈/压栈），方法执行结束<strong>出栈</strong></li>
<li>栈不存在垃圾回收问题</li>
</ul>
<p><strong>栈中可能出现的异常：</strong></p>
<p>Java 虚拟机规范允许 <strong>Java虚拟机栈的大小是动态的或者是固定不变的</strong></p>
<ul>
<li>如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常</li>
<li>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<strong>OutOfMemoryError</strong>异常</li>
</ul>
<p>可以通过参数<code>-Xss</code>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p>
<p>官方提供的参考工具，可查一些参数和操作：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html#BGBCIEFC">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html#BGBCIEFC</a></p>
<h3 id="4-2-栈的存储单位"><a href="#4-2-栈的存储单位" class="headerlink" title="4.2 栈的存储单位"></a>4.2 栈的存储单位</h3><p>栈中存储什么？</p>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧（Stack Frame）的格式存在</strong></li>
<li>在这个线程上正在执行的每个方法都各自有对应的一个栈帧</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li>
</ul>
<h3 id="4-3-栈运行原理"><a href="#4-3-栈运行原理" class="headerlink" title="4.3 栈运行原理"></a>4.3 栈运行原理</h3><ul>
<li>JVM 直接对 Java 栈的操作只有两个，对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循“先进后出/后进先出”原则</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（<strong>栈顶栈帧</strong>）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）</li>
<li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧</li>
<li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li>
<li>Java 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</strong></li>
</ul>
<p>IDEA 在 debug 时候，可以在 debug 窗口看到 Frames 中各种方法的压栈和出栈情况</p>
<p><img src="/img/work/image-20220713084555454.png"></p>
<h3 id="4-4-栈帧的内部结构"><a href="#4-4-栈帧的内部结构" class="headerlink" title="4.4 栈帧的内部结构"></a>4.4 栈帧的内部结构</h3><p>每个<strong>栈帧</strong>（Stack Frame）中存储着：</p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（Operand Stack）(或称为表达式栈)</li>
<li>动态链接（Dynamic Linking）：指向运行时常量池的方法引用</li>
<li>方法返回地址（Return Address）：方法正常退出或异常退出的地址</li>
<li>一些附加信息</li>
</ul>
<p><img src="/img/work/image-20220713084958680.png"></p>
<p>继续深抛栈帧中的五部分~~</p>
<h4 id="4-4-1-局部变量表"><a href="#4-4-1-局部变量表" class="headerlink" title="4.4.1 局部变量表"></a>4.4.1 局部变量表</h4><ul>
<li>局部变量表也被称为局部变量数组或者本地变量表</li>
<li>是一组变量值存储空间,<strong>主要用于存储方法参数和定义在方法体内的局部变量</strong>，包括编译器可知的各种 Java 虚拟机<strong>基本数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此相关的位置）和 <strong>returnAddress</strong> 类型（指向了一条字节码指令的地址，已被异常表取代）</li>
<li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li>
<li><strong>局部变量表所需要的容量大小是编译期确定下来的</strong>，并保存在方法的 Code 属性的 <code>maximum local variables</code> 数据项中。在方法运行期间是不会改变局部变量表的大小的</li>
<li>方法嵌套调用的次数由栈的大小决定。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li>
<li><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li>
<li>参数值的存放总是在局部变量数组的 index0 开始，到数组长度 -1 的索引结束</li>
</ul>
<p> <strong>槽 Slot</strong></p>
<ul>
<li>局部变量表最基本的存储单元是 Slot（变量槽）</li>
<li>在局部变量表中，32 位以内的类型只占用一个 Slot(包括returnAddress类型)，64 位的类型（long和double）占用两个连续的 Slot<ul>
<li>byte、short、char 在存储前被转换为 int，boolean 也被转换为 int，0 表示 false，非 0 表示 true</li>
<li>long 和 double 则占据两个 Slot</li>
</ul>
</li>
<li>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，索引值的范围从 0 开始到局部变量表最大的 Slot 数量</li>
<li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个 Slot上</li>
<li><strong>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可</strong>。（比如：访问 long 或 double 类型变量，不允许采用任何方式单独访问其中的某一个 Slot）</li>
<li>如果当前帧是由构造方法或实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 Slot 处，如果当前帧是由构造方法或实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 Slot 处，其余的参数按照参数表顺序继续排列（这里就引出一个问题：静态方法中为什么不可以引用 this，就是因为 this 变量不存在于当前方法的局部变量表中）</li>
<li><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。（下图中，this、a、b、c 理论上应该有 4 个变量，c 复用了 b 的槽）</li>
</ul>
<p><img src="/img/work/image-20220713155517065.png"></p>
<ul>
<li>在栈帧中，与性能调优关系最为密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li>
<li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li>
</ul>
<h4 id="4-4-2-操作数栈"><a href="#4-4-2-操作数栈" class="headerlink" title="4.4.2. 操作数栈"></a>4.4.2. 操作数栈</h4><ul>
<li>每个独立的栈帧中除了包含局部变量表之外，还包含一个<strong>后进先出</strong>（Last-In-First-Out）的操作数栈，也可以称为<strong>表达式栈</strong>（Expression Stack）</li>
<li><strong>操作数栈，在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈（push）、出栈（pop）</strong></li>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如，执行复制、交换、求和等操作</li>
</ul>
<p> <strong>概述</strong></p>
<ul>
<li><p>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></p>
</li>
<li><p>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>此时这个方法的操作数栈是空的</strong></p>
</li>
<li><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性的 <code>max_stack</code> 数据项中</p>
</li>
<li><p>栈中的任何一个元素都可以是任意的 Java 数据类型</p>
<ul>
<li>32bit 的类型占用一个栈单位深度</li>
<li>64bit 的类型占用两个栈单位深度</li>
</ul>
</li>
<li><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p>
</li>
<li><p><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新 PC 寄存器中下一条需要执行的字节码指令</p>
</li>
<li><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</p>
</li>
<li><p>另外，我们说 <strong>Java虚拟机的解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈</p>
</li>
</ul>
<p> <strong>栈顶缓存（Top-of-stack-Cashing）</strong></p>
<p>HotSpot 的执行引擎采用的并非是基于寄存器的架构，但这并不代表 HotSpot VM 的实现并没有间接利用到寄存器资源。寄存器是物理 CPU 中的组成部分之一，它同时也是 CPU 中非常重要的高速存储资源。一般来说，寄存器的读/写速度非常迅速，甚至可以比内存的读/写速度快上几十倍不止，不过寄存器资源却非常有限，不同平台下的 CPU 寄存器数量是不同和不规律的。寄存器主要用于缓存本地机器指令、数值和下一条需要被执行的指令地址等数据。</p>
<p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。由于操作数是存储在内存中的，因此频繁的执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率</strong></p>
<h4 id="4-4-3-动态链接（指向运行时常量池的方法引用）"><a href="#4-4-3-动态链接（指向运行时常量池的方法引用）" class="headerlink" title="4.4.3 动态链接（指向运行时常量池的方法引用）"></a>4.4.3 动态链接（指向运行时常量池的方法引用）</h4><ul>
<li><strong>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。</li>
<li>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为<strong>符号引用</strong>（Symbolic Reference）保存在 Class 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li>
</ul>
<p><img src="/img/work/1657719529492.png"></p>
<p> <strong>JVM 是如何执行方法调用的</strong></p>
<p>方法调用不同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本(即调用哪一个方法)，暂时还不涉及方法内部的具体运行过程。Class 文件的编译过程中不包括传统编译器中的连接步骤，一切方法调用在 Class文件里面存储的都是<strong>符号引用</strong>，而不是方法在实际运行时内存布局中的入口地址（<strong>直接引用</strong>）。也就是需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用。  </p>
<blockquote>
<p>【这一块内容，除了方法调用，还包括解析、分派（静态分派、动态分派、单分派与多分派），这里先不介绍，后续再挖】 </p>
</blockquote>
<p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关 </p>
<ul>
<li><p><strong>静态链接</strong>：当一个字节码文件被装载进 JVM 内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p>
</li>
<li></li>
<li><p><strong>动态链接</strong>：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接</p>
</li>
</ul>
<p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</strong>。 </p>
<ul>
<li>早期绑定：<strong>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时</strong>，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li>
<li>晚期绑定：如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式就被称为晚期绑定。</li>
</ul>
<p><strong>虚方法和非虚方法</strong></p>
<ul>
<li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法</li>
<li>其他方法称为虚方法</li>
</ul>
<p><strong>虚方法表</strong></p>
<p>在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法元数据中搜索合适的目标有可能会影响到执行效率。为了提高性能，JVM 采用在类的方法区建立一个虚方法表（virtual method table），使用索引表来代替查找。非虚方法不会出现在表中。 </p>
<p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。 </p>
<p>虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。 </p>
<h4 id="4-4-4-方法返回地址（return-address）"><a href="#4-4-4-方法返回地址（return-address）" class="headerlink" title="4.4.4. 方法返回地址（return address）"></a>4.4.4. 方法返回地址（return address）</h4><p>用来存放调用该方法的 PC 寄存器的值。 </p>
<p>一个方法的结束，有两种方式 </p>
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。 而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。 </p>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：  </p>
<ol>
<li>执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>一个方法的正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定</li>
</ol>
<p>在字节码指令中，返回指令包含 ireturn(当返回值是 boolean、byte、char、short 和 int 类型时使用)、lreturn、freturn、dreturn 以及 areturn，另外还有一个 return 指令供声明为 void 的方法、实例初始化方法、类和接口的初始化方法使用。 </p>
<ol start="2">
<li> 在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong> </li>
</ol>
<p> 方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。 </p>
<p>本质上，<strong>方法的退出就是当前栈帧出栈的过程</strong>。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。 </p>
<p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</strong> </p>
<h4 id="4-4-5-附加信息"><a href="#4-4-5-附加信息" class="headerlink" title="4.4.5. 附加信息"></a>4.4.5. 附加信息</h4><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。 </p>
<h2 id="5-本地方法栈"><a href="#5-本地方法栈" class="headerlink" title="5. 本地方法栈"></a>5. 本地方法栈</h2><h3 id="5-1-本地方法接口"><a href="#5-1-本地方法接口" class="headerlink" title="5.1 本地方法接口"></a>5.1 本地方法接口</h3><p>简单的讲，一个 Native Method 就是一个 Java 调用非 Java 代码的接口。我们知道的 Unsafe 类就有很多本地方法。</p>
<blockquote>
<p>为什么要使用本地方法（Native Method）?  </p>
</blockquote>
<p>Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来也不容易，或者我们对程序的效率很在意时，问题就来了 </p>
<ul>
<li>与 Java 环境外交互：有时 Java 应用需要与 Java 外面的环境交互，这就是本地方法存在的原因。</li>
<li>与操作系统交互：JVM 支持 Java 语言本身和运行时库，但是有时仍需要依赖一些底层系统的支持。通过本地方法，我们可以实现用 Java 与实现了 jre 的底层系统交互， JVM 的一些部分就是 C 语言写的。 </li>
<li>Sun’s Java：Sun的解释器就是C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分都是用 Java 实现的，它也通过一些本地方法与外界交互。比如，类 <code>java.lang.Thread</code> 的 <code>setPriority()</code> 的方法是用Java 实现的，但它实现调用的是该类的本地方法 <code>setPrioruty()</code>，该方法是C实现的，并被植入 JVM 内部。</li>
</ul>
<h3 id="5-2-本地方法栈（Native-Method-Stack）"><a href="#5-2-本地方法栈（Native-Method-Stack）" class="headerlink" title="5.2 本地方法栈（Native Method Stack）"></a>5.2 本地方法栈（Native Method Stack）</h3><ul>
<li>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用</li>
<li>本地方法栈也是线程私有的</li>
<li> 允许线程固定或者可动态扩展的内存大小 </li>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 <code>StackOverflowError</code> 异常</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java虚拟机将会抛出一个<code>OutofMemoryError</code>异常</li>
<li>本地方法是使用 C 语言实现的</li>
<li>它的具体做法是 <code>Mative Method Stack</code> 中登记 native 方法，在 <code>Execution Engine</code> 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</li>
<li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存</li>
<li>并不是所有 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈</li>
<li><strong>在 Hotspot JVM 中，直接将本地方栈和虚拟机栈合二为一</strong></li>
</ul>
<blockquote>
<p> <strong>栈是运行时的单位，而堆是存储的单位</strong>。 </p>
<p> 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。 </p>
</blockquote>
<h2 id="6-堆内存"><a href="#6-堆内存" class="headerlink" title="6. 堆内存"></a>6. 堆内存</h2><h3 id="6-1-内存划分"><a href="#6-1-内存划分" class="headerlink" title="6.1 内存划分"></a>6.1 内存划分</h3><p>对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p>
<p>为了进行高效的垃圾回收，虚拟机把堆内存<strong>逻辑上</strong>划分成三块区域（<strong>分代的唯一理由就是优化 GC 性能</strong>）：  </p>
<ul>
<li>新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代</li>
<li>老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大</li>
<li>元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存</li>
</ul>
<p><img src="D:\software06\blog\themes\fluid\source\img\work\1657943468538.png"></p>
<p>Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 <code>OutOfMemoryError</code> 异常。  </p>
<p><strong>年轻代 (Young Generation)</strong></p>
<p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 <strong>Minor GC</strong>。年轻一代被分为三个部分——伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为from/to或s0/s1），默认比例是<code>8:1:1</code></p>
<ul>
<li>大多数新创建的对象都位于 Eden 内存空间中</li>
<li>当 Eden 空间被对象填充时，执行<strong>Minor GC</strong>，并将所有幸存者对象移动到一个幸存者空间中</li>
<li>Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的</li>
<li>经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代</li>
</ul>
<p><strong>老年代(Old Generation)</strong></p>
<p>旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间。 </p>
<p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝 </p>
<p><img src="D:\software06\blog\themes\fluid\source\img\work\1657945327669.png"></p>
<p><strong>元空间</strong></p>
<p>不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中方法区的实现。</p>
<p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</p>
<p>所以元空间放在后边的方法区再说。</p>
<h3 id="6-2-设置堆内存大小和-OOM"><a href="#6-2-设置堆内存大小和-OOM" class="headerlink" title="6.2 设置堆内存大小和 OOM"></a>6.2 设置堆内存大小和 OOM</h3><p>Java 堆用于存储 Java 对象实例，那么堆的大小在 JVM 启动的时候就确定了，我们可以通过 <code>-Xmx</code> 和 <code>-Xms</code> 来设定 </p>
<ul>
<li><p><code>-Xms</code> 用来表示堆的起始内存，等价于 <code>-XX:InitialHeapSize</code></p>
</li>
<li><p><code>-Xmx</code> 用来表示堆的最大内存，等价于 <code>-XX:MaxHeapSize</code></p>
</li>
</ul>
<p>如果堆的内存大小超过 <code>-Xmx</code> 设定的最大内存， 就会抛出 <code>OutOfMemoryError</code> 异常。 </p>
<p>我们通常会将 <code>-Xmx</code> 和 <code>-Xms</code> 两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能 </p>
<ul>
<li>默认情况下，初始堆内存大小为：电脑内存大小/64</li>
<li>默认情况下，最大堆内存大小为：电脑内存大小/4</li>
</ul>
<p>可以通过代码获取到我们的设置值，当然也可以模拟 OOM： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>  <span class="hljs-comment">//返回 JVM 堆大小</span><br>  <span class="hljs-keyword">long</span> initalMemory = Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> /<span class="hljs-number">1024</span>;<br>  <span class="hljs-comment">//返回 JVM 堆的最大内存</span><br>  <span class="hljs-keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> /<span class="hljs-number">1024</span>;<br><br>  System.out.println(<span class="hljs-string">&quot;-Xms : &quot;</span>+initalMemory + <span class="hljs-string">&quot;M&quot;</span>);<br>  System.out.println(<span class="hljs-string">&quot;-Xmx : &quot;</span>+maxMemory + <span class="hljs-string">&quot;M&quot;</span>);<br><br>  System.out.println(<span class="hljs-string">&quot;系统内存大小：&quot;</span> + initalMemory * <span class="hljs-number">64</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;G&quot;</span>);<br>  System.out.println(<span class="hljs-string">&quot;系统内存大小：&quot;</span> + maxMemory * <span class="hljs-number">4</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;G&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>查看 JVM 堆内存分配</strong></p>
<ol>
<li>在默认不配置 JVM 堆内存大小的情况下，JVM 根据默认值来配置当前内存大小</li>
<li> 默认情况下新生代和老年代的比例是 1:2，可以通过 <code>–XX:NewRatio</code> 来配置 </li>
</ol>
<ul>
<li>新生代中的 <strong>Eden</strong>:<strong>From Survivor</strong>:<strong>To Survivor</strong> 的比例是 <strong>8:1:1</strong>，可以通过 <code>-XX:SurvivorRatio</code> 来配置</li>
</ul>
<ol start="3">
<li> 若在 JDK 7 中开启了 <code>-XX:+UseAdaptiveSizePolicy</code>，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄此时 <code>–XX:NewRatio</code> 和 <code>-XX:SurvivorRatio</code> 将会失效，而 JDK 8 是默认开启<code>-XX:+UseAdaptiveSizePolicy</code>在 JDK 8中，<strong>不要随意关闭</strong><code>-XX:+UseAdaptiveSizePolicy</code>，除非对堆内存的划分有明确的规划   </li>
</ol>
<p> 每次 GC 后都会重新计算 Eden、From Survivor、To Survivor 的大小 </p>
<p> 计算依据是<strong>GC过程</strong>中统计的<strong>GC时间</strong>、<strong>吞吐量</strong>、<strong>内存占用量</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">java -XX:+PrintFlagsFinal -version | grep HeapSize<br>    uintx ErgoHeapSizeLimit                         = 0                                   &#123;product&#125;<br>    uintx HeapSizePerGCThread                       = 87241520                            &#123;product&#125;<br>    uintx InitialHeapSize                          := 134217728                           &#123;product&#125;<br>    uintx LargePageHeapSizeThreshold                = 134217728                           &#123;product&#125;<br>    uintx MaxHeapSize                              := 2147483648                          &#123;product&#125;<br>java version &quot;1.8.0_211&quot;<br>Java(TM) SE Runtime Environment (build 1.8.0_211-b12)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)<br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> jmap -heap 进程号</span><br></code></pre></td></tr></table></figure>

<h3 id="6-3-对象在堆中的生命周期"><a href="#6-3-对象在堆中的生命周期" class="headerlink" title="6.3 对象在堆中的生命周期"></a>6.3 对象在堆中的生命周期</h3><ol>
<li>在 JVM 内存模型的堆中，堆被划分为新生代和老年代 <ul>
<li>新生代又被进一步划分为 <strong>Eden区</strong> 和 <strong>Survivor区</strong>，Survivor 区由 <strong>From Survivor</strong> 和 <strong>To Survivor</strong> 组成</li>
</ul>
</li>
<li> 当创建一个对象时，对象会被优先分配到新生代的 Eden 区 </li>
</ol>
<ul>
<li>此时 JVM 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li>
</ul>
<ol start="3">
<li> 当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC） </li>
</ol>
<ul>
<li>JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1</li>
<li>对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1</li>
</ul>
<ol start="4">
<li>如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，对象会<strong>直接被分配到老年代</strong></li>
</ol>
<h3 id="6-4-对象的分配过程"><a href="#6-4-对象的分配过程" class="headerlink" title="6.4 对象的分配过程"></a>6.4 对象的分配过程</h3><p>为对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。 </p>
<ol>
<li>new 的对象先放在伊甸园区，此区有大小限制</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li>
<li>然后将伊甸园中的剩余对象移动到幸存者 0 区</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，如果没有回收，就会放到幸存者 1 区</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区</li>
<li>什么时候才会去养老区呢？ 默认是 15 次回收标记</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理</li>
<li>若养老区执行了 Major GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常</li>
</ol>
<h3 id="6-5-GC-垃圾回收简介"><a href="#6-5-GC-垃圾回收简介" class="headerlink" title="6.5 GC 垃圾回收简介"></a>6.5 GC 垃圾回收简介</h3><p><strong>Minor GC、Major GC、Full GC</strong></p>
<p>JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。 </p>
<p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC） </p>
<ul>
<li>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为： <ul>
<li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集</li>
<li> 老年代收集（Major GC/Old GC）：只是老年代的垃圾收集 </li>
<li>目前，只有 CMS GC 会有单独收集老年代的行为</li>
<li>很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收</li>
<li> 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集 </li>
<li>目前只有 G1 GC 会有这种行为</li>
</ul>
</li>
<li>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾</li>
</ul>
<h3 id="6-6-TLAB"><a href="#6-6-TLAB" class="headerlink" title="6.6 TLAB"></a>6.6 TLAB</h3><p>Thread Local Allocation Buffer 的简写，基于 CAS 的独享线程（Mutator Threads）可以优先将对象分配在 Eden 中的一块内存，因为是 Java 线程独享的内存区没有锁竞争，所以分配速度更快，每个 TLAB 都是一个线程独享的。 </p>
<p><strong>什么是 TLAB （Thread Local Allocation Buffer）?</strong></p>
<ul>
<li>从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内</li>
<li>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为<strong>快速分配策略</strong></li>
<li>OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计</li>
</ul>
<p><strong>为什么要有 TLAB ?</strong></p>
<ul>
<li><p>堆区是线程共享的，任何线程都可以访问到堆区中的共享数据</p>
</li>
<li><p>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p>
</li>
<li><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</p>
</li>
</ul>
<p>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。 </p>
<p>在程序中，可以通过 <code>-XX:UseTLAB</code> 设置是否开启 TLAB 空间。 </p>
<p>默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，我们可以通过 <code>-XX:TLABWasteTargetPercent</code> 设置 TLAB 空间所占用 Eden 空间的百分比大小。 </p>
<p>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。 </p>
<h3 id="6-7-堆是分配对象存储的唯一选择吗"><a href="#6-7-堆是分配对象存储的唯一选择吗" class="headerlink" title="6.7 堆是分配对象存储的唯一选择吗"></a>6.7 堆是分配对象存储的唯一选择吗</h3><blockquote>
<p> 随着 JIT 编译期的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。 ——《深入理解 Java 虚拟机》 </p>
</blockquote>
<p><strong>逃逸分析</strong></p>
<p><strong>逃逸分析(Escape Analysis)是目前 Java 虚拟机中比较前沿的优化技术。这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</strong>。通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。 </p>
<p>逃逸分析的基本行为就是分析对象动态作用域： </p>
<ul>
<li> 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸 </li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中，称为方法逃逸。</li>
</ul>
<p>例如： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuffer <span class="hljs-title">craeteStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>   StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>   sb.append(s1);<br>   sb.append(s2);<br>   <span class="hljs-keyword">return</span> sb;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>StringBuffer sb</code>是一个方法内部变量，上述代码中直接将sb返回，这样这个 StringBuffer 有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。 </p>
<p>上述代码如果想要 <code>StringBuffer sb</code>不逃出方法，可以这样写： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>   StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>   sb.append(s1);<br>   sb.append(s2);<br>   <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不直接返回 StringBuffer，那么 StringBuffer 将不会逃逸出方法。 </p>
<p><strong>参数设置：</strong> </p>
<ul>
<li>在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析</li>
<li>如果使用较早版本，可以通过<code>-XX&quot;+DoEscapeAnalysis</code>显式开启</li>
</ul>
<p>开发中使用局部变量，就不要在方法外定义。 </p>
<p>使用逃逸分析，编译器可以对代码做优化： </p>
<ul>
<li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</li>
<li><strong>同步省略</strong>：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li>
<li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器</li>
</ul>
<p>JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。 </p>
<p>常见栈上分配的场景：成员变量赋值、方法返回值、实例引用传递 </p>
<p><strong>代码优化之同步省略（消除）</strong></p>
<ul>
<li>线程同步的代价是相当高的，同步的后果是降低并发性和性能</li>
<li>在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这个代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫做<strong>同步省略，也叫锁消除</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">keep</span><span class="hljs-params">()</span> </span>&#123;<br>  Object keeper = <span class="hljs-keyword">new</span> Object();<br>  <span class="hljs-keyword">synchronized</span>(keeper) &#123;<br>    System.out.println(keeper);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上代码，代码中对 keeper 这个对象进行加锁，但是 keeper 对象的生命周期只在 <code>keep()</code>方法中，并不会被其他线程所访问到，所以在 JIT编译阶段就会被优化掉。优化成： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">keep</span><span class="hljs-params">()</span> </span>&#123;<br>  Object keeper = <span class="hljs-keyword">new</span> Object();<br>  System.out.println(keeper);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>代码优化之标量替换</strong></p>
<p><strong>标量</strong>（Scalar）是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。 </p>
<p>相对的，那些的还可以分解的数据叫做<strong>聚合量</strong>（Aggregate），Java 中的对象就是聚合量，因为其还可以分解成其他聚合量和标量。</p>
<p>在JIT阶段，通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM 不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。这个过程就是<strong>标量替换</strong>。</p>
<p>通过 <code>-XX:+EliminateAllocations</code> 可以开启标量替换，<code>-XX:+PrintEliminateAllocations</code> 查看标量替换情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>   alloc();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">alloc</span><span class="hljs-params">()</span> </span>&#123;<br>   Point point = <span class="hljs-keyword">new</span> Point（<span class="hljs-number">1</span>,<span class="hljs-number">2</span>）;<br>   System.out.println(<span class="hljs-string">&quot;point.x=&quot;</span>+point.x+<span class="hljs-string">&quot;; point.y=&quot;</span>+point.y);<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> y;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上代码中，point 对象并没有逃逸出 <code>alloc()</code> 方法，并且 point 对象是可以拆解成标量的。那么，JIT 就不会直接创建 Point 对象，而是直接使用两个标量 int x ，int y 来替代 Point 对象。     </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">alloc</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">int</span> y = <span class="hljs-number">2</span>;<br>   System.out.println(<span class="hljs-string">&quot;point.x=&quot;</span>+x+<span class="hljs-string">&quot;; point.y=&quot;</span>+y);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>代码优化之栈上分配</strong></p>
<p>我们通过 JVM 内存分配可以知道 JAVA 中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠 GC 进行回收内存，如果对象数量较多的时候，会给 GC 带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM 通过逃逸分析确定该对象不会被外部访问。那就通过标量替换将该对象分解在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。 </p>
<p><strong>总结：</strong> </p>
<p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。 </p>
<p><strong>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong> </p>
<p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。 </p>
<p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。 </p>
<h2 id="7-方法区"><a href="#7-方法区" class="headerlink" title="7. 方法区"></a>7. 方法区</h2><ul>
<li>方法区（Method Area）与 Java 堆一样，是所有线程共享的内存区域。</li>
<li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</li>
<li>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 <code>String.intern()</code>方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</li>
<li>方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误</li>
<li>JVM 关闭后方法区即被释放</li>
</ul>
<h3 id="7-1-解惑"><a href="#7-1-解惑" class="headerlink" title="7.1 解惑"></a>7.1 解惑</h3><p>你是否也有看不同的参考资料，有的内存结构图有方法区，有的又是永久代，元数据区，一脸懵逼的时候？ </p>
<ul>
<li><strong>方法区（method area）**只是 **JVM 规范**中定义的一个**概念**，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而</strong>永久代（PermGen）是 Hotspot虚拟机特有的概念， Java8 的时候又被元空间**取代了，永久代和元空间都可以理解为方法区的落地实现。</li>
<li>永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生OOM（都会有溢出异常）</li>
<li>Java7 中我们通过<code>-XX:PermSize</code> 和 <code>-xx:MaxPermSize</code> 来设置永久代参数，Java8 之后，随着永久代的取消，这些参数也就随之失效了，改为通过<code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 用来设置元空间参数</li>
<li>存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中</li>
<li>如果方法区域中的内存不能用于满足分配请求，则 Java 虚拟机抛出 <code>OutOfMemoryError</code></li>
<li>JVM 规范说方法区在逻辑上是堆的一部分，但目前实际上是与 Java 堆分开的（Non-Heap）</li>
</ul>
<p>所以对于方法区，Java8 之后的变化： </p>
<ul>
<li>移除了永久代（PermGen），替换为元空间（Metaspace）；</li>
<li>永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；</li>
<li>永久代中的 interned Strings 和 class static variables 转移到了 Java heap；</li>
<li>永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize）</li>
</ul>
<h3 id="7-2-设置方法区内存的大小"><a href="#7-2-设置方法区内存的大小" class="headerlink" title="7.2 设置方法区内存的大小"></a>7.2 设置方法区内存的大小</h3><p>JDK8 及以后： </p>
<ul>
<li>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 指定，替代上述原有的两个参数</li>
<li>默认值依赖于平台。Windows 下，<code>-XX:MetaspaceSize</code> 是 21M，<code>-XX:MaxMetaspacaSize</code> 的值是 -1，即没有限制</li>
<li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据发生溢出，虚拟机一样会抛出异常 <code>OutOfMemoryError:Metaspace</code></li>
<li><code>-XX:MetaspaceSize</code> ：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的 <code>-XX:MetaspaceSize</code> 的值为20.75MB，这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置，新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过 <code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值</li>
<li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次，通过垃圾回收的日志可观察到 Full GC 多次调用。为了避免频繁 GC，建议将 <code>-XX:MetaspaceSize</code> 设置为一个相对较高的值。</li>
</ul>
<h3 id="7-3-方法区内部结构"><a href="#7-3-方法区内部结构" class="headerlink" title="7.3 方法区内部结构"></a>7.3 方法区内部结构</h3><p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。 </p>
<p><strong>类型信息</strong></p>
<p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息 </p>
<ul>
<li>这个类型的完整有效名称（全名=包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于 interface或是 java.lang.Object，都没有父类）</li>
<li>这个类型的修饰符（public，abstract，final 的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
<p><strong>域（Field）信息</strong></p>
<ul>
<li>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li>
<li>域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）</li>
</ul>
<p><strong>方法（Method）信息</strong></p>
<p>JVM 必须保存所有方法的 </p>
<ul>
<li>方法名称</li>
<li>方法的返回类型</li>
<li>方法参数的数量和类型</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li>
<li>方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li>
<li>异常表（abstract 和 native 方法除外）<ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
<p><strong>栈、堆、方法区的交互关系</strong> </p>
<h3 id="7-4-运行时常量池"><a href="#7-4-运行时常量池" class="headerlink" title="7.4 运行时常量池"></a>7.4 运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分，理解运行时常量池的话，我们先来说说字节码文件（Class 文件）中的常量池（常量池表） </p>
<p><strong>常量池</strong></p>
<p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型、域和方法的符号引用。 </p>
<p><strong>为什么需要常量池？</strong></p>
<p>一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。  </p>
<p>如下，我们通过 jclasslib 查看一个只有 Main 方法的简单类，字节码中的 #2 指向的就是 Constant Pool </p>
<p><img src="D:\software06\blog\themes\fluid\source\img\work\1658068250032.png"></p>
<p>常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。 </p>
<p><strong>运行时常量池</strong></p>
<ul>
<li>在加载类和结构到虚拟机后，就会创建对应的运行时常量池</li>
<li>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong></li>
<li>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的</li>
<li>运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址 <ul>
<li>运行时常量池，相对于 Class 文件常量池的另一个重要特征是：<strong>动态性</strong>，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 <code>intern()</code> 方法就是这样的</li>
</ul>
</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。</li>
</ul>
<h3 id="7-5-方法区在-JDK6、7、8中的演进细节"><a href="#7-5-方法区在-JDK6、7、8中的演进细节" class="headerlink" title="7.5 方法区在 JDK6、7、8中的演进细节"></a>7.5 方法区在 JDK6、7、8中的演进细节</h3><p>只有 HotSpot 才有永久代的概念 </p>
<table>
<thead>
<tr>
<th align="center">jdk1.6及之前</th>
<th align="center">有永久代，静态变量存放在永久代上</th>
</tr>
</thead>
<tbody><tr>
<td align="center">jdk1.7</td>
<td align="center">有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中</td>
</tr>
<tr>
<td align="center">jdk1.8及之后</td>
<td align="center">取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td>
</tr>
</tbody></table>
<p><strong>移除永久代原因</strong></p>
<p><a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a> </p>
<p> <img src="D:\software06\blog\themes\fluid\source\img\work\007S8ZIlly1gg04ve34c2j30z00u0dp7.jpg"> </p>
<ul>
<li>为永久代设置空间大小是很难确定的。 </li>
</ul>
<p>在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。如果某个实际 Web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现 OOM。而元空间和永久代最大的区别在于，元空间不在虚拟机中，而是使用本地内存，所以默认情况下，元空间的大小仅受本地内存限制 </p>
<ul>
<li>对永久代进行调优较困难</li>
</ul>
<h3 id="7-6-方法区的垃圾回收"><a href="#7-6-方法区的垃圾回收" class="headerlink" title="7.6 方法区的垃圾回收"></a>7.6 方法区的垃圾回收</h3><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。 </p>
<p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量： </p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收 </p>
<p>判定一个类型是否属于“不再被使用的类”，需要同时满足三个条件： </p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<p>Java 虚拟机被允许堆满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot 虚拟机提供了 <code>-Xnoclassgc</code> 参数进行控制，还可以使用 <code>-verbose:class</code> 以及 <code>-XX:+TraceClassLoading</code> 、<code>-XX:+TraceClassUnLoading</code> 查看类加载和卸载信息。 </p>
<p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。 </p>
<h2 id="8-参考与感谢"><a href="#8-参考与感谢" class="headerlink" title="8. 参考与感谢"></a>8. 参考与感谢</h2><p><a href="https://javakeeper.starfish.ink/java/JVM/Runtime-Data-Areas.html#%E7%9B%B4%E5%87%BB%E9%9D%A2%E8%AF%95">文章来源于海星</a></p>
<p>原作者参考内容如下</p>
<p>算是一篇学习笔记，共勉，主要来源：</p>
<p>《深入理解 Java 虚拟机 第三版》</p>
<p>宋红康老师的 JVM 教程</p>
<p><a href="https://docs.oracle.com/javase/specs/index.html">https://docs.oracle.com/javase/specs/index.html</a></p>
<p><a href="https://www.cnblogs.com/wicfhwffg/p/9382677.html">https://www.cnblogs.com/wicfhwffg/p/9382677.html</a></p>
<p><a href="https://www.cnblogs.com/hollischuang/p/12501950.html">https://www.cnblogs.com/hollischuang/p/12501950.html</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发锁</title>
    <url>/2022/05/18/Java%E5%B9%B6%E5%8F%91%E9%94%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>引言</strong></p>
<blockquote>
<p> 本文先阐述 Java 中各种锁的概念。 </p>
<p> 然后，介绍锁的核心实现 AQS。 </p>
<p>然后，重点介绍 Lock 和 Condition 两个接口及其实现。并发编程有两个核心问题：同步和互斥。</p>
<p><strong>互斥</strong>，即同一时刻只允许一个线程访问共享资源；</p>
<p> <strong>同步</strong>，即线程之间如何通信、协作。 </p>
<p> 这两大问题，管程（<code>sychronized</code>）都是能够解决的。<strong>J.U.C 包还提供了 Lock 和 Condition 两个接口来实现管程，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题</strong>。 </p>
</blockquote>
<h2 id="1-并发锁简介"><a href="#1-并发锁简介" class="headerlink" title="1. 并发锁简介"></a>1. 并发锁简介</h2><p>确保线程安全最常见的做法是利用锁机制（<code>Lock</code>、<code>sychronized</code>）来对共享数据做互斥同步，这样在同一个时刻，只有一个线程可以执行某个方法或者某个代码块，那么操作必然是原子性的，线程安全的。 </p>
<p>在工作、面试中，经常会听到各种五花八门的锁，听的人云里雾里。锁的概念术语很多，它们是针对不同的问题所提出的，通过简单的梳理，也不难理解。 </p>
<h3 id="1-1-可重入锁"><a href="#1-1-可重入锁" class="headerlink" title="1.1. 可重入锁"></a>1.1. 可重入锁</h3><p><strong>可重入锁，顾名思义，指的是线程可以重复获取同一把锁</strong>。即同一个线程在外层方法获取了锁，在进入内层方法会自动获取锁。 </p>
<p><strong>可重入锁可以在一定程度上避免死锁</strong>。 </p>
<ul>
<li><strong><code>ReentrantLock</code> 、<code>ReentrantReadWriteLock</code> 是可重入锁</strong>。这点，从其命名也不难看出。</li>
<li><strong><code>synchronized</code> 也是一个可重入锁</strong>。</li>
</ul>
<p>【示例】<code>synchronized</code> 的可重入示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncLockDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setA</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.out.println(<span class="hljs-string">&quot;锁A&quot;</span>);<br>        setB();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setB</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;锁B&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码就是一个典型场景：如果使用的锁不是可重入锁的话，<code>setB</code> 可能不会被当前线程执行，从而造成死锁。</p>
<p>【示例】<code>ReentrantLock</code> 的可重入示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLockDemo</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLockDemo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.value = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//获取锁</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//释放锁保证</span><br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addOne</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//获取锁</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 注意：此处已经成功获取锁，进入 get 方法后，又尝试获取锁，</span><br>            <span class="hljs-comment">// 如果锁不是可重入的，会导致死锁</span><br>            value = <span class="hljs-number">1</span> + getValue();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="1-2-公平锁与非公平锁"><a href="#1-2-公平锁与非公平锁" class="headerlink" title="1.2. 公平锁与非公平锁"></a>1.2. 公平锁与非公平锁</h3><ul>
<li><strong>公平锁</strong> - 公平锁是指 <strong>多线程按照申请锁的顺序来获取锁</strong>。</li>
<li><strong>非公平锁</strong> - 非公平锁是指 <strong>多线程不按照申请锁的顺序来获取锁</strong> 。这就可能会出现优先级反转（后来者居上）或者饥饿现象（某线程总是抢不过别的线程，导致始终无法执行）。</li>
</ul>
<p>公平锁为了保证线程申请顺序，势必要付出一定的性能代价，因此其吞吐量一般低于非公平锁。</p>
<p>公平锁与非公平锁 在 Java 中的典型实现：</p>
<ul>
<li><strong><code>synchronized</code> 只支持非公平锁</strong>。</li>
<li><strong><code>ReentrantLock</code> 、<code>ReentrantReadWriteLock</code>，默认是非公平锁，但支持公平锁</strong>。</li>
</ul>
<h3 id="1-3-独享锁与共享锁"><a href="#1-3-独享锁与共享锁" class="headerlink" title="1.3. 独享锁与共享锁"></a>1.3. 独享锁与共享锁</h3><p>独享锁与共享锁是一种广义上的说法，从实际用途上来看，也常被称为互斥锁与读写锁。</p>
<ul>
<li><strong>独享锁</strong> - 独享锁是指<strong>锁一次只能被一个线程所持有</strong>。</li>
<li><strong>共享锁</strong> - 共享锁是指 <strong>锁可被多个线程所持有</strong>。</li>
</ul>
<p>独享锁与共享锁在 Java 中的典型实现：</p>
<ul>
<li><strong><code>synchronized</code> 、<code>ReentrantLock</code> 只支持独享锁</strong>。</li>
<li><strong><code>ReentrantReadWriteLock</code> 其写锁是独享锁，其读锁是共享锁</strong>。读锁是共享锁使得并发读是非常高效的，读写，写读 ，写写的过程是互斥的。</li>
</ul>
<h3 id="1-4-悲观锁与乐观锁"><a href="#1-4-悲观锁与乐观锁" class="headerlink" title="1.4. 悲观锁与乐观锁"></a>1.4. 悲观锁与乐观锁</h3><p>乐观锁与悲观锁不是指具体的什么类型的锁，而是<strong>处理并发同步的策略</strong>。</p>
<ul>
<li><strong>悲观锁</strong> - 悲观锁对于并发采取悲观的态度，认为：<strong>不加锁的并发操作一定会出问题</strong>。<strong>悲观锁适合写操作频繁的场景</strong>。</li>
<li><strong>乐观锁</strong> - 乐观锁对于并发采取乐观的态度，认为：<strong>不加锁的并发操作也没什么问题。对于同一个数据的并发操作，是不会发生修改的</strong>。在更新数据的时候，会采用不断尝试更新的方式更新数据。<strong>乐观锁适合读多写少的场景</strong>。</li>
</ul>
<p>悲观锁与乐观锁在 Java 中的典型实现：</p>
<ul>
<li>悲观锁在 Java 中的应用就是通过使用 <code>synchronized</code> 和 <code>Lock</code> 显示加锁来进行互斥同步，这是一种阻塞同步。</li>
<li>乐观锁在 Java 中的应用就是采用 <code>CAS</code> 机制（<code>CAS</code> 操作通过 <code>Unsafe</code> 类提供，但这个类不直接暴露为 API，所以都是间接使用，如各种原子类）。</li>
</ul>
<h3 id="1-5-偏向锁、轻量级锁、重量级锁"><a href="#1-5-偏向锁、轻量级锁、重量级锁" class="headerlink" title="1.5. 偏向锁、轻量级锁、重量级锁"></a>1.5. 偏向锁、轻量级锁、重量级锁</h3><p>所谓轻量级锁与重量级锁，指的是锁控制粒度的粗细。显然，控制粒度越细，阻塞开销越小，并发性也就越高。</p>
<p>Java 1.6 以前，重量级锁一般指的是 <code>synchronized</code> ，而轻量级锁指的是 <code>volatile</code>。</p>
<p>Java 1.6 以后，针对 <code>synchronized</code> 做了大量优化，引入 4 种锁状态：无锁状态、偏向锁、轻量级锁和重量级锁。锁可以单向的从偏向锁升级到轻量级锁，再从轻量级锁升级到重量级锁 。</p>
<ul>
<li><strong>偏向锁</strong> - 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</li>
<li><strong>轻量级锁</strong> - 是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</li>
<li><strong>重量级锁</strong> - 是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</li>
</ul>
<h3 id="1-6-分段锁"><a href="#1-6-分段锁" class="headerlink" title="1.6. 分段锁"></a>1.6. 分段锁</h3><p>分段锁其实是一种锁的设计，并不是具体的一种锁。所谓分段锁，就是把锁的对象分成多段，每段独立控制，使得锁粒度更细，减少阻塞开销，从而提高并发性。这其实很好理解，就像高速公路上的收费站，如果只有一个收费口，那所有的车只能排成一条队缴费；如果有多个收费口，就可以分流了。</p>
<p><code>Hashtable</code> 使用 <code>synchronized</code> 修饰方法来保证线程安全性，那么面对线程的访问，Hashtable 就会锁住整个对象，所有的其它线程只能等待，这种阻塞方式的吞吐量显然很低。</p>
<p>Java 1.7 以前的 <code>ConcurrentHashMap</code> 就是分段锁的典型案例。<code>ConcurrentHashMap</code> 维护了一个 <code>Segment</code> 数组，一般称为分段桶。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments;<br></code></pre></td></tr></table></figure>

<p>当有线程访问 <code>ConcurrentHashMap</code> 的数据时，<code>ConcurrentHashMap</code> 会先根据 hashCode 计算出数据在哪个桶（即哪个 Segment），然后锁住这个 <code>Segment</code>。</p>
<h3 id="1-7-显示锁和内置锁"><a href="#1-7-显示锁和内置锁" class="headerlink" title="1.7. 显示锁和内置锁"></a>1.7. 显示锁和内置锁</h3><p>Java 1.5 之前，协调对共享对象的访问时可以使用的机制只有 <code>synchronized</code> 和 <code>volatile</code>。这两个都属于内置锁，即锁的申请和释放都是由 JVM 所控制。</p>
<p>Java 1.5 之后，增加了新的机制：<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code> ，这类锁的申请和释放都可以由程序所控制，所以常被称为显示锁。</p>
<p><code>synchronized</code> 的用法和原理可以参考：<a href="https://pudewu.github.io/2022/04/25/Java%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/">Java并发核心机制-synchronized关键字</a></p>
<p>注意：如果不需要 <code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code> 所提供的高级同步特性，<strong>应该优先考虑使用 <code>synchronized</code></strong> 。理由如下：</p>
<ul>
<li><p>Java 1.6 以后，<code>synchronized</code> 做了大量的优化，其性能已经与 <code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code> 基本上持平。</p>
</li>
<li><p>从趋势来看，Java 未来更可能会优化 <code>synchronized</code> ，而不是 <code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code> ，因为 <code>synchronized</code> 是 JVM 内置属性，它能执行一些优化。</p>
</li>
<li><p><code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code> 申请和释放锁都是由程序控制，如果使用不当，可能造成死锁，这是很危险的。</p>
</li>
</ul>
<p>以下对比一下显示锁和内置锁的差异：</p>
<ul>
<li><strong>主动获取锁和释放锁</strong><ul>
<li><code>synchronized</code> 不能主动获取锁和释放锁。获取锁和释放锁都是 JVM 控制的。</li>
<li><code>ReentrantLock</code> 可以主动获取锁和释放锁。（如果忘记释放锁，就可能产生死锁）。</li>
</ul>
</li>
<li><strong>响应中断</strong><ul>
<li><code>synchronized</code> 不能响应中断。</li>
<li><code>ReentrantLock</code> 可以响应中断。</li>
</ul>
</li>
<li><strong>超时机制</strong><ul>
<li><code>synchronized</code> 没有超时机制。</li>
<li><code>ReentrantLock</code> 有超时机制。<code>ReentrantLock</code> 可以设置超时时间，超时后自动释放锁，避免一直等待。</li>
</ul>
</li>
<li><strong>支持公平锁</strong> <ul>
<li><code>synchronized</code> 只支持非公平锁。</li>
<li><code>ReentrantLock</code> 支持非公平锁和公平锁。</li>
</ul>
</li>
<li> <strong>是否支持共享</strong> </li>
<li>被 <code>synchronized</code> 修饰的方法或代码块，只能被一个线程访问（独享）。如果这个线程被阻塞，其他线程也只能等待</li>
<li><code>ReentrantLock</code> 可以基于 <code>Condition</code> 灵活的控制同步条件。</li>
<li><strong>是否支持读写分离</strong><ul>
<li><code>synchronized</code> 不支持读写锁分离；</li>
<li><code>ReentrantReadWriteLock</code> 支持读写锁，从而使阻塞读写的操作分开，有效提高并发性。</li>
</ul>
</li>
</ul>
<h2 id="2-Lock-和-Condition"><a href="#2-Lock-和-Condition" class="headerlink" title="2. Lock 和 Condition"></a>2. Lock 和 Condition</h2><h3 id="2-1-为何引入-Lock-和-Condition"><a href="#2-1-为何引入-Lock-和-Condition" class="headerlink" title="2.1. 为何引入 Lock 和 Condition"></a>2.1. 为何引入 Lock 和 Condition</h3><p>并发编程领域，有两大核心问题：一个是<strong>互斥</strong>，即同一时刻只允许一个线程访问共享资源；另一个是<strong>同步</strong>，即线程之间如何通信、协作。这两大问题，管程都是能够解决的。 <strong>Java SDK 并发包通过 Lock 和 Condition 两个接口来实现管程，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题</strong>。  </p>
<p>synchronized 是管程的一种实现，既然如此，何必再提供 Lock 和 Condition。 </p>
<p>JDK 1.6 以前，synchronized 还没有做优化，性能远低于 Lock。但是，性能不是引入 Lock 的最重要因素。真正关键在于：synchronized 使用不当，可能会出现死锁。 </p>
<p>synchronized 无法通过<strong>破坏不可抢占条件</strong>来避免死锁。原因是 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。 </p>
<p>与内置锁 <code>synchronized</code> 不同的是，**<code>Lock</code> 提供了一组无条件的、可轮询的、定时的以及可中断的锁操作**，所有获取锁、释放锁的操作都是显式的操作。 </p>
<p><strong>Lock优势:</strong></p>
<ul>
<li><strong>能够响应中断</strong>。synchronized 的问题是，持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，一旦发生死锁，就没有任何机会来唤醒阻塞的线程。但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有机会释放曾经持有的锁 A。这样就破坏了不可抢占条件了。 </li>
<li> <strong>支持超时</strong>。  如果线程在一段时间之内没有获取到锁 , 不是进入阻塞状态， 而是返回一个错误，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。 </li>
<li> <strong>非阻塞地获取锁</strong>。  如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。 </li>
</ul>
<h3 id="2-2-Lock-接口"><a href="#2-2-Lock-接口" class="headerlink" title="2.2. Lock 接口"></a>2.2. Lock 接口</h3><p><code>Lock</code> 的接口定义如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Lock</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>lock()</code> - 获取锁。</li>
<li><code>unlock()</code> - 释放锁。</li>
<li><code>tryLock()</code> - 尝试获取锁，仅在调用时锁未被另一个线程持有的情况下，才获取该锁。</li>
<li><code>tryLock(long time, TimeUnit unit)</code> - 和 <code>tryLock()</code> 类似，区别仅在于限定时间，如果限定时间内未获取到锁，视为失败。</li>
<li><code>lockInterruptibly()</code> - 锁未被另一个线程持有，且线程没有被中断的情况下，才能获取锁。</li>
<li><code>newCondition()</code> - 返回一个绑定到 <code>Lock</code> 对象上的 <code>Condition</code> 实例。</li>
</ul>
<h3 id="2-3-Condition"><a href="#2-3-Condition" class="headerlink" title="2.3. Condition"></a>2.3. Condition</h3><p><strong>Condition 实现了管程模型里面的条件变量</strong>。 </p>
<p>前文中提过 <code>Lock</code> 接口中 有一个 <code>newCondition()</code> 方法用于返回一个绑定到 <code>Lock</code> 对象上的 <code>Condition</code> 实例。<code>Condition</code> 是什么？有什么作用？本节将一一讲解。 </p>
<p>在单线程中，一段代码的执行可能依赖于某个状态，如果不满足状态条件，代码就不会被执行（典型的场景，如：<code>if ... else ...</code>）。在并发环境中，当一个线程判断某个状态条件时，其状态可能是由于其他线程的操作而改变，这时就需要有一定的协调机制来确保在同一时刻，数据只能被一个线程锁修改，且修改的数据状态被所有线程所感知。   </p>
<p>Java 1.5 之前，主要是利用 <code>Object</code> 类中的 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 配合 <code>synchronized</code> 来进行线程间通信 。</p>
<p><code>wait</code>、<code>notify</code>、<code>notifyAll</code> 需要配合 <code>synchronized</code> 使用，不适用于 <code>Lock</code>。而使用 <code>Lock</code> 的线程，彼此间通信应该使用 <code>Condition</code> 。这可以理解为，什么样的锁配什么样的钥匙。<strong>内置锁（<code>synchronized</code>）配合内置条件队列（<code>wait</code>、<code>notify</code>、<code>notifyAll</code> ），显式锁（<code>Lock</code>）配合显式条件队列（<code>Condition</code> ）</strong>。 </p>
<h4 id="2-3-1-Condition-的特性"><a href="#2-3-1-Condition-的特性" class="headerlink" title="2.3.1 Condition 的特性"></a>2.3.1 Condition 的特性</h4><p><code>Condition</code> 接口定义如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Condition</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">awaitNanos</span><span class="hljs-params">(<span class="hljs-keyword">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signalAll</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中，<code>await</code>、<code>signal</code>、<code>signalAll</code> 与 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 相对应，功能也相似。除此以外，<code>Condition</code> 相比内置条件队列（ <code>wait</code>、<code>notify</code>、<code>notifyAll</code> ），提供了更为丰富的功能： </p>
<ul>
<li>每个锁（<code>Lock</code>）上可以存在多个 <code>Condition</code>，这意味着锁的状态条件可以有多个。</li>
<li>支持公平的或非公平的队列操作。</li>
<li>支持可中断的条件等待，相关方法：<code>awaitUninterruptibly()</code> 。</li>
<li>支持可定时的等待，相关方法：<code>awaitNanos(long)</code> 、<code>await(long, TimeUnit)</code>、<code>awaitUntil(Date)</code>。</li>
</ul>
<h4 id="2-3-2-Condition-的用法"><a href="#2-3-2-Condition-的用法" class="headerlink" title="2.3.2 Condition 的用法"></a>2.3.2 Condition 的用法</h4><p>这里以 <code>Condition</code> 来实现一个消费者、生产者模式。 </p>
<blockquote>
<p>注意：事实上，解决此类问题使用 <code>CountDownLatch</code>、<code>Semaphore</code> 等工具更为便捷、安全。 </p>
</blockquote>
<p>产品类 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition productMsg = lock.newCondition();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition consumerMsg = lock.newCondition();<br><br>    <span class="hljs-keyword">private</span> String message;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> state;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> end;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//lock</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (!state) &#123;<br>                productMsg.await();<br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;consume message : &quot;</span> + message);<br>            state = <span class="hljs-keyword">false</span>;<br><br>            consumerMsg.signal();<br><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Thread interrupted - viewMessage&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (state) &#123;<br><br>                consumerMsg.await();<br><br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;produce msg: &quot;</span> + message);<br>            <span class="hljs-keyword">this</span>.message = message;<br>            state = <span class="hljs-keyword">true</span>;<br>            productMsg.signal();<br><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Thread interrupted - publishMessage&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnd</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> end;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEnd</span> <span class="hljs-params">(<span class="hljs-keyword">boolean</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.end = end;<br>    &#125;<br><br><br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p> 消费者 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br><br>    <span class="hljs-keyword">private</span> Message message;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageConsumer</span><span class="hljs-params">(Message message)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.message = message;<br>    &#125;<br><br><br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span> (!message.isEnd()) &#123;<br>            message.consume();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br><br>    <span class="hljs-keyword">private</span> Message message;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageProducer</span><span class="hljs-params">(Message message)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.message = message;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        produce();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;String&gt; mesgs = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        mesgs.add(<span class="hljs-string">&quot;Beigin&quot;</span>);<br>        mesgs.add(<span class="hljs-string">&quot;Msg1&quot;</span>);<br>        mesgs.add(<span class="hljs-string">&quot;Msg2&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (String mesg : mesgs) &#123;<br>            message.produce(mesg);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br><br>        &#125;<br>        message.produce(<span class="hljs-string">&quot;End&quot;</span>);<br>        message.setEnd(<span class="hljs-keyword">true</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockConditionDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Message msg = <span class="hljs-keyword">new</span> Message();<br>        Thread producer = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MessageProducer(msg));<br>        Thread consumer = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MessageConsumer(msg));<br>        producer.start();<br>        consumer.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-ReentrantLock"><a href="#3-ReentrantLock" class="headerlink" title="3. ReentrantLock"></a>3. ReentrantLock</h2><p><code>ReentrantLock</code> 类是 <code>Lock</code> 接口的具体实现，与内置锁 <code>synchronized</code> 相同的是，它是一个<strong>可重入锁</strong>。 </p>
<h3 id="3-1-ReentrantLock-的特性"><a href="#3-1-ReentrantLock-的特性" class="headerlink" title="3.1. ReentrantLock 的特性"></a>3.1. ReentrantLock 的特性</h3><p><code>ReentrantLock</code> 的特性如下:</p>
<ul>
<li> <strong><code>ReentrantLock</code></strong> 提供了与 <strong><code>synchronized</code> 相同的互斥性、内存可见性和可重入性</strong>。 </li>
<li><code>ReentrantLock</code> <strong>支持公平锁和非公平锁</strong>（默认）两种模式。</li>
<li> <code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，支持了 <code>synchronized</code> 所不具备的<strong>灵活性</strong>。 </li>
<li><code>synchronized</code> 无法中断一个正在等待获取锁的线程</li>
<li><code>synchronized</code> 无法在请求获取一个锁时无休止地等待</li>
</ul>
<h3 id="3-2-ReentrantLock-的用法"><a href="#3-2-ReentrantLock-的用法" class="headerlink" title="3.2. ReentrantLock 的用法"></a>3.2. ReentrantLock 的用法</h3><p> 前文了解了 <code>ReentrantLock</code> 的特性，接下来，我们要讲述其具体用法。 </p>
<p><strong>ReentrantLock 的构造方法</strong></p>
<p><code>ReentrantLock</code> 有两个构造方法 </p>
<ul>
<li><code>ReentrantLock()</code> - 默认构造方法会初始化一个<strong>非公平锁（NonfairSync）</strong>；</li>
<li><code>ReentrantLock(boolean)</code> - <code>new ReentrantLock(true)</code> 会初始化一个<strong>公平锁（FairSync）</strong>。</li>
</ul>
<p><strong>lock 和 unlock 方法</strong></p>
<ul>
<li><code>lock()</code> - <strong>无条件获取锁</strong>。如果当前线程无法获取锁，则当前线程进入休眠状态不可用，直至当前线程获取到锁。如果该锁没有被另一个线程持有，则获取该锁并立即返回，将锁的持有计数设置为 1。</li>
<li><code>unlock()</code> - 用于<strong>释放锁</strong>。</li>
</ul>
<blockquote>
<p>注意：请务必牢记，获取锁操作 <strong><code>lock()</code> 必须在 <code>try catch</code> 块中进行，并且将释放锁操作 <code>unlock()</code> 放在 <code>finally</code> 块中进行，以保证锁一定被被释放，防止死锁的发生</strong>。 </p>
</blockquote>
<p>示例：<code>ReentrantLock</code> 的基本操作 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLockDemo1</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Task task = <span class="hljs-keyword">new</span> Task();<br>        MyThread tA = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;Thread-A&quot;</span>, task);<br>        MyThread tB = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;Thread-B&quot;</span>, task);<br>        MyThread tC = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;Thread-C&quot;</span>, task);<br>        tA.start();<br>        tB.start();<br>        tC.start();<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> Task task;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name,Task task)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(name);<br>            <span class="hljs-keyword">this</span>.task = task;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            task.excute();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">excute</span> <span class="hljs-params">()</span> </span>&#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>                    System.out.println(lock.toString());<br>                    <span class="hljs-comment">// 查询当前线程 hold 住此锁的次数</span><br>                    System.out.println(<span class="hljs-string">&quot;\t holdCount: &quot;</span> + lock.getHoldCount());<br><br>                    <span class="hljs-comment">// 查询正等待获取此锁的线程数</span><br>                    System.out.println(<span class="hljs-string">&quot;\t queuedLength: &quot;</span> + lock.getQueueLength());<br><br>                    <span class="hljs-comment">// 是否为公平锁</span><br>                    System.out.println(<span class="hljs-string">&quot;\t isFair: &quot;</span> + lock.isFair());<br><br>                    <span class="hljs-comment">// 是否被锁住</span><br>                    System.out.println(<span class="hljs-string">&quot;\t isLocked: &quot;</span> + lock.isLocked());<br><br>                    <span class="hljs-comment">// 是否被当前线程持有锁</span><br>                    System.out.println(<span class="hljs-string">&quot;\t isHeldByCurrentThread: &quot;</span> + lock.isHeldByCurrentThread());<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">500</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">java.util.concurrent.locks.ReentrantLock@45f342d8[Locked by thread Thread-A]<br>	 holdCount: <span class="hljs-number">1</span><br>	 queuedLength: <span class="hljs-number">2</span><br>	 isFair: <span class="hljs-keyword">false</span><br>	 isLocked: <span class="hljs-keyword">true</span><br>	 isHeldByCurrentThread: <span class="hljs-keyword">true</span><br>java.util.concurrent.locks.ReentrantLock@45f342d8[Locked by thread Thread-A]<br>	 holdCount: <span class="hljs-number">1</span><br>	 queuedLength: <span class="hljs-number">2</span><br>	 isFair: <span class="hljs-keyword">false</span><br>	 isLocked: <span class="hljs-keyword">true</span><br>	 isHeldByCurrentThread: <span class="hljs-keyword">true</span><br>.....<br></code></pre></td></tr></table></figure>



<p><strong>tryLock 方法</strong></p>
<p>与无条件获取锁相比，tryLock 有更完善的容错机制。 </p>
<ul>
<li><code>tryLock()</code> - <strong>可轮询获取锁</strong>。如果成功，则返回 true；如果失败，则返回 false。也就是说，这个方法<strong>无论成败都会立即返回</strong>，获取不到锁（锁已被其他线程获取）时不会一直等待。</li>
<li><code>tryLock(long, TimeUnit)</code> - <strong>可定时获取锁</strong>。和 <code>tryLock()</code> 类似，区别仅在于这个方法在<strong>获取不到锁时会等待一定的时间</strong>，在时间期限之内如果还获取不到锁，就返回 false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回 true。</li>
</ul>
<p>示例：<code>ReentrantLock</code> 的 <code>tryLock()</code> 操作 </p>
<p>修改上个示例中的 <code>execute()</code> 方法 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (lock.tryLock()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>               <span class="hljs-comment">// 略...</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取锁失败&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>示例：<code>ReentrantLock</code> 的 <code>tryLock(long, TimeUnit)</code> 操作 </p>
<p>修改上个示例中的 <code>execute()</code> 方法 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (lock.tryLock(<span class="hljs-number">2</span>, TimeUnit.SECONDS)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>                    <span class="hljs-comment">// 略...</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取锁失败&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取锁超时&quot;</span>);<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>lockInterruptibly 方法</strong></p>
<ul>
<li><code>lockInterruptibly()</code> - <strong>可中断获取锁</strong>。可中断获取锁可以在获得锁的同时保持对中断的响应。可中断获取锁比其它获取锁的方式稍微复杂一些，需要两个 <code>try-catch</code> 块（如果在获取锁的操作中抛出了 <code>InterruptedException</code> ，那么可以使用标准的 <code>try-finally</code> 加锁模式）。 <ul>
<li>举例来说：假设有两个线程同时通过 <code>lock.lockInterruptibly()</code> 获取某个锁时，若线程 A 获取到了锁，则线程 B 只能等待。若此时对线程 B 调用 <code>threadB.interrupt()</code> 方法能够中断线程 B 的等待过程。由于 <code>lockInterruptibly()</code> 的声明中抛出了异常，所以 <code>lock.lockInterruptibly()</code> 必须放在 <code>try</code> 块中或者在调用 <code>lockInterruptibly()</code> 的方法外声明抛出 <code>InterruptedException</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p> 🔔 注意：当一个线程获取了锁之后，是不会被 <code>interrupt()</code> 方法中断的。单独调用 <code>interrupt()</code> 方法不能中断正在运行状态中的线程，只能中断阻塞状态中的线程。因此当通过 <code>lockInterruptibly()</code> 方法获取某个锁时，如果未获取到锁，只有在等待的状态下，才可以响应中断。 </p>
</blockquote>
<p>示例：<code>ReentrantLock</code> 的 <code>lockInterruptibly()</code> 操作 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        lock.lockInterruptibly();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-comment">// 略...</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;被中断&quot;</span>);<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>newCondition 方法</strong></p>
<p><code>newCondition()</code> - 返回一个绑定到 <code>Lock</code> 对象上的 <code>Condition</code> 实例。</p>
<h3 id="3-3-ReentrantLock-的原理"><a href="#3-3-ReentrantLock-的原理" class="headerlink" title="3.3. ReentrantLock 的原理"></a>3.3. ReentrantLock 的原理</h3><p><strong>ReentrantLock 的可见性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock rtl = <span class="hljs-keyword">new</span> ReentrantLock();<br>  <span class="hljs-keyword">int</span> value;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addOne</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 获取锁</span><br>    rtl.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      value+=<span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">// 保证锁能释放</span><br>      rtl.unlock();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ReentrantLock，内部持有一个 volatile 的成员变量 state，获取锁的时候，会读写 state 的值；解锁的时候，也会读写 state 的值（简化后的代码如下面所示）。也就是说，在执行 value+=1 之前，程序先读写了一次 volatile 变量 state，在执行 value+=1 之后，又读写了一次 volatile 变量 state。根据相关的 Happens-Before 规则：  </p>
<ol>
<li><strong>顺序性规则</strong>：对于线程 T1，value+=1 Happens-Before 释放锁的操作 unlock()；</li>
<li><strong>volatile 变量规则</strong>：由于 state = 1 会先读取 state，所以线程 T1 的 unlock() 操作 Happens-Before 线程 T2 的 lock() 操作；</li>
<li><strong>传递性规则</strong>：线程 T1 的 value+=1 Happens-Before 线程 T2 的 lock() 操作。</li>
</ol>
<p><strong>ReentrantLock 的数据结构</strong></p>
<p>阅读 <code>ReentrantLock</code> 的源码，可以发现它有一个核心字段： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>sync</code> - 内部抽象类 <code>ReentrantLock.Sync</code> 对象，<code>Sync</code> 继承自 AQS。它有两个子类：</li>
<li><code>ReentrantLock.FairSync</code> - 公平锁。</li>
<li><code>ReentrantLock.NonfairSync</code> - 非公平锁。</li>
</ul>
<p>查看源码可以发现，<code>ReentrantLock</code> 实现 <code>Lock</code> 接口其实是调用 <code>ReentrantLock.FairSync</code> 或 <code>ReentrantLock.NonfairSync</code> 中各自的实现。 </p>
<p><strong>ReentrantLock 的获取锁和释放锁</strong></p>
<p>ReentrantLock 获取锁和释放锁的接口，从表象看，是调用 <code>ReentrantLock.FairSync</code> 或 <code>ReentrantLock.NonfairSync</code> 中各自的实现；从本质上看，是基于 AQS 的实现。 </p>
<p>仔细阅读源码很容易发现： </p>
<ul>
<li><p><code>void lock()</code> 调用 Sync 的 lock() 方法。</p>
</li>
<li><p><code>void lockInterruptibly()</code> 直接调用 AQS 的 <strong>获取可中断的独占锁</strong>方法 <code>lockInterruptibly()</code>。</p>
</li>
<li><p><code>boolean tryLock()</code> 调用 Sync 的 <code>nonfairTryAcquire()</code> 。</p>
</li>
<li><p><code>boolean tryLock(long time, TimeUnit unit)</code> 直接调用 AQS 的 <strong>获取超时等待式的独占锁</strong>方法 <code>tryAcquireNanos(int arg, long nanosTimeout)</code>。</p>
</li>
<li><p><code>void unlock()</code> 直接调用 AQS 的 <strong>释放独占锁</strong> 方法 <code>release(int arg)</code> 。</p>
</li>
</ul>
<p>直接调用 AQS 接口的方法就不再赘述了，其原理将在下面章节讲解。</p>
<p><code>nonfairTryAcquire</code> 方法源码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 公平锁和非公平锁都会用这个方法区尝试获取锁</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>    <span class="hljs-keyword">int</span> c = getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>         <span class="hljs-comment">// 如果同步状态为0，将其设为 acquires，并设置当前线程为排它线程</span><br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-keyword">int</span> nextc = c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>处理流程很简单：</p>
<ul>
<li>如果同步状态为 0，设置同步状态设为 acquires，并设置当前线程为排它线程，然后返回 true，获取锁成功。</li>
<li>如果同步状态不为 0 且当前线程为排它线程，设置同步状态为当前状态值+acquires 值，然后返回 true，获取锁成功。</li>
<li>否则，返回 false，获取锁失败。</li>
</ul>
<p><strong>公平锁和非公平锁</strong></p>
<p>ReentrantLock 这个类有两个构造函数，一个是无参构造函数，一个是传入 fair 参数的构造函数。fair 参数代表的是锁的公平策略，如果传入 true 就表示需要构造一个公平锁，反之则表示要构造一个非公平锁。 </p>
<p>锁都对应着一个等待队列，如果一个线程没有获得锁，就会进入等待队列，当有线程释放锁的时候，就需要从等待队列中唤醒一个等待的线程。如果是公平锁，唤醒的策略就是谁等待的时间长，就唤醒谁，很公平；如果是非公平锁，则不提供这个公平保证，有可能等待时间短的线程反而先被唤醒。 </p>
<p>lock 方法在公平锁和非公平锁中的实现： </p>
<p>二者的区别仅在于申请非公平锁时，如果同步状态为 0，尝试将其设为 1，如果成功，直接将当前线程置为排它线程；否则和公平锁一样，调用 AQS 获取独占锁方法 <code>acquire</code>。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 非公平锁实现</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>    <span class="hljs-comment">// 如果同步状态为0，将其设为1，并设置当前线程为排它线程</span><br>        setExclusiveOwnerThread(Thread.currentThread());<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-comment">// 调用 AQS 获取独占锁方法 acquire</span><br>        acquire(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 公平锁实现</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用 AQS 获取独占锁方法 acquire</span><br>    acquire(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-ReentrantReadWriteLock"><a href="#4-ReentrantReadWriteLock" class="headerlink" title="4. ReentrantReadWriteLock"></a>4. ReentrantReadWriteLock</h2><p><code>ReadWriteLock</code> 适用于<strong>读多写少的场景</strong>。 </p>
<p><code>ReentrantReadWriteLock</code> 类是 <code>ReadWriteLock</code> 接口的具体实现，它是一个可重入的读写锁。 </p>
<p><code>ReentrantReadWriteLock</code> 维护了一对读写锁，将读写锁分开，有利于提高并发效率。 </p>
<p>读写锁，并不是 Java 语言特有的，而是一个广为使用的通用技术，所有的读写锁都遵守以下三条基本原则： </p>
<ul>
<li>允许多个线程同时读共享变量；</li>
<li>只允许一个线程写共享变量；</li>
<li>如果一个写线程正在执行写操作，此时禁止读线程读共享变量。</li>
</ul>
<p>读写锁与互斥锁的一个重要区别就是<strong>读写锁允许多个线程同时读共享变量</strong>，而互斥锁是不允许的，这是读写锁在读多写少场景下性能优于互斥锁的关键。但<strong>读写锁的写操作是互斥的</strong>，当一个线程在写共享变量的时候，是不允许其他线程执行写操作和读操作。 </p>
<h3 id="4-1-ReentrantReadWriteLock-的特性"><a href="#4-1-ReentrantReadWriteLock-的特性" class="headerlink" title="4.1. ReentrantReadWriteLock 的特性"></a>4.1. ReentrantReadWriteLock 的特性</h3><p>ReentrantReadWriteLock 的特性如下： </p>
<ul>
<li><strong><code>ReentrantReadWriteLock</code> 适用于读多写少的场景</strong>。如果是写多读少的场景，由于 <code>ReentrantReadWriteLock</code> 其内部实现比 <code>ReentrantLock</code> 复杂，性能可能反而要差一些。如果存在这样的问题，需要具体问题具体分析。由于 <code>ReentrantReadWriteLock</code> 的读写锁（<code>ReadLock</code>、<code>WriteLock</code>）都实现了 <code>Lock</code> 接口，所以要替换为 <code>ReentrantLock</code> 也较为容易。</li>
<li><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> 接口，支持了 <code>ReentrantLock</code> 所不具备的读写锁分离。<code>ReentrantReadWriteLock</code> 维护了一对读写锁（<code>ReadLock</code>、<code>WriteLock</code>）。将读写锁分开，有利于提高并发效率。<code>ReentrantReadWriteLock</code> 的加锁策略是：<strong>允许多个读操作并发执行，但每次只允许一个写操作</strong>。</li>
<li><code>ReentrantReadWriteLock</code> 为读写锁都提供了可重入的加锁语义。</li>
<li><code>ReentrantReadWriteLock</code> 支持公平锁和非公平锁（默认）两种模式。</li>
</ul>
<p> <code>ReadWriteLock</code> 接口定义如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReadWriteLock</span> </span>&#123;<br>    <span class="hljs-function">Lock <span class="hljs-title">readLock</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Lock <span class="hljs-title">writeLock</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>readLock</code> - 返回用于读操作的锁（<code>ReadLock</code>）。</li>
<li><code>writeLock</code> - 返回用于写操作的锁（<code>WriteLock</code>）。</li>
</ul>
<p>在读写锁和写入锁之间的交互可以采用多种实现方式，<code>ReadWriteLock</code> 的一些可选实现包括： </p>
<ul>
<li><strong>释放优先</strong> - 当一个写入操作释放写锁，并且队列中同时存在读线程和写线程，那么应该优先选择读线程、写线程，还是最先发出请求的线程？</li>
<li><strong>读线程插队</strong> - 如果锁是由读线程持有，但有写线程正在等待，那么新到达的读线程能否立即获得访问权，还是应该在写线程后面等待？如果允许读线程插队到写线程之前，那么将提高并发性，但可能造成线程饥饿问题。</li>
<li><strong>重入性</strong> - 读锁和写锁是否是可重入的？</li>
<li><strong>降级</strong> - 如果一个线程持有写入锁，那么它能否在不释放该锁的情况下获得读锁？这可能会使得写锁被降级为读锁，同时不允许其他写线程修改被保护的资源。</li>
<li><strong>升级</strong> - 读锁能否优先于其他正在等待的读线程和写线程而升级为一个写锁？在大多数的读写锁实现中并不支持升级，因为如果没有显式的升级操作，那么很容易造成死锁。</li>
</ul>
<h3 id="4-2-ReentrantReadWriteLock-的用法"><a href="#4-2-ReentrantReadWriteLock-的用法" class="headerlink" title="4.2. ReentrantReadWriteLock 的用法"></a>4.2. ReentrantReadWriteLock 的用法</h3><p><strong>ReentrantReadWriteLock 的构造方法</strong></p>
<p><code>ReentrantReadWriteLock</code> 和 <code>ReentrantLock</code> 一样，也有两个构造方法，且用法相似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantReadWriteLock</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantReadWriteLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>ReentrantReadWriteLock()</code> - 默认构造方法会初始化一个<strong>非公平锁（NonfairSync）</strong>。在非公平的锁中，线程获得锁的顺序是不确定的。写线程降级为读线程是可以的，但读线程升级为写线程是不可以的（这样会导致死锁）。</li>
<li><code>ReentrantReadWriteLock(boolean)</code> - <code>new ReentrantLock(true)</code> 会初始化一个<strong>公平锁（FairSync）</strong>。对于公平锁，等待时间最长的线程将优先获得锁。如果这个锁是读线程持有，则另一个线程请求写锁，那么其他读线程都不能获得读锁，直到写线程释放写锁。</li>
</ul>
<p><strong>ReentrantReadWriteLock 的使用实例</strong></p>
<p><code>ReentrantReadWriteLock</code> 的读写锁（<code>ReadLock</code>、<code>WriteLock</code>）都实现了 <code>Lock</code> 接口，所以其各自独立的使用方式与 <code>ReentrantLock</code> 一样.</p>
<p><code>ReentrantReadWriteLock</code> 与 <code>ReentrantLock</code> 用法上的差异，主要在于读写锁的配合使用。本文以一个典型使用场景来进行讲解。</p>
<p>【示例】基于 <code>ReadWriteLock</code> 实现一个简单的泛型无界缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnboundedCache</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K, V&gt; cacheMap = <span class="hljs-keyword">new</span> WeakHashMap&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReadWriteLock cacheLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(K key)</span> </span>&#123;<br>        cacheLock.readLock().lock();<br>        V value;<br>        <span class="hljs-keyword">try</span> &#123;<br>            value = cacheMap.get(key);<br>            String log = String.format(<span class="hljs-string">&quot;%s 读数据 %s:%s&quot;</span>, Thread.currentThread().getName(), key, value);<br>            System.out.println(log);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            cacheLock.readLock().unlock();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key,V value)</span> </span>&#123;<br>        cacheLock.writeLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            cacheMap.put(key,value);<br>            String log = String.format(<span class="hljs-string">&quot;%s 写入数据 %s:%s&quot;</span>, Thread.currentThread().getName(), key, value);<br>            System.out.println(log);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            cacheLock.writeLock().unlock();<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(K key)</span> </span>&#123;<br>        cacheLock.writeLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> cacheMap.remove(key);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            cacheLock.writeLock().unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>        cacheLock.writeLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">this</span>.cacheMap.clear();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            cacheLock.writeLock().unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>说明:</p>
<ul>
<li>使用 <code>WeakHashMap</code> 而不是 <code>HashMap</code> 来存储键值对。<code>WeakHashMap</code> 中存储的对象是弱引用，JVM GC 时会自动清除没有被引用的弱引用对象。</li>
<li>向 <code>Map</code> 写数据前加写锁，写完后，释放写锁。</li>
<li>向 <code>Map</code> 读数据前加读锁，读完后，释放读锁。</li>
</ul>
<p>测试其线程安全性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantReadWriteLockDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> UnboundedCache&lt;Integer,Integer&gt; cache = <span class="hljs-keyword">new</span> UnboundedCache();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executorService = Executors.newCachedThreadPool();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            executorService.execute(<span class="hljs-keyword">new</span> MyThread());<br>            cache.get(<span class="hljs-number">0</span>);<br>        &#125;<br>        executorService.shutdown();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-comment">/** 线程任务每次向缓存中写入 3 个随机值，key 固定 */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            Random random = <span class="hljs-keyword">new</span> Random();<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>                cache.put(i,random.nextInt(<span class="hljs-number">100</span>));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>说明：示例中，通过线程池启动 20 个并发任务。任务每次向缓存中写入 3 个随机值，key 固定；然后主线程每次固定读取缓存中第一个 key 的值。</p>
<p>输出结果：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">main 读数据 0:null<br>pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-1</span> 写入数据 0:94<br>pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-1</span> 写入数据 1:24<br>pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-1</span> 写入数据 2:58<br>main 读数据 0:94<br>pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-2</span> 写入数据 0:21<br>pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-2</span> 写入数据 1:54<br>pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-2</span> 写入数据 2:88<br>pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-1</span> 写入数据 0:85<br>pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-1</span> 写入数据 1:5<br>pool<span class="hljs-string">-1</span>-thread<span class="hljs-string">-1</span> 写入数据 2:38<br>main 读数据 0:85<br>main 读数据 0:85<br>...<br></code></pre></td></tr></table></figure>

<h3 id="4-3-ReentrantReadWriteLock-的原理"><a href="#4-3-ReentrantReadWriteLock-的原理" class="headerlink" title="4.3. ReentrantReadWriteLock 的原理"></a>4.3. ReentrantReadWriteLock 的原理</h3><p><strong>ReentrantReadWriteLock 的数据结构</strong></p>
<p>阅读 ReentrantReadWriteLock 的源码，可以发现它有三个核心字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Inner class providing readlock */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;<br><span class="hljs-comment">/** Inner class providing writelock */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;<br><span class="hljs-comment">/** Performs all synchronization mechanics */</span><br><span class="hljs-keyword">final</span> Sync sync;<br><br><span class="hljs-keyword">public</span> ReentrantReadWriteLock.<span class="hljs-function">WriteLock <span class="hljs-title">writeLock</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> writerLock; &#125;<br><span class="hljs-keyword">public</span> ReentrantReadWriteLock.<span class="hljs-function">ReadLock  <span class="hljs-title">readLock</span><span class="hljs-params">()</span>  </span>&#123; <span class="hljs-keyword">return</span> readerLock; &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>sync</code> - 内部类 <code>ReentrantReadWriteLock.Sync</code> 对象。与 <code>ReentrantLock</code> 类似，它有两个子类：<code>ReentrantReadWriteLock.FairSync</code> 和 <code>ReentrantReadWriteLock.NonfairSync</code> ，分别表示公平锁和非公平锁的实现。</li>
<li><code>readerLock</code> - 内部类 <code>ReentrantReadWriteLock.ReadLock</code> 对象，这是一把读锁。</li>
<li><code>writerLock</code> - 内部类 <code>ReentrantReadWriteLock.WriteLock</code> 对象，这是一把写锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">// 调用 AQS 获取共享锁方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.acquireShared(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 调用 AQS 释放共享锁方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.releaseShared(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">// 调用 AQS 获取独占锁方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 调用 AQS 释放独占锁方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-StampedLock"><a href="#5-StampedLock" class="headerlink" title="5. StampedLock"></a>5. StampedLock</h2><p>ReadWriteLock 支持两种模式：一种是读锁，一种是写锁。而 StampedLock 支持三种模式，分别是：<strong>写锁</strong>、<strong>悲观读锁</strong>和<strong>乐观读</strong>。其中，写锁、悲观读锁的语义和 ReadWriteLock 的写锁、读锁的语义非常类似，允许多个线程同时获取悲观读锁，但是只允许一个线程获取写锁，写锁和悲观读锁是互斥的。不同的是：StampedLock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp。 </p>
<blockquote>
<p>注意这里，用的是“乐观读”这个词，而不是“乐观读锁”，是要提醒你，<strong>乐观读这个操作是无锁的</strong>，所以相比较 ReadWriteLock 的读锁，乐观读的性能更好一些。 </p>
</blockquote>
<p>StampedLock 的性能之所以比 ReadWriteLock 还要好，其关键是 <strong>StampedLock 支持乐观读</strong>的方式。 </p>
<ul>
<li>ReadWriteLock 支持多个线程同时读，但是当多个线程同时读的时候，所有的写操作会被阻塞；</li>
<li>而 StampedLock 提供的乐观读，是允许一个线程获取写锁的，也就是说不是所有的写操作都被阻塞。</li>
</ul>
<p>对于读多写少的场景 StampedLock 性能很好，简单的应用场景基本上可以替代 ReadWriteLock，但是<strong>StampedLock 的功能仅仅是 ReadWriteLock 的子集</strong>，在使用的时候，还是有几个地方需要注意一下。 </p>
<ul>
<li><strong>StampedLock 不支持重入</strong></li>
<li>StampedLock 的悲观读锁、写锁都不支持条件变量。</li>
<li>如果线程阻塞在 StampedLock 的 readLock() 或者 writeLock() 上时，此时调用该阻塞线程的 interrupt() 方法，会导致 CPU 飙升。**使用 StampedLock 一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly() 和写锁 writeLockInterruptibly()**。</li>
</ul>
<p> 【示例】StampedLock 阻塞时，调用 interrupt() 导致 CPU 飙升 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> StampedLock lock<br>  = <span class="hljs-keyword">new</span> StampedLock();<br>Thread T1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>  <span class="hljs-comment">// 获取写锁</span><br>  lock.writeLock();<br>  <span class="hljs-comment">// 永远阻塞在此处，不释放写锁</span><br>  LockSupport.park();<br>&#125;);<br>T1.start();<br><span class="hljs-comment">// 保证 T1 获取写锁</span><br>Thread.sleep(<span class="hljs-number">100</span>);<br>Thread T2 = <span class="hljs-keyword">new</span> Thread(()-&gt;<br>  <span class="hljs-comment">// 阻塞在悲观读锁</span><br>  lock.readLock()<br>);<br>T2.start();<br><span class="hljs-comment">// 保证 T2 阻塞在读锁</span><br>Thread.sleep(<span class="hljs-number">100</span>);<br><span class="hljs-comment">// 中断线程 T2</span><br><span class="hljs-comment">// 会导致线程 T2 所在 CPU 飙升</span><br>T2.interrupt();<br>T2.join();<br></code></pre></td></tr></table></figure>

<p> 【示例】StampedLock 读模板： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> StampedLock sl =<br>  <span class="hljs-keyword">new</span> StampedLock();<br><br><span class="hljs-comment">// 乐观读</span><br><span class="hljs-keyword">long</span> stamp =<br>  sl.tryOptimisticRead();<br><span class="hljs-comment">// 读入方法局部变量</span><br>......<br><span class="hljs-comment">// 校验 stamp</span><br><span class="hljs-keyword">if</span> (!sl.validate(stamp))&#123;<br>  <span class="hljs-comment">// 升级为悲观读锁</span><br>  stamp = sl.readLock();<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 读入方法局部变量</span><br>    .....<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 释放悲观读锁</span><br>    sl.unlockRead(stamp);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 使用方法局部变量执行业务操作</span><br>......<br></code></pre></td></tr></table></figure>

<p>【示例】StampedLock 写模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = sl.writeLock();<br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">// 写共享变量</span><br>  ......<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  sl.unlockWrite(stamp);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6-AQS"><a href="#6-AQS" class="headerlink" title="6.AQS"></a>6.AQS</h2><blockquote>
<p><code>AbstractQueuedSynchronizer</code>（简称 <strong>AQS</strong>）是<strong>队列同步器</strong>，顾名思义，其主要作用是处理同步。它是并发锁和很多同步工具类的实现基石（如 <code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code>、<code>FutureTask</code> 等）。 </p>
</blockquote>
<h3 id="6-1-AQS-的要点"><a href="#6-1-AQS-的要点" class="headerlink" title="6.1. AQS 的要点"></a>6.1. AQS 的要点</h3><p><strong>AQS 提供了对独享锁与共享锁的支持</strong>。 </p>
<p>在 <code>java.util.concurrent.locks</code> 包中的相关锁（常用的有 <code>ReentrantLock</code>、 <code>ReadWriteLock</code>）都是基于 AQS 来实现。这些锁都没有直接继承 AQS，而是定义了一个 <code>Sync</code> 类去继承 AQS。为什么要这样呢？因为锁面向的是使用用户，而同步器面向的则是线程控制，那么在锁的实现中聚合同步器而不是直接继承 AQS 就可以很好的隔离二者所关注的事情。 </p>
<h3 id="6-2-AQS-的应用"><a href="#6-2-AQS-的应用" class="headerlink" title="6.2. AQS 的应用"></a>6.2. AQS 的应用</h3><p><strong>AQS 提供了对独享锁与共享锁的支持</strong>。 </p>
<p><strong>独享锁 API</strong></p>
<p>获取、释放独享锁的主要 API 如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquireNanos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg, <span class="hljs-keyword">long</span> nanosTimeout)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>acquire</code> - 获取独占锁。</li>
<li><code>acquireInterruptibly</code> - 获取可中断的独占锁。</li>
<li> <code>tryAcquireNanos</code> - 尝试在指定时间内获取可中断的独占锁。在以下三种情况下回返回： </li>
<li>在超时时间内，当前线程成功获取了锁；</li>
<li>当前线程在超时时间内被中断；</li>
<li>超时时间结束，仍未获得锁返回 false。</li>
<li> <code>release</code> - 释放独占锁.</li>
</ul>
<p><strong>共享锁 API</strong></p>
<p>获取、释放共享锁的主要 API 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquireSharedNanos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg, <span class="hljs-keyword">long</span> nanosTimeout)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>acquireShared</code> - 获取共享锁。</li>
<li><code>acquireSharedInterruptibly</code> - 获取可中断的共享锁。</li>
<li><code>tryAcquireSharedNanos</code> - 尝试在指定时间内获取可中断的共享锁。</li>
<li><code>release</code> - 释放共享锁。</li>
</ul>
<h3 id="6-3-AQS-的原理"><a href="#6-3-AQS-的原理" class="headerlink" title="6.3. AQS 的原理"></a>6.3. AQS 的原理</h3><blockquote>
<p>ASQ 原理要点：</p>
<ul>
<li>AQS 使用一个整型的 <code>volatile</code> 变量来 <strong>维护同步状态</strong>。状态的意义由子类赋予。</li>
<li>AQS 维护了一个 FIFO 的双链表，用来存储获取锁失败的线程。</li>
</ul>
</blockquote>
<p><strong>AQS 的数据结构</strong></p>
<p>阅读 AQS 的源码，可以发现：AQS 继承自 <code>AbstractOwnableSynchronize</code>。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractOwnableSynchronizer</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">/** 等待队列的队头，懒加载。只能通过 setHead 方法修改。 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br>    <span class="hljs-comment">/** 等待队列的队尾，懒加载。只能通过 enq 方法添加新的等待节点。*/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br>    <span class="hljs-comment">/** 同步状态 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>state</code> - AQS 使用一个整型的 <code>volatile</code> 变量来 <strong>维护同步状态</strong>。 <ul>
<li>这个整数状态的意义由子类来赋予，如<code>ReentrantLock</code> 中该状态值表示所有者线程已经重复获取该锁的次数，<code>Semaphore</code> 中该状态值表示剩余的许可数量。</li>
</ul>
</li>
<li><code>head</code> 和 <code>tail</code> - AQS <strong>维护了一个 <code>Node</code> 类型（AQS 的内部类）的双链表来完成同步状态的管理</strong>。这个双链表是一个双向的 FIFO 队列，通过 <code>head</code> 和 <code>tail</code> 指针进行访问。当 <strong>有线程获取锁失败后，就被添加到队列末尾</strong>。</li>
</ul>
<p> <img src="/img/work/aqs_1.png"> </p>
<p>再来看一下 <code>Node</code> 的源码 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-comment">/** 该等待同步的节点处于共享模式 */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();<br>    <span class="hljs-comment">/** 该等待同步的节点处于独占模式 */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">/** 线程等待状态，状态值有: 0、1、-1、-2、-3 */</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">/** 前驱节点 */</span><br>    <span class="hljs-keyword">volatile</span> Node prev;<br>    <span class="hljs-comment">/** 后继节点 */</span><br>    <span class="hljs-keyword">volatile</span> Node next;<br>    <span class="hljs-comment">/** 等待锁的线程 */</span><br>    <span class="hljs-keyword">volatile</span> Thread thread;<br><br>  	<span class="hljs-comment">/** 和节点是否共享有关 */</span><br>    Node nextWaiter;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>很显然，Node 是一个双链表结构。 </p>
<ul>
<li><code>waitStatus</code> - <code>Node</code> 使用一个整型的 <code>volatile</code> 变量来 维护 AQS 同步队列中线程节点的状态。<code>waitStatus</code> 有五个状态值： <ul>
<li><code>CANCELLED(1)</code> - 此状态表示：该节点的线程可能由于超时或被中断而 <strong>处于被取消(作废)状态</strong>，一旦处于这个状态，表示这个节点应该从等待队列中移除。</li>
<li><code>SIGNAL(-1)</code> - 此状态表示：<strong>后继节点会被挂起</strong>，因此在当前节点释放锁或被取消之后，必须唤醒(<code>unparking</code>)其后继结点。</li>
<li><code>CONDITION(-2)</code> - 此状态表示：该节点的线程 <strong>处于等待条件状态</strong>，不会被当作是同步队列上的节点，直到被唤醒(<code>signal</code>)，设置其值为 0，再重新进入阻塞状态。</li>
<li><code>PROPAGATE(-3)</code> - 此状态表示：下一个 <code>acquireShared</code> 应无条件传播。</li>
<li>0 - 非以上状态。</li>
</ul>
</li>
</ul>
<h4 id="6-3-1-独占锁的获取和释放"><a href="#6-3-1-独占锁的获取和释放" class="headerlink" title="6.3.1 独占锁的获取和释放"></a><strong>6.3.1 独占锁的获取和释放</strong></h4><p><strong>获取独占锁</strong></p>
<p>AQS 中使用 <code>acquire(int arg)</code> 方法获取独占锁，其大致流程如下： </p>
<ol>
<li>先尝试获取同步状态，如果获取同步状态成功，则结束方法，直接返回。</li>
<li>如果获取同步状态不成功，AQS 会不断尝试利用 CAS 操作将当前线程插入等待同步队列的队尾，直到成功为止。</li>
<li>接着，不断尝试为等待队列中的线程节点获取独占锁。</li>
</ol>
<p> <img src="/img/work/aqs_2.png"> </p>
<p> <img src="/img/work/aqs_3.png"> </p>
<p>详细流程可以用下图来表示，请结合源码来理解（一图胜千言）：</p>
<p> <img src="/img/work/aqs_4.png"> </p>
<p><strong>释放独占锁</strong></p>
<p>AQS 中使用 <code>release(int arg)</code> 方法释放独占锁，其大致流程如下：</p>
<ol>
<li>先尝试获取解锁线程的同步状态，如果获取同步状态不成功，则结束方法，直接返回。</li>
<li>如果获取同步状态成功，AQS 会尝试唤醒当前线程节点的后继节点。</li>
</ol>
<h3 id="6-4-公平锁和非公平锁区别"><a href="#6-4-公平锁和非公平锁区别" class="headerlink" title="6.4.公平锁和非公平锁区别"></a>6.4.<strong>公平锁和非公平锁区别</strong></h3><ol>
<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。 </p>
<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。 </p>
<p><strong>具体AbstractQueuedSynchronizer源码分析放在后面文章做具体详解</strong></p>
<h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><ul>
<li><a href="https://dunwu.github.io/javacore/concurrent/Java%E9%94%81.html#_1-%E5%B9%B6%E5%8F%91%E9%94%81%E7%AE%80%E4%BB%8B">引自Java并发锁并在此基础上做一些修改</a></li>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2">https://javadoop.com/post/AbstractQueuedSynchronizer-2</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>Java并发锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池</title>
    <url>/2022/06/11/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><h3 id="1-1-什么是线程池"><a href="#1-1-什么是线程池" class="headerlink" title="1.1. 什么是线程池"></a>1.1. 什么是线程池</h3><p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。</p>
<h3 id="1-2-为什么要用线程池"><a href="#1-2-为什么要用线程池" class="headerlink" title="1.2. 为什么要用线程池"></a>1.2. 为什么要用线程池</h3><p>如果并发请求数量很多，但每个线程执行的时间很短，就会出现频繁的创建和销毁线程。如此一来，会大大降低系统的效率，可能频繁创建和销毁线程的时间、资源开销要大于实际工作的所需。</p>
<p>正是由于这个问题，所以有必要引入线程池。使用 <strong>线程池的好处</strong> 有以下几点：</p>
<ul>
<li><strong>降低资源消耗</strong> - 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong> - 当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong> - 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</li>
<li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li>
</ul>
<h3 id="1-3-线程池解决的问题是什么"><a href="#1-3-线程池解决的问题是什么" class="headerlink" title="1.3 线程池解决的问题是什么"></a>1.3 线程池解决的问题是什么</h3><p>线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题： </p>
<ol>
<li>频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li>
<li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li>
<li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li>
</ol>
<p>为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。 </p>
<p>Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia </p>
<p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。 </p>
<p>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括： </p>
<p>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片 </p>
<ol>
<li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li>
<li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。</li>
<li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li>
</ol>
<h2 id="2-线程池总览"><a href="#2-线程池总览" class="headerlink" title="2.线程池总览"></a>2.线程池总览</h2><p>以下是java 线程池几个相关类的继承结构：</p>
<p><img src="/img/work/1.jpg" alt="线程池继承结构"></p>
<p>先简单说说这个继承结构，Executor 位于最顶层，也是最简单的，就一个 execute(Runnable runnable) 接口方法定义。</p>
<p>ExecutorService 也是接口，在 Executor 接口的基础上添加了很多的接口方法，所以<strong>一般来说我们会使用这个接口</strong>。</p>
<p>然后再下来一层是 AbstractExecutorService，从名字我们就知道，这是抽象类，这里实现了非常有用的一些方法供子类直接使用，之后我们再细说。</p>
<p>然后才到我们的重点部分 ThreadPoolExecutor 类，这个类提供了关于线程池所需的非常丰富的功能。</p>
<p>另外，我们还涉及到下图中的这些类：</p>
<p><img src="/img/work/others.png"></p>
<p>同在并发包中的 Executors 类，类名中带字母 s，我们猜到这个是工具类，里面的方法都是静态方法，如以下我们最常用的用于生成 ThreadPoolExecutor 的实例的一些方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>另外，由于线程池支持<strong>获取线程执行的结果</strong>，所以，引入了 Future 接口，RunnableFuture 继承自此接口，然后我们最需要关心的就是它的实现类 FutureTask。到这里，记住这个概念，在线程池的使用过程中，我们是往线程池提交任务（task），使用过线程池的都知道，我们提交的每个任务是实现了 Runnable 接口的，其实就是先将 Runnable 的任务包装成 FutureTask，然后再提交到线程池。这样，读者才能比较容易记住 FutureTask 这个类名：它首先是一个任务（Task），然后具有 Future 接口的语义，即可以在将来（Future）得到执行的结果。</p>
<p>当然，线程池中的 BlockingQueue 也是非常重要的概念，如果线程数达到 corePoolSize，我们的每个任务会提交到等待队列中，等待线程池中的线程来取任务并执行。这里的 BlockingQueue 通常我们使用其实现类 LinkedBlockingQueue、ArrayBlockingQueue 和 SynchronousQueue，每个实现类都有不同的特征，使用场景之后会慢慢分析。</p>
<blockquote>
<p>把事情说完整：除了上面说的这些类外，还有一个很重要的类，就是定时任务实现类 ScheduledThreadPoolExecutor，它继承自本文要重点讲解的 ThreadPoolExecutor，用于实现定时执行。不过本文不会介绍它的实现，我相信读者看完本文后可以比较容易地看懂它的源码。</p>
</blockquote>
<h2 id="3-Executor-接口"><a href="#3-Executor-接口" class="headerlink" title="3. Executor 接口"></a>3. Executor 接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Executor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以看到 Executor 接口非常简单，就一个 <code>void execute(Runnable command)</code> 方法，代表提交一个任务。为了让大家理解 java 线程池的整个设计方案，我会按照 Doug Lea 的设计思路来多说一些相关的东西。</p>
<p>我们经常这样启动一个线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable()&#123;<br>  <span class="hljs-comment">// do something</span><br>&#125;).start();<br></code></pre></td></tr></table></figure>

<p>用了线程池 Executor 后就可以像下面这么使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Executor executor = anExecutor;<br>executor.execute(<span class="hljs-keyword">new</span> RunnableTask1());<br>executor.execute(<span class="hljs-keyword">new</span> RunnableTask2());<br></code></pre></td></tr></table></figure>

<p>如果我们希望线程池同步执行每一个任务，我们可以这么实现这个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Executor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>        r.run();<span class="hljs-comment">// 这里不是用的new Thread(r).start()，也就是说没有启动任何一个新的线程。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们希望每个任务提交进来后，直接启动一个新的线程来执行这个任务，我们可以这么实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPerTaskExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Executor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(r).start();  <span class="hljs-comment">// 每个任务都用一个新的线程来执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们再来看下怎么组合两个 Executor 来使用，下面这个实现是将所有的任务都加到一个 queue 中，然后从 queue 中取任务，交给真正的执行器执行，这里采用 synchronized 进行并发控制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerialExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Executor</span> </span>&#123;<br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">final</span> Queue&lt;Runnable&gt; tasks = <span class="hljs-keyword">new</span> ArrayDeque&lt;Runnable&gt;();<br>    <span class="hljs-comment">// 这个才是真正的执行器</span><br>    <span class="hljs-keyword">final</span> Executor executor;<br>    <span class="hljs-comment">// 当前正在执行的任务</span><br>    Runnable active;<br><br>    <span class="hljs-comment">// 初始化的时候，指定执行器</span><br>    SerialExecutor(Executor executor) &#123;<br>        <span class="hljs-keyword">this</span>.executor = executor;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加任务到线程池: 将任务添加到任务队列，scheduleNext 触发执行器去任务队列取任务</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Runnable r)</span> </span>&#123;<br>        tasks.offer(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    r.run();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    scheduleNext();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">if</span> (active == <span class="hljs-keyword">null</span>) &#123;<br>            scheduleNext();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> ((active = tasks.poll()) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 具体的执行转给真正的执行器 executor</span><br>            executor.execute(active);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然了，Executor 这个接口只有提交任务的功能，太简单了，我们想要更丰富的功能，比如我们想知道执行结果、我们想知道当前线程池有多少个线程活着、已经完成了多少任务等等，这些都是这个接口的不足的地方。接下来我们要介绍的是继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口，这个接口提供了比较丰富的功能，也是我们最常使用到的接口。</p>
<h2 id="4-ExecutorService"><a href="#4-ExecutorService" class="headerlink" title="4 ExecutorService"></a>4 ExecutorService</h2><p>一般我们定义一个线程池的时候，往往都是使用这个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ExecutorService executor = Executors.newFixedThreadPool(args...);<br>ExecutorService executor = Executors.newCachedThreadPool(args...);<br></code></pre></td></tr></table></figure>

<p>因为这个接口中定义的一系列方法大部分情况下已经可以满足我们的需要了。</p>
<p>那么我们简单初略地来看一下这个接口中都有哪些方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Executor</span> </span>&#123;<br><br>    <span class="hljs-comment">// 关闭线程池，已提交的任务继续执行，不接受继续提交新任务</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 关闭线程池，尝试停止正在执行的所有任务，不接受继续提交新任务</span><br>    <span class="hljs-comment">// 它和前面的方法相比，加了一个单词“now”，区别在于它会去停止当前正在进行的任务</span><br>    <span class="hljs-function">List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 线程池是否已关闭</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isShutdown</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 如果调用了 shutdown() 或 shutdownNow() 方法后，所有任务结束了，那么返回true</span><br>    <span class="hljs-comment">// 这个方法必须在调用shutdown或shutdownNow方法之后调用才会返回true</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTerminated</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 等待所有任务完成，并设置超时时间</span><br>    <span class="hljs-comment">// 我们这么理解，实际应用中是，先调用 shutdown 或 shutdownNow，</span><br>    <span class="hljs-comment">// 然后再调这个方法等待所有的线程真正地完成，返回值意味着有没有超时</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitTermination</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> InterruptedException</span>;<br><br>    <span class="hljs-comment">// 提交一个 Callable 任务</span><br>    &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span></span>;<br><br>    <span class="hljs-comment">// 提交一个 Runnable 任务，第二个参数将会放到 Future 中，作为返回值，</span><br>    <span class="hljs-comment">// 因为 Runnable 的 run 方法本身并不返回任何东西</span><br>    &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task, T result)</span></span>;<br><br>    <span class="hljs-comment">// 提交一个 Runnable 任务</span><br>    Future&lt;?&gt; submit(Runnable task);<br><br>    <span class="hljs-comment">// 执行所有任务，返回 Future 类型的一个 list</span><br>    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)<br>            <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-comment">// 也是执行所有任务，但是这里设置了超时时间</span><br>    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<br>                                  <span class="hljs-keyword">long</span> timeout, TimeUnit unit)<br>            <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-comment">// 只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果</span><br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;<br><br>    <span class="hljs-comment">// 同上一个方法，只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果，</span><br>    <span class="hljs-comment">// 不过这个带超时，超过指定的时间，抛出 TimeoutException 异常</span><br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这些方法都很好理解，一个简单的线程池主要就是这些功能，能提交任务，能获取结果，能关闭线程池，这也是为什么我们经常用这个接口的原因。</p>
<h2 id="5-FutureTask"><a href="#5-FutureTask" class="headerlink" title="5. FutureTask"></a>5. FutureTask</h2><p>在继续往下层介绍 ExecutorService 的实现类之前，我们先来说说相关的类 FutureTask。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs txt">Future      Runnable<br>   \           /<br>    \         /<br>   RunnableFuture<br>          |<br>          |<br>      FutureTask<br><br>FutureTask 通过 RunnableFuture 间接实现了 Runnable 接口，<br>所以每个 Runnable 通常都先包装成 FutureTask，<br>然后调用 executor.execute(Runnable command) 将其提交给线程池<br></code></pre></td></tr></table></figure>

<p>我们知道，Runnable 的 void run() 方法是没有返回值的，所以，通常，如果我们需要的话，会在 submit 中指定第二个参数作为返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task, T result)</span></span>;<br></code></pre></td></tr></table></figure>

<p>其实到时候会通过这两个参数，将其包装成 Callable。它和 Runnable 的区别在于 run() 没有返回值，而 Callable 的 call() 方法有返回值，同时，如果运行出现异常，call() 方法会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br><br>    <span class="hljs-function">V <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这里，就不展开说 FutureTask 类了，因为本文篇幅本来就够大了，这里我们需要知道怎么用就行了。</p>
<p>下面，我们来看看 <code>ExecutorService</code> 的抽象实现 <code>AbstractExecutorService</code> 。</p>
<h2 id="6-AbstractExecutorService"><a href="#6-AbstractExecutorService" class="headerlink" title="6. AbstractExecutorService"></a>6. AbstractExecutorService</h2><p>AbstractExecutorService 抽象类派生自 ExecutorService 接口，然后在其基础上实现了几个实用的方法，这些方法提供给子类进行调用。</p>
<p>这个抽象类实现了 invokeAny 方法和 invokeAll 方法，这里的两个 newTaskFor 方法也比较有用，用于将任务包装成 FutureTask。定义于最上层接口 Executor中的 <code>void execute(Runnable command)</code> 由于不需要获取结果，不会进行 FutureTask 的包装。</p>
<blockquote>
<p>需要获取结果（FutureTask），用 submit 方法，不需要获取结果，可以用 execute 方法。</p>
</blockquote>
<p>下面，我将一行一行源码地来分析这个类，跟着源码来看看其实现吧：</p>
<blockquote>
<p>Tips: invokeAny 和 invokeAll 方法占了这整个类的绝大多数篇幅，读者可以选择适当跳过，因为它们可能在你的实践中使用的频次比较低，而且它们不带有承前启后的作用，不用担心会漏掉什么导致看不懂后面的代码。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractExecutorService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExecutorService</span> </span>&#123;<br>  <span class="hljs-comment">// RunnableFuture 是用于获取执行结果的，我们常用它的子类 FutureTask</span><br>  <span class="hljs-comment">// 下面两个 newTaskFor 方法用于将我们的任务包装成 FutureTask 提交到线程池中执行</span><br>  <span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">RunnableFuture&lt;T&gt; <span class="hljs-title">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FutureTask&lt;T&gt;(runnable, value);<br>  &#125;<br>  <br>  <span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">RunnableFuture&lt;T&gt; <span class="hljs-title">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FutureTask&lt;T&gt;(callable);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 提交任务</span><br>  <span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-comment">// 1. 将任务包装成 FutureTask</span><br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// 2. 交给执行器执行，execute 方法由具体的子类来实现</span><br>    <span class="hljs-comment">// 前面也说了，FutureTask 间接实现了Runnable 接口。</span><br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task, T result)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-comment">// 1. 将任务包装成 FutureTask</span><br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);<br>    <span class="hljs-comment">// 2. 交给执行器执行</span><br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-comment">// 1. 将任务包装成 FutureTask</span><br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br>    <span class="hljs-comment">// 2. 交给执行器执行</span><br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 此方法目的：将 tasks 集合中的任务提交到线程池执行，任意一个线程执行完后就可以结束了</span><br>  <span class="hljs-comment">// 第二个参数 timed 代表是否设置超时机制，超时时间为第三个参数，</span><br>  <span class="hljs-comment">// 如果 timed 为 true，同时超时了还没有一个线程返回结果，那么抛出 TimeoutException 异常</span><br>  <span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">doInvokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">boolean</span> timed, <span class="hljs-keyword">long</span> nanos)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;<br>    <span class="hljs-keyword">if</span> (tasks == <span class="hljs-keyword">null</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-comment">// 任务数</span><br>    <span class="hljs-keyword">int</span> ntasks = tasks.size();<br>    <span class="hljs-keyword">if</span> (ntasks == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-comment">// </span><br>    List&lt;Future&lt;T&gt;&gt; futures= <span class="hljs-keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);<br><br>    <span class="hljs-comment">// ExecutorCompletionService 不是一个真正的执行器，参数 this 才是真正的执行器</span><br>    <span class="hljs-comment">// 它对执行器进行了包装，每个任务结束后，将结果保存到内部的一个 completionQueue 队列中</span><br>    <span class="hljs-comment">// 这也是为什么这个类的名字里面有个 Completion 的原因吧。</span><br>    ExecutorCompletionService&lt;T&gt; ecs = <span class="hljs-keyword">new</span> ExecutorCompletionService&lt;T&gt;(<span class="hljs-keyword">this</span>);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 用于保存异常信息，此方法如果没有得到任何有效的结果，那么我们可以抛出最后得到的一个异常</span><br>      ExecutionException ee = <span class="hljs-keyword">null</span>;<br>      <span class="hljs-keyword">long</span> lastTime = timed ? System.nanoTime() : <span class="hljs-number">0</span>;<br>      Iterator&lt;? extends Callable&lt;T&gt;&gt; it = tasks.iterator();<br><br>      <span class="hljs-comment">// 首先先提交一个任务，后面的任务到下面的 for 循环一个个提交</span><br>      futures.add(ecs.submit(it.next()));<br><br>      <span class="hljs-comment">// 提交了一个任务，所以任务数量减 1</span><br>      --ntasks;<br><br>      <span class="hljs-comment">// 正在执行的任务数(提交的时候 +1，任务结束的时候 -1)</span><br>      <span class="hljs-keyword">int</span> active = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// ecs 上面说了，其内部有一个 completionQueue 用于保存执行完成的结果</span><br>        <span class="hljs-comment">// BlockingQueue 的 poll 方法不阻塞，返回 null 代表队列为空</span><br>        Future&lt;T&gt; f = ecs.poll();<br>        <span class="hljs-comment">// 为 null，说明刚刚提交的第一个线程还没有执行完成</span><br>        <span class="hljs-comment">// 在前面先提交一个任务，加上这里做一次检查，也是为了提高性能</span><br>        <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>) &#123;<br>          <span class="hljs-keyword">if</span> (ntasks &gt; <span class="hljs-number">0</span>) &#123;<br>            --ntasks;<br>            futures.add(ecs.submit(it.next()));<br>            ++active;<br>          &#125;<br><br>          <span class="hljs-comment">//这里的 active == 0，说明所有的任务都执行失败，那么这里是 for 循环出口</span><br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (active == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-comment">// 这里也是 else if。这里说的是，没有任务了，但是设置了超时时间，这里检测是否超时</span><br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timed) &#123;<br>            <span class="hljs-comment">// 带等待的 poll 方法</span><br>            f = ecs.poll(nanos, TimeUnit.NANOSECONDS);<br>            <span class="hljs-comment">// 如果已经超时，抛出 TimeoutException 异常，这整个方法就结束了</span><br>            <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)<br>              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TimeoutException();<br>            <span class="hljs-keyword">long</span> now = System.nanoTime();<br>            nanos -= now - lastTime;<br>            lastTime = now;<br><br>          &#125;<br>          <span class="hljs-comment">// 这里是 else。说明，没有任务需要提交，但是池中的任务没有完成，还没有超时(如果设置了超时)</span><br>          <span class="hljs-comment">// take() 方法会阻塞，直到有元素返回，说明有任务结束了</span><br>          <span class="hljs-keyword">else</span><br>            f = ecs.take();<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 我感觉上面这一段并不是很好理解，这里简单说下。</span><br><span class="hljs-comment">        * 1. 首先，这在一个 for 循环中，我们设想每一个任务都没那么快结束，</span><br><span class="hljs-comment">        * 那么，每一次都会进到第一个分支，进行提交任务，直到将所有的任务都提交了</span><br><span class="hljs-comment">        * 2. 任务都提交完成后，如果设置了超时，那么 for 循环其实进入了“一直检测是否超时”这件事情上</span><br><span class="hljs-comment">        * 3. 如果没有设置超时机制，那么不必要检测超时，那就会阻塞在 ecs.take() 方法上，等待获取第一个执行结果</span><br><span class="hljs-comment">        * 4. 如果所有的任务都执行失败，也就是说 future 都返回了，但是 f.get() 抛出异常，那么从 active == 0 分支出去当然，</span><br><span class="hljs-comment">        * 这个需要看下面的 if 分支。</span><br><span class="hljs-comment">        */</span><br><br>        <span class="hljs-comment">// 有任务结束了</span><br>        <span class="hljs-keyword">if</span> (f != <span class="hljs-keyword">null</span>) &#123;<br>          --active;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 返回执行结果，如果有异常，都包装成 ExecutionException</span><br>            <span class="hljs-keyword">return</span> f.get();<br>          &#125;<span class="hljs-keyword">catch</span> (ExecutionException eex) &#123;<br>            ee = eex;<br>          &#125; <span class="hljs-keyword">catch</span> (RuntimeException rex) &#123;<br>            ee = <span class="hljs-keyword">new</span> ExecutionException(rex);<br>          &#125;<br>        &#125;<span class="hljs-comment">// 注意看 for 循环的范围，一直到这里</span><br>        <span class="hljs-keyword">if</span> (ee == <span class="hljs-keyword">null</span>)<br>          ee = <span class="hljs-keyword">new</span> ExecutionException();<br>        <span class="hljs-keyword">throw</span> ee;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 方法退出之前，取消其他的任务</span><br>        <span class="hljs-keyword">for</span> (Future&lt;T&gt; f : futures)<br>          f.cancel(<span class="hljs-keyword">true</span>);<br>      &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="hljs-function">      <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException </span>&#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> doInvokeAny(tasks, <span class="hljs-keyword">false</span>, <span class="hljs-number">0</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (TimeoutException cannotHappen) &#123;<br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>      &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;<br>        <span class="hljs-keyword">return</span> doInvokeAny(tasks, <span class="hljs-keyword">true</span>, unit.toNanos(timeout));<br>    &#125;<br>    <br>    <span class="hljs-comment">// 执行所有的任务，返回任务结果。</span><br>    <span class="hljs-comment">// 先不要看这个方法，我们先想想，其实我们自己提交任务到线程池，也是想要线程池执行所有的任务</span><br>    <span class="hljs-comment">// 只不过，我们是每次 submit 一个任务，这里以一个集合作为参数提交</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)<br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>      <span class="hljs-keyword">if</span> (tasks == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>      List&lt;Future&lt;T&gt;&gt; futures = <span class="hljs-keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());<br>      <span class="hljs-keyword">boolean</span> done = <span class="hljs-keyword">false</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 这个很简单</span><br>        <span class="hljs-keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;<br>          <span class="hljs-comment">// 包装成 FutureTask</span><br>          RunnableFuture&lt;T&gt; f = newTaskFor(t);<br>          futures.add(f);<br>          <span class="hljs-comment">// 提交任务</span><br>          execute(f);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Future&lt;T&gt; f : futures) &#123;<br>          <span class="hljs-keyword">if</span> (!f.isDone()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">// 这是一个阻塞方法，直到获取到值，或抛出了异常</span><br>              <span class="hljs-comment">// 这里有个小细节，其实 get 方法签名上是会抛出 InterruptedException 的</span><br>              <span class="hljs-comment">// 可是这里没有进行处理，而是抛给外层去了。此异常发生于还没执行完的任务被取消了</span><br>              f.get();<br>            &#125; <span class="hljs-keyword">catch</span> (CancellationException ignore) &#123;<br>            &#125; <span class="hljs-keyword">catch</span> (ExecutionException ignore) &#123;<br>            &#125;<br>          &#125;<br>        &#125;<br>        done = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">// 这个方法返回，不像其他的场景，返回 List&lt;Future&gt;，其实执行结果还没出来</span><br>        <span class="hljs-comment">// 这个方法返回是真正的返回，任务都结束了</span><br>        <span class="hljs-keyword">return</span> futures;<br>        <br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 为什么要这个？就是上面说的有异常的情况</span><br>        <span class="hljs-keyword">if</span> (!done)<br>          <span class="hljs-keyword">for</span> (Future&lt;T&gt; f : futures)<br>            f.cancel(<span class="hljs-keyword">true</span>);<br>      &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 带超时的 invokeAll，我们找不同吧</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<br>                                         <span class="hljs-keyword">long</span> timeout, TimeUnit unit)<br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>      <span class="hljs-keyword">if</span> (tasks == <span class="hljs-keyword">null</span> || unit == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>      <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);<br>      List&lt;Future&lt;T&gt;&gt; futures = <span class="hljs-keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());<br>      <span class="hljs-keyword">boolean</span> done = <span class="hljs-keyword">false</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (Callable&lt;T&gt; t : tasks)<br>          futures.add(newTaskFor(t));<br>        <span class="hljs-keyword">long</span> lastTime = System.nanoTime();<br>        Iterator&lt;Future&lt;T&gt;&gt; it = futures.iterator();<br>        <span class="hljs-comment">// 每提交一个任务，检测一次是否超时</span><br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>          execute((Runnable)(it.next()));<br>          <span class="hljs-keyword">long</span> now = System.nanoTime();<br>          nanos -= now - lastTime;<br>          lastTime = now;<br>          <span class="hljs-comment">// 超时</span><br>          <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> futures;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Future&lt;T&gt; f : futures) &#123;<br>          <span class="hljs-keyword">if</span> (!f.isDone()) &#123;<br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)<br>              <span class="hljs-keyword">return</span> futures;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">// 调用带超时的 get 方法，这里的参数 nanos 是剩余的时间，</span><br>              <span class="hljs-comment">// 因为上面其实已经用掉了一些时间了</span><br>              f.get(nanos, TimeUnit.NANOSECONDS);<br>            &#125; <span class="hljs-keyword">catch</span> (CancellationException ignore) &#123;<br><br>            &#125; <span class="hljs-keyword">catch</span> (ExecutionException ignore) &#123;<br><br>            &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;<br>              <span class="hljs-keyword">return</span> futures;<br>            &#125; <br>            <span class="hljs-keyword">long</span> now = System.nanoTime();<br>            nanos -= now - lastTime;<br>            lastTime = now;<br>          &#125;<br>        &#125;<br>        done = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">return</span> futures;<br>      &#125;<span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (!done)<br>          <span class="hljs-keyword">for</span> (Future&lt;T&gt; f : futures)<br>            f.cancel(<span class="hljs-keyword">true</span>);<br>      &#125;<br>      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>到这里，我们发现，这个抽象类包装了一些基本的方法，可是像 submit、invokeAny、invokeAll 等方法，它们都没有真正开启线程来执行任务，它们都只是在方法内部调用了 execute 方法，所以最重要的 execute(Runnable runnable) 方法还没出现，需要等具体执行器来实现这个最重要的部分，这里我们要说的就是 ThreadPoolExecutor 类了。</p>
<h2 id="7-ThreadPoolExecutor"><a href="#7-ThreadPoolExecutor" class="headerlink" title="7.ThreadPoolExecutor"></a>7.ThreadPoolExecutor</h2><p>ThreadPoolExecutor 是 JDK 中的线程池实现，这个类实现了一个线程池需要的各个方法，它实现了任务提交、线程管理、监控等等方法。</p>
<p>我们可以基于它来进行业务上的扩展，以实现我们需要的其他功能，比如实现定时任务的类 ScheduledThreadPoolExecutor 就继承自 ThreadPoolExecutor。当然，这不是本文关注的重点，下面，还是赶紧进行源码分析吧。</p>
<p>首先，我们来看看线程池实现中的几个概念和处理流程。</p>
<p>我们先回顾下提交任务的几个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-keyword">null</span>);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task, T result)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一个最基本的概念是，submit 方法中，参数是 Runnable 类型（也有Callable 类型），这个参数不是用于 new </p>
<p>Thread(<strong>runnable</strong>).start() 中的，此处的这个参数不是用于启动线程的，这里指的是<strong>任务</strong>，任务要做的事情是 run() 方法里面定义的或 Callable 中的 call() 方法里面定义的。</p>
<p>初学者往往会搞混这个，因为 Runnable 总是在各个地方出现，经常把一个 Runnable 包到另一个 Runnable 中。请把它想象成有个 Task 接口，这个接口里面有一个 run() 方法。</p>
<p>我们回过神来继续往下看，我画了一个简单的示意图来描述线程池中的一些主要的构件：</p>
<p><img src="/img/work/pool-1.png"></p>
<p>当然，上图没有考虑队列是否有界，提交任务时队列满了怎么办？什么情况下会创建新的线程？提交任务时线程池满了怎么办？空闲线程怎么关掉？这些问题下面我们会一一解决。</p>
<p>我们经常会使用 <code>Executors</code> 这个工具类来快速构造一个线程池，对于初学者而言，这种工具类是很有用的，开发者不需要关注太多的细节，只要知道自己需要一个线程池，仅仅提供必需的参数就可以了，其他参数都采用作者提供的默认值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里先不说有什么区别，它们最终都会导向这个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-params"><span class="hljs-function">                          TimeUnit unit,</span></span><br><span class="hljs-params"><span class="hljs-function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-params"><span class="hljs-function">                          ThreadFactory threadFactory,</span></span><br><span class="hljs-params"><span class="hljs-function">                          RejectedExecutionHandler handler)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>      maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>      maximumPoolSize &lt; corePoolSize ||<br>      keepAliveTime &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>  <span class="hljs-comment">// 这几个参数都是必须要有的</span><br>  <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br><br>  <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;<br>  <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;<br>  <span class="hljs-keyword">this</span>.workQueue = workQueue;<br>  <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>  <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br>  <span class="hljs-keyword">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>基本上，上面的构造方法中列出了我们最需要关心的几个属性了，下面逐个介绍下构造方法中出现的这几个属性：</p>
<ul>
<li>corePoolSize</li>
</ul>
<blockquote>
<p>核心线程数，不要抠字眼，反正先记着有这么个属性就可以了。</p>
</blockquote>
<ul>
<li>maximumPoolSize</li>
</ul>
<blockquote>
<p>最大线程数，线程池允许创建的最大线程数。</p>
</blockquote>
<ul>
<li>workQueue</li>
</ul>
<blockquote>
<p>任务队列，BlockingQueue 接口的某个实现（常使用 ArrayBlockingQueue 和 LinkedBlockingQueue）。</p>
</blockquote>
<ul>
<li>keepAliveTime</li>
</ul>
<blockquote>
<p>空闲线程的保活时间，如果某线程的空闲时间超过这个值都没有任务给它做，那么可以被关闭了。注意这个值并不会对所有线程起作用，如果线程池中的线程数少于等于核心线程数 corePoolSize，那么这些线程不会因为空闲太长时间而被关闭，当然，也可以通过调用 <code>allowCoreThreadTimeOut(true)</code>使核心线程数内的线程也可以被回收。</p>
</blockquote>
<ul>
<li>threadFactory</li>
</ul>
<blockquote>
<p>用于生成线程，一般我们可以用默认的就可以了。通常，我们可以通过它将我们的线程的名字设置得比较可读一些，如 Message-Thread-1， Message-Thread-2 类似这样。</p>
</blockquote>
<ul>
<li>handler</li>
</ul>
<blockquote>
<p>当线程池已经满了，但是又有新的任务提交的时候，该采取什么策略由这个来指定。有几种方式可供选择，像抛出异常、直接拒绝然后返回等，也可以自己实现相应的接口实现自己的逻辑，这个之后再说。</p>
</blockquote>
<p>除了上面几个属性外，我们再看看其他重要的属性。</p>
<p>Doug Lea 采用一个 32 位的整数来存放线程池的状态和当前池中的线程数，其中高 3 位用于存放线程池状态，低 29 位表示线程数（即使只有 29 位，也已经不小了，大概 5 亿多，现在还没有哪个机器能起这么多线程的吧）。我们知道，java 语言在整数编码上是统一的，都是采用补码的形式，下面是简单的移位操作和布尔操作，都是挺简单的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">// 这里 COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数</span><br><span class="hljs-comment">// 很多初学者很喜欢在自己的代码中写很多 29 这种数字，或者某个特殊的字符串，然后分布在各个地方，这是非常糟糕的</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<br><br><br><span class="hljs-comment">// 000 11111111111111111111111111111</span><br><span class="hljs-comment">// 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1=536870911</span><br><span class="hljs-comment">// 以我们现在计算机的实际情况，这个数量还是够用的</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 我们说了，线程池的状态存放在高 3 位中</span><br><span class="hljs-comment">// 运算结果为 111跟29个0：111 00000000000000000000000000000</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 000 00000000000000000000000000000</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 001 00000000000000000000000000000</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 010 00000000000000000000000000000</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 011 00000000000000000000000000000</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 将整数 c 的低 29 位修改为 0，就得到了线程池的状态</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">runStateOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>     </span>&#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<br><br><span class="hljs-comment">// 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>  </span>&#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Bit field accessors that don&#x27;t require unpacking ctl.</span><br><span class="hljs-comment"> * These depend on the bit layout and on workerCount being never negative.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">runStateLessThan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> c &lt; s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">runStateAtLeast</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> c &gt;= s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRunning</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> c &lt; SHUTDOWN;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>上面就是对一个整数的简单的位操作，几个操作方法将会在后面的源码中一直出现，所以读者最好把方法名字和其代表的功能记住，看源码的时候也就不需要来来回回翻了。</p>
<p>在这里，介绍下线程池中的各个状态和状态变化的转换过程：</p>
<ul>
<li>RUNNING：正常的状态：接受新的任务，处理等待队列中的任务</li>
<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务</li>
<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</li>
<li>TIDYING：所有的任务都销毁了，workCount 为 0。线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()</li>
<li>TERMINATED：terminated() 方法结束后，线程池的状态就会变成这个</li>
</ul>
<blockquote>
<p>RUNNING 定义为 -1，SHUTDOWN 定义为 0，其他的都比 0 大，所以等于 0 的时候不能提交任务，大于 0 的话，连正在执行的任务也需要中断。</p>
</blockquote>
<p>看了这几种状态的介绍，读者大体也可以猜到十之八九的状态转换了，各个状态的转换过程有以下几种：</p>
<ul>
<li>RUNNING -&gt; SHUTDOWN：当调用了 shutdown() 后，会发生这个状态转换，这也是最重要的</li>
<li>(RUNNING or SHUTDOWN) -&gt; STOP：当调用 shutdownNow() 后，会发生这个状态转换，这下要清楚 shutDown() 和 shutDownNow() 的区别了</li>
<li>SHUTDOWN -&gt; TIDYING：当任务队列和线程池都清空后，会由 SHUTDOWN 转换为 TIDYING</li>
<li>STOP -&gt; TIDYING：当任务队列清空后，发生这个转换</li>
<li>TIDYING -&gt; TERMINATED：这个前面说了，当 terminated() 方法结束后</li>
</ul>
<p>上面的几个记住核心的就可以了，尤其第一个和第二个。</p>
<p>另外，我们还要看看一个内部类 Worker，因为 Doug Lea 把线程池中的线程包装成了一个个 Worker，翻译成工人，就是线程池中做任务的线程。所以到这里，我们知道<strong>任务是 Runnable（内部变量名叫 task 或 command），线程是 Worker</strong>。</p>
<p>Worker 这里又用到了抽象类 AbstractQueuedSynchronizer。题外话，AQS 在并发中真的是到处出现，而且非常容易使用，写少量的代码就能实现自己需要的同步方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span></span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span><br><span class="hljs-class"></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">6138294804551838833L</span>;<br>  <br>  <span class="hljs-comment">// 这个是真正的线程，任务靠你啦</span><br>  <span class="hljs-keyword">final</span> Thread thread;<br>  <br>  <span class="hljs-comment">// 前面说了，这里的 Runnable 是任务。为什么叫 firstTask？因为在创建线程的时候，如果同时指定了</span><br>  <span class="hljs-comment">// 这个线程起来以后需要执行的第一个任务，那么第一个任务就是存放在这里的(线程可不止执行这一个任务)</span><br>  <span class="hljs-comment">// 当然了，也可以为 null，这样线程起来了，自己到任务队列（BlockingQueue）中取任务（getTask 方法）就行了</span><br>  Runnable firstTask;<br>  <br>  <span class="hljs-comment">// 用于存放此线程完成的任务数，注意了，这里用了 volatile，保证可见性</span><br>  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> completedTasks;<br>  <br>  <span class="hljs-comment">// Worker 只有这一个构造方法，传入 firstTask，也可以传 null</span><br>  Worker(Runnable firstTask) &#123;<br>    setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>    <span class="hljs-keyword">this</span>.firstTask = firstTask;<br>    <span class="hljs-comment">// 调用 ThreadFactory 来创建一个新的线程</span><br>    <span class="hljs-keyword">this</span>.thread = getThreadFactory().newThread(<span class="hljs-keyword">this</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 这里调用了外部类的 runWorker 方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    runWorker(<span class="hljs-keyword">this</span>);<br>  &#125;<br>  <br>  ...<span class="hljs-comment">// 其他几个方法没什么好看的，就是用 AQS 操作，来获取这个线程的执行权，用了独占锁</span><br>   <br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>前面虽然啰嗦，但是简单。有了上面的这些基础后，我们终于可以看看 ThreadPoolExecutor 的 execute 方法了，前面源码分析的时候也说了，各种方法都最终依赖于 execute 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>  <span class="hljs-comment">// 前面说的那个表示 “线程池状态” 和 “线程数” 的整数</span><br>  <span class="hljs-keyword">int</span> c = ctl.get();<br>  <br>  <span class="hljs-comment">// 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，</span><br>  <span class="hljs-comment">// 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span><br>  <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>    <span class="hljs-comment">// 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了</span><br>    <span class="hljs-comment">// 至于执行的结果，到时候会包装到 FutureTask 中。</span><br>    <span class="hljs-comment">// 返回 false 代表线程池不允许提交任务</span><br>    <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>      <span class="hljs-keyword">return</span>;<br>    c = ctl.get();<br>  &#125;<br>  <span class="hljs-comment">// 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了</span><br>  <span class="hljs-comment">// 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span><br>  <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>    <span class="hljs-comment">/* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程</span><br><span class="hljs-comment">     * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span><br><span class="hljs-comment">     * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">int</span> recheck = ctl.get();<br>    <span class="hljs-comment">// 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span><br>    <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>    <span class="hljs-comment">// 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span><br>    <span class="hljs-comment">// 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>      addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>  &#125;<br>  <span class="hljs-comment">// 如果 workQueue 队列满了，那么进入到这个分支</span><br>  <span class="hljs-comment">// 以 maximumPoolSize 为界创建新的 worker，</span><br>  <span class="hljs-comment">// 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>    reject(command);<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>对创建线程的错误理解：如果线程数少于 corePoolSize，创建一个线程，如果线程数在 [corePoolSize, maximumPoolSize] 之间那么可以创建线程或复用空闲线程，keepAliveTime 对这个区间的线程有效。</p>
<p>从上面的几个分支，我们就可以看出，上面的这段话是错误的。</p>
</blockquote>
<p>上面这些一时半会也不可能全部消化搞定，我们先继续往下吧，到时候再回头看几遍。</p>
<p>这个方法非常重要 addWorker(Runnable firstTask, boolean core) 方法，我们看看它是怎么创建新的线程的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第一个参数是准备提交给这个线程执行的任务，之前说了，可以为 null</span><br><span class="hljs-comment">// 第二个参数为 true 代表使用核心线程数 corePoolSize 作为创建线程的界限，也就说创建这个线程的时候，</span><br><span class="hljs-comment">//         如果线程池中的线程总数已经达到 corePoolSize，那么不能响应这次创建线程的请求</span><br><span class="hljs-comment">//         如果是 false，代表使用最大线程数 maximumPoolSize 作为界限</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br><br>        <span class="hljs-comment">// 这个非常不好理解</span><br>        <span class="hljs-comment">// 如果线程池已关闭，并满足以下条件之一，那么不创建新的 worker：</span><br>        <span class="hljs-comment">// 1. 线程池状态大于 SHUTDOWN，其实也就是 STOP, TIDYING, 或 TERMINATED</span><br>        <span class="hljs-comment">// 2. firstTask != null</span><br>        <span class="hljs-comment">// 3. workQueue.isEmpty()</span><br>        <span class="hljs-comment">// 简单分析下：</span><br>        <span class="hljs-comment">// 还是状态控制的问题，当线程池处于 SHUTDOWN 的时候，不允许提交任务，但是已有的任务继续执行</span><br>        <span class="hljs-comment">// 当状态大于 SHUTDOWN 时，不允许提交任务，且中断正在执行的任务</span><br>        <span class="hljs-comment">// 多说一句：如果线程池处于 SHUTDOWN，但是 firstTask 为 null，且 workQueue 非空，那么是允许创建 worker 的</span><br>        <span class="hljs-comment">// 这是因为 SHUTDOWN 的语义：不允许提交新的任务，但是要把已经进入到 workQueue 的任务执行完，所以在满足条件的基础上，是允许创建新的 Worker 的</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-keyword">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 如果成功，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了</span><br>            <span class="hljs-comment">// 这里失败的话，说明有其他线程也在尝试往线程池中创建线程</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            <span class="hljs-comment">// 由于有并发，重新再读取一下 ctl</span><br>            c = ctl.get();<br>            <span class="hljs-comment">// 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了</span><br>            <span class="hljs-comment">// 可是如果是因为其他线程的操作，导致线程池的状态发生了变更，如有其他线程关闭了这个线程池</span><br>            <span class="hljs-comment">// 那么需要回到外层的for循环</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">     * 到这里，我们认为在当前这个时刻，可以开始创建线程来执行任务了，</span><br><span class="hljs-comment">     * 因为该校验的都校验了，至于以后会发生什么，那是以后的事，至少当前是满足条件的</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">// worker 是否已经启动</span><br>    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 是否已将这个 worker 添加到 workers 这个 HashSet 中</span><br>    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>    Worker w = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>        <span class="hljs-comment">// 把 firstTask 传给 worker 的构造方法</span><br>        w = <span class="hljs-keyword">new</span> Worker(firstTask);<br>        <span class="hljs-comment">// 取 worker 中的线程对象，之前说了，Worker的构造方法会调用 ThreadFactory 来创建一个新的线程</span><br>        <span class="hljs-keyword">final</span> Thread t = w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 这个是整个线程池的全局锁，持有这个锁才能让下面的操作“顺理成章”，</span><br>            <span class="hljs-comment">// 因为关闭一个线程池需要这个锁，至少我持有锁的期间，线程池不会被关闭</span><br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br><br>                <span class="hljs-keyword">int</span> c = ctl.get();<br>                <span class="hljs-keyword">int</span> rs = runStateOf(c);<br><br>                <span class="hljs-comment">// 小于 SHUTTDOWN 那就是 RUNNING，这个自不必说，是最正常的情况</span><br>                <span class="hljs-comment">// 如果等于 SHUTDOWN，前面说了，不接受新的任务，但是会继续执行等待队列中的任务</span><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;<br>                    <span class="hljs-comment">// worker 里面的 thread 可不能是已经启动的</span><br>                    <span class="hljs-keyword">if</span> (t.isAlive())<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                    <span class="hljs-comment">// 加到 workers 这个 HashSet 中</span><br>                    workers.add(w);<br>                    <span class="hljs-keyword">int</span> s = workers.size();<br>                    <span class="hljs-comment">// largestPoolSize 用于记录 workers 中的个数的最大值</span><br>                    <span class="hljs-comment">// 因为 workers 是不断增加减少的，通过这个值可以知道线程池的大小曾经达到的最大值</span><br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-comment">// 添加成功的话，启动这个线程</span><br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                <span class="hljs-comment">// 启动线程</span><br>                t.start();<br>                workerStarted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉</span><br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-comment">// 返回线程是否启动成功</span><br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>简单看下 addWorkFailed 的处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// workers 中删除掉相应的 worker</span><br><span class="hljs-comment">// workCount 减 1</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addWorkerFailed</span><span class="hljs-params">(Worker w)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-keyword">null</span>)<br>            workers.remove(w);<br>        decrementWorkerCount();<br>        <span class="hljs-comment">// rechecks for termination, in case the existence of this worker was holding up termination</span><br>        tryTerminate();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>回过头来，继续往下走。我们知道，worker 中的线程 start 后，其 run 方法会调用 runWorker 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Worker 类的 run() 方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    runWorker(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>继续往下看 runWorker 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 此方法由 worker 线程启动后调用，这里用一个 while 循环来不断地从等待队列中获取任务并执行</span><br><span class="hljs-comment">// 前面说了，worker 在初始化的时候，可以指定 firstTask，那么第一个任务也就可以不需要从队列中获取</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWorker</span><span class="hljs-params">(Worker w)</span> </span>&#123;<br>  Thread wt = Thread.currentThread();<br>  <span class="hljs-comment">// 该线程的第一个任务(如果有的话)</span><br>  Runnable task = w.firstTask;<br>  w.firstTask = <span class="hljs-keyword">null</span>;<br>  w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>  <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 循环调用 getTask 获取任务</span><br>    <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;<br>      w.lock();<br>      <span class="hljs-comment">// 如果线程池状态大于等于 STOP，那么意味着该线程也要中断</span><br>      <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>           (Thread.interrupted() &amp;&amp;<br>            runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>          !wt.isInterrupted())<br>        wt.interrupt();<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 这是一个钩子方法，留给需要的子类实现</span><br>        beforeExecute(wt, task);<br>        Throwable thrown = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 到这里终于可以执行任务了</span><br>          task.run();<br>          <br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>          thrown = x; <span class="hljs-keyword">throw</span> x;<br>        &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>          thrown = x; <span class="hljs-keyword">throw</span> x;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>          <span class="hljs-comment">// 这里不允许抛出 Throwable，所以转换为 Error</span><br>          thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>          <span class="hljs-comment">// 也是一个钩子方法，将 task 和异常作为参数，留给需要的子类实现</span><br>          afterExecute(task, thrown);<br>        &#125;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 置空 task，准备 getTask 获取下一个任务</span><br>        task = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 累加完成的任务数</span><br>        w.completedTasks++;<br>        <span class="hljs-comment">// 释放掉 worker 的独占锁</span><br>        w.unlock();<br>      &#125;<br>    &#125;<br>    completedAbruptly = <span class="hljs-keyword">false</span>;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 如果到这里，需要执行线程关闭：</span><br>    <span class="hljs-comment">// 1. 说明 getTask 返回 null，也就是说，队列中已经没有任务需要执行了，执行关闭</span><br>    <span class="hljs-comment">// 2. 任务执行过程中发生了异常</span><br>    <span class="hljs-comment">// 第一种情况，已经在代码处理了将 workCount 减 1，这个在 getTask 方法分析中会说</span><br>    <span class="hljs-comment">// 第二种情况，workCount 没有进行处理，所以需要在 processWorkerExit 中处理</span><br>    <span class="hljs-comment">// 限于篇幅，我不准备分析这个方法了，感兴趣的读者请自行分析源码</span><br>    processWorkerExit(w, completedAbruptly);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看看 getTask() 是怎么获取任务的，这个方法写得真的很好，每一行都很简单，组合起来却所有的情况都想好了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 此方法有三种可能：</span><br><span class="hljs-comment">// 1. 阻塞直到获取到任务返回。我们知道，默认 corePoolSize 之内的线程是不会被回收的，</span><br><span class="hljs-comment">//      它们会一直等待任务</span><br><span class="hljs-comment">// 2. 超时退出。keepAliveTime 起作用的时候，也就是如果这么多时间内都没有任务，那么应该执行关闭</span><br><span class="hljs-comment">// 3. 如果发生了以下条件，此方法必须返回 null:</span><br><span class="hljs-comment">//    - 池中有大于 maximumPoolSize 个 workers 存在(通过调用 setMaximumPoolSize 进行设置)</span><br><span class="hljs-comment">//    - 线程池处于 SHUTDOWN，而且 workQueue 是空的，前面说了，这种不再接受新的任务</span><br><span class="hljs-comment">//    - 线程池处于 STOP，不仅不接受新的线程，连 workQueue 中的线程也不再执行</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title">getTask</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">boolean</span> timedOut = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br>  retry:<br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>    <span class="hljs-keyword">int</span> rs = runStateOf(c);<br>    <span class="hljs-comment">// 两种可能</span><br>    <span class="hljs-comment">// 1. rs == SHUTDOWN &amp;&amp; workQueue.isEmpty()</span><br>    <span class="hljs-comment">// 2. rs &gt;= STOP</span><br>    <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>      <span class="hljs-comment">// CAS 操作，减少工作线程数</span><br>      decrementWorkerCount();<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">boolean</span> timed;      <span class="hljs-comment">// Are workers subject to culling?</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br>      <span class="hljs-comment">// 允许核心线程数内的线程回收，或当前线程数超过了核心线程数，那么有可能发生超时关闭</span><br>      timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;<br>      <span class="hljs-comment">// 这里 break，是为了不往下执行后一个 if (compareAndDecrementWorkerCount(c))</span><br>      <span class="hljs-comment">// 两个 if 一起看：如果当前线程数 wc &gt; maximumPoolSize，或者超时，都返回 null</span><br>      <span class="hljs-comment">// 那这里的问题来了，wc &gt; maximumPoolSize 的情况，为什么要返回 null？</span><br>      <span class="hljs-comment">//    换句话说，返回 null 意味着关闭线程。</span><br>      <span class="hljs-comment">// 那是因为有可能开发者调用了 setMaximumPoolSize() 将线程池的 maximumPoolSize 调小了，那么多余的 Worker 就需要被关闭</span><br>      <span class="hljs-keyword">if</span> (wc &lt;= maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed))<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>      c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>      <span class="hljs-comment">// compareAndDecrementWorkerCount(c) 失败，线程池中的线程数发生了改变</span><br>      <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>        <span class="hljs-keyword">continue</span> retry;<br>      <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>    &#125;<br>    <span class="hljs-comment">// wc &lt;= maximumPoolSize 同时没有超时</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 到 workQueue 中获取任务</span><br>      Runnable r = timed ?<br>        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>      workQueue.take();<br>      <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> r;<br>      timedOut = <span class="hljs-keyword">true</span>;<br>    &#125;<span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>      <span class="hljs-comment">// 如果此 worker 发生了中断，采取的方案是重试</span><br>      <span class="hljs-comment">// 解释下为什么会发生中断，这个读者要去看 setMaximumPoolSize 方法。</span><br><br>      <span class="hljs-comment">// 如果开发者将 maximumPoolSize 调小了，导致其小于当前的 workers 数量，</span><br>      <span class="hljs-comment">// 那么意味着超出的部分线程要被关闭。重新进入 for 循环，自然会有部分线程会返回 null</span><br>      timedOut = <span class="hljs-keyword">false</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>到这里，基本上也说完了整个流程，读者这个时候应该回到 execute(Runnable command) 方法，看看各个分支，我把代码贴过来一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br><br>    <span class="hljs-comment">// 前面说的那个表示 “线程池状态” 和 “线程数” 的整数</span><br>    <span class="hljs-keyword">int</span> c = ctl.get();<br><br>    <span class="hljs-comment">// 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，</span><br>    <span class="hljs-comment">// 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-comment">// 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了</span><br>        <span class="hljs-comment">// 至于执行的结果，到时候会包装到 FutureTask 中。</span><br>        <span class="hljs-comment">// 返回 false 代表线程池不允许提交任务</span><br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br>    <span class="hljs-comment">// 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了</span><br><br>    <span class="hljs-comment">// 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-comment">/* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程</span><br><span class="hljs-comment">         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span><br><span class="hljs-comment">         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">int</span> recheck = ctl.get();<br>        <span class="hljs-comment">// 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span><br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-comment">// 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span><br>        <span class="hljs-comment">// 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>    <span class="hljs-comment">// 如果 workQueue 队列满了，那么进入到这个分支</span><br>    <span class="hljs-comment">// 以 maximumPoolSize 为界创建新的 worker，</span><br>    <span class="hljs-comment">// 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面各个分支中，有两种情况会调用 reject(command) 来处理任务，因为按照正常的流程，线程池此时不能接受这个任务，所以需要执行我们的拒绝策略。接下来，我们说一说 ThreadPoolExecutor 中的拒绝策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reject</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>    <span class="hljs-comment">// 执行拒绝策略</span><br>    handler.rejectedExecution(command, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此处的 handler 我们需要在构造线程池的时候就传入这个参数，它是 RejectedExecutionHandler 的实例。</p>
<p>RejectedExecutionHandler 在 ThreadPoolExecutor 中有四个已经定义好的实现类可供我们直接使用，当然，我们也可以实现自己的策略，不过一般也没有必要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 只要线程池没有被关闭，那么由提交任务的线程自己来执行这个任务。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CallerRunsPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            r.run();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 不管怎样，直接抛出 RejectedExecutionException 异常</span><br><span class="hljs-comment">// 这个是默认的策略，如果我们构造线程池的时候不传相应的 handler 的话，那就会指定使用这个</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbortPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +<br>                                             <span class="hljs-string">&quot; rejected from &quot;</span> +<br>                                             e.toString());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 不做任何处理，直接忽略掉这个任务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiscardPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 这个相对霸道一点，如果线程池没有被关闭的话，</span><br><span class="hljs-comment">// 把队列队头的任务(也就是等待了最长时间的)直接扔掉，然后提交这个任务到等待队列中</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiscardOldestPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            e.getQueue().poll();<br>            e.execute(r);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>到这里，ThreadPoolExecutor 的源码算是分析结束了。文章可能过于长，需要读者静下来看，理解相对更容易些。</p>
<h2 id="8-Executors"><a href="#8-Executors" class="headerlink" title="8.Executors"></a>8.Executors</h2><p>这节其实也不是分析 Executors 这个类，因为它仅仅是工具类，它的所有方法都是 static 的。</p>
<p>在实际使用线程池的场景中，我们往往不是直接使用 <code>ThreadPoolExecutor</code> ，而是使用 JDK 中提供的具有代表性的线程池实例。</p>
<h3 id="8-1-newFixedThreadPool"><a href="#8-1-newFixedThreadPool" class="headerlink" title="8.1 newFixedThreadPool"></a>8.1 newFixedThreadPool</h3><p><strong>生成一个固定大小的线程池：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最大线程数设置为与核心线程数相等，此时 keepAliveTime 设置为 0（因为这里它是没用的，即使不为 0，线程池默认也不会回收 corePoolSize 内的线程），任务队列采用 LinkedBlockingQueue，无界队列。</p>
<p>过程分析：刚开始，每提交一个任务都创建一个 worker，当 worker 的数量达到 nThreads 后，不再创建新的线程，而是把任务提交到 LinkedBlockingQueue 中，而且之后线程数始终为 nThreads。</p>
<p><code>FixedThreadPool</code> 是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>
<p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FixedThreadPoolDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            executorService.execute(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;执行&quot;</span>);<br>            &#125;);<br>        &#125;<br>        executorService.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="8-2-newSingleThreadExecutor"><a href="#8-2-newSingleThreadExecutor" class="headerlink" title="8.2 newSingleThreadExecutor"></a>8.2 newSingleThreadExecutor</h3><p><strong>生成只有一个线程的固定线程池：</strong></p>
<p>这个更简单，和上面的一样，只要设置线程数为 1 就可以了。其只会创建唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 <strong>如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它</strong> 。</p>
<p>单工作线程最大的特点是：<strong>可保证顺序地执行各个任务</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br>        (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleThreadExecutorDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executorService = Executors.newSingleThreadExecutor();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            executorService.execute(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行&quot;</span>);<br>            &#125;);<br>        &#125;<br>        executorService.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="8-3-newCachedThreadPool"><a href="#8-3-newCachedThreadPool" class="headerlink" title="8.3 newCachedThreadPool"></a>8.3 newCachedThreadPool</h3><p><strong>生成一个需要的时候就创建新的线程，同时可以复用之前创建的线程（如果这个线程当前没有任务）的线程池：</strong></p>
<ul>
<li>如果线程池大小超过处理任务所需要的线程数，就会回收部分空闲的线程；</li>
<li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为 1 分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li>
<li>此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。 因此，使用 <code>CachedThreadPool</code> 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>
</ul>
<p><strong>源码分析</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>核心线程数为 0，最大线程数为 Integer.MAX_VALUE，keepAliveTime 为 60 秒，任务队列采用 SynchronousQueue。</p>
<p>这种线程池对于任务可以比较快速地完成的情况有比较好的性能。如果线程空闲了 60 秒都没有任务，那么将关闭此线程并从线程池中移除。所以如果线程池空闲了很长时间也不会有问题，因为随着所有的线程都会被关闭，整个线程池不会占用任何的系统资源。</p>
<p>过程分析：我把 execute 方法的主体黏贴过来，让大家看得明白些。鉴于 corePoolSize 是 0，那么提交任务的时候，直接将任务提交到队列中，由于采用了 SynchronousQueue，所以如果是第一个任务提交的时候，offer 方法肯定会返回 false，因为此时没有任何 worker 对这个任务进行接收，那么将进入到最后一个分支来创建第一个 worker。之后再提交任务的话，取决于是否有空闲下来的线程对任务进行接收，如果有，会进入到第二个 if 语句块中，否则就是和第一个任务一样，进到最后的 else if 分支创建新线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> c = ctl.get();<br><span class="hljs-comment">// corePoolSize 为 0，所以不会进到这个 if 分支</span><br><span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>    <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>        <span class="hljs-keyword">return</span>;<br>    c = ctl.get();<br>&#125;<br><span class="hljs-comment">// offer 如果有空闲线程刚好可以接收此任务，那么返回 true，否则返回 false</span><br><span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>    <span class="hljs-keyword">int</span> recheck = ctl.get();<br>    <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>        reject(command);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>        addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>    reject(command);<br></code></pre></td></tr></table></figure>

<p>SynchronousQueue 是一个比较特殊的 BlockingQueue，其本身不储存任何元素，它有一个虚拟队列（或虚拟栈），不管读操作还是写操作，如果当前队列中存储的是与当前操作相同模式的线程，那么当前操作也进入队列中等待；如果是相反模式，则配对成功，从当前队列中取队头节点。</p>
<p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CachedThreadPoolDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService executorService = Executors.newCachedThreadPool();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            executorService.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行&quot;</span>);<br>                &#125;<br>            &#125;);<br>        &#125;<br>        executorService.shutdown();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="8-4-newScheduleThreadPool"><a href="#8-4-newScheduleThreadPool" class="headerlink" title="8.4 newScheduleThreadPool"></a>8.4 newScheduleThreadPool</h3><p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledThreadPoolDemo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        scheduled();<br>        scheduleAtFixedRate();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduled</span><span class="hljs-params">()</span> </span>&#123;<br>        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            executorService.schedule(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行&quot;</span>);<br>            &#125;,<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>        &#125;<br><br>        executorService.shutdown();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleAtFixedRate</span><span class="hljs-params">()</span> </span>&#123;<br>        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            executorService.scheduleAtFixedRate(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行&quot;</span>);<br>            &#125;,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,TimeUnit.SECONDS);<br>        &#125;<br>        executorService.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="9-线程池最佳实践"><a href="#9-线程池最佳实践" class="headerlink" title="9.线程池最佳实践"></a>9.线程池最佳实践</h2><h3 id="9-1-计算线程数量"><a href="#9-1-计算线程数量" class="headerlink" title="9.1 计算线程数量"></a>9.1 计算线程数量</h3><p>一般多线程执行的任务类型可以分为 CPU 密集型和 I/O 密集型，根据不同的任务类型，我们计算线程数的方法也不一样。</p>
<p><strong>CPU 密集型任务：</strong>这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。 </p>
<p><strong>I/O 密集型任务：</strong>这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</p>
<h3 id="9-2-建议使用有界阻塞队列"><a href="#9-2-建议使用有界阻塞队列" class="headerlink" title="9.2 建议使用有界阻塞队列"></a>9.2 建议使用有界阻塞队列</h3><p>不建议使用 <code>Executors</code> 的最重要的原因是：<code>Executors</code> 提供的很多方法默认使用的都是无界的 <code>LinkedBlockingQueue</code>，高负载情境下，无界队列很容易导致 OOM，而 OOM 会导致所有请求都无法处理，这是致命问题。所以<strong>强烈建议使用有界队列</strong>。</p>
<p>《阿里巴巴 Java 开发手册》中提到，禁止使用这些方法来创建线程池，而应该手动 <code>new ThreadPoolExecutor</code> 来创建线程池。制订这条规则是因为容易导致生产事故，最典型的就是 <code>newFixedThreadPool</code> 和 <code>newCachedThreadPool</code>，可能因为资源耗尽导致 OOM 问题。</p>
<p>【示例】<code>newFixedThreadPool</code> OOM</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ThreadPoolExecutor threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>printStats(threadPool);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++) &#123;<br>	threadPool.execute(() -&gt; &#123;<br>		String payload = IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">1000000</span>)<br>			.mapToObj(__ -&gt; <span class="hljs-string">&quot;a&quot;</span>)<br>			.collect(Collectors.joining(<span class="hljs-string">&quot;&quot;</span>)) + UUID.randomUUID().toString();<br>		<span class="hljs-keyword">try</span> &#123;<br>			TimeUnit.HOURS.sleep(<span class="hljs-number">1</span>);<br>		&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>		&#125;<br>		log.info(payload);<br>	&#125;);<br>&#125;<br><br>threadPool.shutdown();<br>threadPool.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.HOURS);<br></code></pre></td></tr></table></figure>

<p><code>newFixedThreadPool</code> 使用的工作队列是 <code>LinkedBlockingQueue</code> ，而默认构造方法的 <code>LinkedBlockingQueue</code> 是一个 <code>Integer.MAX_VALUE</code> 长度的队列，可以认为是无界的。如果任务较多并且执行较慢的话，队列可能会快速积压，撑爆内存导致 OOM。</p>
<p>【示例】<code>newCachedThreadPool</code> OOM</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ThreadPoolExecutor threadPool = (ThreadPoolExecutor) Executors.newCachedThreadPool();<br>printStats(threadPool);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++) &#123;<br>	threadPool.execute(() -&gt; &#123;<br>		String payload = UUID.randomUUID().toString();<br>		<span class="hljs-keyword">try</span> &#123;<br>			TimeUnit.HOURS.sleep(<span class="hljs-number">1</span>);<br>		&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>		&#125;<br>		log.info(payload);<br>	&#125;);<br>&#125;<br>threadPool.shutdown();<br>threadPool.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.HOURS);<br></code></pre></td></tr></table></figure>

<p><code>newCachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code>，可以认为是没有上限的，而其工作队列 <code>SynchronousQueue</code> 是一个没有存储空间的阻塞队列。这意味着，只要有请求到来，就必须找到一条工作线程来处理，如果当前没有空闲的线程就再创建一条新的。</p>
<p>如果大量的任务进来后会创建大量的线程。我们知道线程是需要分配一定的内存空间作为线程栈的，比如 1MB，因此无限制创建线程必然会导致 OOM。</p>
<h3 id="9-3-重要任务应该自定义拒绝策略"><a href="#9-3-重要任务应该自定义拒绝策略" class="headerlink" title="9.3 重要任务应该自定义拒绝策略"></a>9.3 重要任务应该自定义拒绝策略</h3><p>使用有界队列，当任务过多时，线程池会触发执行拒绝策略，线程池默认的拒绝策略会 throw <code>RejectedExecutionException</code> 这是个运行时异常，对于运行时异常编译器并不强制 <code>catch</code> 它，所以开发人员很容易忽略。因此<strong>默认拒绝策略要慎重使用</strong>。如果线程池处理的任务非常重要，建议自定义自己的拒绝策略；并且在实际工作中，自定义的拒绝策略往往和降级策略配合使用。</p>
<h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h2><p><strong>java 线程池有哪些关键属性？</strong></p>
<blockquote>
<p>corePoolSize，maximumPoolSize，workQueue，keepAliveTime，rejectedExecutionHandler</p>
<p>corePoolSize 到 maximumPoolSize 之间的线程会被回收，当然 corePoolSize 的线程也可以通过设置而得到回收（allowCoreThreadTimeOut(true)）。</p>
<p>workQueue 用于存放任务，添加任务的时候，如果当前线程数超过了 corePoolSize，那么往该队列中插入任务，线程池中的线程会负责到队列中拉取任务。</p>
<p>keepAliveTime 用于设置空闲时间，如果线程数超出了 corePoolSize，并且有些线程的空闲时间超过了这个值，会执行关闭这些线程的操作</p>
<p>rejectedExecutionHandler 用于处理当线程池不能执行此任务时的情况，默认有<strong>抛出 RejectedExecutionException 异常</strong>、<strong>忽略任务</strong>、<strong>使用提交任务的线程来执行此任务</strong>和<strong>将队列中等待最久的任务删除，然后提交此任务</strong>这四种策略，默认为抛出异常。</p>
</blockquote>
<p><strong>说说线程池中的线程创建时机？</strong></p>
<ol>
<li>如果当前线程数少于 corePoolSize，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务；</li>
<li>如果当前线程数已经达到 corePoolSize，那么将提交的任务添加到队列中，等待线程池中的线程去队列中取任务；</li>
<li>如果队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 maximumPoolSize，如果此时线程数超过了 maximumPoolSize，那么执行拒绝策略。</li>
</ol>
<p><strong>注意：</strong>如果将队列设置为无界队列，那么线程数达到 corePoolSize 后，其实线程数就不会再增长了。因为后面的任务直接往队列塞就行了，此时 maximumPoolSize 参数就没有什么意义。</p>
<p><strong>什么时候会执行拒绝策略？</strong></p>
<ol>
<li>workers 的数量达到了 corePoolSize（任务此时需要进入任务队列），任务入队成功，与此同时线程池被关闭了，而且关闭线程池并没有将这个任务出队，那么执行拒绝策略。这里说的是非常边界的问题，入队和关闭线程池并发执行，读者仔细看看 execute 方法是怎么进到第一个 reject(command) 里面的。</li>
<li>workers 的数量大于等于 corePoolSize，将任务加入到任务队列，可是队列满了，任务入队失败，那么准备开启新的线程，可是线程数已经达到 maximumPoolSize，那么执行拒绝策略。</li>
</ol>
<p>本文篇幅过长，耐心读完你肯定会有不一样的收获。</p>
<h2 id="11-参考"><a href="#11-参考" class="headerlink" title="11.参考"></a>11.参考</h2><p><a href="https://javadoop.com/post/java-thread-pool">深度解读 java 线程池设计思想及源码实现</a></p>
<p><a href="https://dunwu.github.io/javacore/concurrent/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#_1-%E7%AE%80%E4%BB%8B">Java线程池</a></p>
<p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></p>
<p><a href="https://www.cnblogs.com/MOBIN/p/5436482.html">https://www.cnblogs.com/MOBIN/p/5436482.html</a></p>
<p><a href="https://www.jianshu.com/p/d2729853c4da">https://www.jianshu.com/p/d2729853c4da</a></p>
<p><a href="https://book.douban.com/subject/26591326/">并发编程的艺术</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java多线程与并发</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
</search>
