<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java基础-面向对象</title>
    <url>/2021/10/12/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="一、封装"><a href="#一、封装" class="headerlink" title="一、封装"></a>一、封装</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>类的封装，是指将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象的内部信息，而是通过该类所提供的方法来实现对内部信息的操作。即<strong>封装就是把同一类事物的共性（包括属性和方法）归到同一类中，方便使用。</strong>    </p>
<p>封装和继承几乎都是为多态而准备的。 </p>
<p>封装也称信息隐藏，是指利用抽象数据类型把数据和基于数据的操作封装起来，使其成为一个不可分割的整体，数据隐藏在抽象数据内部，尽可能的隐藏数据细节，只保留一些接口使其与外界发生联系。也就是说用户无需知道内部的数据和方法的具体实现细节，只需根据留在外部的接口进行操作就行。 </p>
<h4 id="2-封装的实现"><a href="#2-封装的实现" class="headerlink" title="2. 封装的实现"></a>2. <strong>封装的实现</strong></h4><ul>
<li> 需要修改属性的访问控制符（修改为private）； </li>
<li> 创建getter/setter方法（用于属性的读写）； </li>
<li> 在getter/setter方法中加入属性控制语句（用于判断属性值的合法性）; </li>
</ul>
<p><strong>属性 (成员变量 ) 随对象存放在堆中</strong></p>
<p>直接通过对象调用属性，修改属性值是不安全的，那<strong>怎么办</strong>？</p>
<p>具体实现过程：在定义一个类时，将类中的属性私有化，即使用private关键字来修饰，私有属性只能在它所在类中被访问，如果外界想要访问私有属性，需要提供一些使用public修饰的共有方法，其中包括用于获取属性值的getXxx()方法和设置属性值的setXxx()方法。</p>
<p>Boolean的get方法默认名为isXXX（）</p>
<p>把成员变量设置为私有的，只能在本类中使用，所以属性也叫<strong>全局变量</strong>。</p>
<h4 id="3-封装的优缺点"><a href="#3-封装的优缺点" class="headerlink" title="3.封装的优缺点"></a>3.封装的优缺点</h4><blockquote>
<p>优点</p>
</blockquote>
<ul>
<li> 将变化隔离 </li>
<li> 便于使用 </li>
<li> 提高重用性 </li>
<li> 提高安全性 </li>
</ul>
<blockquote>
<p>缺点</p>
</blockquote>
<p> 将变量等使用private修饰，或者封装进方法内，使其不能直接被访问，增加了访问步骤与难度！ </p>
<p><strong>实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;<br> <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">     * 对属性的封装一个人的姓名、年龄</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">     */</span><br> <br>    <span class="hljs-keyword">private</span> String name;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">     * setter()、getter()是该对象对外开发的接口</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">     */</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br> <br>        <span class="hljs-keyword">return</span> name;<br> <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br> <br>        <span class="hljs-keyword">this</span>.name = name;<br> <br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br> <br>        <span class="hljs-keyword">return</span> age;<br> <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br> <br>        <span class="hljs-keyword">this</span>.age = age;<br> <br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h3><p> 继承关键字：<code>extends</code> </p>
<h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h4><p>在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类称作子类，现有类被称作父类或基类，子类会自动拥有父类所有可继承的属性和方法。</p>
<p><strong>简单的说</strong>:  继承是类与类的一种关系，比较像集合中的从属于关系。比如说，狗属于动物。就可以看成狗类继承了动物类，那么狗类就是动物类的子类（派生类），动物类就是狗类的父类（基类）。在Java中是单继承的，也就是说一个子类只有一个父类。 </p>
<h4 id="2-继承的特点："><a href="#2-继承的特点：" class="headerlink" title="2. 继承的特点："></a><strong>2. 继承的特点：</strong></h4><p>（1） 子类比父类强大<br>（2）java是单继承，不能进行多继承。但是可以继承多层子类（<strong>不建议继承超过3层</strong>）<br>（3）子类继承父类，但是对父类的成员变量是无法直接操作，只能通过父类继承过来的setter和getter方法. </p>
<h4 id="3-继承优缺点"><a href="#3-继承优缺点" class="headerlink" title="3.继承优缺点"></a>3.继承优缺点</h4><blockquote>
<p>优点</p>
</blockquote>
<p>  (1)  减少代码量，能很好的提高复用率。<br>  (2)  使类与类之间存在继承关系，是实现多态操作的前提。 </p>
<blockquote>
<p>缺点</p>
</blockquote>
<p>继承使得多个类之间具有了子父类关系，当一个类存在多个子类的时候，如果父类发生变化，那么这些子类会跟着一同变化，造成类与类之间的“强耦合”关系！ </p>
<h4 id="4-继承注意点"><a href="#4-继承注意点" class="headerlink" title="4.继承注意点"></a><strong>4.继承注意点</strong></h4><p> (1) 不要仅仅为了获取某个类的某个功能而去继承这个类<br> (2) 类与类之间要存在所属关系，不能够随意继承 </p>
<h4 id="5-何时使用继承"><a href="#5-何时使用继承" class="headerlink" title="5.何时使用继承"></a><strong>5.何时使用继承</strong></h4><p>（1）具有公共的属性与行为操作的时候，提高复用性<br>（2）具有is–a的所属关系的类与类之间 </p>
<h4 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a><strong>7. 结论</strong></h4><p>（1）执行构造方法创建对象完成对象的初始化时，先执行父类的构造，完成父类的初始化，再执行本类的初始化工作。</p>
<p>（2）第一次创建Phone（父）类，是直接继承Object,而Object是jdk提供的工具类，自然不会有属性，所以Object类只提供了无参的构造，在执行Phone方法时，无论是无参还是有参都会先执行父类Object的无参构造。</p>
<p>（3）但是对于Phone的子类Mobile，必须也要有自己的构造方法，由于构造执行的特性，对于无参构造，先执行了Phone的无参构造，对于有参构造，则先执行父类Phone的有参，然后才执行本类属性sex的初始化。</p>
<p>（4）构造方法constructor中,无论是否显式还是隐式调用super(),子类在创建对象调用时都会执行super();</p>
<p>（5）显式调用构造是在需要通过父类的带参构造来完成子类的带参构造。例如Mobile类带参构造中显示调用的Super(brand,price,service)</p>
<p>（6）对于父类私有的属性，即使子类继承，但是在test.java中，子类是无法直接访问的，在制定子类的带参构造方法时，只能通过调用父类的带参构造来完成。对于父类非私有的属性，子类对象可以直接调用。</p>
<h3 id="三、多态"><a href="#三、多态" class="headerlink" title="三、多态"></a>三、多态</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h4><p>多态指的是对象的多种形态。 多态有两种：引用多态和方法多态。<strong>继承是多态的实现基础。</strong>Java的多态是由类的继承、方法重写以及父类引用指向子类对象体现的。由于一个父类可以有多个子类，多个子类都可以重写父类方法，并且多个不同的子类对象也可以指向同一个父类；这样，程序只有在运行时才能知道具体代表的是哪个子类对象，这就体现了多态。</p>
<p><strong>实例</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义抽象类Animal</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><br><span class="hljs-comment">//定义 Cat类继承Animal抽象类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-comment">//实现shout()方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;喵喵。。。&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//定义Dog类继承Animal抽象类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-comment">//实现shout()方法</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;汪汪。。。&quot;</span>)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//定义测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Animal an1 = <span class="hljs-keyword">new</span> Cat();<br>        Animal an2 = <span class="hljs-keyword">new</span> Dog();<br>        <br>        an1.shout();<br>        an2.shout();<br>    &#125;<br>&#125;<br><br><br><br><br></code></pre></td></tr></table></figure>

<h4 id="2-多态存在的前提（多态的三要素）"><a href="#2-多态存在的前提（多态的三要素）" class="headerlink" title="2. 多态存在的前提（多态的三要素）"></a>2. <strong>多态存在的前提（多态的三要素）</strong></h4><p>(1)  必须有子类和父类，具有继承或实现（继承） </p>
<p>(2) 子类必须重写父类的方法（重写）</p>
<p>(3) 父类的引用变量指向子类的对象（向上转型）  </p>
<h4 id="3-多态优缺点"><a href="#3-多态优缺点" class="headerlink" title="3.多态优缺点"></a>3.多态优缺点</h4><blockquote>
<p>优点</p>
</blockquote>
<p>  A. 可替换性，多态对一存在的代码具有可替代性</p>
<p>  B. 可扩充性：增加的子类不影响已存在的类的特性的运行和操作</p>
<p>  C. 接口性：多态时超类通过方法签名想子类提供了一个公共的接口，由子类来完善或者覆盖它而实现的</p>
<p>  D. 灵活性：在应用中体现了灵活多样的操作，提高了使用的效率</p>
<p>  E. 简化性： 多态简化对应用软件的代码的编写和修改过程，尤其在处理大量的对象的运算和操作时，这个特点尤为突出和重要</p>
<blockquote>
<p>缺点</p>
</blockquote>
<p>只能使用父类的引用访问父类的成员 </p>
<h4 id="4-多态中的成员特点"><a href="#4-多态中的成员特点" class="headerlink" title="4. 多态中的成员特点"></a>4. <strong>多态中的成员特点</strong></h4><p>  成员变量：编译与运行时期都看父类！ 成员方法：编译时期看父类，运行时期看子类 </p>
<p>参考：</p>
<hr>
<p><a href="https://blog.csdn.net/hellosweet1/article/details/81320384">https://blog.csdn.net/hellosweet1/article/details/81320384</a></p>
<p>Java基础入门第二版</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis事务</title>
    <url>/2021/09/28/Redis%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>事务</p>
</blockquote>
<p> redis单条命令是原子性的，但是事务不保证原子性 </p>
<p>redis事务本质：一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行的过程中，会按照顺序执行</p>
<p> <strong>一次性、顺序性、排他性</strong>！执行一系列命令！ </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">------ 队列 set set set 执行------<br></code></pre></td></tr></table></figure>



<p> <strong>事务没有隔离级别的概念</strong> </p>
<p>所有的命令在事务中，并没有被执行！只有发起执行的命令的时候才会执行！Exec</p>
<p><strong>Redis单条命令式保存原子性的，但是事务不保证原子性！</strong></p>
<p>redis事务:</p>
<ul>
<li>开始事务(multi)</li>
<li>命令入队(。。）</li>
<li>执行事务(exec)</li>
</ul>
 <span id="more"></span>

<blockquote>
<p>正常执行事务</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi # 开启事务<br>OK<br><span class="hljs-meta">#</span><span class="bash"> 命令入队</span><br>127.0.0.1:6379&gt; set k1 v1<br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; get k2<br>QUEUED<br>127.0.0.1:6379&gt; set k3 v3<br>QUEUED<br>127.0.0.1:6379&gt; exec # 执行事务<br>1) OK<br>2) OK<br>3) &quot;v2&quot;<br>4) OK<br></code></pre></td></tr></table></figure>



<blockquote>
<p>放弃事务</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; set key1 v1<br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2 <br>QUEUED<br>127.0.0.1:6379&gt; set k3 v3<br>QUEUED<br>127.0.0.1:6379&gt; set k4 v4<br>QUEUED<br>127.0.0.1:6379&gt; DISCARD  # 取消事务<br>OK<br>127.0.0.1:6379&gt; GET k4  # 事务队列中命令都不会被执行<br>(nil)<br></code></pre></td></tr></table></figure>



<blockquote>
<p> 编译型异常(代码有问题，命令有错误)，事务中所有的命令都不会被执行 </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; MULTI <br>OK<br>127.0.0.1:6379&gt; set k1 v1 <br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2 <br>QUEUED<br>127.0.0.1:6379&gt; set k3 v3 <br>QUEUED<br>127.0.0.1:6379&gt; getset k3  # 错误的命令<br>(error) ERR wrong number of arguments for &#x27;getset&#x27; command<br>127.0.0.1:6379&gt; et k4 v4  # 错误的命令<br>(error) ERR unknown command `et`, with args beginning with: `k4`, `v4`, <br>127.0.0.1:6379&gt; set k4 v4<br>QUEUED<br>127.0.0.1:6379&gt; exec<br>(error) EXECABORT Transaction discarded because of previous errors.<br>127.0.0.1:6379&gt; get k4 # 所有的命令都不会被执行！<br>(nil)<br></code></pre></td></tr></table></figure>



<blockquote>
<p> 运行时异常（1/0）， 如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行 的，错误命令抛出异常！  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set k1 &quot;v1&quot;<br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; incr k1 # 会执行的时候失败！<br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; set k3 v3<br>QUEUED<br>127.0.0.1:6379&gt; get k3<br>QUEUED<br>127.0.0.1:6379&gt; exec<br>1) (error) ERR value is not an integer or out of range # 虽然第一条命令报错了，但是<br>依旧正常执行成功了！<br>2) OK<br>3) OK<br>4) &quot;v3&quot;<br>127.0.0.1:6379&gt; get k2<br>&quot;v2&quot;<br>127.0.0.1:6379&gt; get k3<br>&quot;v3&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p> 监控！ Watch （面试常问！）  </p>
</blockquote>
<p> <strong>悲观锁</strong>：</p>
<ul>
<li>很悲观，认为什么时候都会出问题，无论做什么都会加锁！ </li>
</ul>
<p> 乐观锁： </p>
<ul>
<li> 很乐观，认为什么时候都不会出问题，所以不会上锁！ 更新数据的时候去判断一下，在此期间是否 有人修改过这个数据， 获取version </li>
<li> 更新的时候比较 version</li>
</ul>
<blockquote>
<p> Redis测监视测试 </p>
</blockquote>
<p> 正常执行成功！ </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set money 100<br>OK<br>127.0.0.1:6379&gt; set out 0<br>OK<br>127.0.0.1:6379&gt; watch money # 监视 money 对象<br>OK<br>127.0.0.1:6379&gt; multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！<br>OK<br>127.0.0.1:6379&gt; DECRBY money 20<br>QUEUED<br>127.0.0.1:6379&gt; INCRBY out 20<br>QUEUED<br>127.0.0.1:6379&gt; exec<br>1) (integer) 80<br>2) (integer) 20<br></code></pre></td></tr></table></figure>

<p> 测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！ </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; watch money # 监视 money<br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; DECRBY money 10<br>QUEUED<br>127.0.0.1:6379&gt; INCRBY out 10<br>QUEUED<br>127.0.0.1:6379&gt; exec # 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失<br>败！<br>(nil)<br></code></pre></td></tr></table></figure>

<p> 如果修改失败，获取最新的值就好  </p>
<p>参考：<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=8440565446323209776&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=8440565446323209776&amp;spm_id_from=333.337.0.0</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis持久化</title>
    <url>/2021/09/30/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://redis.io/">Redis</a>有两种持久化的方式：快照（<code>RDB</code>文件）和追加式文件（<code>AOF</code>文件）：</p>
<ul>
<li>RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。</li>
<li>AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。</li>
<li>Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。</li>
<li>两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。</li>
</ul>
<h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><blockquote>
<p>工作原理</p>
</blockquote>
<ul>
<li>Redis调用fork()，产生一个子进程</li>
<li>子进程把数据写到一个临时的RDB文件</li>
<li>当子进程写完新的RDB文件后，把旧的RDB文件替换掉</li>
</ul>
<p><img src="/2021/09/30/Redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210930171854270.png"></p>
<p>一般在主从复制中,rdb做备用在从机上</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>RDB文件是一个很简洁的单文件，它保存了某个时间点的Redis数据，很适合用于做备份。你可以设定一个时间点对RDB文件进行归档，这样就能在需要的时候很轻易的把数据恢复到不同的版本</li>
<li>基于上面所描述的特性，RDB很适合用于灾备。单文件很方便就能传输到远程的服务器上</li>
<li>RDB的性能很好，需要进行持久化时，主进程会fork一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的I/O操作</li>
<li>比起AOF，在数据量比较大的情况下，RDB的启动速度更快</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>RDB容易造成数据的丢失。假设每5分钟保存一次快照，如果Redis因为某些原因不能正常工作，那么从上次产生快照到Redis出现问题这段时间的数据就会丢失了</li>
<li>RDB使用<code>fork()</code>产生子进程进行数据的持久化，如果数据比较大的话可能就会花费点时间，造成Redis停止服务几毫秒。如果数据量很大且CPU性能不是很好的时候，停止服务的时间甚至会到1秒</li>
</ol>
<h3 id="文件路径和名称"><a href="#文件路径和名称" class="headerlink" title="文件路径和名称"></a>文件路径和名称</h3><p>默认Redis会把快照文件存储为当前目录下一个名为<code>dump.rdb</code>的文件。要修改文件的存储路径和名称，可以通过修改配置文件<code>redis.conf</code>实现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> RDB文件名，默认为dump.rdb。</span><br>dbfilename dump.rdb<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 文件存放的目录，AOF文件同样存放在此目录下。默认为当前工作目录。</span><br>dir ./<br></code></pre></td></tr></table></figure>



<h3 id="保存点（RDB的启用和禁用）"><a href="#保存点（RDB的启用和禁用）" class="headerlink" title="保存点（RDB的启用和禁用）"></a>保存点（RDB的启用和禁用）</h3><p>可以配置保存点，使Redis如果在每N秒后数据发生了M次改变就保存快照文件。例如下面这个保存点配置表示每60秒，如果数据发生了1000次以上的变动，Redis就会自动保存快照文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">save &lt;seconds&gt; &lt;changes&gt; 格式</span><br>save 60 1000   #60S内如果1000个key发生了修改，Redis就会自动保存快照文件<br></code></pre></td></tr></table></figure>



<p>保存点可以设置多个，Redis的配置文件就默认设置了3个保存点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 可以设置多个</span><br>save 900 1 #900秒后至少1个key有变动<br>save 300 10 #300秒后至少10个key有变动<br>save 60 10000 #60秒后至少10000个key有变动<br></code></pre></td></tr></table></figure>



<p>如果想禁用快照保存的功能，可以通过注释掉所有”save”配置达到，或者在最后一条”save”配置后添加如下的配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">save &quot;&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>触发机制说明</p>
</blockquote>
<ol>
<li>save的规则满足的情况下，会自动触发rdb规则</li>
<li>执行 flushall 命令，也会触发rdb规则！</li>
<li>退出redis，也会产生 rdb 文件</li>
</ol>
<blockquote>
<p>如何恢复rdb文件</p>
</blockquote>
<ol>
<li>只需要将rdb文件放在redis启动目录即可，redis启动的时候会自动检查dump.rdb 恢复其中 的数据</li>
<li>查看存放目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; config get dir<br>1) &quot;dir&quot;<br>2) &quot;/usr/local/bin&quot; # 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据<br></code></pre></td></tr></table></figure>



<h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>快照并不是很可靠。如果你的电脑突然宕机了，或者电源断了，又或者不小心杀掉了进程，那么最新的数据就会丢失。而AOF文件则提供了一种更为可靠的持久化方式。每当Redis接受到会修改数据集的命令时，就会把命令追加到AOF文件里，当你重启Redis时，AOF里的命令会被重新执行一次，重建数据。</p>
<blockquote>
<p>工作原理</p>
</blockquote>
<p><img src="/2021/09/30/Redis%E6%8C%81%E4%B9%85%E5%8C%96/image-20210930180234429.png"></p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol>
<li>比RDB可靠。你可以制定不同的fsync策略：不进行fsync、每秒fsync一次和每次查询进行fsync。默认是每秒fsync一次。这意味着你最多丢失一秒钟的数据。</li>
<li>AOF日志文件是一个纯追加的文件。就算是遇到突然停电的情况，也不会出现日志的定位或者损坏问题。甚至如果因为某些原因（例如磁盘满了）命令只写了一半到日志文件里，我们也可以用<code>redis-check-aof</code>这个工具很简单的进行修复</li>
<li> 当AOF文件太大时，Redis会自动在后台进行重写。重写很安全，因为重写是在一个新的文件上进行，同时Redis会继续往旧的文件追加数据。新文件上会写入能重建当前数据集的最小操作命令的集合。当新文件重写完，Redis会把新旧文件进行切换，然后开始把数据写到新文件上 </li>
<li> AOF把操作命令以简单易懂的格式一条接一条的保存在文件里，很容易导出来用于恢复数据。例如我们不小心用<code>FLUSHALL</code>命令把所有数据刷掉了，只要文件没有被重写，我们可以把服务停掉，把最后那条命令删掉，然后重启服务，这样就能把被刷掉的数据恢复回来 </li>
</ol>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li> 在相同的数据集下，AOF文件的大小一般会比RDB文件大 </li>
<li> 在某些fsync策略下，AOF的速度会比RDB慢。通常fsync设置为每秒一次就能获得比较高的性能，而在禁止fsync的情况下速度可以达到RDB的水平 </li>
<li> 在过去曾经发现一些很罕见的BUG导致使用AOF重建的数据跟原数据不一致的问题 </li>
</ol>
<h3 id="启用AOF"><a href="#启用AOF" class="headerlink" title="启用AOF"></a>启用AOF</h3><p> 把配置项<code>appendonly</code>设为<code>yes</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">设置开启aof</span><br>appendonly yes<br></code></pre></td></tr></table></figure>



<h3 id="文件路径和名称-1"><a href="#文件路径和名称-1" class="headerlink" title="文件路径和名称"></a>文件路径和名称</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 文件存放目录，与RDB共用。默认为当前工作目录。</span><br>dir ./<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 默认文件名为appendonly.aof</span><br>appendfilename &quot;appendonly.aof&quot;<br></code></pre></td></tr></table></figure>



<h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p> 你可以配置Redis调用fsync的频率，有三个选项： </p>
<ol>
<li>每当有新命令追加到AOF的时候调用fsync。速度最慢，但是最安全</li>
<li> 每秒fsync一次。速度快（2.4版本跟快照方式速度差不多），安全性不错（最多丢失1秒的数据） </li>
<li> 从不fsync，交由系统去处理。这个方式速度最快，但是安全性一般 </li>
</ol>
<p> 推荐使用每秒fsync一次的方式（默认的方式），因为它速度快，安全性也不错。相关配置如下： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> appendfsync always</span><br>appendfsync everysec<br><span class="hljs-meta">#</span><span class="bash"> appendfsync no</span><br></code></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="日志重写"><a href="#日志重写" class="headerlink" title="日志重写"></a>日志重写</h3><p>​       随着写操作的不断增加，AOF文件会越来越大。例如你递增一个计数器100次，那么最终结果就是数据集里的计数器的值为最终的递增结果，但是AOF文件里却会把这100次操作完整的记录下来。而事实上要恢复这个记录，只需要1个命令就行了，也就是说AOF文件里那100条命令其实可以精简为1条。所以Redis支持这样一个功能：在不中断服务的情况下在后台重建AOF文件 </p>
<p> <strong>工作原理如下 :</strong></p>
<ol>
<li> Redis调用fork()，产生一个子进程 </li>
<li> 子进程把新的AOF写到一个临时文件里 </li>
<li> 主进程持续把新的变动写到内存里的buffer，同时也会把这些新的变动写到旧的AOF里，这样即使重写失败也能保证数据的安全 </li>
<li> 当子进程完成文件的重写后，主进程会获得一个信号，然后把内存里的buffer追加到子进程生成的那个新AOF里 </li>
</ol>
<p><strong>我们可以通过配置设置日志重写的条件：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Redis会记住自从上一次重写后AOF文件的大小（如果自Redis启动后还没重写过，则记住启动时使用的AOF文件的大小）。</span><br><span class="hljs-meta">#</span><span class="bash"> 如果当前的文件大小比起记住的那个大小超过指定的百分比，则会触发重写。</span><br><span class="hljs-meta">#</span><span class="bash"> 同时需要设置一个文件大小最小值，只有大于这个值文件才会重写，以防文件很小，但是已经达到百分比的情况。</span><br><br>auto-aof-rewrite-percentage 100<br>auto-aof-rewrite-min-size 64mb<br></code></pre></td></tr></table></figure>



<p> 要禁用自动的日志重写功能，我们可以把百分比设置为0： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">auto-aof-rewrite-percentage 0<br></code></pre></td></tr></table></figure>

<p><strong>Redis 2.4以上才可以自动进行日志重写，之前的版本需要手动运行<a href="http://redis.io/commands/bgrewriteaof">BGREWRITEAOF</a>这个命令。</strong> </p>
<h3 id="数据损坏修复"><a href="#数据损坏修复" class="headerlink" title="数据损坏修复"></a>数据损坏修复</h3><p> 如果因为某些原因（例如服务器崩溃）AOF文件损坏了，导致Redis加载不了，可以通过以下方式进行修复： </p>
<ul>
<li> 备份AOF文件 </li>
<li> 使用<code>redis-check-aof</code>命令修复原始的AOF文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-check-aof --fix   aof文件<br></code></pre></td></tr></table></figure>

<ul>
<li> 可以使用<code>diff -u</code>命令看下两个文件的差异 </li>
<li> 使用修复过的文件重启Redis服务 </li>
</ul>
<h3 id="从RDB切换到AOF"><a href="#从RDB切换到AOF" class="headerlink" title="从RDB切换到AOF"></a>从RDB切换到AOF</h3><p> 这里只说Redis &gt;= 2.2版本的方式： </p>
<ul>
<li><p>备份一个最新的<code>dump.rdb</code>的文件，并把备份文件放在一个安全的地方。</p>
</li>
<li><p>运行以下两条命令：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">$ redis-cli<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span> appendonly <span class="hljs-literal">yes</span><br>$ redis-cli<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span> save <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure></li>
<li><p>确保数据跟切换前一致。</p>
</li>
<li><p>确保数据正确的写到AOF文件里。</p>
</li>
</ul>
<p><strong>第二条命令是用来禁用RDB的持久化方式，但是这不是必须的，因为你可以同时启用两种持久化方式。</strong></p>
<p><strong>记得对配置文件<code>redis.conf</code>进行编辑启用AOF，因为命令行方式修改配置在重启Redis后就会失效。</strong></p>
<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h3 id="建议的备份方法："><a href="#建议的备份方法：" class="headerlink" title="建议的备份方法："></a>建议的备份方法：</h3><ul>
<li>创建一个定时任务，每小时和每天创建一个快照，保存在不同的文件夹里。</li>
<li>定时任务运行时，把太旧的文件进行删除。例如只保留48小时的按小时创建的快照和一到两个月的按天创建的快照。</li>
<li>每天确保一次把快照文件传输到数据中心外的地方进行保存，至少不能保存在Redis服务所在的服务器。</li>
</ul>
<p>参考：</p>
<hr>
<p>​      <a href="https://segmentfault.com/a/1190000002906345">https://segmentfault.com/a/1190000002906345</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的三种特殊类型</title>
    <url>/2021/09/26/Redis%E7%9A%84%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial 地理位置"></a>Geospatial 地理位置</h3><p><strong>朋友的定位，附近的人，打车距离计算？ Redis 的 Geo 在Redis3.2 版本就推出了！ 这个功能可以推算地理位置的信息，两地之间的距离，方圆 几里的人！</strong> </p>
 <span id="more"></span>

<p>官方文档：<a href="https://www.redis.net.cn/order/3685.html">https://www.redis.net.cn/order/3685.html</a></p>
<p>从官网中我们可以看到此数据类型只有<strong>六个命令</strong></p>
<p><img src="/2021/09/26/Redis%E7%9A%84%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B/1632661034050.png"></p>
<p>下面就分别举例来做介绍</p>
<blockquote>
<h4 id="GEOADD"><a href="#GEOADD" class="headerlink" title="GEOADD"></a><strong>GEOADD</strong></h4></blockquote>
<p>官方说明：将指定的地理空间位置（纬度、经度、名称）添加到指定的key中</p>
<p> 该命令以采用标准格式的参数x,y,所以经度必须在纬度之前 ， 规定有如下</p>
<ol>
<li> 有效的经度从-180度到180度 </li>
<li>有效的纬度从-85.05112878度到85.05112878度。</li>
<li> 当坐标位置超出上述指定范围时，该命令将会返回一个错误。 </li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">geo使用举例</span><br><span class="hljs-meta">#</span><span class="bash">通过百度坐标拾取可以获取指定城市坐标 106.680848,26.642216 当前我获取的是自己所在城市的坐标</span><br>127.0.0.1:6379&gt; GEOADD china:city 106.680848 26.642216 guiyang<br>(integer) 1<br><br>127.0.0.1:6379&gt; GEOADD china:city 121.466742 31.231236 shanghai<br>(integer) 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">可以同时添加多个坐标</span><br>127.0.0.1:6379&gt; GEOADD china:city 114.100924 22.675499 shengzhen  106.561887 29.564724 chongqing<br>(integer) 2<br><br></code></pre></td></tr></table></figure>



<blockquote>
<p><strong>GEOPOS</strong>  </p>
</blockquote>
<p> 从<code>key</code>里返回所有给定位置元素的位置（经度和纬度） </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">需要先指定</span><br>127.0.0.1:6379&gt; GEOPOS china:city shanghai shengzhen<br>1) 1) &quot;121.46674007177352905&quot;<br>   2) &quot;31.23123598368359666&quot;<br>2) 1) &quot;114.10092204809188843&quot;<br>   2) &quot;22.6755001616335008&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p> <strong>GEODIST</strong> </p>
</blockquote>
<p>获取两个给定位置之间的距离, 如果两个位置之间的其中一个不存在， 那么命令返回空值 </p>
<p>指定单位的参数 unit 必须是以下单位的其中一个：</p>
<ul>
<li><strong>m</strong> 表示单位为米。</li>
<li><strong>km</strong> 表示单位为千米。</li>
<li><strong>mi</strong> 表示单位为英里。</li>
<li><strong>ft</strong> 表示单位为英尺。</li>
</ul>
<p>如果用户没有显式地指定单位参数， 那么 <code>GEODIST</code> 默认使用米作为单位。</p>
<p><code>GEODIST</code> 命令在计算距离时会假设地球为完美的球形， 在极限情况下， 这一假设最大会造成 0.5% 的误差。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">输入两个城市  并指定计量单位 这里指定的km</span><br>127.0.0.1:6379&gt; GEODIST china:city shanghai chongqing km<br>&quot;1440.7483&quot;<br><br></code></pre></td></tr></table></figure>



<blockquote>
<p><strong>GEORADIUS</strong></p>
</blockquote>
<p>给定的经纬度为中心， 找出某一半径内的元素</p>
<p>范围可以使用以下其中一个单位：</p>
<ul>
<li><strong>m</strong> 表示单位为米。</li>
<li><strong>km</strong> 表示单位为千米。</li>
<li><strong>mi</strong> 表示单位为英里。</li>
<li><strong>ft</strong> 表示单位为英尺。</li>
</ul>
<p>在给定以下可选项时， 命令会返回额外的信息：</p>
<ul>
<li><code>WITHDIST</code>: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</li>
<li><code>WITHCOORD</code>: 将位置元素的经度和维度也一并返回。</li>
<li><code>WITHHASH</code>: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</li>
</ul>
<p>命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式：</p>
<ul>
<li><code>ASC</code>: 根据中心的位置， 按照从近到远的方式返回位置元素。</li>
<li><code>DESC</code>: 根据中心的位置， 按照从远到近的方式返回位置元素。</li>
</ul>
<p>例如：</p>
<p> 我附近的人？ （获得所有附近的人的地址，定位！）通过半径来查询！ 获得指定数量的人</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">以110，30 这个经度为中心寻找方圆一千公里以内的城市</span><br>127.0.0.1:6379&gt; GEORADIUS china:city  110 30 1000 km<br>1) &quot;guiyang&quot;<br>2) &quot;chongqing&quot;<br>3) &quot;shengzhen&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 将具体距离、经纬度信息也一并返回</span><br>127.0.0.1:6379&gt; GEORADIUS china:city  110 30 1000 km WITHCOORD WITHDIST<br>1) 1) &quot;guiyang&quot;<br>   2) &quot;495.0114&quot;<br>   3) 1) &quot;106.68084830045700073&quot;<br>      2) &quot;26.64221710938331711&quot;<br>2) 1) &quot;chongqing&quot;<br>   2) &quot;335.3982&quot;<br>   3) 1) &quot;106.56188696622848511&quot;<br>      2) &quot;29.56472525888953129&quot;<br>3) 1) &quot;shengzhen&quot;<br>   2) &quot;911.2583&quot;<br>   3) 1) &quot;114.10092204809188843&quot;<br>      2) &quot;22.6755001616335008&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>GEORADIUSBYMEMBER</p>
</blockquote>
<p>找出位于指定范围内的元素，中心点是由给定的位置元素决定</p>
<p>这个命令和 <a href="https://www.redis.net.cn/order/3689.html">GEORADIUS</a> 命令一样， 都可以找出位于指定范围内的元素， 但是 <code>GEORADIUSBYMEMBER</code> 的中心点是由给定的位置元素决定的， 而不是像 <a href="https://www.redis.net.cn/order/3689.html">GEORADIUS</a> 那样， 使用输入的经度和纬度来决定中心点 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 找出位于指定元素周围的其他元素！</span><br>127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city chongqing 500 km<br>1) &quot;guiyang&quot;<br>2) &quot;chongqing&quot;<br></code></pre></td></tr></table></figure>

<p> GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; ZRANGE china:city 0 -1 # 查看地图中全部的元素<br>1) &quot;chongqi&quot;<br>2) &quot;xian&quot;<br>3) &quot;shengzhen&quot;<br>4) &quot;hangzhou&quot;<br>5) &quot;shanghai&quot;<br>6) &quot;beijing&quot;<br>127.0.0.1:6379&gt; zrem china:city beijing # 移除指定元素！<br>(integer) 1<br>127.0.0.1:6379&gt; ZRANGE china:city 0 -1<br>1) &quot;chongqi&quot;<br>2) &quot;xian&quot;<br>3) &quot;shengzhen&quot;<br>4) &quot;hangzhou&quot;<br>5) &quot;shanghai&quot;<br></code></pre></td></tr></table></figure>



<h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><blockquote>
<p>什么是基数？</p>
</blockquote>
<p> 比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。 </p>
<blockquote>
<p>简介</p>
</blockquote>
<p>Redis 2.8.9 版本就更新了 Hyperloglog 数据结构！ Redis Hyperloglog 基数统计的算法！</p>
<p>优点：占用的内存是固定，2^64 不同的元素的技术，只需要废 12KB内存！如果要从内存角度来比较的话 Hyperloglog 首选！</p>
<p>网页的 UV （一个人访问一个网站多次，但是还是算作一个人！）</p>
<p>传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 ! 这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id；</p>
<p>0.81% 错误率！ 统计UV任务，可以忽略不计的！</p>
<blockquote>
<p>实例</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> PFADD w3ckey &quot;redis&quot;<br> <br><span class="hljs-number">1</span>) (<span class="hljs-type">integer</span>) <span class="hljs-number">1</span><br> <br>redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> PFADD w3ckey &quot;mongodb&quot;<br> <br><span class="hljs-number">1</span>) (<span class="hljs-type">integer</span>) <span class="hljs-number">1</span><br> <br>redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> PFADD w3ckey &quot;mysql&quot;<br> <br><span class="hljs-number">1</span>) (<span class="hljs-type">integer</span>) <span class="hljs-number">1</span><br> <br>redis <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> PFCOUNT w3ckey<br> <br>(<span class="hljs-type">integer</span>) <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p>如果允许容错，那么一定可以使用 Hyperloglog</p>
<p>如果不允许容错，就使用 set 或者自己的数据类型即可</p>
<h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><blockquote>
<p>位存储</p>
</blockquote>
<p>统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡，365打卡！ 两个状态的，都可以使用Bitmaps！ Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！ 365 天 = 365 bit 1字节 = 8bit 46 个字节左右！</p>
<blockquote>
<p>测试</p>
</blockquote>
<p>使用bitmap 来记录 周一到周日的打卡！</p>
<p>周一：1 周二：0 周三：0 周四：1 ……</p>
<p><img src="/2021/09/26/Redis%E7%9A%84%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B/1632664931110.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">0</span> <span class="hljs-number">1</span> <br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">1</span> <span class="hljs-number">0</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">2</span> <span class="hljs-number">0</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">3</span> <span class="hljs-number">1</span> <br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">4</span> <span class="hljs-number">1</span> <br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">5</span> <span class="hljs-number">1</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> setbit sign <span class="hljs-number">6</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>查看某一天是否有打卡！</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> getbit sign <span class="hljs-number">3</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> getbit sign <span class="hljs-number">6</span><br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>统计操作，统计 打卡的天数！</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span><span class="hljs-operator">&gt;</span> bitcount sign # 统计这周的打卡记录，就可以看到是否有全勤！<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>



<p>参考：</p>
<p>​       Redis官网：<a href="https://www.redis.net.cn/">https://www.redis.net.cn/</a></p>
<p>​       B站狂神说Java:<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0</a></p>
<p>​      </p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis缓存穿透和雪崩</title>
    <url>/2021/10/11/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="服务的高可用问题"><a href="#服务的高可用问题" class="headerlink" title="服务的高可用问题"></a>服务的高可用问题</h3><p>​       Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一 些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。 另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。  </p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><blockquote>
<p>概念  </p>
</blockquote>
<p>​    缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中,于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中(秒杀!)，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了 缓存穿透。 </p>
<p><img src="/2021/10/11/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/1633962251731.png"></p>
<blockquote>
<p>解决方案  </p>
</blockquote>
<p><strong>布隆过滤器</strong>  </p>
<p>​     布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则 丢弃，从而避免了对底层存储系统的查询压力； </p>
<p><img src="/2021/10/11/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/1633962830773.png"></p>
<p><strong>缓存空对象</strong> </p>
<p>​    当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数 据将会从缓存中获取，保护了后端数据源；  </p>
<p>但是这种方法会存在两个问题： </p>
<p>1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多 的空值的键； </p>
<p>2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于 需要保持一致性的业务会有影响。 </p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><blockquote>
<p>概述 </p>
</blockquote>
<p>​      这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中 对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一 个屏障上凿开了一个洞。 </p>
<p>​     当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访 问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。 </p>
<p><strong>解决方案</strong></p>
<blockquote>
<p>设置热点数据永不过期   </p>
</blockquote>
<p>​     从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。  </p>
<p> <strong>加互斥锁</strong></p>
<p>​     分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布 式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考 验很大。  </p>
<p><img src="/2021/10/11/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/1633963512731.png"></p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p> <strong>概念</strong>  </p>
<p>​      缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机！ </p>
<p>​      产生雪崩的原因之一，比如双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。 </p>
<p><img src="/2021/10/11/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/1633963929642.png"></p>
<p>​      其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知 的，很有可能瞬间就把数据库压垮。 </p>
<blockquote>
<p>解决方案  </p>
</blockquote>
<p><strong>redis高可用</strong> </p>
<p>​      这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。</p>
<p><strong>限流降级</strong></p>
<p>​      这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 </p>
<p><strong>数据预热</strong> </p>
<p>​     数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数 据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。 </p>
<p>引用:</p>
<hr>
<p>狂神说Java:<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合Flowable工作流(1)</title>
    <url>/2021/09/17/SpringBoot%E6%95%B4%E5%90%88Flowable%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Flowable流程图"><a href="#Flowable流程图" class="headerlink" title="Flowable流程图"></a>Flowable流程图</h1><h3 id="Flowable是什么？"><a href="#Flowable是什么？" class="headerlink" title="Flowable是什么？"></a>Flowable是什么？</h3><p> Flowable是一个使用Java编写的轻量级业务流程引擎。Flowable流程引擎可用于部署BPMN 2.0流程定义（用于定义流程的行业XML标准）， 创建这些流程定义的流程实例，进行查询，访问运行中或历史的流程实例与相关数据，等等。</p>
<p> Flowable可以十分灵活地加入你的应用/服务/构架。可以将JAR形式发布的Flowable库加入应用或服务，来<em>嵌入</em>引擎。 以JAR形式发布使Flowable可以轻易加入任何Java环境：Java SE；Tomcat、Jetty或Spring之类的servlet容器；JBoss或WebSphere之类的Java EE服务器，等等。 另外，也可以使用Flowable REST API进行HTTP调用。也有许多Flowable应用（Flowable Modeler, Flowable Admin, Flowable IDM 与 Flowable Task），提供了直接可用的UI示例，可以使用流程与任务。 </p>
 <span id="more"></span>

<p>Flowable流程需要先画流程图，然后再根据流程图引用自项目中，所以以下先画好流程图，然后再进行集成Spring boot生成</p>
<blockquote>
<p>部署FlowableUi</p>
</blockquote>
<ol>
<li><p>官方网址下载FlowableUI：<a href="https://flowable.com/open-source/downloads/">https://flowable.com/open-source/downloads/</a></p>
</li>
<li><p>将下载好之后的压缩包进行解压进入文件夹之后会看到一个war包文件下，打开文件夹将会有一个（flowable-ui.war）文件</p>
</li>
<li><p>安装部署Tomcat，安装部署就略过了百度都有，将上面的war包放入tomcat的webapps目录下，并在当前目录下执行以下命令</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>flowable-ui.war<br></code></pre></td></tr></table></figure></li>
<li><p>启动之后，有一行日志：Tomcat started on port(s): 8080 (http) with context path ‘/flowable-ui’，从以上可以看出端口默认为8080，路径为：/flowable-ui 。即访问：<a href="http://localhost:8080/flowable-ui%EF%BC%8C">http://localhost:8080/flowable-ui，</a></p>
<p>  账号：admin 密码：test </p>
</li>
</ol>
<blockquote>
<p>画流程图</p>
</blockquote>
<p><strong>登录之后</strong> </p>
<p><img src="https://res.cloudinary.com/dlzf16hlo/image/upload/v1632027508/blog/1632027486_1_qqpru0.png"></p>
<p><strong>选择建模器应用程序</strong></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis三种集群模式之Cluster模式</title>
    <url>/2021/10/07/redis-cluster%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1、redis-cluter设计"><a href="#1、redis-cluter设计" class="headerlink" title="1、redis-cluter设计"></a>1、redis-cluter设计</h2><p> Redis集群搭建的方式有多种，开始使用主从模式做集群，若master宕机需要手动配置slave转为master；后来为了高可用提出来(redis-sentinel)<strong>哨兵</strong>模式，该模式下有一个哨兵监视master和slave，若master宕机可自动将slave转为master，但它也有一个问题，就是不能动态扩充；从redis 3.0之后版本支持redis-cluster集群. </p>
<p> Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。其redis-cluster架构图如下： </p>
<p><img src="/2021/10/07/redis-cluster%E9%9B%86%E7%BE%A4/1633829297415.png"></p>
<p> 其结构特点： </p>
<ol>
<li> 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。 </li>
<li> 节点的fail是通过集群中超过半数的节点检测失效时才生效。 </li>
<li> 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。 </li>
<li> redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配）,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value。 </li>
<li> Redis集群预分好16384个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。 </li>
</ol>
<h2 id="2、redis-cluster节点分配"><a href="#2、redis-cluster节点分配" class="headerlink" title="2、redis cluster节点分配"></a>2、redis cluster节点分配</h2><p>现在我们是三个节点分别是：A,B,C 三个节点，它们可以是一台机器上的三个端口，也可以是三台不同服务器。那么，采用哈希槽（hash solt）的方式来分配16384个solt的话，他们三个节点分别承担的solt区间是：</p>
<ul>
<li><p>节点A覆盖0－5460; </p>
</li>
<li><p>节点B覆盖5461－10922; </p>
</li>
<li><p>节点C覆盖10923－16383；</p>
</li>
</ul>
<p> 获取数据： </p>
<p>​     如果存入一个值，按照redis-cluster哈希槽的算法：CRC16(‘key’)%16384 = 6782。那么就会把这个key的存储分配到 B 上。同样，当我连接（A，B，C）任何一个节点，想获取’key’这个key时，也会这样的算法，然后内部跳转到B节点上获取数据新增一个主节点：</p>
<p> 新增一个节点D，redis cluster的这种做法是从各个节点的前面各拿取一部分slot到D上，我会在接下来的实践中实验。大致就会变成这样： </p>
<ul>
<li>节点A覆盖1365-5460</li>
<li> 节点B覆盖6827-10922</li>
<li> 节点C覆盖12288-16383</li>
<li> 节点D覆盖0-1364,5461-6826,10923-12287 </li>
</ul>
<h2 id="3、-Redis-Cluster主从模式"><a href="#3、-Redis-Cluster主从模式" class="headerlink" title="3、 Redis Cluster主从模式"></a>3、 <strong>Redis Cluster主从模式</strong></h2><p>​        redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。</p>
<p>​       上面那个例子里, 集群有ABC三个主节点, 如果这3个节点都没有加入从节点，如果B挂掉了，我们就无法访问整个集群了。A和C的slot也无法访问。所以我们在集群建立的时候，一定要为每个主节点都添加了从节点, 比如像这样, 集群包含主节点A、B、C, 以及从节点A1、B1、C1, 那么即使B挂掉系统也可以继续正确工作。B1节点替代了B节点，所以Redis集群将会选择B1节点作为新的主节点，集群将会继续正确地提供服务。 当B重新开启后，它就会变成B1的从节点。不过需要注意，如果节点B和B1同时挂了，Redis集群就无法继续正确地提供服务了。</p>
<h2 id="4、redis6-2-5-集群部署"><a href="#4、redis6-2-5-集群部署" class="headerlink" title="4、redis6.2.5 集群部署"></a><strong>4、redis6.2.5 集群部署</strong></h2><p><strong>集群中至少应该有奇数个节点，所以至少有三个节点，每个节点至少有一个备份节点，所以下面使用6节点（主节点、备份节点由redis-cluster集群确定）。</strong></p>
<h3 id="4-1-准备工作"><a href="#4-1-准备工作" class="headerlink" title="4.1 准备工作"></a><strong>4.1 准备工作</strong></h3><p>   本文使用两台centOS7主机，一台机器3个节点，创建出3 master、3 salve 环境，master（192.168.1.8） salve(192.168.1.10) </p>
<h3 id="4-2-创建Redis节点"><a href="#4-2-创建Redis节点" class="headerlink" title="4.2 创建Redis节点"></a>4.2 创建Redis节点</h3><p>首先在指定目录下创建  redis_cluster </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mkdir /software01/redis_cluster<br></code></pre></td></tr></table></figure>

<p> 在 redis_cluster 目录下，创建名为 6379、6380、6381的目录，并将 redis.conf 拷贝到这六个目录中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> mkdir 6379 6380 6381、6382、6383、6384</span><br><span class="hljs-meta">#</span><span class="bash"> cp redis.conf redis_cluster/6379</span><br><span class="hljs-meta">#</span><span class="bash"> cp redis.conf redis_cluster/6380</span> <br><span class="hljs-meta">#</span><span class="bash"> cp redis.conf redis_cluster/6381</span><br></code></pre></td></tr></table></figure>

<p> 分别修改这三个配置文件，修改如下内容 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">port 6379　　　　　　#端口6379 6380 6381、6382、6383、6384 <br>bind 本机ip 　　　　 #默认ip为127.0.0.1 需要改为其他节点机器可访问的ip 否则创建集群时无法访问对应的端口，无法创建集群 <br>daemonize yes 　　  #redis后台运行 <br>pidfile /var/run/redis_6379.pid 　　#pidfile文件对应6379,6380,6381 <br>cluster-enabled yes 　　　　　　　　　#开启集群 <br>cluster-config-file nodes_6379.conf #集群的配置 配置文件首次启动自动生成 6379,6380,6381 <br>cluster-node-timeout 15000 　　　　　　#请求超时 默认15秒，可自行设置  <br>appendonly yes 　　　　　　　　　　　　#aof日志开启 有需要就开启，它会每次写操作都记录一条日志<br></code></pre></td></tr></table></figure>



<p>接着在另外一台机器上（192.168.1.10），的操作重复以上三步，只是把目录改为6382、6383、6384，对应的配置文件也按照这个规则修改即可. </p>
<h3 id="4-3-启动各节点"><a href="#4-3-启动各节点" class="headerlink" title="4.3 启动各节点"></a>4.3 启动各节点</h3><p> 第一台机器上执行: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# redis-server /root/software01/redis_cluster/6379/redis.conf <br>[root@centos7 bin]# redis-server /root/software01/redis_cluster/6380/redis.conf <br>[root@centos7 bin]# redis-server /root/software01/redis_cluster/6381/redis.conf <br></code></pre></td></tr></table></figure>

<p> 另外一台机器上执行: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# redis-server /root/software01/redis_cluster/6382/redis.conf <br>[root@centos7 bin]# redis-server /root/software01/redis_cluster/6383/redis.conf <br>[root@centos7 bin]# redis-server /root/software01/redis_cluster/6384/redis.conf <br></code></pre></td></tr></table></figure>



<h3 id="4-4-检查-redis-启动情况"><a href="#4-4-检查-redis-启动情况" class="headerlink" title="4.4 检查 redis 启动情况"></a>4.4 检查 redis 启动情况</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> ps -ef | grep redis //查看redis启动情况</span><br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/07/redis-cluster%E9%9B%86%E7%BE%A4/1633850372740.png"></p>
<p><img src="/2021/10/07/redis-cluster%E9%9B%86%E7%BE%A4/1633850438157.png"></p>
<h3 id="4-5-创建集群"><a href="#4-5-创建集群" class="headerlink" title="4.5 创建集群"></a>4.5 创建集群</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# ./redis-cli --cluster create 192.168.1.10:6379 192.168.1.10:6380 192.168.1.10:6381 192.168.1.8:6382 192.168.1.8:6383 192.168.1.8:6384 --cluster-replicas 1<br></code></pre></td></tr></table></figure>

<p> <strong>注意：Redis Cluster最低要求是3个主节点，如果需要集群需要认证，则在最后加入 -a xx 即可。</strong> </p>
<p>以上命令执行完成后</p>
<p><img src="/2021/10/07/redis-cluster%E9%9B%86%E7%BE%A4/1633868265946.png"></p>
<p>输入yes之后将会出现以下信息</p>
<p><img src="/2021/10/07/redis-cluster%E9%9B%86%E7%BE%A4/1633868317543.png"></p>
<h3 id="4-6-测试"><a href="#4-6-测试" class="headerlink" title="4.6 测试"></a>4.6 测试</h3><p> 在第一台机器上连接集群的6379端口的节点，在另外一台连接6382节点，连接方式为  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli -h 192.168.1.10 -c -p 6379  #-h 连接主机的ip <br>                                      #-c连接集群结点时使用，此选项可防止moved和ask异常 <br>                                      #-p 端口   <br>                                      #-a 如果设置密码 可加上-a进行密码验证登录 <br></code></pre></td></tr></table></figure>

<p>在6379节点设置key值，然后在6382获取key的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">在节点6379上设置值</span><br>192.168.1.10:6379&gt; set k1 v1<br><span class="hljs-meta">-&gt;</span><span class="bash"> Redirected to slot [12706] located at 192.168.1.10:6380</span><br>OK<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">在6382也可以获取值</span><br>192.168.1.8:6382&gt; get k1<br><span class="hljs-meta">-&gt;</span><span class="bash"> Redirected to slot [12706] located at 192.168.1.10:6380</span><br>&quot;v1&quot;<br></code></pre></td></tr></table></figure>

<p>结果分别如下：</p>
<p><img src="/2021/10/07/redis-cluster%E9%9B%86%E7%BE%A4/1633869331466.png"></p>
<p><img src="/2021/10/07/redis-cluster%E9%9B%86%E7%BE%A4/1633869348246.png"></p>
<h2 id="5-Cluster模式的优缺点"><a href="#5-Cluster模式的优缺点" class="headerlink" title="5. Cluster模式的优缺点"></a>5. Cluster模式的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li>无中心架构，数据按照slot分布在多个节点。</li>
<li>集群中的每个节点都是平等的关系，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</li>
<li>可线性扩展到1000多个节点，节点可动态添加或删除</li>
<li>能够实现自动故障转移，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色转换</li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li>客户端实现复杂，驱动要求实现Smart Client，缓存slots mapping信息并及时更新，提高了开发难度。目前仅JedisCluster相对成熟，异常处理还不完善，比如常见的“max redirect exception”</li>
<li>节点会因为某些原因发生阻塞（阻塞时间大于 cluster-node-timeout）被判断下线，这种failover是没有必要的</li>
<li>数据通过异步复制，不保证数据的强一致性</li>
<li>slave充当“冷备”，不能缓解读压力</li>
<li>批量操作限制，目前只支持具有相同slot值的key执行批量操作，对mset、mget、sunion等操作支持不友好</li>
<li>key事务操作支持有线，只支持多key在同一节点的事务操作，多key分布不同节点时无法使用事务功能</li>
<li>不支持多数据库空间，单机redis可以支持16个db，集群模式下只能使用一个，即db 0</li>
</ol>
<p> <strong>Redis Cluster模式不建议使用pipeline和multi-keys操作，减少max redirect产生的场景。</strong> </p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>Redis集群方案的三种模式，其中主从复制模式能实现读写分离，但是不能自动故障转移；哨兵模式基于主从复制模式，能实现自动故障转移，达到高可用，但与主从复制模式一样，不能在线扩容，容量受限于单机的配置；Cluster模式通过无中心化架构，实现分布式存储，可进行线性扩展，也能高可用，但对于像批量操作、事务操作等的支持性不够好。三种模式各有优缺点，可根据实际场景进行选择。</p>
<h2 id="附：Redis集群各种参数设置"><a href="#附：Redis集群各种参数设置" class="headerlink" title="附：Redis集群各种参数设置"></a>附：Redis集群各种参数设置</h2><h3 id="1-创建集群主节点"><a href="#1-创建集群主节点" class="headerlink" title="1. 创建集群主节点"></a>1. 创建集群主节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster create 192.168.1.10:6379 192.168.1.10:6380 192.168.1.10:6381<br></code></pre></td></tr></table></figure>

<h3 id="2-创建集群主从节点"><a href="#2-创建集群主从节点" class="headerlink" title="2. 创建集群主从节点"></a>2. 创建集群主从节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">/redis-cli --cluster create 192.168.1.10:6379 192.168.1.10:6380 192.168.1.10:6381 192.168.1.8:6382 192.168.1.8:6383 192.168.1.8:6384 --cluster-replicas 1<br></code></pre></td></tr></table></figure>

<p> <strong>说明：–cluster-replicas 参数为数字，1表示每个主节点需要1个从节点。</strong> </p>
<p>通过该方式创建的带有从节点的机器不能够自己手动指定主节点，所以如果需要指定的话，需要自己手动指定，先使用1或3创建好主节点后，再通过4来处理。 </p>
<h3 id="3-添加集群主节点"><a href="#3-添加集群主节点" class="headerlink" title="3. 添加集群主节点"></a>3. 添加集群主节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster add-node 192.168.1.8:6382 192.168.1.10:6379 <br></code></pre></td></tr></table></figure>

<p>说明：为一个指定集群添加节点，需要先连到该集群的任意一个节点IP（192.168.1.10:6379），再把新节点加入。该2个参数的顺序有要求：新加入的节点放前 </p>
<h3 id="4-添加集群从节点"><a href="#4-添加集群从节点" class="headerlink" title="4. 添加集群从节点"></a>4. 添加集群从节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster add-node 192.168.1.8:6382 192.168.1.10:6379 --cluster-slave --cluster-master-id 117457eab5071954faab5e81c3170600d5192270<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">说明：把6382节点加入到6379节点的集群中，并且当做node_id:17ea90fd81280b5ee7999cbf0313f89206688242的从节点。如果不指定 --cluster-master-id 会随机分配到任意一个主节点。</span><br></code></pre></td></tr></table></figure>

<h3 id="5-删除节点"><a href="#5-删除节点" class="headerlink" title="5. 删除节点"></a>5. 删除节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster del-node 192.168.1.8:6384 f6a6957421b80409106cb36be3c7ba41f3b603ff<br></code></pre></td></tr></table></figure>

<p>说明：指定IP、端口和node_id 来删除一个节点，从节点可以直接删除，有slot分配的主节点不能直接删除。</p>
<p>注意：当被删除掉的节点重新起来之后不能自动加入集群，但其和主的复制还是正常的，也可以通过该节点看到集群信息（通过其他正常节点已经看不到该被del-node节点的信息）。</p>
<p>如果想要再次加入集群，则需要先在该节点执行cluster reset，再用add-node进行添加，进行增量同步复制。</p>
<h3 id="6-检查集群"><a href="#6-检查集群" class="headerlink" title="6. 检查集群"></a>6. 检查集群</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster check 192.168.1.8:6384 --cluster-search-multiple-owners<br></code></pre></td></tr></table></figure>

<p> 说明：任意连接一个集群节点，进行集群状态检查 </p>
<h3 id="7-集群信息查看"><a href="#7-集群信息查看" class="headerlink" title="7. 集群信息查看"></a>7. 集群信息查看</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster info 192.168.1.8:6384<br></code></pre></td></tr></table></figure>

<p> 说明：检查key、slots、从节点个数的分配情况 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# redis-cli --cluster info 192.168.1.8:6384<br>192.168.1.10:6379 (17ea90fd...) -&gt; 1 keys | 5461 slots | 1 slaves.<br>192.168.1.8:6382 (4a8b3637...) -&gt; 0 keys | 5462 slots | 1 slaves.<br>192.168.1.10:6380 (4c4710e3...) -&gt; 1 keys | 5461 slots | 1 slaves.<br>[OK] 2 keys in 3 masters.<br>0.00 keys per slot on average.<br></code></pre></td></tr></table></figure>

<h3 id="8-修复集群"><a href="#8-修复集群" class="headerlink" title="8. 修复集群"></a>8. 修复集群</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster fix 192.168.1.8:6384 --cluster-search-multiple-owners<br></code></pre></td></tr></table></figure>

<p> 说明：修复集群和槽的重复分配问题 </p>
<h3 id="9-设置集群的超时时间"><a href="#9-设置集群的超时时间" class="headerlink" title="9. 设置集群的超时时间"></a>9. 设置集群的超时时间</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster set-timeout 192.168.1.8:6382 10000<br></code></pre></td></tr></table></figure>

<p> 说明：连接到集群的任意一节点来设置集群的超时时间参数cluster-node-timeout </p>
<h3 id="10-集群中执行相关命令"><a href="#10-集群中执行相关命令" class="headerlink" title="10. 集群中执行相关命令"></a>10. 集群中执行相关命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster call 192.168.1.10:6381 config set requirepass cc<br>redis-cli -a cc --cluster call 192.168.1.10:6381 config set masterauth cc<br>redis-cli -a cc --cluster call 192.168.1.10 config rewrite<br></code></pre></td></tr></table></figure>

<p> 说明：连接到集群的任意一节点来对整个集群的所有节点进行设置。 </p>
<p>到此，相关集群的基本操作已经介绍完，现在说明集群迁移的相关操作。</p>
<p>Redis 6.0 新增了几个命令：</p>
<p>1，fix 的子命令：–cluster-fix-with-unreachable-masters</p>
<p>2，call的子命令：–cluster-only-masters、–cluster-only-replicas</p>
<p>3，集群节点备份：backup</p>
<h2 id="迁移相关"><a href="#迁移相关" class="headerlink" title="迁移相关"></a>迁移相关</h2><h3 id="在线迁移slot-："><a href="#在线迁移slot-：" class="headerlink" title="在线迁移slot ："></a><strong>在线迁移slot</strong> ：</h3><p>​       在线把集群的一些slot从集群原来slot节点迁移到新的节点，即可以完成集群的在线横向扩容和缩容。有2种方式进行迁移</p>
<p>一、是根据提示来进行操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">直接连接到集群的任意一节点</span><br>redis-cli -a cc --cluster reshard 192.168.1.10:6379<br></code></pre></td></tr></table></figure>

<p>​       二、是根据参数进行操作： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli -a cc --cluster reshard 192.168.1.10:6379 --cluster-from 117457eab5071954faab5e81c3170600d5192270 --cluster-to 815da8448f5d5a304df0353ca10d8f9b77016b28 --cluster-slots 10 --cluster-yes --cluster-timeout 5000 --cluster-pipeline 10 --cluster-replace<br></code></pre></td></tr></table></figure>

<p>​       说明：连接到集群的任意一节点来对指定节点指定数量的slot进行迁移到指定的节点。  </p>
<h3 id="平衡（rebalance）slot-："><a href="#平衡（rebalance）slot-：" class="headerlink" title="平衡（rebalance）slot ："></a>平衡（rebalance）<strong>slot</strong> ：</h3><p>1）  平衡集群中各个节点的slot数量 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli -a cc --cluster rebalance 192.168.163.132:6379<br></code></pre></td></tr></table></figure>

<p>2）根据集群中各个节点设置的权重等平衡slot数量（不执行，只模拟） </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli -a cc --cluster rebalance --cluster-weight 117457eab5071954faab5e81c3170600d5192270=5 815da8448f5d5a304df0353ca10d8f9b77016b28=4 56005b9413cbf225783906307a2631109e753f8f=3 --cluster-simulate 192.168.1.10:6379<br></code></pre></td></tr></table></figure>

<ol start="3">
<li> 导入集群 </li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli --cluster import 192.168.1.10:6379 --cluster-from 192.168.1.10:9021 --cluster-replace<br></code></pre></td></tr></table></figure>

<p> 说明：外部Redis实例（9021）导入到集群中的任意一节点。 </p>
<p> 注意：测试下来发现参数–cluster-replace没有用，如果集群中已经包含了某个key，在导入的时候会失败，不会覆盖，只有清空集群key才能导入。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">*** Importing 97847 keys from DB 0<br>Migrating 9223372011174675807 to 192.168.1.10:6381: Source 192.168.1.10:9021 replied with error:<br>ERR Target instance replied with error: BUSYKEY Target key name already exists<br></code></pre></td></tr></table></figure>

<p> 并且发现如果集群设置了密码，也会导入失败，需要设置集群密码为空才能进行导入（call）。通过monitor（9021）的时候发现，在migrate的时候需要密码进行auth认证 </p>
<p><strong>Redis Cluster 通过redis-cli –cluster来创建和管理集群的方式和 redis-trib.rb脚本绝大部分都是一样的，所以对于比较熟悉 redis-trib.rb 脚本的，使用–cluster也非常顺手。</strong> </p>
<p>参考：</p>
<hr>
<p><a href="https://www.cnblogs.com/zhoujinyi/p/11606935.html">https://www.cnblogs.com/zhoujinyi/p/11606935.html</a></p>
<p><a href="https://www.cnblogs.com/saneri/p/12409173.html">https://www.cnblogs.com/saneri/p/12409173.html</a></p>
<p>半路雨歌链接：<a href="https://juejin.cn/post/6844904097116585991">https://juejin.cn/post/6844904097116585991</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis.conf详解</title>
    <url>/2021/09/29/redis-conf%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>以下将从配置文件中顺序往下讲解</strong>,<strong>涉及主从复制，持久化将会另起讲解</strong></p>
<h4 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h4><p><img src="/2021/09/29/redis-conf%E8%AF%A6%E8%A7%A3/1632924192904.png"></p>
<p>1.配置文件unit单位大小写不敏感</p>
<h4 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h4><p><img src="/2021/09/29/redis-conf%E8%AF%A6%E8%A7%A3/1632924269484.png"></p>
<p>类似我们nginx中的include中的包含文件</p>
 <span id="more"></span>

<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">bind 127.0.0.1 # 绑定的ip<br>protected-mode yes # 保护模式<br>port 6379 #端口设置<br></code></pre></td></tr></table></figure>



<h4 id="通用-GENERAL"><a href="#通用-GENERAL" class="headerlink" title="通用 GENERAL"></a>通用 GENERAL</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"> daemonize yes #以守护进程的方式运行，默认是no，当我们需要后台启动时需要我们手动设置为yes<br> <br> pidfile /var/run/redis_6379.pid  #如果我们以后台方式运行，我们就需要指定一个pid文件<br> <br><span class="hljs-meta"> </span><br><span class="hljs-meta">#</span><span class="bash">日志</span> <br><span class="hljs-meta">#</span><span class="bash"> Specify the server verbosity level.</span><br><span class="hljs-meta">#</span><span class="bash">ze yes This can be one of:</span><br><span class="hljs-meta">#</span><span class="bash"> debug (a lot of information, useful <span class="hljs-keyword">for</span> development/testing)</span><br><span class="hljs-meta">#</span><span class="bash"> verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="hljs-meta">#</span><span class="bash"> notice (moderately verbose, what you want <span class="hljs-keyword">in</span> production probably) 生产环境</span><br><span class="hljs-meta">#</span><span class="bash"> warning (only very important / critical messages are logged)</span><br>loglevel notice<br><br>logfile &quot;&quot; #日志的文件位置名<br><br>databases 16  #数据库的数量，默认是16个数据库<br><br>always-show-logo no #是否总是显示日志<br><br> <br></code></pre></td></tr></table></figure>



<h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p><strong>持久化，在规定的时间内，执行了多少次操作，则会持久化到文件.rdb.aof</strong>, <strong>redis是内存数据库,如果没有持久化，那么数据断电即丢失</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">如果3600s内，如果至少有一个key进行了修改，即进行持久化操作</span><br>save 3600 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">如果300S内，如果至少300S内，至少有10个可以进行了修改，即进行持久化操作</span><br>save 300 10<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">如果60S内，如果至少10000个进行了修改，即进行持久化操作</span><br>save 60 10000<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">后续持久化配置需要用到这里</span><br><br>stop-writes-on-bgsave-error yes #持久化如果出错，是否继续持久化<br><br>rdbcompression yes #是否压缩rdb文件,会消耗一些CPU资源<br><br>rdbchecksum yes  #保存rdb文件的时候，进行错误的核查校验！<br><br>dbfilename dump.rdb # 指定本地数据库文件名，一般采用默认的 dump.rdb<br><br>dir ./  #指定本地数据库存放目录，一般也用默认配置<br><br><br><br><br><br></code></pre></td></tr></table></figure>



<h4 id="SECURITY-安全"><a href="#SECURITY-安全" class="headerlink" title="SECURITY 安全"></a>SECURITY 安全</h4><p><img src="/2021/09/29/redis-conf%E8%AF%A6%E8%A7%A3/1632927510924.png"></p>
<p> <strong>可以在这里设置redis的密码，默认是没有密码！</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">               <br>requirepass 123456  #设置密码，设置后需要重启服务才有效,这里设置的是123456<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">当我们登录之后，执行命令将会出现以下提示需要认证</span><br>(error) NOAUTH Authentication required.<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">认证即可正常操作</span><br>127.0.0.1:6379&gt; auth 123456<br>OK<br><br>127.0.0.1:6379&gt; set k1 v1<br>OK<br>127.0.0.1:6379&gt; get k1<br>&quot;v1&quot;<br><br></code></pre></td></tr></table></figure>



<h4 id="限制-CLIENTS"><a href="#限制-CLIENTS" class="headerlink" title="限制 CLIENTS"></a>限制 CLIENTS</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><br>maxclients 10000  #设置能连接上redis的最大客户端的数量<br><br>maxmemory &lt;bytes&gt; #redis配置最大的内存容量<br><br><br><br>maxmemory-policy noeviction # 内存达到上限后的处理策略<br><span class="hljs-meta">#</span><span class="bash"> volatile-lru -&gt; Evict using approximated LRU, only keys with an expire <span class="hljs-built_in">set</span>.</span><br><span class="hljs-meta">#</span><span class="bash"> allkeys-lru -&gt; Evict any key using approximated LRU.</span><br><span class="hljs-meta">#</span><span class="bash"> volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire <span class="hljs-built_in">set</span>.</span><br><span class="hljs-meta">#</span><span class="bash"> allkeys-lfu -&gt; Evict any key using approximated LFU.</span><br><span class="hljs-meta">#</span><span class="bash"> volatile-random -&gt; Remove a random key having an expire <span class="hljs-built_in">set</span>.</span><br><span class="hljs-meta">#</span><span class="bash"> allkeys-random -&gt; Remove a random key, any key.</span><br><span class="hljs-meta">#</span><span class="bash"> volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span><br><span class="hljs-meta">#</span><span class="bash"> noeviction -&gt; Don<span class="hljs-string">&#x27;t evict anything, just return an error on write operations.</span></span><br>        1. volatile-lru: 只对设置了过期时间的key进行LRU(默认值)<br>        2. allkeys-lru： 删除lru算法的key<br>        3. volatile-random：随机删除即将过期key<br>        4. allkeys-random：随机删除<br>        5. volatile-ttl： 删除即将过期的<br>        6. noeviction ： 永不过期，返回错误<br>        7. volatile-lfu：使用近似 LFU 驱逐，只有设置过期的键<br><br></code></pre></td></tr></table></figure>



<h4 id="APPEND-ONLY-模式-aof配置"><a href="#APPEND-ONLY-模式-aof配置" class="headerlink" title="APPEND ONLY 模式 aof配置"></a>APPEND ONLY 模式 aof配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">appendonly no #默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！<br>appendfilename &quot;appendonly.aof&quot; #持久化名称<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> appendfsync always   <span class="hljs-comment">#每次修改都会sync。消耗性能</span></span><br>appendfsync everysec   #每秒执行一次sync，可能会丢失这1S的数据<br><span class="hljs-meta">#</span><span class="bash"> appendfsync no       <span class="hljs-comment">#不执行 sync，这个时候操作系统自己同步数据，速度最快！</span></span><br></code></pre></td></tr></table></figure>



<p>参考：</p>
<p>​       B站狂神说Java:<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0</a></p>
<p>​      Redis.Conf配置文件</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis三种集群模式之主从复制</title>
    <url>/2021/10/06/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader),后者称为从节点(slave/flollower);<strong>数据的复制是单向的，只能由主节点到从节点，Master以写为主，Slave以读为主</strong>。</p>
<h3 id="1-1主从复制的作用主要包括："><a href="#1-1主从复制的作用主要包括：" class="headerlink" title="1.1主从复制的作用主要包括："></a>1.1主从复制的作用主要包括：</h3><ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 （即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写 少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
<li>高可用(集群)基石： 除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复 制是Redis高可用的基础 </li>
</ol>
<p><strong>注意：如redis运用于工程项目中，不能使用单机redis，原因如下：</strong></p>
<ol>
<li> 从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大。</li>
<li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存为256G，也不能将所有内存作用于Redis存储内存，一般单台Redis最大使用内存不应该超过20G。</li>
</ol>
<p>一般结构架构如下：</p>
<p><img src="/2021/10/06/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1633523383473.png"></p>
<h2 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2.基本原理"></a>2.基本原理</h2><p> 主从复制模式中包含一个主数据库实例(master)与一个或多个从数据库实例(slave)，客户端可对主数据库进行读写操作，对从数据库进行读操作，主数据库写入的数据会实时自动同步给从数据库 </p>
<h3 id="2-1复制原理图"><a href="#2-1复制原理图" class="headerlink" title="2.1复制原理图"></a>2.1复制原理图</h3><p><img src="/2021/10/06/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1633524169754.png"></p>
<h3 id="2-3具体步骤"><a href="#2-3具体步骤" class="headerlink" title="2.3具体步骤"></a>2.3具体步骤</h3><ol>
<li> 从服务器连接主服务器，发送SYNC命令 ；</li>
<li> 主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；</li>
<li> 主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；  </li>
<li>  从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； </li>
<li> 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； </li>
<li>  从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令； </li>
</ol>
<h2 id="3-部署示例"><a href="#3-部署示例" class="headerlink" title="3.部署示例"></a>3.部署示例</h2><p>只配置从库，不用配置主库，主库具体配置，可以参考前面文章《Redis.Conf详解》及《Redis持久化》,我这里配置的是<strong>一主两从</strong></p>
<h3 id="3-1-查看主库信息"><a href="#3-1-查看主库信息" class="headerlink" title="3.1 查看主库信息"></a>3.1 查看主库信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看当前库的信息</span><br>127.0.0.1:6379&gt;info replication<br><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:master  #角色<br>connected_slaves:0  #从机信息<br>master_failover_state:no-failover<br>master_replid:e3d0ce67427f5c928650af42bc66dd0c294f5dbe<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:0<br>second_repl_offset:-1<br>repl_backlog_active:0<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:0<br>repl_backlog_histlen:0<br><br></code></pre></td></tr></table></figure>



<h3 id="2-2-配置文件"><a href="#2-2-配置文件" class="headerlink" title="2.2 配置文件"></a>2.2 配置文件</h3><ol>
<li><p>复制三个redis.conf文件，然后修改对应信息，例如slave1.conf,slave2.conf</p>
</li>
<li><p>分别修改端口信息</p>
</li>
<li><p>分别修改配置文件中pid名称</p>
</li>
<li><p>分别修改log文件名称</p>
</li>
<li><p>分别修改dump.rdb名称</p>
</li>
</ol>
<h3 id="3-3-启动服务"><a href="#3-3-启动服务" class="headerlink" title="3.3 启动服务"></a>3.3 启动服务</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# redis-server etc/slave1.conf #启动从库1<br>[root@centos7 bin]# redis-server etc/slave2.conf #启动从库2<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查看redis服务信息</span><br>[root@centos7 bin]# ps -ef | grep redis<br>root       2766      1  0 05:33 ?        00:00:02 redis-server 127.0.0.1:6379 <br>root       3250      1  0 06:05 ?        00:00:00 redis-server 127.0.0.1:6380<br>root       3263      1  0 06:05 ?        00:00:00 redis-server 127.0.0.1:6381<br>root       3293   2715  0 06:09 pts/1    00:00:00 grep --color=auto redis<br><br></code></pre></td></tr></table></figure>



<h3 id="3-4-一主两从命令方式设置"><a href="#3-4-一主两从命令方式设置" class="headerlink" title="3.4 一主两从命令方式设置"></a>3.4 一主两从命令方式设置</h3><p> 默认情况下，每台Redis服务器都是主节点 ，一般我们配置从机即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">分别登录从服务器</span><br>[root@centos7 bin]# redis-cli -p 6380<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">设置主master,也就找那一台当主节点</span><br>127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379  #寻找主节点，找谁当老大<br>OK<br><br>127.0.0.1:6380&gt; INFO replication<br><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:slave  # 当前角色是从机<br>master_host:127.0.0.1 # 可以的看到主机的信息<br>master_port:6379  #主机端口<br>master_link_status:down<br>master_last_io_seconds_ago:-1<br>master_sync_in_progress:0<br>slave_repl_offset:1<br>master_link_down_since_seconds:-1<br>slave_priority:100<br>slave_read_only:1<br>replica_announced:1<br>connected_slaves:0<br>master_failover_state:no-failover<br>master_replid:449ba98d5fcd3c32154dfd049716ce5ca3ee4d4b<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:0<br>second_repl_offset:-1<br>repl_backlog_active:0<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:0<br>repl_backlog_histlen:0<br></code></pre></td></tr></table></figure>

<p>回到6379中查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:master<br>connected_slaves:1 #一个从节点<br>slave0:ip=127.0.0.1,port=6380,state=online,offset=28,lag=0  #从节点信息<br>master_failover_state:no-failover<br>master_replid:b717806873adac0ac99646e873b92a744d2406df<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:28<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:28<br></code></pre></td></tr></table></figure>

<p>第二个从节点根据上面配置即可</p>
<p><strong>注意：使用命令方式配置只是暂时的，重启服务即失效，推荐在配置文件中配置</strong></p>
<h3 id="3-5-一主两从配置文件方式设置（推荐）"><a href="#3-5-一主两从配置文件方式设置（推荐）" class="headerlink" title="3.5 一主两从配置文件方式设置（推荐）"></a>3.5 一主两从配置文件方式设置（推荐）</h3><p>在从数据配置文件中添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">replicaof 127.0.0.1 6379 # master的ip，port<br>masterauth 123456 # master的密码<br>replica-serve-stale-data no # 如果slave无法与master同步，设置成slave不可读，方便监控脚本发现问题<br></code></pre></td></tr></table></figure>



<p>分别启动两个从服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# redis-server etc/slave1.conf <br>[root@centos7 bin]# redis-server etc/slave2.conf <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">然后再在主服务器输入以下信息即可查看到两个从服务器信息</span><br>127.0.0.1:6379&gt; INFO replication<br><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:master<br>connected_slaves:2  #两个从数据库<br>slave0:ip=127.0.0.1,port=6380,state=online,offset=1008,lag=1<br>slave1:ip=127.0.0.1,port=6381,state=online,offset=1008,lag=1<br>master_failover_state:no-failover<br>master_replid:b717806873adac0ac99646e873b92a744d2406df<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:1008<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:1008<br></code></pre></td></tr></table></figure>



<blockquote>
<p>数据测试</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">主数据库写</span><br>127.0.0.1:6379&gt; set k1 v1<br>OK<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">从数据读</span><br>127.0.0.1:6380&gt; get k1<br>&quot;v1&quot;<br></code></pre></td></tr></table></figure>





<blockquote>
<p>细节</p>
</blockquote>
<p> 主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动被从机保存！ </p>
<p>主机写：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set k1 v1<br>OK<br></code></pre></td></tr></table></figure>

<p>从机写：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6380&gt; set k1 v1<br>(error) READONLY You can&#x27;t write against a read only replica. #不能写入<br><br></code></pre></td></tr></table></figure>



<h2 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4.优缺点"></a>4.优缺点</h2><h3 id="4-1优点"><a href="#4-1优点" class="headerlink" title="4.1优点"></a>4.1优点</h3><ul>
<li>master能自动将数据同步到slave，可以进行读写分离，分担master的读压力</li>
<li>master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求</li>
</ul>
<h3 id="4-2缺点"><a href="#4-2缺点" class="headerlink" title="4.2缺点"></a>4.2缺点</h3><ul>
<li>不具备自动容错与恢复功能，master或slave的宕机都可能导致客户端请求失败，需要等待机器重启或手动切换客户端IP才能恢复</li>
<li>master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题</li>
<li>难以支持在线扩容，Redis的容量受限于单机配置</li>
</ul>
<p>参考：</p>
<hr>
<p>狂神说Java：<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0</a></p>
<p>半路雨歌：<a href="https://juejin.cn/post/6844904097116585991#heading-1">https://juejin.cn/post/6844904097116585991#heading-1</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis三种集群模式之哨兵模式</title>
    <url>/2021/10/06/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p> 主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工 干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑 哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题 。</p>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独 立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例</strong> </p>
<p><img src="/2021/10/06/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/1633534256141.png"></p>
<p> 这里的哨兵有两个作用:</p>
<ul>
<li> 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器 </li>
<li> 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服 务器，修改配置文件，让它们切换主机 </li>
</ul>
<p> 然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。 各个哨兵之间还会进行监控，这样就形成了多哨兵模式。 </p>
<p><img src="/2021/10/06/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/1633534636100.png"> </p>
<h3 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2.工作原理"></a>2.工作原理</h3><ol>
<li>首先主节点的信息是配置在哨兵(Sentinel)的配置文件中</li>
<li>哨兵节点会和配置的主节点建立起两条连接<code>命令连接</code>和<code>订阅连接</code></li>
<li>哨兵会通过<code>命令连接</code>每10s发送一次<code>INFO</code>命令，通过<code>INFO命令</code>，主节点会返回自己的run_id和自己的<code>从节点信息</code></li>
<li>哨兵会对这些从节点也建立两条连接<code>命令连接</code>和<code>订阅连接</code></li>
<li>哨兵通过<code>命令连接</code>向从节点发送<code>INFO</code>命令，获取到他的一些信息<br>a. run_id<br>b. role<br>c. 从服务器的复制偏移量 offset等</li>
<li>因为哨兵对与集群中的其他节点(主从节点)当前都有两条连接，<code>命令连接</code>和<code>订阅连接</code><br> a. 通过<code>命令连接</code>向服务器的<code>_sentinel:hello</code>频道发送一条消息，内容包括自己的ip端口、run_id、配置纪元(后续投票的时候会用到)等<br> b. 通过<code>订阅连接</code>对服务器的<code>_sentinel:hello</code>频道做了监听，所以所有的向该频道发送的哨兵的消息都能被接受到<br> c. 解析监听到的消息，进行分析提取，就可以知道还有那些别的哨兵服务节点也在监听这些主从节点了，更新结构体将这些哨兵节点记录下来<br> d. 向观察到的其他的哨兵节点建立<code>命令连接</code>—-没有<code>订阅连接</code></li>
</ol>
<h3 id="3-哨兵模式下的故障迁移"><a href="#3-哨兵模式下的故障迁移" class="headerlink" title="3.哨兵模式下的故障迁移"></a>3.哨兵模式下的故障迁移</h3><h4 id="3-2主观下线"><a href="#3-2主观下线" class="headerlink" title="3.2主观下线"></a><strong>3.2主观下线</strong></h4><p>哨兵(Sentinel)节点会每秒一次的频率向建立了命令连接的实例发送PING命令，如果在<code>down-after-milliseconds</code>毫秒内没有做出有效响应包括(PONG/LOADING/MASTERDOWN)以外的响应，哨兵就会将该实例在本结构体中的状态标记为<code>SRI_S_DOWN</code>主观下线</p>
<h4 id="3-3客观下线"><a href="#3-3客观下线" class="headerlink" title="3.3客观下线"></a><strong>3.3客观下线</strong></h4><p>当一个哨兵节点发现主节点处于主观下线状态是，会向其他的哨兵节点发出询问，该节点是不是已经主观下线了。如果超过配置参数<code>quorum</code>个节点认为是主观下线时，该哨兵节点就会将自己维护的结构体中该主节点标记为<code>SRI_O_DOWN</code>客观下线<br> 询问命令<code>SENTINEL is-master-down-by-addr    </code></p>
<p><img src="/2021/10/06/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/1633535070130.png"></p>
<h4 id="3-4-leader选举"><a href="#3-4-leader选举" class="headerlink" title="3.4 leader选举"></a>3.4 <strong>leader选举</strong></h4><p>在认为主节点<code>客观下线</code>的情况下,哨兵节点间会发起一次选举，命令还是上面的命令<code>SENTINEL is-master-down-by-addr    </code>,只是<code>run_id</code>这次会将<code>自己的run_id</code>带进去，希望接受者将自己设置为主节点。如果超过半数以上的节点返回将该节点标记为leader的情况下，会有该leader对故障进行迁移</p>
<h4 id="3-5故障迁移"><a href="#3-5故障迁移" class="headerlink" title="3.5故障迁移"></a><strong>3.5故障迁移</strong></h4><ol>
<li>在从节点中挑选出新的主节点<br> a. 通讯正常<br> b. 优先级排序<br> c. 优先级相同是选择offset最大的</li>
<li>将该节点设置成新的主节点 <code>SLAVEOF no one</code>,并确保在后续的INGO命令时，该节点返回状态为master</li>
<li>将其他的从节点设置成从新的主节点复制, <code>SLAVEOF命令</code> </li>
<li>将旧的主节点变成新的主节点的从节点</li>
</ol>
<h3 id="4-部署示例"><a href="#4-部署示例" class="headerlink" title="4.部署示例"></a>4.部署示例</h3><p> 哨兵模式基于前文的主从复制模式。当前示例为一主二从模式</p>
<p>4.1首先在reids解压后的文件中将sentinel.conf文件复制到redis.conf文件的目录下</p>
<p><img src="/2021/10/06/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/1633536145531.png"></p>
<p>4.2在配置文件中进行如下配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> mymaster定义一个master数据库的名称，后面是master的ip， port，1表示至少需要一个Sentinel进程同意才能将master判断为失效，如果不满足这个条件，则自动故障转移（failover）不会执行</span><br>sentinel monitor mymaster 127.0.0.1 6379 1 <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> master的密码</span><br>sentinel auth-pass mymaster 123456 <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 5s未回复PING，则认为master主观下线，默认为30s</span><br>sentinel down-after-milliseconds mymaster 5000 <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 指定在执行故障转移时，最多可以有多少个slave实例在同步新的master实例，在slave实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长</span><br>sentinel parallel-syncs mymaster 2  <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 如果在该时间（ms）内未能完成故障转移操作，则认为故障转移失败，生产环境需要根据数据量设置该值</span><br>sentinel failover-timeout mymaster 300000 <br></code></pre></td></tr></table></figure>



<p> <strong>一个哨兵可以监控多个master数据库，只需按上述配置添加多套</strong> </p>
<p>4.3 分别以26379,36379,46379端口启动三个sentinel </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@centos7 bin]# redis-sentinel etc/sentinel1.conf <br>[root@centos7 bin]# redis-sentinel etc/sentinel2.conf <br>[root@centos7 bin]# redis-sentinel etc/sentinel3.conf <br></code></pre></td></tr></table></figure>



<p>4.4测试Master挂掉场景</p>
<p><img src="/2021/10/06/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/1633537126366.png"></p>
<p> 执行 <code>kill -9 4965</code> 将master进程干掉，进入slave中执行 <code>info replication</code>查看 </p>
<p><strong>哨兵服务输出信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">12292:X 07 Oct 2021 18:56:28.858 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.<br>12292:X 07 Oct 2021 18:56:28.858 # Sentinel ID is 0d12a3731fac0690b3cf55d7a424b8a5c0bb2889<br>12292:X 07 Oct 2021 18:56:28.858 # +monitor master mymaster 127.0.0.1 6380 quorum 1<br>12292:X 07 Oct 2021 18:56:38.924 * +convert-to-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 18:59:29.468 * +fix-slave-config slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.021 # +sdown master mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.021 # +odown master mymaster 127.0.0.1 6380 #quorum 1/1<br>12292:X 07 Oct 2021 19:01:59.021 # +new-epoch 2<br>12292:X 07 Oct 2021 19:01:59.021 # +try-failover master mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.023 # +vote-for-leader 0d12a3731fac0690b3cf55d7a424b8a5c0bb2889 2<br>12292:X 07 Oct 2021 19:01:59.023 # +elected-leader master mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.023 # +failover-state-select-slave master mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.078 # +selected-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.078 * +failover-state-send-slaveof-noone slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:01:59.140 * +failover-state-wait-promotion slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:00.090 # +promoted-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:00.090 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:00.157 * +slave-reconf-sent slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:01.134 * +slave-reconf-inprog slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:01.134 * +slave-reconf-done slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:01.220 # +failover-end master mymaster 127.0.0.1 6380<br>12292:X 07 Oct 2021 19:02:01.220 # +switch-master mymaster 127.0.0.1 6380 127.0.0.1 6379<br>12292:X 07 Oct 2021 19:02:01.221 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379<br>12292:X 07 Oct 2021 19:02:01.221 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379<br>12292:X 07 Oct 2021 19:02:06.230 # +sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379<br></code></pre></td></tr></table></figure>

<p>从以上信息，可以看出6380的master已经被移除，选举出了6379为master。</p>
<p><strong>如果当我们再次启动6380服务，已经变为从节点</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6380&gt; info replication<br><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:slave #从节点角色<br>master_host:127.0.0.1<br>master_port:6379<br></code></pre></td></tr></table></figure>



<h3 id="5-优缺点"><a href="#5-优缺点" class="headerlink" title="5.优缺点"></a>5.优缺点</h3><h4 id="5-1优点"><a href="#5-1优点" class="headerlink" title="5.1优点"></a>5.1优点</h4><ol>
<li> 哨兵集群，基于主从复制模式，所有的主从配置优点，它全有 </li>
<li> 主从可以切换，故障可以转移，系统的可用性就会更好 </li>
<li> 哨兵模式就是主从模式的升级，手动到自动，更加健壮！ </li>
</ol>
<h4 id="5-2缺点"><a href="#5-2缺点" class="headerlink" title="5.2缺点"></a>5.2缺点</h4><ol>
<li>同样也继承了主从模式难以在线扩容的缺点，Redis的容量受限于单机配置</li>
<li>需要额外的资源来启动sentinel进程，实现相对复杂一点，同时slave节点作为备份节点不提供服务</li>
</ol>
<h3 id="6-哨兵模式全部配置"><a href="#6-哨兵模式全部配置" class="headerlink" title="6.哨兵模式全部配置"></a>6.哨兵模式全部配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Example sentinel.conf</span><br><span class="hljs-meta">#</span><span class="bash"> 哨兵sentinel实例运行的端口 默认26379</span><br>port 26379<br><span class="hljs-meta">#</span><span class="bash"> 哨兵sentinel的工作目录</span><br>dir /tmp<br><span class="hljs-meta">#</span><span class="bash"> 哨兵sentinel监控的redis主节点的 ip port</span><br><span class="hljs-meta">#</span><span class="bash"> master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符<span class="hljs-string">&quot;.-_&quot;</span>组成。</span><br><span class="hljs-meta">#</span><span class="bash"> quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br>sentinel monitor mymaster 127.0.0.1 6379 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span><br><span class="hljs-meta">#</span><span class="bash"> 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br>sentinel auth-pass mymaster MySUPER--secret-0123passw0rd<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br>sentinel down-after-milliseconds mymaster 30000<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br>sentinel parallel-syncs mymaster 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span><br><span class="hljs-meta">#</span><span class="bash">1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span><br><span class="hljs-meta">#</span><span class="bash">2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span><br><span class="hljs-meta">#</span><span class="bash">3.当想要取消一个正在进行的failover所需要的时间。</span><br><span class="hljs-meta">#</span><span class="bash">4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><br><span class="hljs-meta">#</span><span class="bash"> 默认三分钟</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br>sentinel failover-timeout mymaster 180000<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> SCRIPTS EXECUTION</span><br><span class="hljs-meta">#</span><span class="bash">配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span><br><span class="hljs-meta">#</span><span class="bash">对于脚本的运行结果有以下规则：</span><br><span class="hljs-meta">#</span><span class="bash">若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><br><span class="hljs-meta">#</span><span class="bash">若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><br><span class="hljs-meta">#</span><span class="bash">如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><br><span class="hljs-meta">#</span><span class="bash">一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span><br><span class="hljs-meta">#</span><span class="bash">通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><br><span class="hljs-meta">#</span><span class="bash">通知脚本</span><br><span class="hljs-meta">#</span><span class="bash"> shell编程</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span><br>sentinel notification-script mymaster /var/redis/notify.sh<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 客户端重新配置主节点参数脚本</span><br><span class="hljs-meta">#</span><span class="bash"> 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><br><span class="hljs-meta">#</span><span class="bash"> 以下参数将会在调用脚本时传给脚本:</span><br><span class="hljs-meta">#</span><span class="bash"> &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><span class="hljs-meta">#</span><span class="bash"> 目前&lt;state&gt;总是“failover”,</span><br><span class="hljs-meta">#</span><span class="bash"> &lt;role&gt;是“leader”或者“observer”中的一个。</span><br><span class="hljs-meta">#</span><span class="bash"> 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span><br><span class="hljs-meta">#</span><span class="bash"> 这个脚本应该是通用的，能被多次调用，不是针对性的。</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span><br>sentinel client-reconfig-script mymaster /var/redis/reconfig.sh # 一般都是由运维来配置！<br></code></pre></td></tr></table></figure>



<p>参考：</p>
<hr>
<p>狂神说Java：<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=18051804489571055526&amp;spm_id_from=333.337.0.0</a></p>
<p>半路雨歌：<a href="https://juejin.cn/post/6844904097116585991#heading-1">https://juejin.cn/post/6844904097116585991#heading-1</a></p>
<p><a href="https://www.jianshu.com/p/d6d2325a5ec7">https://www.jianshu.com/p/d6d2325a5ec7</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础</title>
    <url>/2021/09/25/redis%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Redis是什么？</p>
</blockquote>
<p> Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由<a href="https://baike.baidu.com/item/Pivotal">Pivotal</a>赞助。 </p>
<p> 免费和开源！是当下最热门的 NoSQL 技术之一！也被人们称之为结构化数据库！ </p>
 <span id="more"></span>

<blockquote>
<p>Redis作用于那些</p>
</blockquote>
<ol>
<li> 内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof） </li>
<li> 效率高，可以用于高速缓存 </li>
<li> 发布订阅系统 </li>
<li> 地图信息分析  </li>
<li> 计时器、计数器（浏览量！）  </li>
<li>…</li>
</ol>
<blockquote>
<p>主要特性</p>
</blockquote>
<ol>
<li> 多样的数据类型 </li>
</ol>
<p>   2、持久化</p>
<p>   3、集群 </p>
<p>   4、事务 </p>
<h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><blockquote>
<p>Linux安装</p>
</blockquote>
<p>Redis官网地址: <a href="https://redis.io/">https://redis.io/</a></p>
<p><img src="/2021/09/25/redis%E5%9F%BA%E7%A1%80/1632572684797.png"></p>
<p>1.下载后,可获得一个tar压缩，我这里放到了 /opt目录下</p>
<p><img src="/2021/09/25/redis%E5%9F%BA%E7%A1%80/1632573739375.png"></p>
<p>2.解压Redis安装包 解压命令: tar zxvf redis-6.2.5.tar.gz</p>
<p><img src="/2021/09/25/redis%E5%9F%BA%E7%A1%80/1632574069385.png"></p>
<p>3.解压之后可以看到一个redis目录,进入Redis目录可以看到redis.conf的一个文件</p>
<p><img src="/2021/09/25/redis%E5%9F%BA%E7%A1%80/1632574182949.png"></p>
<p>4.在redis下我们首先进行基本安装及编译安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">基础环境安装</span><br>yum install gcc-c++<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">编译</span><br>make<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">安装 redis安装之后默认安装在 /usr/<span class="hljs-built_in">local</span>/bin 下</span><br>make install<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">make PREFIX=/data/redis install  指定目录安装</span><br><br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/25/redis%E5%9F%BA%E7%A1%80/1632575400027.png"></p>
<p>5.在安装目录下复制redis.conf文件复制到安装目录下即：/usr/local/bin</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cp redis.conf /usr/local/bin/<br></code></pre></td></tr></table></figure>



<p>6.修改redis启动方式，因为redis默认启动方式不是后台启动，因此我们需要进入redis.conf中修改为yes</p>
<p><img src="/2021/09/25/redis%E5%9F%BA%E7%A1%80/1632575702117.png"></p>
<p>7.启动redis服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">启动redis服务</span><br>redis-server etc/redis.conf   #在bin目录下创建了etc目录  redis启动需要将配置文件一同操作<br><br></code></pre></td></tr></table></figure>



<p>8.连接测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">连接客户端命令 -p 指定端口</span><br>redis-cli -p 6379<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">可以看到连接并ping通</span><br>127.0.0.1:6379&gt; ping<br>PONG<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">连接之后如何正常退出？</span><br>127.0.0.1:6379&gt; shutdown #先关闭，防止有数据被中断<br>not connected&gt; exit  #退出<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">此时通过查看进程是否存在</span><br>ps -ef | grep redis<br><br></code></pre></td></tr></table></figure>

<p>9.查看redis进程</p>
<p><img src="/2021/09/25/redis%E5%9F%BA%E7%A1%80/1632576417517.png"></p>
<p>当客户端连接退出后，任务进程将会不存在</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="redis默认数据库"><a href="#redis默认数据库" class="headerlink" title="redis默认数据库"></a>redis默认数据库</h3><p>通过查看配置文件</p>
<p><strong>redis默认有16个数据库，默认使用第0个数据库</strong> </p>
<p><img src="/2021/09/25/redis%E5%9F%BA%E7%A1%80/1632576644195.png"></p>
<p>我们可以对数据库进行选择</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">数据使用选择，redis默认界面，我们可以使用table键进行命令补全</span><br>127.0.0.1:6379&gt; SELECT 2<br>OK<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查看库大小</span><br>127.0.0.1:6379[2]&gt; DBSIZE<br>(integer) 0<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查看所有key</span><br>127.0.0.1:6379[2]&gt; KEYS *<br></code></pre></td></tr></table></figure>

<p><strong>清除当前数据库 flushdb</strong></p>
<p><strong>清除全部数据库的内容 FLUSHALL</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; KEYS * <br>1) &quot;name&quot;<br>127.0.0.1:6379&gt; FLUSHDB<br>OK<br>127.0.0.1:6379&gt; KEYS * <br>(empty array)<br>127.0.0.1:6379&gt; <br><br></code></pre></td></tr></table></figure>



<blockquote>
<p>Redis是单线程</p>
</blockquote>
<p> 大家应该知道Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据 机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了！所有就使用了单线程了！</p>
<p> Redis 是C 语言写的，官方提供的数据为 100000+ 的QPS，完全不比同样是使用 key-vale的 Memecache差！ </p>
<h3 id="Redis单线程为什么还这么快？"><a href="#Redis单线程为什么还这么快？" class="headerlink" title="Redis单线程为什么还这么快？"></a>Redis单线程为什么还这么快？</h3><p>了解计算机原理的应该知道   CPU &gt;  内存 &gt; 磁盘</p>
<p><strong>核心：redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程 （CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高 的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！</strong></p>
<h2 id="五大类型"><a href="#五大类型" class="headerlink" title="五大类型"></a>五大类型</h2><blockquote>
<p>官方文档说明</p>
</blockquote>
<p> Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="http://www.redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a href="http://www.redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a href="http://www.redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）。 </p>
<blockquote>
<p>下面命令需要我们记住，现在我们一般使用的spring boot，Jedis方法基本都是这些命令</p>
</blockquote>
<h3 id="Redis基本操作"><a href="#Redis基本操作" class="headerlink" title="Redis基本操作"></a>Redis基本操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查询所有key</span><br>127.0.0.1:6379&gt; KEYS * <br>(empty array)<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">set</span> key</span><br>127.0.0.1:6379&gt; SET name pudewu<br>OK<br><br><br>127.0.0.1:6379&gt; KEYS * <br>1) &quot;name&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">判断key值是不是存在</span><br>127.0.0.1:6379&gt; EXISTS name<br>(integer) 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 移除当前的key</span><br>127.0.0.1:6379&gt; MOVE name 1<br>(integer) 1<br><br><br>127.0.0.1:6379&gt; KEYS *<br>(empty array)<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取key</span><br>127.0.0.1:6379&gt; get name<br>&quot;pudewu&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 设置key的过期时间，单位是秒</span><br>127.0.0.1:6379&gt; EXPIRE name 20<br>(integer) 1<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 查看当前key的剩余时间</span><br>127.0.0.1:6379&gt; TTL name<br>(integer) 17<br>127.0.0.1:6379&gt; TTL name<br>(integer) 13<br>127.0.0.1:6379&gt; TTL name<br>(integer) 12<br>127.0.0.1:6379&gt; TTL name<br>(integer) 11<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查看key的类型</span><br>127.0.0.1:6379&gt; type name<br>string<br></code></pre></td></tr></table></figure>

<p><strong>如果对有些命令不会的可以在官网查看帮助命令</strong></p>
<h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>相信这个命令是我们经常使用到的</p>
<blockquote>
<p>添加Key，获取Key</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; SET k2 v2<br>OK<br>127.0.0.1:6379&gt; GET k2<br>&quot;v2&quot;<br>127.0.0.1:6379&gt; EXISTS k2<br>(integer) 1<br>127.0.0.1:6379&gt; APPEND k2 &quot;hello&quot;<br>(integer) 7<br>127.0.0.1:6379&gt; get k2<br>&quot;v2hello&quot;<br>127.0.0.1:6379&gt; STRLEN k2<br>(integer) 7<br>127.0.0.1:6379&gt; APPEND k2 &quot;redis学习&quot;<br>(integer) 18<br>127.0.0.1:6379&gt; STRLEN k2<br>(integer) 18<br>127.0.0.1:6379&gt; GET k2<br>&quot;v2helloredis\xe5\xad\xa6\xe4\xb9\xa0&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>String自增自减</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">设置默认值为0</span><br>127.0.0.1:6379&gt; set number 0<br>OK<br>127.0.0.1:6379&gt; get number<br>&quot;0&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">自增1</span><br>127.0.0.1:6379&gt; INCR number <br>(integer) 1<br>127.0.0.1:6379&gt; INCR number <br>(integer) 2<br>127.0.0.1:6379&gt; INCR number <br>(integer) 3<br>127.0.0.1:6379&gt; INCR number <br>(integer) 4<br>127.0.0.1:6379&gt; get number<br>&quot;4&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">自减1</span><br>127.0.0.1:6379&gt; DECR number <br>(integer) 3<br>127.0.0.1:6379&gt; DECR number <br>(integer) 2<br>127.0.0.1:6379&gt; DECR number <br>(integer) 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">自定义 增加值</span><br>127.0.0.1:6379&gt; INCRBY number 10<br>(integer) 11<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">自定义 减值</span><br>127.0.0.1:6379&gt; DECRBY number 5<br>(integer) 6<br></code></pre></td></tr></table></figure>



<blockquote>
<p>字符串范围</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 设置 key的值</span><br>127.0.0.1:6379&gt; set key &quot;hello redis&quot;<br>OK<br>127.0.0.1:6379&gt; get key1<br>(nil)<br>127.0.0.1:6379&gt; get key<br>&quot;hello redis&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 截取字符串 [0,3]</span><br>127.0.0.1:6379&gt; GETRANGE key 0 3<br>&quot;hell&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 获取全部的字符串 和 get key是一样的</span><br>127.0.0.1:6379&gt; GETRANGE key 0 -1<br>&quot;hello redis&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 替换！</span><br>127.0.0.1:6379&gt; set key2 &quot;redis fast&quot;<br>OK<br>127.0.0.1:6379&gt; get key2<br>&quot;redis fast&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 替换指定位置开始的字符串！</span><br>127.0.0.1:6379&gt; SETRANGE key2 1 realy<br>(integer) 10<br>127.0.0.1:6379&gt; get key2<br>&quot;rrealyfast&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p> 设置过期时间 </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> setex (<span class="hljs-built_in">set</span> with expire) <span class="hljs-comment"># 设置过期时间</span></span><br><span class="hljs-meta">#</span><span class="bash"> setnx (<span class="hljs-built_in">set</span> <span class="hljs-keyword">if</span> not exist) <span class="hljs-comment"># 不存在在设置 （在分布式锁中会常常使用！）</span></span><br>127.0.0.1:6379&gt; setex key3 30 &quot;hello&quot; # 设置key3 的值为 hello,30秒后过期<br>OK<br>127.0.0.1:6379&gt; ttl key3<br>(integer) 26<br>127.0.0.1:6379&gt; get key3<br>&quot;hello&quot;<br>127.0.0.1:6379&gt; setnx mykey &quot;redis&quot; # 如果mykey 不存在，创建mykey<br>(integer) 1<br>127.0.0.1:6379&gt; keys *<br>1) &quot;key2&quot;<br>2) &quot;mykey&quot;<br>3) &quot;key1&quot;<br>127.0.0.1:6379&gt; ttl key3<br>(integer) -2<br>127.0.0.1:6379&gt; setnx mykey &quot;MongoDB&quot; # 如果mykey存在，创建失败！<br>(integer) 0<br>127.0.0.1:6379&gt; get mykey<br>&quot;redis&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>mset mget</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 # 同时设置多个值<br>OK<br>127.0.0.1:6379&gt; keys *<br>1) &quot;k1&quot;<br>2) &quot;k2&quot;<br>3) &quot;k3&quot;<br>127.0.0.1:6379&gt; mget k1 k2 k3 # 同时获取多个值<br>1) &quot;v1&quot;<br>2) &quot;v2&quot;<br>3) &quot;v3&quot;<br>127.0.0.1:6379&gt; msetnx k1 v1 k4 v4 # msetnx 是一个原子性的操作，要么一起成功，要么一起<br>失败！<br>(integer) 0<br>127.0.0.1:6379&gt; get k4<br>(nil)<br><span class="hljs-meta">#</span><span class="bash"> 对象</span><br>set user:1 &#123;name:zhangsan,age:3&#125; # 设置一个user:1 对象 值为 json字符来保存一个对象！<br><span class="hljs-meta">#</span><span class="bash"> 这里的key是一个巧妙的设计： user:&#123;id&#125;:&#123;filed&#125; , 如此设计在Redis中是完全OK了！</span><br>127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2<br>OK<br>127.0.0.1:6379&gt; mget user:1:name user:1:age<br>1) &quot;zhangsan&quot;<br>2) &quot;2&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p><strong>getset</strong> </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; getset db redis # 如果不存在值，则返回 nil<br>(nil)<br>127.0.0.1:6379&gt; get db<br>&quot;redis<br>127.0.0.1:6379&gt; getset db mongodb # 如果存在值，获取原来的值，并设置新的值<br>&quot;redis&quot;<br>127.0.0.1:6379&gt; get db<br>&quot;mongodb&quot;<br></code></pre></td></tr></table></figure>



<h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h3><p> 在redis里面，我们可以把list玩成 ，栈、队列、阻塞队列！ 所有的list命令都是用l开头的，Redis不区分大小命令  </p>
<blockquote>
<p>lrange list 0 -1 查询list中所有 </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 将一个值或者多个值，插入到列表头部 （左）</span><br>127.0.0.1:6379&gt; lpush list one<br><br>127.0.0.1:6379&gt; lpush list two<br><br>127.0.0.1:6379&gt; lpush list three<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 0 -1 表示查询当前key下所有值</span><br>127.0.0.1:6379&gt; lrange list 0 -1<br><br>1) &quot;three&quot;<br>2) &quot;two&quot;<br>3) &quot;one&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p> RPush将一个值或多个值，插入到列表位部(右) </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; Rpush list righr<br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>1) &quot;three&quot;<br>2) &quot;two&quot;<br>3) &quot;one&quot;<br>4) &quot;righr&quot;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>Lpop左移除列表</strong>  <strong>Rpop右移除列表</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 移除第一个元素</span><br>127.0.0.1:6379&gt; Lpop list<br>&quot;three&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">移除最后一个元素</span><br>127.0.0.1:6379&gt; Rpop list<br>&quot;righr&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查询list中所有数据</span><br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>1) &quot;two&quot;<br>2) &quot;one&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<h3 id="Lindex"><a href="#Lindex" class="headerlink" title="Lindex"></a>Lindex</h3></blockquote>
<p>通过下表获得list中的某一个值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; lindex list 1<br>&quot;one&quot;<br></code></pre></td></tr></table></figure>



<blockquote>
<p> Llen获取列表长度 </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; llen list<br>(integer) 4<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">指定移除列</span>   <br>127.0.0.1:6379&gt; lrem list 1 one<br></code></pre></td></tr></table></figure>





<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li>他实际上是一个链表，before Node after ， left，right 都可以插入值</li>
<li>如果key 不存在，创建新的链表</li>
<li>如果key存在，新增内容</li>
<li>如果移除了所有值，空链表，也代表不存在！</li>
<li>在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~</li>
</ul>
<p><strong>在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~</strong></p>
<h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h3><p> set中的值不能重复,无序 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># set集合中添加元素  SADD</span></span><br>127.0.0.1:6379&gt; sadd myset &quot;hello set&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查询<span class="hljs-built_in">set</span>中所有元素 SMEMBERS</span> <br>127.0.0.1:6379&gt; Smembers myset<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> SISMEMBER 查询<span class="hljs-built_in">set</span>中某个值是否存在</span><br>127.0.0.1:6379&gt; SISMEMBER myset hello<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取Set中集合元素个数</span><br>127.0.0.1:6379&gt; scard myset<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">rem 移除<span class="hljs-built_in">set</span>中元素</span><br>127.0.0.1:6379&gt; srem myset yes<br>(integer) 1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> SRANDMEMBER 随机抽取<span class="hljs-built_in">set</span>集合中数据</span><br>127.0.0.1:6379&gt; SRANDMEMBER myset<br><br><br>==============================================================================<br>删除指定Set数据、随机删除Set数据<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">SMOVE  将一个指定的值，移动到另一个<span class="hljs-built_in">set</span>值中</span><br>127.0.0.1:6379&gt; smove myset myset2 &quot;dewu1&quot;    <br><br><br>==============================================================================<br>数字集合类：<br>- 差集 SDIFF<br>- 交集<br>- 并集<br><br>127.0.0.1:6379&gt; SDIFF key1 key2  # 差集<br><br>127.0.0.1:6379&gt; SINTER key1 key2 # 交集 共同好友就可以这样实现<br><br>127.0.0.1:6379&gt; SUNION key1 key2 # 并集<br></code></pre></td></tr></table></figure>





<h3 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash(哈希)"></a>Hash(哈希)</h3><p> <strong>Map集合，key-map! 时候这个值是一个map集合！ 本质和String类型没有太大区别，还是一个简单的 key-vlaue！</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 添加hash值  hset</span></span><br>127.0.0.1:6379&gt; hset myhash field kuangshen<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 获取<span class="hljs-built_in">hash</span>值  hget</span><br>127.0.0.1:6379&gt; hget myhash field<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">set</span>多个 key-vlaue</span><br>127.0.0.1:6379&gt; hmset myhash field1 hello field2 world<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取多个<span class="hljs-built_in">hash</span>值</span><br>127.0.0.1:6379&gt; hmget myhash field1 field2<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取所有<span class="hljs-built_in">hash</span>中的值</span><br>127.0.0.1:6379&gt;  hgetall myhash<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">删除<span class="hljs-built_in">hash</span>操作  hdel</span><br>127.0.0.1:6379&gt; hdel myhash field1<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 只获得所有field</span><br><span class="hljs-meta">#</span><span class="bash"> 只获得所有value</span><br>127.0.0.1:6379&gt; hkeys myhash # 只获得所有field<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">只获得所有value</span><br>127.0.0.1:6379&gt; hvals myhash<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">incr decr</span><br>127.0.0.1:6379&gt; hset myhash field3 5 #指定增量！<br>127.0.0.1:6379&gt; HINCRby myhash field3 1<br>127.0.0.1:6379&gt; hincrby myhash field3 -1<br><br>127.0.0.1:6379&gt; hsetnx myhash field4 hello # 如果不存在则可以设置<br>127.0.0.1:6379&gt; hsetnx myhash field4 world # 如果存在则不能设置<br></code></pre></td></tr></table></figure>



<p> <strong>hash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！ hash 更适合于对象的 存储，String更加适合字符串存储！</strong> </p>
<h3 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset(有序集合)"></a>Zset(有序集合)</h3><p> <strong>在set基础上增加了一个值，set k1 v1   zset k1 score1  v1</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">添加有序集合</span><br>127.0.0.1:6379&gt; zadd dewu 1 redis<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">多个添加</span><br>127.0.0.1:6379&gt; zadd dewu 2 two 3 three<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查询集合元素</span><br>127.0.0.1:6379&gt; zrange dewu 0 -1<br><br><br>=====================================================<br>排序如何实现<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">添加三个用户</span><br>127.0.0.1:6379&gt; zadd salary 2500 xiaoming <br>(integer) 1<br>127.0.0.1:6379&gt; zadd salary 3000 xiaohong <br>(integer) 1<br>127.0.0.1:6379&gt; zadd salary 3500 zhangsan<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> ZRANGEBYSCORE key min max</span><br>127.0.0.1:6379&gt;  ZRANGEBYSCORE salary -inf +inf<br>1) &quot;xiaoming&quot;<br>2) &quot;xiaohong&quot;<br>3) &quot;zhangsan&quot;  # 显示全部的用户 从小到大！<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">从大到小排序</span><br>127.0.0.1:6379&gt; zrevrange salary 0 -1<br>1) &quot;zhangsan&quot;<br>2) &quot;xiaohong&quot;<br>3) &quot;xiaoming&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">显示全部用户并且附带成绩</span><br>127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores<br>1) &quot;xiaoming&quot;<br>2) &quot;2500&quot;<br>3) &quot;xiaohong&quot;<br>4) &quot;3000&quot;<br>5) &quot;zhangsan&quot;<br>6) &quot;3500&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">显示工资小于2500的员工升序排序</span><br>127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 withscores<br>1) &quot;xiaoming&quot;<br>2) &quot;2500&quot;<br><br><br>=================================================================<br><span class="hljs-meta">#</span><span class="bash"> 移除rem中的元素</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">移除集合中指定元素</span><br>127.0.0.1:6379&gt; zrem salary xiaoming<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取有序集合中的个数</span><br>127.0.0.1:6379&gt; zcard salary<br><br>==================================================================<br><br>127.0.0.1:6379&gt; zadd xiaolong 1 hello<br>127.0.0.1:6379&gt; zadd xiaolong 2 world 3 kuangsheng<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取指定区间的成员数量！</span><br>127.0.0.1:6379&gt; zcount xiaolong 1 3<br> <br></code></pre></td></tr></table></figure>



<p>参考：<a href="https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=8440565446323209776&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1S54y1R7SB?from=search&amp;seid=8440565446323209776&amp;spm_id_from=333.337.0.0</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
